import { BreadRecipe, BreadStep, Ingredient } from '../components/BreadTypes';
import { projectId, publicAnonKey } from '../components/supabase/info';

// Types for AI recipe generation
export interface AIRecipeRequest {
  images: File[];
  recipeName?: string;
  additionalNotes?: string;
}

interface AIServerResponse {
  success: boolean;
  recipe: any;
  metadata?: {
    requestId?: string;
    imagesProcessed?: number;
    generatedAt: string;
    model: string;
  };
  error?: string;
  details?: string;
}

// Convert server recipe format to our BreadRecipe format with enhanced ingredient name handling
function convertServerRecipeToBreadRecipe(serverRecipe: any): BreadRecipe {
  console.log('🔄 Converting server recipe to BreadRecipe format:', serverRecipe);

  // Convert ingredients to our format with improved name handling
  const ingredients: Ingredient[] = serverRecipe.ingredients?.map((ing: any, index: number) => {
    // Handle multiple possible property names from different AI responses
    let ingredientName = ing.name || ing.item || ing.ingredient || ing.title || '';
    
    // Fallback to generic name if still empty
    if (!ingredientName || ingredientName.trim() === '') {
      ingredientName = `Ingredient ${index + 1}`;
      console.warn(`⚠️ Missing ingredient name at index ${index}, using fallback: "${ingredientName}"`);
    }

    // Clean up the ingredient name
    ingredientName = String(ingredientName).trim();

    // Handle amount and unit with better defaults
    const amount = ing.amount || ing.quantity || '1';
    const unit = ing.unit || ing.measurement || '';
    const notes = ing.notes || ing.note || ing.description || '';

    const ingredient: Ingredient = {
      id: ing.id || `ingredient-${index}`,
      item: ingredientName, // This is the key field for our BreadRecipe format
      amount: String(amount),
      unit: String(unit).trim(),
      notes: String(notes).trim()
    };

    console.log(`📦 Converted ingredient ${index + 1}: "${ingredient.item}" (${ingredient.amount} ${ingredient.unit})`);
    return ingredient;
  }) || [];

  // Convert steps to our format
  const steps: BreadStep[] = serverRecipe.steps?.map((step: any, index: number) => ({
    id: step.id || `step-${index}`,
    title: step.title || `Step ${index + 1}`,
    instruction: step.description || step.instruction || step.directions || '',
    duration: Number(step.duration) || 30,
    temperature: step.temperature || '',
    tips: step.tips || '',
    ingredients: step.ingredients || [],
    isOptional: false
  })) || [];

  // Ensure we have valid data
  const recipe: BreadRecipe = {
    id: serverRecipe.id || `ai-recipe-${Date.now()}`,
    name: serverRecipe.name || 'AI Generated Bread Recipe',
    description: serverRecipe.description || 'A delicious bread recipe generated by AI',
    difficulty: serverRecipe.difficulty || 'Intermediate',
    prepTime: serverRecipe.prepTime || 60,
    totalTime: serverRecipe.totalTime || 240,
    servings: serverRecipe.servings || 8,
    imageUrl: serverRecipe.imageUrl || 'https://images.unsplash.com/photo-1549931319-a545dcf3bc73?w=400&h=300&fit=crop',
    ingredients,
    steps,
    tags: serverRecipe.tags || ['ai-generated', 'bread'],
    createdBy: '', // Will be set by the calling component
    createdAt: new Date(serverRecipe.createdAt || Date.now()),
    updatedAt: new Date(serverRecipe.updatedAt || Date.now()),
    isUserCreated: true
  };

  console.log('✅ Successfully converted to BreadRecipe format:', recipe.name);
  console.log(`📦 Final ingredient list: ${ingredients.map(i => `"${i.item}"`).join(', ')}`);
  console.log(`📝 Recipe has ${ingredients.length} ingredients and ${steps.length} steps`);
  
  // Validate that all ingredients have names
  const missingNames = ingredients.filter(ing => !ing.item || ing.item.trim() === '');
  if (missingNames.length > 0) {
    console.error(`❌ Found ${missingNames.length} ingredients with missing names:`, missingNames);
  }
  
  return recipe;
}

// Main function to generate recipe from images using backend API
export async function generateRecipeFromImages(request: AIRecipeRequest): Promise<BreadRecipe> {
  try {
    console.log('🚀 Starting AI recipe generation');
    console.log(`📸 Processing ${request.images.length} image(s)`);
    console.log(`📝 Recipe details: ${request.recipeName ? `Name: "${request.recipeName}"` : 'No name'}, ${request.additionalNotes ? `Notes: "${request.additionalNotes.substring(0, 50)}..."` : 'No notes'}`);

    // Check if we have either images OR text details
    const hasImages = request.images && request.images.length > 0;
    const hasTextDetails = (request.recipeName?.trim() || request.additionalNotes?.trim());
    
    if (!hasImages && !hasTextDetails) {
      throw new Error('Please provide either images or recipe details to generate a recipe');
    }

    // Validate images if provided
    if (hasImages) {
      for (const image of request.images) {
        if (!image.type.startsWith('image/')) {
          throw new Error(`File "${image.name}" is not a valid image`);
        }
        if (image.size > 5 * 1024 * 1024) { // 5MB limit
          throw new Error(`Image "${image.name}" is too large. Maximum size is 5MB`);
        }
      }
    }

    // Prepare form data for backend
    const formData = new FormData();
    
    // Add images if provided
    if (hasImages) {
      request.images.forEach((image) => {
        formData.append('images', image);
      });
    }

    // Add text details (always include these)
    if (request.recipeName?.trim()) {
      formData.append('recipeName', request.recipeName.trim());
    }

    if (request.additionalNotes?.trim()) {
      formData.append('additionalNotes', request.additionalNotes.trim());
    }

    // Determine difficulty from additional notes
    let difficulty = 'Intermediate';
    if (request.additionalNotes) {
      const notes = request.additionalNotes.toLowerCase();
      if (notes.includes('beginner') || notes.includes('easy') || notes.includes('simple')) {
        difficulty = 'Beginner';
      } else if (notes.includes('advanced') || notes.includes('expert') || notes.includes('complex')) {
        difficulty = 'Advanced';
      }
    }
    formData.append('difficulty', difficulty);

    console.log(`📡 Sending request to backend AI service (${hasImages ? 'with images' : 'text-only'})`);

    // Call backend API
    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/server/generate-recipe-from-images`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${publicAnonKey}`,
      },
      body: formData
    });

    if (!response.ok) {
      let errorMessage = `Backend API error (${response.status})`;
      try {
        const errorData: AIServerResponse = await response.json();
        errorMessage = errorData.error || errorMessage;
        if (errorData.details) {
          console.error('❌ Backend error details:', errorData.details);
        }
      } catch (parseError) {
        console.error('❌ Failed to parse error response:', parseError);
      }
      throw new Error(errorMessage);
    }

    const serverResponse: AIServerResponse = await response.json();

    if (!serverResponse.success || !serverResponse.recipe) {
      throw new Error(serverResponse.error || 'Failed to generate recipe');
    }

    console.log('✅ Successfully received recipe from backend');
    console.log('📊 Generation metadata:', serverResponse.metadata);

    // Convert server response to our format with enhanced ingredient handling
    const recipe = convertServerRecipeToBreadRecipe(serverResponse.recipe);

    // Override name if user provided one
    if (request.recipeName?.trim()) {
      recipe.name = request.recipeName.trim();
    }

    // Final validation to ensure all ingredients have names
    recipe.ingredients.forEach((ingredient, index) => {
      if (!ingredient.item || ingredient.item.trim() === '') {
        console.warn(`⚠️ Fixing missing ingredient name at index ${index}`);
        ingredient.item = `Ingredient ${index + 1}`;
      }
    });

    console.log(`🎯 Final recipe generated: "${recipe.name}"`);
    console.log(`📦 Final ingredient check: ${recipe.ingredients.map(i => `"${i.item}"`).join(', ')}`);
    console.log(`📝 Recipe has ${recipe.ingredients.length} ingredients and ${recipe.steps.length} steps`);

    return recipe;

  } catch (error) {
    console.error('❌ Error in AI recipe generation:', error);
    
    // Provide user-friendly error messages
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error('Unable to connect to AI service. Please check your internet connection and try again.');
    }
    
    if (error instanceof Error) {
      // Pass through our custom error messages
      if (error.message.includes('provide either images or recipe details') || 
          error.message.includes('not a valid image') || 
          error.message.includes('too large')) {
        throw error;
      }
      
      // Handle API-specific errors
      if (error.message.includes('AI service not configured')) {
        throw new Error('AI recipe generation is temporarily unavailable. Please try again later or create a recipe manually.');
      }
      
      if (error.message.includes('temporarily unavailable')) {
        throw new Error('AI service is temporarily busy. Please try again in a few moments.');
      }
    }
    
    // Generic fallback error
    throw new Error('Failed to generate recipe from images. Please try again or create a recipe manually.');
  }
}

// Helper function to generate recipe from text description (future feature)
export async function generateRecipeFromText(description: string, breadType?: string, difficulty: string = 'Intermediate'): Promise<BreadRecipe> {
  try {
    console.log('📝 Starting AI recipe generation from text description');
    console.log(`📄 Description: ${description.substring(0, 100)}...`);

    if (!description || description.trim().length < 10) {
      throw new Error('Please provide a detailed description (at least 10 characters)');
    }

    const requestBody = {
      description: description.trim(),
      difficulty,
      breadType: breadType || ''
    };

    console.log('📡 Sending text-based generation request to backend');

    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/server/generate-recipe-from-text`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${publicAnonKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      let errorMessage = `Backend API error (${response.status})`;
      try {
        const errorData: AIServerResponse = await response.json();
        errorMessage = errorData.error || errorMessage;
      } catch (parseError) {
        console.error('❌ Failed to parse error response:', parseError);
      }
      throw new Error(errorMessage);
    }

    const serverResponse: AIServerResponse = await response.json();

    if (!serverResponse.success || !serverResponse.recipe) {
      throw new Error(serverResponse.error || 'Failed to generate recipe');
    }

    console.log('✅ Successfully received text-based recipe from backend');

    // Convert server response to our format
    const recipe = convertServerRecipeToBreadRecipe(serverResponse.recipe);

    console.log(`🎯 Final text-based recipe generated: "${recipe.name}"`);
    
    return recipe;

  } catch (error) {
    console.error('❌ Error in text-based AI recipe generation:', error);
    
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('Failed to generate recipe from description. Please try again or create a recipe manually.');
  }
}

// Helper function to enhance existing recipes (future feature)
export async function enhanceRecipe(recipe: BreadRecipe, enhancementType: 'improve' | 'simplify' | 'professional' = 'improve'): Promise<BreadRecipe> {
  try {
    console.log(`🔧 Starting recipe enhancement: ${enhancementType}`);
    console.log(`📝 Enhancing recipe: ${recipe.name}`);

    const requestBody = {
      recipe,
      enhancementType
    };

    console.log('📡 Sending enhancement request to backend');

    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/server/enhance-recipe`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${publicAnonKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      let errorMessage = `Backend API error (${response.status})`;
      try {
        const errorData: AIServerResponse = await response.json();
        errorMessage = errorData.error || errorMessage;
      } catch (parseError) {
        console.error('❌ Failed to parse error response:', parseError);
      }
      throw new Error(errorMessage);
    }

    const serverResponse: AIServerResponse = await response.json();

    if (!serverResponse.success || !serverResponse.recipe) {
      throw new Error(serverResponse.error || 'Failed to enhance recipe');
    }

    console.log('✅ Successfully enhanced recipe');

    // Convert server response to our format
    const enhancedRecipe = convertServerRecipeToBreadRecipe(serverResponse.recipe);

    console.log(`🎯 Enhanced recipe: "${enhancedRecipe.name}"`);
    
    return enhancedRecipe;

  } catch (error) {
    console.error('❌ Error in recipe enhancement:', error);
    
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('Failed to enhance recipe. Please try again later.');
  }
}

// Legacy mock function (kept for fallback, but not used in production)
export async function generateRecipeWithMockData(request: AIRecipeRequest): Promise<BreadRecipe> {
  console.log('⚠️ Using mock data for recipe generation (fallback mode)');
  
  // Simple mock implementation as fallback
  const mockRecipe: BreadRecipe = {
    id: `mock-recipe-${Date.now()}`,
    name: request.recipeName || 'AI Generated Artisan Bread',
    description: 'A delicious artisan bread created from your images using AI analysis.',
    difficulty: 'Intermediate',
    prepTime: 30,
    totalTime: 300,
    servings: 8,
    imageUrl: 'https://images.unsplash.com/photo-1549931319-a545dcf3bc73?w=400&h=300&fit=crop',
    ingredients: [
      { id: 'ing-1', item: 'Bread flour', amount: '500', unit: 'g', notes: '' },
      { id: 'ing-2', item: 'Warm water', amount: '350', unit: 'ml', notes: 'Room temperature' },
      { id: 'ing-3', item: 'Active dry yeast', amount: '7', unit: 'g', notes: '' },
      { id: 'ing-4', item: 'Fine sea salt', amount: '10', unit: 'g', notes: '' },
      { id: 'ing-5', item: 'Extra virgin olive oil', amount: '15', unit: 'ml', notes: '' }
    ],
    steps: [
      {
        id: 'step-1',
        title: 'Mix Ingredients',
        instruction: 'In a large bowl, combine flour, yeast, and salt. Add water and olive oil, mixing until a shaggy dough forms.',
        duration: 15,
        temperature: '',
        tips: 'Don\'t overmix at this stage',
        ingredients: [],
        isOptional: false
      },
      {
        id: 'step-2',
        title: 'Knead',
        instruction: 'Turn dough onto a floured surface and knead for 8-10 minutes until smooth and elastic.',
        duration: 10,
        temperature: '',
        tips: 'The dough should pass the windowpane test',
        ingredients: [],
        isOptional: false
      },
      {
        id: 'step-3',
        title: 'First Rise',
        instruction: 'Place in an oiled bowl, cover, and let rise for 1-2 hours until doubled.',
        duration: 90,
        temperature: '',
        tips: 'A warm, draft-free place works best',
        ingredients: [],
        isOptional: false
      },
      {
        id: 'step-4',
        title: 'Shape and Bake',
        instruction: 'Shape the dough, place in pan, let rise 45 minutes, then bake at 375°F for 30-35 minutes.',
        duration: 80,
        temperature: '375°F (190°C)',
        tips: 'Bread is done when it sounds hollow when tapped',
        ingredients: [],
        isOptional: false
      }
    ],
    tags: ['artisan', 'ai-generated', 'bread'],
    createdBy: '',
    createdAt: new Date(),
    updatedAt: new Date(),
    isUserCreated: true
  };

  // Simulate processing delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  return mockRecipe;
}