var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/dexie/dist/dexie.js
var require_dexie = __commonJS({
  "node_modules/dexie/dist/dexie.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Dexie = factory());
    })(exports, function() {
      "use strict";
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
      }
      var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      var keys = Object.keys;
      var isArray = Array.isArray;
      if (typeof Promise !== "undefined" && !_global.Promise) {
        _global.Promise = Promise;
      }
      function extend(obj, extension) {
        if (typeof extension !== "object")
          return obj;
        keys(extension).forEach(function(key) {
          obj[key] = extension[key];
        });
        return obj;
      }
      var getProto = Object.getPrototypeOf;
      var _hasOwn = {}.hasOwnProperty;
      function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
      }
      function props(proto, extension) {
        if (typeof extension === "function")
          extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function(key) {
          setProp(proto, key, extension[key]);
        });
      }
      var defineProperty = Object.defineProperty;
      function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
      }
      function derive(Child) {
        return {
          from: function(Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
              extend: props.bind(null, Child.prototype)
            };
          }
        };
      }
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
      }
      var _slice = [].slice;
      function slice(args, start, end) {
        return _slice.call(args, start, end);
      }
      function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
      }
      function assert(b) {
        if (!b)
          throw new Error("Assertion Failed");
      }
      function asap$1(fn) {
        if (_global.setImmediate)
          setImmediate(fn);
        else
          setTimeout(fn, 0);
      }
      function arrayToObject(array, extractor) {
        return array.reduce(function(result, item, i) {
          var nameAndValue = extractor(item, i);
          if (nameAndValue)
            result[nameAndValue[0]] = nameAndValue[1];
          return result;
        }, {});
      }
      function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string" && hasOwn(obj, keyPath))
          return obj[keyPath];
        if (!keyPath)
          return obj;
        if (typeof keyPath !== "string") {
          var rv = [];
          for (var i = 0, l = keyPath.length; i < l; ++i) {
            var val = getByKeyPath(obj, keyPath[i]);
            rv.push(val);
          }
          return rv;
        }
        var period = keyPath.indexOf(".");
        if (period !== -1) {
          var innerObj = obj[keyPath.substr(0, period)];
          return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return void 0;
      }
      function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === void 0)
          return;
        if ("isFrozen" in Object && Object.isFrozen(obj))
          return;
        if (typeof keyPath !== "string" && "length" in keyPath) {
          assert(typeof value !== "string" && "length" in value);
          for (var i = 0, l = keyPath.length; i < l; ++i) {
            setByKeyPath(obj, keyPath[i], value[i]);
          }
        } else {
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "")
              if (value === void 0) {
                if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                  obj.splice(currentKeyPath, 1);
                else
                  delete obj[currentKeyPath];
              } else
                obj[currentKeyPath] = value;
            else {
              var innerObj = obj[currentKeyPath];
              if (!innerObj || !hasOwn(obj, currentKeyPath))
                innerObj = obj[currentKeyPath] = {};
              setByKeyPath(innerObj, remainingKeyPath, value);
            }
          } else {
            if (value === void 0) {
              if (isArray(obj) && !isNaN(parseInt(keyPath)))
                obj.splice(keyPath, 1);
              else
                delete obj[keyPath];
            } else
              obj[keyPath] = value;
          }
        }
      }
      function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string")
          setByKeyPath(obj, keyPath, void 0);
        else if ("length" in keyPath)
          [].map.call(keyPath, function(kp) {
            setByKeyPath(obj, kp, void 0);
          });
      }
      function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
          if (hasOwn(obj, m))
            rv[m] = obj[m];
        }
        return rv;
      }
      var concat = [].concat;
      function flatten(a) {
        return concat.apply([], a);
      }
      var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + num + "Array";
        });
      }))).filter(function(t) {
        return _global[t];
      });
      var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
        return _global[t];
      }));
      function cloneSimpleObjectTree(o) {
        var rv = {};
        for (var k in o)
          if (hasOwn(o, k)) {
            var v = o[k];
            rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
          }
        return rv;
      }
      function objectIsEmpty(o) {
        for (var k in o)
          if (hasOwn(o, k))
            return false;
        return true;
      }
      var circularRefs = null;
      function deepClone(any) {
        circularRefs = /* @__PURE__ */ new WeakMap();
        var rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
      }
      function innerDeepClone(x) {
        if (!x || typeof x !== "object")
          return x;
        var rv = circularRefs.get(x);
        if (rv)
          return rv;
        if (isArray(x)) {
          rv = [];
          circularRefs.set(x, rv);
          for (var i = 0, l = x.length; i < l; ++i) {
            rv.push(innerDeepClone(x[i]));
          }
        } else if (intrinsicTypes.has(x.constructor)) {
          rv = x;
        } else {
          var proto = getProto(x);
          rv = proto === Object.prototype ? {} : Object.create(proto);
          circularRefs.set(x, rv);
          for (var prop in x) {
            if (hasOwn(x, prop)) {
              rv[prop] = innerDeepClone(x[prop]);
            }
          }
        }
        return rv;
      }
      var toString = {}.toString;
      function toStringTag(o) {
        return toString.call(o).slice(8, -1);
      }
      var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
      var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
      } : function() {
        return null;
      };
      function delArrayItem(a, x) {
        var i = a.indexOf(x);
        if (i >= 0)
          a.splice(i, 1);
        return i >= 0;
      }
      var NO_CHAR_ARRAY = {};
      function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
          if (isArray(arrayLike))
            return arrayLike.slice();
          if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
            return [arrayLike];
          if (it = getIteratorOf(arrayLike)) {
            a = [];
            while (x = it.next(), !x.done)
              a.push(x.value);
            return a;
          }
          if (arrayLike == null)
            return [arrayLike];
          i = arrayLike.length;
          if (typeof i === "number") {
            a = new Array(i);
            while (i--)
              a[i] = arrayLike[i];
            return a;
          }
          return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
          a[i] = arguments[i];
        return a;
      }
      var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return false;
      };
      var dexieErrorNames = [
        "Modify",
        "Bulk",
        "OpenFailed",
        "VersionChange",
        "Schema",
        "Upgrade",
        "InvalidTable",
        "MissingAPI",
        "NoSuchDatabase",
        "InvalidArgument",
        "SubTransaction",
        "Unsupported",
        "Internal",
        "DatabaseClosed",
        "PrematureCommit",
        "ForeignAwait"
      ];
      var idbDomErrorNames = [
        "Unknown",
        "Constraint",
        "Data",
        "TransactionInactive",
        "ReadOnly",
        "Version",
        "NotFound",
        "InvalidState",
        "InvalidAccess",
        "Abort",
        "Timeout",
        "QuotaExceeded",
        "Syntax",
        "DataClone"
      ];
      var errorList = dexieErrorNames.concat(idbDomErrorNames);
      var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
      };
      function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
      }
      derive(DexieError).from(Error).extend({
        toString: function() {
          return this.name + ": " + this.message;
        }
      });
      function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures).map(function(key) {
          return failures[key].toString();
        }).filter(function(v, i, s) {
          return s.indexOf(v) === i;
        }).join("\n");
      }
      function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
      }
      derive(ModifyError).from(DexieError);
      function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function(pos) {
          return failures[pos];
        });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
      }
      derive(BulkError).from(DexieError);
      var errnames = errorList.reduce(function(obj, name) {
        return obj[name] = name + "Error", obj;
      }, {});
      var BaseException = DexieError;
      var exceptions = errorList.reduce(function(obj, name) {
        var fullName = name + "Error";
        function DexieError2(msgOrInner, inner) {
          this.name = fullName;
          if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
          } else if (typeof msgOrInner === "string") {
            this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
            this.inner = inner || null;
          } else if (typeof msgOrInner === "object") {
            this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
            this.inner = msgOrInner;
          }
        }
        derive(DexieError2).from(BaseException);
        obj[name] = DexieError2;
        return obj;
      }, {});
      exceptions.Syntax = SyntaxError;
      exceptions.Type = TypeError;
      exceptions.Range = RangeError;
      var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
          return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
          setProp(rv, "stack", { get: function() {
            return this.inner.stack;
          } });
        }
        return rv;
      }
      var fullNameExceptions = errorList.reduce(function(obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
          obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      fullNameExceptions.ModifyError = ModifyError;
      fullNameExceptions.DexieError = DexieError;
      fullNameExceptions.BulkError = BulkError;
      function nop() {
      }
      function mirror(val) {
        return val;
      }
      function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
          return f2;
        return function(val) {
          return f2(f1(val));
        };
      }
      function callBoth(on1, on2) {
        return function() {
          on1.apply(this, arguments);
          on2.apply(this, arguments);
        };
      }
      function hookCreatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res !== void 0)
            arguments[0] = res;
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res2 !== void 0 ? res2 : res;
        };
      }
      function hookDeletingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          f1.apply(this, arguments);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = this.onerror = null;
          f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
      }
      function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function(modifications) {
          var res = f1.apply(this, arguments);
          extend(modifications, res);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
        };
      }
      function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          if (f2.apply(this, arguments) === false)
            return false;
          return f1.apply(this, arguments);
        };
      }
      function promisableChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res && typeof res.then === "function") {
            var thiz = this, i = arguments.length, args = new Array(i);
            while (i--)
              args[i] = arguments[i];
            return res.then(function() {
              return f2.apply(thiz, args);
            });
          }
          return f2.apply(this, arguments);
        };
      }
      var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function setDebug(value, filter) {
        debug = value;
      }
      var INTERNAL = {};
      var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
        var globalP = Promise.resolve();
        if (typeof crypto === "undefined" || !crypto.subtle)
          return [globalP, getProto(globalP), globalP];
        var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [
          nativeP,
          getProto(nativeP),
          globalP
        ];
      }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
      var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
      var patchGlobalPromise = !!resolvedGlobalPromise;
      function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
      }
      var asap = function(callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
          schedulePhysicalTick();
          needsNewPhysicalTick = false;
        }
      };
      var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
      var globalPSD = {
        id: "global",
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
      };
      var PSD = globalPSD;
      var microtickQueue = [];
      var numScheduledCalls = 0;
      var tickFinalizers = [];
      function DexiePromise(fn) {
        if (typeof this !== "object")
          throw new TypeError("Promises must be constructed via new");
        this._listeners = [];
        this._lib = false;
        var psd = this._PSD = PSD;
        if (typeof fn !== "function") {
          if (fn !== INTERNAL)
            throw new TypeError("Not a function");
          this._state = arguments[1];
          this._value = arguments[2];
          if (this._state === false)
            handleRejection(this, this._value);
          return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
      }
      var thenProp = {
        get: function() {
          var psd = PSD, microTaskId = totalEchoes;
          function then(onFulfilled, onRejected) {
            var _this = this;
            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
            var cleanup = possibleAwait && !decrementExpectedAwaits();
            var rv = new DexiePromise(function(resolve, reject) {
              propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
            });
            if (this._consoleTask)
              rv._consoleTask = this._consoleTask;
            return rv;
          }
          then.prototype = INTERNAL;
          return then;
        },
        set: function(value) {
          setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
            get: function() {
              return value;
            },
            set: thenProp.set
          });
        }
      };
      props(DexiePromise.prototype, {
        then: thenProp,
        _then: function(onFulfilled, onRejected) {
          propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function(onRejected) {
          if (arguments.length === 1)
            return this.then(null, onRejected);
          var type2 = arguments[0], handler = arguments[1];
          return typeof type2 === "function" ? this.then(null, function(err) {
            return err instanceof type2 ? handler(err) : PromiseReject(err);
          }) : this.then(null, function(err) {
            return err && err.name === type2 ? handler(err) : PromiseReject(err);
          });
        },
        finally: function(onFinally) {
          return this.then(function(value) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return value;
            });
          }, function(err) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return PromiseReject(err);
            });
          });
        },
        timeout: function(ms, msg) {
          var _this = this;
          return ms < Infinity ? new DexiePromise(function(resolve, reject) {
            var handle = setTimeout(function() {
              return reject(new exceptions.Timeout(msg));
            }, ms);
            _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
          }) : this;
        }
      });
      if (typeof Symbol !== "undefined" && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
      globalPSD.env = snapShot();
      function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
        this.onRejected = typeof onRejected === "function" ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
      }
      props(DexiePromise, {
        all: function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            if (values.length === 0)
              resolve([]);
            var remaining = values.length;
            values.forEach(function(a, i) {
              return DexiePromise.resolve(a).then(function(x) {
                values[i] = x;
                if (!--remaining)
                  resolve(values);
              }, reject);
            });
          });
        },
        resolve: function(value) {
          if (value instanceof DexiePromise)
            return value;
          if (value && typeof value.then === "function")
            return new DexiePromise(function(resolve, reject) {
              value.then(resolve, reject);
            });
          var rv = new DexiePromise(INTERNAL, true, value);
          return rv;
        },
        reject: PromiseReject,
        race: function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            values.map(function(value) {
              return DexiePromise.resolve(value).then(resolve, reject);
            });
          });
        },
        PSD: {
          get: function() {
            return PSD;
          },
          set: function(value) {
            return PSD = value;
          }
        },
        totalEchoes: { get: function() {
          return totalEchoes;
        } },
        newPSD: newScope,
        usePSD,
        scheduler: {
          get: function() {
            return asap;
          },
          set: function(value) {
            asap = value;
          }
        },
        rejectionMapper: {
          get: function() {
            return rejectionMapper;
          },
          set: function(value) {
            rejectionMapper = value;
          }
        },
        follow: function(fn, zoneProps) {
          return new DexiePromise(function(resolve, reject) {
            return newScope(function(resolve2, reject2) {
              var psd = PSD;
              psd.unhandleds = [];
              psd.onunhandled = reject2;
              psd.finalize = callBoth(function() {
                var _this = this;
                run_at_end_of_this_or_next_physical_tick(function() {
                  _this.unhandleds.length === 0 ? resolve2() : reject2(_this.unhandleds[0]);
                });
              }, psd.finalize);
              fn();
            }, zoneProps, resolve, reject);
          });
        }
      });
      if (NativePromise) {
        if (NativePromise.allSettled)
          setProp(DexiePromise, "allSettled", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve) {
              if (possiblePromises.length === 0)
                resolve([]);
              var remaining = possiblePromises.length;
              var results = new Array(remaining);
              possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                  return results[i] = { status: "fulfilled", value };
                }, function(reason) {
                  return results[i] = { status: "rejected", reason };
                }).then(function() {
                  return --remaining || resolve(results);
                });
              });
            });
          });
        if (NativePromise.any && typeof AggregateError !== "undefined")
          setProp(DexiePromise, "any", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              if (possiblePromises.length === 0)
                reject(new AggregateError([]));
              var remaining = possiblePromises.length;
              var failures = new Array(remaining);
              possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                  return resolve(value);
                }, function(failure) {
                  failures[i] = failure;
                  if (!--remaining)
                    reject(new AggregateError(failures));
                });
              });
            });
          });
      }
      function executePromiseTask(promise, fn) {
        try {
          fn(function(value) {
            if (promise._state !== null)
              return;
            if (value === promise)
              throw new TypeError("A promise cannot be resolved with itself.");
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === "function") {
              executePromiseTask(promise, function(resolve, reject) {
                value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
              });
            } else {
              promise._state = true;
              promise._value = value;
              propagateAllListeners(promise);
            }
            if (shouldExecuteTick)
              endMicroTickScope();
          }, handleRejection.bind(null, promise));
        } catch (ex) {
          handleRejection(promise, ex);
        }
      }
      function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
          return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
          endMicroTickScope();
      }
      function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
          propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
          ++numScheduledCalls;
          asap(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
      }
      function propagateToListener(promise, listener) {
        if (promise._state === null) {
          promise._listeners.push(listener);
          return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
          return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [cb, promise, listener]);
      }
      function callListener(cb, promise, listener) {
        try {
          var ret, value = promise._value;
          if (!promise._state && rejectingErrors.length)
            rejectingErrors = [];
          ret = debug && promise._consoleTask ? promise._consoleTask.run(function() {
            return cb(value);
          }) : cb(value);
          if (!promise._state && rejectingErrors.indexOf(value) === -1) {
            markErrorAsHandled(promise);
          }
          listener.resolve(ret);
        } catch (e) {
          listener.reject(e);
        } finally {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
          --listener.psd.ref || listener.psd.finalize();
        }
      }
      function physicalTick() {
        usePSD(globalPSD, function() {
          beginMicroTickScope() && endMicroTickScope();
        });
      }
      function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
      }
      function endMicroTickScope() {
        var callbacks, i, l;
        do {
          while (microtickQueue.length > 0) {
            callbacks = microtickQueue;
            microtickQueue = [];
            l = callbacks.length;
            for (i = 0; i < l; ++i) {
              var item = callbacks[i];
              item[0].apply(null, item[1]);
            }
          }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
      }
      function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function(p) {
          p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
          finalizers[--i]();
      }
      function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer2() {
          fn();
          tickFinalizers.splice(tickFinalizers.indexOf(finalizer2), 1);
        }
        tickFinalizers.push(finalizer2);
        ++numScheduledCalls;
        asap(function() {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
        }, []);
      }
      function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function(p) {
          return p._value === promise._value;
        }))
          unhandledErrors.push(promise);
      }
      function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
          if (unhandledErrors[--i]._value === promise._value) {
            unhandledErrors.splice(i, 1);
            return;
          }
      }
      function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
      }
      function wrap2(fn, errorCatcher) {
        var psd = PSD;
        return function() {
          var wasRootExec = beginMicroTickScope(), outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn.apply(this, arguments);
          } catch (e) {
            errorCatcher && errorCatcher(e);
          } finally {
            switchToZone(outerScope, false);
            if (wasRootExec)
              endMicroTickScope();
          }
        };
      }
      var task = { awaits: 0, echoes: 0, id: 0 };
      var taskCounter = 0;
      var zoneStack = [];
      var zoneEchoes = 0;
      var totalEchoes = 0;
      var zone_id_counter = 0;
      function newScope(fn, props2, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
          Promise: DexiePromise,
          PromiseProp: { value: DexiePromise, configurable: true, writable: true },
          all: DexiePromise.all,
          race: DexiePromise.race,
          allSettled: DexiePromise.allSettled,
          any: DexiePromise.any,
          resolve: DexiePromise.resolve,
          reject: DexiePromise.reject
        } : {};
        if (props2)
          extend(psd, props2);
        ++parent.ref;
        psd.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
          psd.finalize();
        return rv;
      }
      function incrementExpectedAwaits() {
        if (!task.id)
          task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
      }
      function decrementExpectedAwaits() {
        if (!task.awaits)
          return false;
        if (--task.awaits === 0)
          task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
      }
      if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
      }
      function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
          incrementExpectedAwaits();
          return possiblePromise.then(function(x) {
            decrementExpectedAwaits();
            return x;
          }, function(e) {
            decrementExpectedAwaits();
            return rejection(e);
          });
        }
        return possiblePromise;
      }
      function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
          task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
      }
      function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
      }
      function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
          queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
          return;
        PSD = targetZone;
        if (currentZone === globalPSD)
          globalPSD.env = snapShot();
        if (patchGlobalPromise) {
          var GlobalPromise = globalPSD.env.Promise;
          var targetEnv = targetZone.env;
          if (currentZone.global || targetZone.global) {
            Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
            GlobalPromise.all = targetEnv.all;
            GlobalPromise.race = targetEnv.race;
            GlobalPromise.resolve = targetEnv.resolve;
            GlobalPromise.reject = targetEnv.reject;
            if (targetEnv.allSettled)
              GlobalPromise.allSettled = targetEnv.allSettled;
            if (targetEnv.any)
              GlobalPromise.any = targetEnv.any;
          }
        }
      }
      function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
          Promise: GlobalPromise,
          PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
          all: GlobalPromise.all,
          race: GlobalPromise.race,
          allSettled: GlobalPromise.allSettled,
          any: GlobalPromise.any,
          resolve: GlobalPromise.resolve,
          reject: GlobalPromise.reject
        } : {};
      }
      function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
          switchToZone(psd, true);
          return fn(a1, a2, a3);
        } finally {
          switchToZone(outerScope, false);
        }
      }
      function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== "function" ? fn : function() {
          var outerZone = PSD;
          if (possibleAwait)
            incrementExpectedAwaits();
          switchToZone(zone, true);
          try {
            return fn.apply(this, arguments);
          } finally {
            switchToZone(outerZone, false);
            if (cleanup)
              queueMicrotask(decrementExpectedAwaits);
          }
        };
      }
      function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
          if (zoneEchoes === 0) {
            cb();
          } else {
            enqueueNativeMicroTask(cb);
          }
        } else {
          setTimeout(cb, 0);
        }
      }
      var rejection = DexiePromise.reject;
      function tempTransaction(db2, mode, storeNames, fn) {
        if (!db2.idbdb || !db2._state.openComplete && (!PSD.letThrough && !db2._vip)) {
          if (db2._state.openComplete) {
            return rejection(new exceptions.DatabaseClosed(db2._state.dbOpenError));
          }
          if (!db2._state.isBeingOpened) {
            if (!db2._state.autoOpen)
              return rejection(new exceptions.DatabaseClosed());
            db2.open().catch(nop);
          }
          return db2._state.dbReadyPromise.then(function() {
            return tempTransaction(db2, mode, storeNames, fn);
          });
        } else {
          var trans = db2._createTransaction(mode, storeNames, db2._dbSchema);
          try {
            trans.create();
            db2._state.PR1398_maxLoop = 3;
          } catch (ex) {
            if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
              console.warn("Dexie: Need to reopen db");
              db2.close({ disableAutoOpen: false });
              return db2.open().then(function() {
                return tempTransaction(db2, mode, storeNames, fn);
              });
            }
            return rejection(ex);
          }
          return trans._promise(mode, function(resolve, reject) {
            return newScope(function() {
              PSD.trans = trans;
              return fn(resolve, reject, trans);
            });
          }).then(function(result) {
            if (mode === "readwrite")
              try {
                trans.idbtrans.commit();
              } catch (_a2) {
              }
            return mode === "readonly" ? result : trans._completion.then(function() {
              return result;
            });
          });
        }
      }
      var DEXIE_VERSION = "4.0.8";
      var maxString = String.fromCharCode(65535);
      var minKey = -Infinity;
      var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
      var STRING_EXPECTED = "String expected.";
      var connections = [];
      var DBNAMES_DB = "__dbnames";
      var READONLY = "readonly";
      var READWRITE = "readwrite";
      function combine(filter1, filter2) {
        return filter1 ? filter2 ? function() {
          return filter1.apply(this, arguments) && filter2.apply(this, arguments);
        } : filter1 : filter2;
      }
      var AnyRange = {
        type: 3,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
      };
      function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
          if (obj[keyPath] === void 0 && keyPath in obj) {
            obj = deepClone(obj);
            delete obj[keyPath];
          }
          return obj;
        } : function(obj) {
          return obj;
        };
      }
      function Entity2() {
        throw exceptions.Type();
      }
      function cmp2(a, b) {
        try {
          var ta = type(a);
          var tb = type(b);
          if (ta !== tb) {
            if (ta === "Array")
              return 1;
            if (tb === "Array")
              return -1;
            if (ta === "binary")
              return 1;
            if (tb === "binary")
              return -1;
            if (ta === "string")
              return 1;
            if (tb === "string")
              return -1;
            if (ta === "Date")
              return 1;
            if (tb !== "Date")
              return NaN;
            return -1;
          }
          switch (ta) {
            case "number":
            case "Date":
            case "string":
              return a > b ? 1 : a < b ? -1 : 0;
            case "binary": {
              return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
            }
            case "Array":
              return compareArrays(a, b);
          }
        } catch (_a2) {
        }
        return NaN;
      }
      function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
          var res = cmp2(a[i], b[i]);
          if (res !== 0)
            return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
          if (a[i] !== b[i])
            return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      function type(x) {
        var t = typeof x;
        if (t !== "object")
          return t;
        if (ArrayBuffer.isView(x))
          return "binary";
        var tsTag = toStringTag(x);
        return tsTag === "ArrayBuffer" ? "binary" : tsTag;
      }
      function getUint8Array(a) {
        if (a instanceof Uint8Array)
          return a;
        if (ArrayBuffer.isView(a))
          return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
      }
      var Table = function() {
        function Table2() {
        }
        Table2.prototype._trans = function(mode, fn, writeLocked) {
          var trans = this._tx || PSD.trans;
          var tableName = this.name;
          var task2 = debug && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
          function checkTableInTransaction(resolve, reject, trans2) {
            if (!trans2.schema[tableName])
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            return fn(trans2.idbtrans, trans2);
          }
          var wasRootExec = beginMicroTickScope();
          try {
            var p = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
              return trans._promise(mode, checkTableInTransaction, writeLocked);
            }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            if (task2) {
              p._consoleTask = task2;
              p = p.catch(function(err) {
                console.trace(err);
                return rejection(err);
              });
            }
            return p;
          } finally {
            if (wasRootExec)
              endMicroTickScope();
          }
        };
        Table2.prototype.get = function(keyOrCrit, cb) {
          var _this = this;
          if (keyOrCrit && keyOrCrit.constructor === Object)
            return this.where(keyOrCrit).first(cb);
          if (keyOrCrit == null)
            return rejection(new exceptions.Type("Invalid argument to Table.get()"));
          return this._trans("readonly", function(trans) {
            return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
              return _this.hook.reading.fire(res);
            });
          }).then(cb);
        };
        Table2.prototype.where = function(indexOrCrit) {
          if (typeof indexOrCrit === "string")
            return new this.db.WhereClause(this, indexOrCrit);
          if (isArray(indexOrCrit))
            return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
          var keyPaths = keys(indexOrCrit);
          if (keyPaths.length === 1)
            return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
          var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
            if (ix.compound && keyPaths.every(function(keyPath) {
              return ix.keyPath.indexOf(keyPath) >= 0;
            })) {
              for (var i = 0; i < keyPaths.length; ++i) {
                if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                  return false;
              }
              return true;
            }
            return false;
          }).sort(function(a, b) {
            return a.keyPath.length - b.keyPath.length;
          })[0];
          if (compoundIndex && this.db._maxKey !== maxString) {
            var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
              return indexOrCrit[kp];
            }));
          }
          if (!compoundIndex && debug)
            console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
          var idxByName = this.schema.idxByName;
          var idb = this.db._deps.indexedDB;
          function equals(a, b) {
            return idb.cmp(a, b) === 0;
          }
          var _a2 = keyPaths.reduce(function(_a3, keyPath) {
            var prevIndex = _a3[0], prevFilterFn = _a3[1];
            var index = idxByName[keyPath];
            var value = indexOrCrit[keyPath];
            return [
              prevIndex || index,
              prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                var prop = getByKeyPath(x, keyPath);
                return isArray(prop) && prop.some(function(item) {
                  return equals(value, item);
                });
              } : function(x) {
                return equals(value, getByKeyPath(x, keyPath));
              }) : prevFilterFn
            ];
          }, [null, null]), idx = _a2[0], filterFunction = _a2[1];
          return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
        };
        Table2.prototype.filter = function(filterFunction) {
          return this.toCollection().and(filterFunction);
        };
        Table2.prototype.count = function(thenShortcut) {
          return this.toCollection().count(thenShortcut);
        };
        Table2.prototype.offset = function(offset) {
          return this.toCollection().offset(offset);
        };
        Table2.prototype.limit = function(numRows) {
          return this.toCollection().limit(numRows);
        };
        Table2.prototype.each = function(callback) {
          return this.toCollection().each(callback);
        };
        Table2.prototype.toArray = function(thenShortcut) {
          return this.toCollection().toArray(thenShortcut);
        };
        Table2.prototype.toCollection = function() {
          return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table2.prototype.orderBy = function(index) {
          return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? "[".concat(index.join("+"), "]") : index));
        };
        Table2.prototype.reverse = function() {
          return this.toCollection().reverse();
        };
        Table2.prototype.mapToClass = function(constructor) {
          var _a2 = this, db2 = _a2.db, tableName = _a2.name;
          this.schema.mappedClass = constructor;
          if (constructor.prototype instanceof Entity2) {
            constructor = function(_super) {
              __extends(class_1, _super);
              function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              Object.defineProperty(class_1.prototype, "db", {
                get: function() {
                  return db2;
                },
                enumerable: false,
                configurable: true
              });
              class_1.prototype.table = function() {
                return tableName;
              };
              return class_1;
            }(constructor);
          }
          var inheritedProps = /* @__PURE__ */ new Set();
          for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
            Object.getOwnPropertyNames(proto).forEach(function(propName) {
              return inheritedProps.add(propName);
            });
          }
          var readHook = function(obj) {
            if (!obj)
              return obj;
            var res = Object.create(constructor.prototype);
            for (var m in obj)
              if (!inheritedProps.has(m))
                try {
                  res[m] = obj[m];
                } catch (_) {
                }
            return res;
          };
          if (this.schema.readHook) {
            this.hook.reading.unsubscribe(this.schema.readHook);
          }
          this.schema.readHook = readHook;
          this.hook("reading", readHook);
          return constructor;
        };
        Table2.prototype.defineClass = function() {
          function Class(content) {
            extend(this, content);
          }
          return this.mapToClass(Class);
        };
        Table2.prototype.add = function(obj, key) {
          var _this = this;
          var _a2 = this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.update = function(keyOrObject, modifications) {
          if (typeof keyOrObject === "object" && !isArray(keyOrObject)) {
            var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
            if (key === void 0)
              return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
            return this.where(":id").equals(key).modify(modifications);
          } else {
            return this.where(":id").equals(keyOrObject).modify(modifications);
          }
        };
        Table2.prototype.put = function(obj, key) {
          var _this = this;
          var _a2 = this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.delete = function(key) {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: [key] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.clear = function() {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.bulkGet = function(keys2) {
          var _this = this;
          return this._trans("readonly", function(trans) {
            return _this.core.getMany({
              keys: keys2,
              trans
            }).then(function(result) {
              return result.map(function(res) {
                return _this.hook.reading.fire(res);
              });
            });
          });
        };
        Table2.prototype.bulkAdd = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys2 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a2 = _this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
            if (keyPath && keys2)
              throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (keys2 && keys2.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(function(_a3) {
              var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkPut = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys2 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a2 = _this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
            if (keyPath && keys2)
              throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (keys2 && keys2.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(function(_a3) {
              var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkUpdate = function(keysAndChanges) {
          var _this = this;
          var coreTable = this.core;
          var keys2 = keysAndChanges.map(function(entry) {
            return entry.key;
          });
          var changeSpecs = keysAndChanges.map(function(entry) {
            return entry.changes;
          });
          var offsetMap = [];
          return this._trans("readwrite", function(trans) {
            return coreTable.getMany({ trans, keys: keys2, cache: "clone" }).then(function(objs) {
              var resultKeys = [];
              var resultObjs = [];
              keysAndChanges.forEach(function(_a2, idx) {
                var key = _a2.key, changes = _a2.changes;
                var obj = objs[idx];
                if (obj) {
                  for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                    var keyPath = _b[_i];
                    var value = changes[keyPath];
                    if (keyPath === _this.schema.primKey.keyPath) {
                      if (cmp2(value, key) !== 0) {
                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                      }
                    } else {
                      setByKeyPath(obj, keyPath, value);
                    }
                  }
                  offsetMap.push(idx);
                  resultKeys.push(key);
                  resultObjs.push(obj);
                }
              });
              var numEntries = resultKeys.length;
              return coreTable.mutate({
                trans,
                type: "put",
                keys: resultKeys,
                values: resultObjs,
                updates: {
                  keys: keys2,
                  changeSpecs
                }
              }).then(function(_a2) {
                var numFailures = _a2.numFailures, failures = _a2.failures;
                if (numFailures === 0)
                  return numEntries;
                for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                  var offset = _b[_i];
                  var mappedOffset = offsetMap[Number(offset)];
                  if (mappedOffset != null) {
                    var failure = failures[offset];
                    delete failures[offset];
                    failures[mappedOffset] = failure;
                  }
                }
                throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
              });
            });
          });
        };
        Table2.prototype.bulkDelete = function(keys2) {
          var _this = this;
          var numKeys = keys2.length;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: keys2 });
          }).then(function(_a2) {
            var numFailures = _a2.numFailures, lastResult = _a2.lastResult, failures = _a2.failures;
            if (numFailures === 0)
              return lastResult;
            throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
          });
        };
        return Table2;
      }();
      function Events(ctx) {
        var evs = {};
        var rv = function(eventName, subscriber) {
          if (subscriber) {
            var i2 = arguments.length, args = new Array(i2 - 1);
            while (--i2)
              args[i2 - 1] = arguments[i2];
            evs[eventName].subscribe.apply(null, args);
            return ctx;
          } else if (typeof eventName === "string") {
            return evs[eventName];
          }
        };
        rv.addEventType = add3;
        for (var i = 1, l = arguments.length; i < l; ++i) {
          add3(arguments[i]);
        }
        return rv;
        function add3(eventName, chainFunction, defaultFunction) {
          if (typeof eventName === "object")
            return addConfiguredEvents(eventName);
          if (!chainFunction)
            chainFunction = reverseStoppableEventChain;
          if (!defaultFunction)
            defaultFunction = nop;
          var context = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: function(cb) {
              if (context.subscribers.indexOf(cb) === -1) {
                context.subscribers.push(cb);
                context.fire = chainFunction(context.fire, cb);
              }
            },
            unsubscribe: function(cb) {
              context.subscribers = context.subscribers.filter(function(fn) {
                return fn !== cb;
              });
              context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
            }
          };
          evs[eventName] = rv[eventName] = context;
          return context;
        }
        function addConfiguredEvents(cfg) {
          keys(cfg).forEach(function(eventName) {
            var args = cfg[eventName];
            if (isArray(args)) {
              add3(eventName, cfg[eventName][0], cfg[eventName][1]);
            } else if (args === "asap") {
              var context = add3(eventName, mirror, function fire() {
                var i2 = arguments.length, args2 = new Array(i2);
                while (i2--)
                  args2[i2] = arguments[i2];
                context.subscribers.forEach(function(fn) {
                  asap$1(function fireEvent() {
                    fn.apply(null, args2);
                  });
                });
              });
            } else
              throw new exceptions.InvalidArgument("Invalid event config");
          });
        }
      }
      function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype });
        return constructor;
      }
      function createTableConstructor(db2) {
        return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
          this.db = db2;
          this._tx = trans;
          this.name = name;
          this.schema = tableSchema;
          this.hook = db2._allTables[name] ? db2._allTables[name].hook : Events(null, {
            "creating": [hookCreatingChain, nop],
            "reading": [pureFunctionChain, mirror],
            "updating": [hookUpdatingChain, nop],
            "deleting": [hookDeletingChain, nop]
          });
        });
      }
      function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
      }
      function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
      }
      function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function() {
          return combine(curr(), factory());
        } : factory;
        ctx.justLimit = isLimitFilter && !curr;
      }
      function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
      }
      function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
          return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
          throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
      }
      function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
          trans,
          values: !ctx.keysOnly,
          reverse: ctx.dir === "prev",
          unique: !!ctx.unique,
          query: {
            index,
            range: ctx.range
          }
        });
      }
      function iter(ctx, fn, coreTrans, coreTable) {
        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
          return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        } else {
          var set_1 = {};
          var union = function(item, cursor, advance) {
            if (!filter || filter(cursor, advance, function(result) {
              return cursor.stop(result);
            }, function(err) {
              return cursor.fail(err);
            })) {
              var primaryKey = cursor.primaryKey;
              var key = "" + primaryKey;
              if (key === "[object ArrayBuffer]")
                key = "" + new Uint8Array(primaryKey);
              if (!hasOwn(set_1, key)) {
                set_1[key] = true;
                fn(item, cursor, advance);
              }
            }
          };
          return Promise.all([
            ctx.or._iterate(union, coreTrans),
            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
          ]);
        }
      }
      function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? function(x, c, a) {
          return fn(valueMapper(x), c, a);
        } : fn;
        var wrappedFn = wrap2(mappedFn);
        return cursorPromise.then(function(cursor) {
          if (cursor) {
            return cursor.start(function() {
              var c = function() {
                return cursor.continue();
              };
              if (!filter || filter(cursor, function(advancer) {
                return c = advancer;
              }, function(val) {
                cursor.stop(val);
                c = nop;
              }, function(e) {
                cursor.fail(e);
                c = nop;
              }))
                wrappedFn(cursor.value, cursor, function(advancer) {
                  return c = advancer;
                });
              c();
            });
          }
        });
      }
      var PropModSymbol2 = Symbol();
      var PropModification2 = function() {
        function PropModification3(spec) {
          Object.assign(this, spec);
        }
        PropModification3.prototype.execute = function(value) {
          var _a2;
          if (this.add !== void 0) {
            var term = this.add;
            if (isArray(term)) {
              return __spreadArray(__spreadArray([], isArray(value) ? value : [], true), term, true).sort();
            }
            if (typeof term === "number")
              return (Number(value) || 0) + term;
            if (typeof term === "bigint") {
              try {
                return BigInt(value) + term;
              } catch (_b) {
                return BigInt(0) + term;
              }
            }
            throw new TypeError("Invalid term ".concat(term));
          }
          if (this.remove !== void 0) {
            var subtrahend_1 = this.remove;
            if (isArray(subtrahend_1)) {
              return isArray(value) ? value.filter(function(item) {
                return !subtrahend_1.includes(item);
              }).sort() : [];
            }
            if (typeof subtrahend_1 === "number")
              return Number(value) - subtrahend_1;
            if (typeof subtrahend_1 === "bigint") {
              try {
                return BigInt(value) - subtrahend_1;
              } catch (_c) {
                return BigInt(0) - subtrahend_1;
              }
            }
            throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
          }
          var prefixToReplace = (_a2 = this.replacePrefix) === null || _a2 === void 0 ? void 0 : _a2[0];
          if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
            return this.replacePrefix[1] + value.substring(prefixToReplace.length);
          }
          return value;
        };
        return PropModification3;
      }();
      var Collection = function() {
        function Collection2() {
        }
        Collection2.prototype._read = function(fn, cb) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
        };
        Collection2.prototype._write = function(fn) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
        };
        Collection2.prototype._addAlgorithm = function(fn) {
          var ctx = this._ctx;
          ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection2.prototype._iterate = function(fn, coreTrans) {
          return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection2.prototype.clone = function(props2) {
          var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
          if (props2)
            extend(ctx, props2);
          rv._ctx = ctx;
          return rv;
        };
        Collection2.prototype.raw = function() {
          this._ctx.valueMapper = null;
          return this;
        };
        Collection2.prototype.each = function(fn) {
          var ctx = this._ctx;
          return this._read(function(trans) {
            return iter(ctx, fn, trans, ctx.table.core);
          });
        };
        Collection2.prototype.count = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            var coreTable = ctx.table.core;
            if (isPlainKeyRange(ctx, true)) {
              return coreTable.count({
                trans,
                query: {
                  index: getIndexOrStore(ctx, coreTable.schema),
                  range: ctx.range
                }
              }).then(function(count2) {
                return Math.min(count2, ctx.limit);
              });
            } else {
              var count = 0;
              return iter(ctx, function() {
                ++count;
                return false;
              }, trans, coreTable).then(function() {
                return count;
              });
            }
          }).then(cb);
        };
        Collection2.prototype.sortBy = function(keyPath, cb) {
          var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
          function getval(obj, i) {
            if (i)
              return getval(obj[parts[i]], i - 1);
            return obj[lastPart];
          }
          var order = this._ctx.dir === "next" ? 1 : -1;
          function sorter(a, b) {
            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
            return aVal < bVal ? -order : aVal > bVal ? order : 0;
          }
          return this.toArray(function(a) {
            return a.sort(sorter);
          }).then(cb);
        };
        Collection2.prototype.toArray = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              var valueMapper_1 = ctx.valueMapper;
              var index = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                limit: ctx.limit,
                values: true,
                query: {
                  index,
                  range: ctx.range
                }
              }).then(function(_a2) {
                var result = _a2.result;
                return valueMapper_1 ? result.map(valueMapper_1) : result;
              });
            } else {
              var a_1 = [];
              return iter(ctx, function(item) {
                return a_1.push(item);
              }, trans, ctx.table.core).then(function() {
                return a_1;
              });
            }
          }, cb);
        };
        Collection2.prototype.offset = function(offset) {
          var ctx = this._ctx;
          if (offset <= 0)
            return this;
          ctx.offset += offset;
          if (isPlainKeyRange(ctx)) {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function(cursor, advance) {
                if (offsetLeft === 0)
                  return true;
                if (offsetLeft === 1) {
                  --offsetLeft;
                  return false;
                }
                advance(function() {
                  cursor.advance(offsetLeft);
                  offsetLeft = 0;
                });
                return false;
              };
            });
          } else {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function() {
                return --offsetLeft < 0;
              };
            });
          }
          return this;
        };
        Collection2.prototype.limit = function(numRows) {
          this._ctx.limit = Math.min(this._ctx.limit, numRows);
          addReplayFilter(this._ctx, function() {
            var rowsLeft = numRows;
            return function(cursor, advance, resolve) {
              if (--rowsLeft <= 0)
                advance(resolve);
              return rowsLeft >= 0;
            };
          }, true);
          return this;
        };
        Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
          addFilter(this._ctx, function(cursor, advance, resolve) {
            if (filterFunction(cursor.value)) {
              advance(resolve);
              return bIncludeStopEntry;
            } else {
              return true;
            }
          });
          return this;
        };
        Collection2.prototype.first = function(cb) {
          return this.limit(1).toArray(function(a) {
            return a[0];
          }).then(cb);
        };
        Collection2.prototype.last = function(cb) {
          return this.reverse().first(cb);
        };
        Collection2.prototype.filter = function(filterFunction) {
          addFilter(this._ctx, function(cursor) {
            return filterFunction(cursor.value);
          });
          addMatchFilter(this._ctx, filterFunction);
          return this;
        };
        Collection2.prototype.and = function(filter) {
          return this.filter(filter);
        };
        Collection2.prototype.or = function(indexName) {
          return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection2.prototype.reverse = function() {
          this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
          if (this._ondirectionchange)
            this._ondirectionchange(this._ctx.dir);
          return this;
        };
        Collection2.prototype.desc = function() {
          return this.reverse();
        };
        Collection2.prototype.eachKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.key, cursor);
          });
        };
        Collection2.prototype.eachUniqueKey = function(cb) {
          this._ctx.unique = "unique";
          return this.eachKey(cb);
        };
        Collection2.prototype.eachPrimaryKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.primaryKey, cursor);
          });
        };
        Collection2.prototype.keys = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          var a = [];
          return this.each(function(item, cursor) {
            a.push(cursor.key);
          }).then(function() {
            return a;
          }).then(cb);
        };
        Collection2.prototype.primaryKeys = function(cb) {
          var ctx = this._ctx;
          if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
            return this._read(function(trans) {
              var index = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                values: false,
                limit: ctx.limit,
                query: {
                  index,
                  range: ctx.range
                }
              });
            }).then(function(_a2) {
              var result = _a2.result;
              return result;
            }).then(cb);
          }
          ctx.keysOnly = !ctx.isMatch;
          var a = [];
          return this.each(function(item, cursor) {
            a.push(cursor.primaryKey);
          }).then(function() {
            return a;
          }).then(cb);
        };
        Collection2.prototype.uniqueKeys = function(cb) {
          this._ctx.unique = "unique";
          return this.keys(cb);
        };
        Collection2.prototype.firstKey = function(cb) {
          return this.limit(1).keys(function(a) {
            return a[0];
          }).then(cb);
        };
        Collection2.prototype.lastKey = function(cb) {
          return this.reverse().firstKey(cb);
        };
        Collection2.prototype.distinct = function() {
          var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
          if (!idx || !idx.multi)
            return this;
          var set = {};
          addFilter(this._ctx, function(cursor) {
            var strKey = cursor.primaryKey.toString();
            var found = hasOwn(set, strKey);
            set[strKey] = true;
            return !found;
          });
          return this;
        };
        Collection2.prototype.modify = function(changes) {
          var _this = this;
          var ctx = this._ctx;
          return this._write(function(trans) {
            var modifyer;
            if (typeof changes === "function") {
              modifyer = changes;
            } else {
              var keyPaths = keys(changes);
              var numKeys = keyPaths.length;
              modifyer = function(item) {
                var anythingModified = false;
                for (var i = 0; i < numKeys; ++i) {
                  var keyPath = keyPaths[i];
                  var val = changes[keyPath];
                  var origVal = getByKeyPath(item, keyPath);
                  if (val instanceof PropModification2) {
                    setByKeyPath(item, keyPath, val.execute(origVal));
                    anythingModified = true;
                  } else if (origVal !== val) {
                    setByKeyPath(item, keyPath, val);
                    anythingModified = true;
                  }
                }
                return anythingModified;
              };
            }
            var coreTable = ctx.table.core;
            var _a2 = coreTable.schema.primaryKey, outbound = _a2.outbound, extractKey = _a2.extractKey;
            var limit = _this.db._options.modifyChunkSize || 200;
            var totalFailures = [];
            var successCount = 0;
            var failedKeys = [];
            var applyMutateResult = function(expectedCount, res) {
              var failures = res.failures, numFailures = res.numFailures;
              successCount += expectedCount - numFailures;
              for (var _i = 0, _a3 = keys(failures); _i < _a3.length; _i++) {
                var pos = _a3[_i];
                totalFailures.push(failures[pos]);
              }
            };
            return _this.clone().primaryKeys().then(function(keys2) {
              var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                index: ctx.index,
                range: ctx.range
              };
              var nextChunk = function(offset) {
                var count = Math.min(limit, keys2.length - offset);
                return coreTable.getMany({
                  trans,
                  keys: keys2.slice(offset, offset + count),
                  cache: "immutable"
                }).then(function(values) {
                  var addValues = [];
                  var putValues = [];
                  var putKeys = outbound ? [] : null;
                  var deleteKeys = [];
                  for (var i = 0; i < count; ++i) {
                    var origValue = values[i];
                    var ctx_1 = {
                      value: deepClone(origValue),
                      primKey: keys2[offset + i]
                    };
                    if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                      if (ctx_1.value == null) {
                        deleteKeys.push(keys2[offset + i]);
                      } else if (!outbound && cmp2(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                        deleteKeys.push(keys2[offset + i]);
                        addValues.push(ctx_1.value);
                      } else {
                        putValues.push(ctx_1.value);
                        if (outbound)
                          putKeys.push(keys2[offset + i]);
                      }
                    }
                  }
                  return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                    for (var pos in res.failures) {
                      deleteKeys.splice(parseInt(pos), 1);
                    }
                    applyMutateResult(addValues.length, res);
                  })).then(function() {
                    return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                      trans,
                      type: "put",
                      keys: putKeys,
                      values: putValues,
                      criteria,
                      changeSpec: typeof changes !== "function" && changes,
                      isAdditionalChunk: offset > 0
                    }).then(function(res) {
                      return applyMutateResult(putValues.length, res);
                    });
                  }).then(function() {
                    return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                      trans,
                      type: "delete",
                      keys: deleteKeys,
                      criteria,
                      isAdditionalChunk: offset > 0
                    }).then(function(res) {
                      return applyMutateResult(deleteKeys.length, res);
                    });
                  }).then(function() {
                    return keys2.length > offset + count && nextChunk(offset + limit);
                  });
                });
              };
              return nextChunk(0).then(function() {
                if (totalFailures.length > 0)
                  throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                return keys2.length;
              });
            });
          });
        };
        Collection2.prototype.delete = function() {
          var ctx = this._ctx, range = ctx.range;
          if (isPlainKeyRange(ctx) && (ctx.isPrimKey || range.type === 3)) {
            return this._write(function(trans) {
              var primaryKey = ctx.table.core.schema.primaryKey;
              var coreRange = range;
              return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count) {
                return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a2) {
                  var failures = _a2.failures;
                  _a2.lastResult;
                  _a2.results;
                  var numFailures = _a2.numFailures;
                  if (numFailures)
                    throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                      return failures[pos];
                    }), count - numFailures);
                  return count - numFailures;
                });
              });
            });
          }
          return this.modify(deleteCallback);
        };
        return Collection2;
      }();
      var deleteCallback = function(value, ctx) {
        return ctx.value = null;
      };
      function createCollectionConstructor(db2) {
        return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
          this.db = db2;
          var keyRange = AnyRange, error = null;
          if (keyRangeGenerator)
            try {
              keyRange = keyRangeGenerator();
            } catch (ex) {
              error = ex;
            }
          var whereCtx = whereClause._ctx;
          var table = whereCtx.table;
          var readingHook = table.hook.reading.fire;
          this._ctx = {
            table,
            index: whereCtx.index,
            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true,
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error,
            or: whereCtx.or,
            valueMapper: readingHook !== mirror ? readingHook : null
          };
        });
      }
      function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
      }
      function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
      }
      function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
      }
      function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function() {
          return rangeEqual("");
        }).limit(0);
      }
      function upperFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toUpperCase();
        } : function(s) {
          return s.toLowerCase();
        };
      }
      function lowerFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toLowerCase();
        } : function(s) {
          return s.toUpperCase();
        };
      }
      function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length; ++i) {
          var lwrKeyChar = lowerKey[i];
          if (lwrKeyChar !== lowerNeedle[i]) {
            if (cmp3(key[i], upperNeedle[i]) < 0)
              return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
            if (cmp3(key[i], lowerNeedle[i]) < 0)
              return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
            if (llp >= 0)
              return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
            return null;
          }
          if (cmp3(key[i], lwrKeyChar) < 0)
            llp = i;
        }
        if (length < lowerNeedle.length && dir === "next")
          return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
          return key.substr(0, upperNeedle.length);
        return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
      }
      function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function(s) {
          return typeof s === "string";
        })) {
          return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
          upper = upperFactory(dir);
          lower = lowerFactory(dir);
          compare = dir === "next" ? simpleCompare : simpleCompareReverse;
          var needleBounds = needles.map(function(needle) {
            return { lower: lower(needle), upper: upper(needle) };
          }).sort(function(a, b) {
            return compare(a.lower, b.lower);
          });
          upperNeedles = needleBounds.map(function(nb) {
            return nb.upper;
          });
          lowerNeedles = needleBounds.map(function(nb) {
            return nb.lower;
          });
          direction = dir;
          nextKeySuffix = dir === "next" ? "" : suffix;
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function() {
          return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
        });
        c._ondirectionchange = function(direction2) {
          initDirection(direction2);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function(cursor, advance, resolve) {
          var key = cursor.key;
          if (typeof key !== "string")
            return false;
          var lowerKey = lower(key);
          if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
            return true;
          } else {
            var lowestPossibleCasing = null;
            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
              var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
              if (casing === null && lowestPossibleCasing === null)
                firstPossibleNeedle = i + 1;
              else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                lowestPossibleCasing = casing;
              }
            }
            if (lowestPossibleCasing !== null) {
              advance(function() {
                cursor.continue(lowestPossibleCasing + nextKeySuffix);
              });
            } else {
              advance(resolve);
            }
            return false;
          }
        });
        return c;
      }
      function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
          type: 2,
          lower,
          upper,
          lowerOpen,
          upperOpen
        };
      }
      function rangeEqual(value) {
        return {
          type: 1,
          lower: value,
          upper: value
        };
      }
      var WhereClause = function() {
        function WhereClause2() {
        }
        Object.defineProperty(WhereClause2.prototype, "Collection", {
          get: function() {
            return this._ctx.table.db.Collection;
          },
          enumerable: false,
          configurable: true
        });
        WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
          includeLower = includeLower !== false;
          includeUpper = includeUpper === true;
          try {
            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
              return emptyCollection(this);
            return new this.Collection(this, function() {
              return createRange(lower, upper, !includeLower, !includeUpper);
            });
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
        };
        WhereClause2.prototype.equals = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return rangeEqual(value);
          });
        };
        WhereClause2.prototype.above = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, true);
          });
        };
        WhereClause2.prototype.aboveOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, false);
          });
        };
        WhereClause2.prototype.below = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value, false, true);
          });
        };
        WhereClause2.prototype.belowOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value);
          });
        };
        WhereClause2.prototype.startsWith = function(str) {
          if (typeof str !== "string")
            return fail(this, STRING_EXPECTED);
          return this.between(str, str + maxString, true, true);
        };
        WhereClause2.prototype.startsWithIgnoreCase = function(str) {
          if (str === "")
            return this.startsWith(str);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x.indexOf(a[0]) === 0;
          }, [str], maxString);
        };
        WhereClause2.prototype.equalsIgnoreCase = function(str) {
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x === a[0];
          }, [str], "");
        };
        WhereClause2.prototype.anyOfIgnoreCase = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.indexOf(x) !== -1;
          }, set, "");
        };
        WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.some(function(n) {
              return x.indexOf(n) === 0;
            });
          }, set, maxString);
        };
        WhereClause2.prototype.anyOf = function() {
          var _this = this;
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          var compare = this._cmp;
          try {
            set.sort(compare);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          if (set.length === 0)
            return emptyCollection(this);
          var c = new this.Collection(this, function() {
            return createRange(set[0], set[set.length - 1]);
          });
          c._ondirectionchange = function(direction) {
            compare = direction === "next" ? _this._ascending : _this._descending;
            set.sort(compare);
          };
          var i = 0;
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while (compare(key, set[i]) > 0) {
              ++i;
              if (i === set.length) {
                advance(resolve);
                return false;
              }
            }
            if (compare(key, set[i]) === 0) {
              return true;
            } else {
              advance(function() {
                cursor.continue(set[i]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.notEqual = function(value) {
          return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.noneOf = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return new this.Collection(this);
          try {
            set.sort(this._ascending);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var ranges = set.reduce(function(res, val) {
            return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
          }, null);
          ranges.push([set[set.length - 1], this.db._maxKey]);
          return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.inAnyRange = function(ranges, options) {
          var _this = this;
          var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
          if (ranges.length === 0)
            return emptyCollection(this);
          if (!ranges.every(function(range) {
            return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
          })) {
            return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
          }
          var includeLowers = !options || options.includeLowers !== false;
          var includeUppers = options && options.includeUppers === true;
          function addRange2(ranges2, newRange) {
            var i = 0, l = ranges2.length;
            for (; i < l; ++i) {
              var range = ranges2[i];
              if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                range[0] = min(range[0], newRange[0]);
                range[1] = max(range[1], newRange[1]);
                break;
              }
            }
            if (i === l)
              ranges2.push(newRange);
            return ranges2;
          }
          var sortDirection = ascending;
          function rangeSorter(a, b) {
            return sortDirection(a[0], b[0]);
          }
          var set;
          try {
            set = ranges.reduce(addRange2, []);
            set.sort(rangeSorter);
          } catch (ex) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var rangePos = 0;
          var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
            return ascending(key, set[rangePos][1]) > 0;
          } : function(key) {
            return ascending(key, set[rangePos][1]) >= 0;
          };
          var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
            return descending(key, set[rangePos][0]) > 0;
          } : function(key) {
            return descending(key, set[rangePos][0]) >= 0;
          };
          function keyWithinCurrentRange(key) {
            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
          }
          var checkKey = keyIsBeyondCurrentEntry;
          var c = new this.Collection(this, function() {
            return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
          });
          c._ondirectionchange = function(direction) {
            if (direction === "next") {
              checkKey = keyIsBeyondCurrentEntry;
              sortDirection = ascending;
            } else {
              checkKey = keyIsBeforeCurrentEntry;
              sortDirection = descending;
            }
            set.sort(rangeSorter);
          };
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while (checkKey(key)) {
              ++rangePos;
              if (rangePos === set.length) {
                advance(resolve);
                return false;
              }
            }
            if (keyWithinCurrentRange(key)) {
              return true;
            } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
              return false;
            } else {
              advance(function() {
                if (sortDirection === ascending)
                  cursor.continue(set[rangePos][0]);
                else
                  cursor.continue(set[rangePos][1]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.startsWithAnyOf = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (!set.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(this, "startsWithAnyOf() only works with strings");
          }
          if (set.length === 0)
            return emptyCollection(this);
          return this.inAnyRange(set.map(function(str) {
            return [str, str + maxString];
          }));
        };
        return WhereClause2;
      }();
      function createWhereClauseConstructor(db2) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
          this.db = db2;
          this._ctx = {
            table,
            index: index === ":id" ? null : index,
            or: orCollection
          };
          this._cmp = this._ascending = cmp2;
          this._descending = function(a, b) {
            return cmp2(b, a);
          };
          this._max = function(a, b) {
            return cmp2(a, b) > 0 ? a : b;
          };
          this._min = function(a, b) {
            return cmp2(a, b) < 0 ? a : b;
          };
          this._IDBKeyRange = db2._deps.IDBKeyRange;
          if (!this._IDBKeyRange)
            throw new exceptions.MissingAPI();
        });
      }
      function eventRejectHandler(reject) {
        return wrap2(function(event) {
          preventDefault(event);
          reject(event.target.error);
          return false;
        });
      }
      function preventDefault(event) {
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.preventDefault)
          event.preventDefault();
      }
      var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
      var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
      var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
      var Transaction = function() {
        function Transaction2() {
        }
        Transaction2.prototype._lock = function() {
          assert(!PSD.global);
          ++this._reculock;
          if (this._reculock === 1 && !PSD.global)
            PSD.lockOwnerFor = this;
          return this;
        };
        Transaction2.prototype._unlock = function() {
          assert(!PSD.global);
          if (--this._reculock === 0) {
            if (!PSD.global)
              PSD.lockOwnerFor = null;
            while (this._blockedFuncs.length > 0 && !this._locked()) {
              var fnAndPSD = this._blockedFuncs.shift();
              try {
                usePSD(fnAndPSD[1], fnAndPSD[0]);
              } catch (e) {
              }
            }
          }
          return this;
        };
        Transaction2.prototype._locked = function() {
          return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction2.prototype.create = function(idbtrans) {
          var _this = this;
          if (!this.mode)
            return this;
          var idbdb = this.db.idbdb;
          var dbOpenError = this.db._state.dbOpenError;
          assert(!this.idbtrans);
          if (!idbtrans && !idbdb) {
            switch (dbOpenError && dbOpenError.name) {
              case "DatabaseClosedError":
                throw new exceptions.DatabaseClosed(dbOpenError);
              case "MissingAPIError":
                throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
              default:
                throw new exceptions.OpenFailed(dbOpenError);
            }
          }
          if (!this.active)
            throw new exceptions.TransactionInactive();
          assert(this._completion._state === null);
          idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
          idbtrans.onerror = wrap2(function(ev) {
            preventDefault(ev);
            _this._reject(idbtrans.error);
          });
          idbtrans.onabort = wrap2(function(ev) {
            preventDefault(ev);
            _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
            _this.active = false;
            _this.on("abort").fire(ev);
          });
          idbtrans.oncomplete = wrap2(function() {
            _this.active = false;
            _this._resolve();
            if ("mutatedParts" in idbtrans) {
              globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
            }
          });
          return this;
        };
        Transaction2.prototype._promise = function(mode, fn, bWriteLock) {
          var _this = this;
          if (mode === "readwrite" && this.mode !== "readwrite")
            return rejection(new exceptions.ReadOnly("Transaction is readonly"));
          if (!this.active)
            return rejection(new exceptions.TransactionInactive());
          if (this._locked()) {
            return new DexiePromise(function(resolve, reject) {
              _this._blockedFuncs.push([function() {
                _this._promise(mode, fn, bWriteLock).then(resolve, reject);
              }, PSD]);
            });
          } else if (bWriteLock) {
            return newScope(function() {
              var p2 = new DexiePromise(function(resolve, reject) {
                _this._lock();
                var rv = fn(resolve, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve, reject);
              });
              p2.finally(function() {
                return _this._unlock();
              });
              p2._lib = true;
              return p2;
            });
          } else {
            var p = new DexiePromise(function(resolve, reject) {
              var rv = fn(resolve, reject, _this);
              if (rv && rv.then)
                rv.then(resolve, reject);
            });
            p._lib = true;
            return p;
          }
        };
        Transaction2.prototype._root = function() {
          return this.parent ? this.parent._root() : this;
        };
        Transaction2.prototype.waitFor = function(promiseLike) {
          var root = this._root();
          var promise = DexiePromise.resolve(promiseLike);
          if (root._waitingFor) {
            root._waitingFor = root._waitingFor.then(function() {
              return promise;
            });
          } else {
            root._waitingFor = promise;
            root._waitingQueue = [];
            var store = root.idbtrans.objectStore(root.storeNames[0]);
            (function spin() {
              ++root._spinCount;
              while (root._waitingQueue.length)
                root._waitingQueue.shift()();
              if (root._waitingFor)
                store.get(-Infinity).onsuccess = spin;
            })();
          }
          var currentWaitPromise = root._waitingFor;
          return new DexiePromise(function(resolve, reject) {
            promise.then(function(res) {
              return root._waitingQueue.push(wrap2(resolve.bind(null, res)));
            }, function(err) {
              return root._waitingQueue.push(wrap2(reject.bind(null, err)));
            }).finally(function() {
              if (root._waitingFor === currentWaitPromise) {
                root._waitingFor = null;
              }
            });
          });
        };
        Transaction2.prototype.abort = function() {
          if (this.active) {
            this.active = false;
            if (this.idbtrans)
              this.idbtrans.abort();
            this._reject(new exceptions.Abort());
          }
        };
        Transaction2.prototype.table = function(tableName) {
          var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
          if (hasOwn(memoizedTables, tableName))
            return memoizedTables[tableName];
          var tableSchema = this.schema[tableName];
          if (!tableSchema) {
            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
          }
          var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
          transactionBoundTable.core = this.db.core.table(tableName);
          memoizedTables[tableName] = transactionBoundTable;
          return transactionBoundTable;
        };
        return Transaction2;
      }();
      function createTransactionConstructor(db2) {
        return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
          var _this = this;
          this.db = db2;
          this.mode = mode;
          this.storeNames = storeNames;
          this.schema = dbschema;
          this.chromeTransactionDurability = chromeTransactionDurability;
          this.idbtrans = null;
          this.on = Events(this, "complete", "error", "abort");
          this.parent = parent || null;
          this.active = true;
          this._reculock = 0;
          this._blockedFuncs = [];
          this._resolve = null;
          this._reject = null;
          this._waitingFor = null;
          this._waitingQueue = null;
          this._spinCount = 0;
          this._completion = new DexiePromise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
          });
          this._completion.then(function() {
            _this.active = false;
            _this.on.complete.fire();
          }, function(e) {
            var wasActive = _this.active;
            _this.active = false;
            _this.on.error.fire(e);
            _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
            return rejection(e);
          });
        });
      }
      function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
          name,
          keyPath,
          unique,
          multi,
          auto,
          compound,
          src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
      }
      function nameFromKeyPath(keyPath) {
        return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
      }
      function createTableSchema(name, primKey, indexes) {
        return {
          name,
          primKey,
          indexes,
          mappedClass: null,
          idxByName: arrayToObject(indexes, function(index) {
            return [index.name, index];
          })
        };
      }
      function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
      }
      var getMaxKey = function(IdbKeyRange) {
        try {
          IdbKeyRange.only([[]]);
          getMaxKey = function() {
            return [[]];
          };
          return [[]];
        } catch (e) {
          getMaxKey = function() {
            return maxString;
          };
          return maxString;
        }
      };
      function getKeyExtractor(keyPath) {
        if (keyPath == null) {
          return function() {
            return void 0;
          };
        } else if (typeof keyPath === "string") {
          return getSinglePathKeyExtractor(keyPath);
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split(".");
        if (split.length === 1) {
          return function(obj) {
            return obj[keyPath];
          };
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
      }
      var _id_counter = 0;
      function getKeyPathAlias(keyPath) {
        return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
      }
      function createDBCore(db2, IdbKeyRange, tmpTrans) {
        function extractSchema(db3, trans) {
          var tables2 = arrayify(db3.objectStoreNames);
          return {
            schema: {
              name: db3.name,
              tables: tables2.map(function(table) {
                return trans.objectStore(table);
              }).map(function(store) {
                var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                var compound = isArray(keyPath);
                var outbound = keyPath == null;
                var indexByKeyPath = {};
                var result = {
                  name: store.name,
                  primaryKey: {
                    name: null,
                    isPrimaryKey: true,
                    outbound,
                    compound,
                    keyPath,
                    autoIncrement,
                    unique: true,
                    extractKey: getKeyExtractor(keyPath)
                  },
                  indexes: arrayify(store.indexNames).map(function(indexName) {
                    return store.index(indexName);
                  }).map(function(index) {
                    var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath2 = index.keyPath;
                    var compound2 = isArray(keyPath2);
                    var result2 = {
                      name,
                      compound: compound2,
                      keyPath: keyPath2,
                      unique,
                      multiEntry,
                      extractKey: getKeyExtractor(keyPath2)
                    };
                    indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                    return result2;
                  }),
                  getIndexByKeyPath: function(keyPath2) {
                    return indexByKeyPath[getKeyPathAlias(keyPath2)];
                  }
                };
                indexByKeyPath[":id"] = result.primaryKey;
                if (keyPath != null) {
                  indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                }
                return result;
              })
            },
            hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
          };
        }
        function makeIDBKeyRange(range) {
          if (range.type === 3)
            return null;
          if (range.type === 4)
            throw new Error("Cannot convert never type to IDBKeyRange");
          var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
          var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
          return idbRange;
        }
        function createDbCoreTable(tableSchema) {
          var tableName = tableSchema.name;
          function mutate(_a3) {
            var trans = _a3.trans, type2 = _a3.type, keys2 = _a3.keys, values = _a3.values, range = _a3.range;
            return new Promise(function(resolve, reject) {
              resolve = wrap2(resolve);
              var store = trans.objectStore(tableName);
              var outbound = store.keyPath == null;
              var isAddOrPut = type2 === "put" || type2 === "add";
              if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
                throw new Error("Invalid operation type: " + type2);
              var length = (keys2 || values || { length: 1 }).length;
              if (keys2 && values && keys2.length !== values.length) {
                throw new Error("Given keys array must have same length as given values array.");
              }
              if (length === 0)
                return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              var req;
              var reqs = [];
              var failures = [];
              var numFailures = 0;
              var errorHandler = function(event) {
                ++numFailures;
                preventDefault(event);
              };
              if (type2 === "deleteRange") {
                if (range.type === 4)
                  return resolve({ numFailures, failures, results: [], lastResult: void 0 });
                if (range.type === 3)
                  reqs.push(req = store.clear());
                else
                  reqs.push(req = store.delete(makeIDBKeyRange(range)));
              } else {
                var _a4 = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null], args1 = _a4[0], args2 = _a4[1];
                if (isAddOrPut) {
                  for (var i = 0; i < length; ++i) {
                    reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                    req.onerror = errorHandler;
                  }
                } else {
                  for (var i = 0; i < length; ++i) {
                    reqs.push(req = store[type2](args1[i]));
                    req.onerror = errorHandler;
                  }
                }
              }
              var done = function(event) {
                var lastResult = event.target.result;
                reqs.forEach(function(req2, i2) {
                  return req2.error != null && (failures[i2] = req2.error);
                });
                resolve({
                  numFailures,
                  failures,
                  results: type2 === "delete" ? keys2 : reqs.map(function(req2) {
                    return req2.result;
                  }),
                  lastResult
                });
              };
              req.onerror = function(event) {
                errorHandler(event);
                done(event);
              };
              req.onsuccess = done;
            });
          }
          function openCursor2(_a3) {
            var trans = _a3.trans, values = _a3.values, query2 = _a3.query, reverse = _a3.reverse, unique = _a3.unique;
            return new Promise(function(resolve, reject) {
              resolve = wrap2(resolve);
              var index = query2.index, range = query2.range;
              var store = trans.objectStore(tableName);
              var source = index.isPrimaryKey ? store : store.index(index.name);
              var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
              var req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
              req.onerror = eventRejectHandler(reject);
              req.onsuccess = wrap2(function(ev) {
                var cursor = req.result;
                if (!cursor) {
                  resolve(null);
                  return;
                }
                cursor.___id = ++_id_counter;
                cursor.done = false;
                var _cursorContinue = cursor.continue.bind(cursor);
                var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                if (_cursorContinuePrimaryKey)
                  _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                var _cursorAdvance = cursor.advance.bind(cursor);
                var doThrowCursorIsNotStarted = function() {
                  throw new Error("Cursor not started");
                };
                var doThrowCursorIsStopped = function() {
                  throw new Error("Cursor not stopped");
                };
                cursor.trans = trans;
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                cursor.fail = wrap2(reject);
                cursor.next = function() {
                  var _this = this;
                  var gotOne = 1;
                  return this.start(function() {
                    return gotOne-- ? _this.continue() : _this.stop();
                  }).then(function() {
                    return _this;
                  });
                };
                cursor.start = function(callback) {
                  var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                    resolveIteration = wrap2(resolveIteration);
                    req.onerror = eventRejectHandler(rejectIteration);
                    cursor.fail = rejectIteration;
                    cursor.stop = function(value) {
                      cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                      resolveIteration(value);
                    };
                  });
                  var guardedCallback = function() {
                    if (req.result) {
                      try {
                        callback();
                      } catch (err) {
                        cursor.fail(err);
                      }
                    } else {
                      cursor.done = true;
                      cursor.start = function() {
                        throw new Error("Cursor behind last entry");
                      };
                      cursor.stop();
                    }
                  };
                  req.onsuccess = wrap2(function(ev2) {
                    req.onsuccess = guardedCallback;
                    guardedCallback();
                  });
                  cursor.continue = _cursorContinue;
                  cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                  cursor.advance = _cursorAdvance;
                  guardedCallback();
                  return iterationPromise;
                };
                resolve(cursor);
              }, reject);
            });
          }
          function query(hasGetAll2) {
            return function(request) {
              return new Promise(function(resolve, reject) {
                resolve = wrap2(resolve);
                var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                var index = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var idbKeyRange = makeIDBKeyRange(range);
                if (limit === 0)
                  return resolve({ result: [] });
                if (hasGetAll2) {
                  var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                  req.onsuccess = function(event) {
                    return resolve({ result: event.target.result });
                  };
                  req.onerror = eventRejectHandler(reject);
                } else {
                  var count_1 = 0;
                  var req_1 = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                  var result_1 = [];
                  req_1.onsuccess = function(event) {
                    var cursor = req_1.result;
                    if (!cursor)
                      return resolve({ result: result_1 });
                    result_1.push(values ? cursor.value : cursor.primaryKey);
                    if (++count_1 === limit)
                      return resolve({ result: result_1 });
                    cursor.continue();
                  };
                  req_1.onerror = eventRejectHandler(reject);
                }
              });
            };
          }
          return {
            name: tableName,
            schema: tableSchema,
            mutate,
            getMany: function(_a3) {
              var trans = _a3.trans, keys2 = _a3.keys;
              return new Promise(function(resolve, reject) {
                resolve = wrap2(resolve);
                var store = trans.objectStore(tableName);
                var length = keys2.length;
                var result = new Array(length);
                var keyCount = 0;
                var callbackCount = 0;
                var req;
                var successHandler = function(event) {
                  var req2 = event.target;
                  if ((result[req2._pos] = req2.result) != null)
                    ;
                  if (++callbackCount === keyCount)
                    resolve(result);
                };
                var errorHandler = eventRejectHandler(reject);
                for (var i = 0; i < length; ++i) {
                  var key = keys2[i];
                  if (key != null) {
                    req = store.get(keys2[i]);
                    req._pos = i;
                    req.onsuccess = successHandler;
                    req.onerror = errorHandler;
                    ++keyCount;
                  }
                }
                if (keyCount === 0)
                  resolve(result);
              });
            },
            get: function(_a3) {
              var trans = _a3.trans, key = _a3.key;
              return new Promise(function(resolve, reject) {
                resolve = wrap2(resolve);
                var store = trans.objectStore(tableName);
                var req = store.get(key);
                req.onsuccess = function(event) {
                  return resolve(event.target.result);
                };
                req.onerror = eventRejectHandler(reject);
              });
            },
            query: query(hasGetAll),
            openCursor: openCursor2,
            count: function(_a3) {
              var query2 = _a3.query, trans = _a3.trans;
              var index = query2.index, range = query2.range;
              return new Promise(function(resolve, reject) {
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var idbKeyRange = makeIDBKeyRange(range);
                var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                req.onsuccess = wrap2(function(ev) {
                  return resolve(ev.target.result);
                });
                req.onerror = eventRejectHandler(reject);
              });
            }
          };
        }
        var _a2 = extractSchema(db2, tmpTrans), schema = _a2.schema, hasGetAll = _a2.hasGetAll;
        var tables = schema.tables.map(function(tableSchema) {
          return createDbCoreTable(tableSchema);
        });
        var tableMap = {};
        tables.forEach(function(table) {
          return tableMap[table.name] = table;
        });
        return {
          stack: "dbcore",
          transaction: db2.transaction.bind(db2),
          table: function(name) {
            var result = tableMap[name];
            if (!result)
              throw new Error("Table '".concat(name, "' not found"));
            return tableMap[name];
          },
          MIN_KEY: -Infinity,
          MAX_KEY: getMaxKey(IdbKeyRange),
          schema
        };
      }
      function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function(down, _a2) {
          var create = _a2.create;
          return __assign(__assign({}, down), create(down));
        }, stackImpl);
      }
      function createMiddlewareStacks(middlewares, idbdb, _a2, tmpTrans) {
        var IDBKeyRange = _a2.IDBKeyRange;
        _a2.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
          dbcore
        };
      }
      function generateMiddlewareStacks(db2, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db2._middlewares, idbdb, db2._deps, tmpTrans);
        db2.core = stacks.dbcore;
        db2.tables.forEach(function(table) {
          var tableName = table.name;
          if (db2.core.schema.tables.some(function(tbl) {
            return tbl.name === tableName;
          })) {
            table.core = db2.core.table(tableName);
            if (db2[tableName] instanceof db2.Table) {
              db2[tableName].core = table.core;
            }
          }
        });
      }
      function setApiOnPlace(db2, objs, tableNames, dbschema) {
        tableNames.forEach(function(tableName) {
          var schema = dbschema[tableName];
          objs.forEach(function(obj) {
            var propDesc = getPropertyDescriptor(obj, tableName);
            if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
              if (obj === db2.Transaction.prototype || obj instanceof db2.Transaction) {
                setProp(obj, tableName, {
                  get: function() {
                    return this.table(tableName);
                  },
                  set: function(value) {
                    defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                  }
                });
              } else {
                obj[tableName] = new db2.Table(tableName, schema);
              }
            }
          });
        });
      }
      function removeTablesApi(db2, objs) {
        objs.forEach(function(obj) {
          for (var key in obj) {
            if (obj[key] instanceof db2.Table)
              delete obj[key];
          }
        });
      }
      function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
      }
      function runUpgraders(db2, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db2._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
          globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
          db2._storeNames.push("$meta");
        }
        var trans = db2._createTransaction("readwrite", db2._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function() {
          PSD.trans = trans;
          PSD.transless = transless;
          if (oldVersion === 0) {
            keys(globalSchema).forEach(function(tableName) {
              createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
            });
            generateMiddlewareStacks(db2, idbUpgradeTrans);
            DexiePromise.follow(function() {
              return db2.on.populate.fire(trans);
            }).catch(rejectTransaction);
          } else {
            generateMiddlewareStacks(db2, idbUpgradeTrans);
            return getExistingVersion(db2, trans, oldVersion).then(function(oldVersion2) {
              return updateTablesAndIndexes(db2, oldVersion2, trans, idbUpgradeTrans);
            }).catch(rejectTransaction);
          }
        });
      }
      function patchCurrentVersion(db2, idbUpgradeTrans) {
        createMissingTables(db2._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
          idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
        }
        var globalSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db2, db2._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db2._dbSchema);
        var _loop_1 = function(tableChange2) {
          if (tableChange2.change.length || tableChange2.recreate) {
            console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
            return { value: void 0 };
          }
          var store = idbUpgradeTrans.objectStore(tableChange2.name);
          tableChange2.add.forEach(function(idx) {
            if (debug)
              console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
            addIndex(store, idx);
          });
        };
        for (var _i = 0, _a2 = diff.change; _i < _a2.length; _i++) {
          var tableChange = _a2[_i];
          var state_1 = _loop_1(tableChange);
          if (typeof state_1 === "object")
            return state_1.value;
        }
      }
      function getExistingVersion(db2, trans, oldVersion) {
        if (trans.storeNames.includes("$meta")) {
          return trans.table("$meta").get("version").then(function(metaVersion) {
            return metaVersion != null ? metaVersion : oldVersion;
          });
        } else {
          return DexiePromise.resolve(oldVersion);
        }
      }
      function updateTablesAndIndexes(db2, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db2._versions;
        var globalSchema = db2._dbSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function(v) {
          return v._cfg.version >= oldVersion;
        });
        if (versToRun.length === 0) {
          return DexiePromise.resolve();
        }
        versToRun.forEach(function(version) {
          queue.push(function() {
            var oldSchema = globalSchema;
            var newSchema = version._cfg.dbschema;
            adjustToExistingIndexNames(db2, oldSchema, idbUpgradeTrans);
            adjustToExistingIndexNames(db2, newSchema, idbUpgradeTrans);
            globalSchema = db2._dbSchema = newSchema;
            var diff = getSchemaDiff(oldSchema, newSchema);
            diff.add.forEach(function(tuple) {
              createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
            });
            diff.change.forEach(function(change) {
              if (change.recreate) {
                throw new exceptions.Upgrade("Not yet support for changing primary key");
              } else {
                var store_1 = idbUpgradeTrans.objectStore(change.name);
                change.add.forEach(function(idx) {
                  return addIndex(store_1, idx);
                });
                change.change.forEach(function(idx) {
                  store_1.deleteIndex(idx.name);
                  addIndex(store_1, idx);
                });
                change.del.forEach(function(idxName) {
                  return store_1.deleteIndex(idxName);
                });
              }
            });
            var contentUpgrade = version._cfg.contentUpgrade;
            if (contentUpgrade && version._cfg.version > oldVersion) {
              generateMiddlewareStacks(db2, idbUpgradeTrans);
              trans._memoizedTables = {};
              var upgradeSchema_1 = shallowClone(newSchema);
              diff.del.forEach(function(table) {
                upgradeSchema_1[table] = oldSchema[table];
              });
              removeTablesApi(db2, [db2.Transaction.prototype]);
              setApiOnPlace(db2, [db2.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
              trans.schema = upgradeSchema_1;
              var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
              if (contentUpgradeIsAsync_1) {
                incrementExpectedAwaits();
              }
              var returnValue_1;
              var promiseFollowed = DexiePromise.follow(function() {
                returnValue_1 = contentUpgrade(trans);
                if (returnValue_1) {
                  if (contentUpgradeIsAsync_1) {
                    var decrementor = decrementExpectedAwaits.bind(null, null);
                    returnValue_1.then(decrementor, decrementor);
                  }
                }
              });
              return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                return returnValue_1;
              });
            }
          });
          queue.push(function(idbtrans) {
            var newSchema = version._cfg.dbschema;
            deleteRemovedTables(newSchema, idbtrans);
            removeTablesApi(db2, [db2.Transaction.prototype]);
            setApiOnPlace(db2, [db2.Transaction.prototype], db2._storeNames, db2._dbSchema);
            trans.schema = db2._dbSchema;
          });
          queue.push(function(idbtrans) {
            if (db2.idbdb.objectStoreNames.contains("$meta")) {
              if (Math.ceil(db2.idbdb.version / 10) === version._cfg.version) {
                db2.idbdb.deleteObjectStore("$meta");
                delete db2._dbSchema.$meta;
                db2._storeNames = db2._storeNames.filter(function(name) {
                  return name !== "$meta";
                });
              } else {
                idbtrans.objectStore("$meta").put(version._cfg.version, "version");
              }
            }
          });
        });
        function runQueue() {
          return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
        }
        return runQueue().then(function() {
          createMissingTables(globalSchema, idbUpgradeTrans);
        });
      }
      function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
          del: [],
          add: [],
          change: []
        };
        var table;
        for (table in oldSchema) {
          if (!newSchema[table])
            diff.del.push(table);
        }
        for (table in newSchema) {
          var oldDef = oldSchema[table], newDef = newSchema[table];
          if (!oldDef) {
            diff.add.push([table, newDef]);
          } else {
            var change = {
              name: table,
              def: newDef,
              recreate: false,
              del: [],
              add: [],
              change: []
            };
            if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
              change.recreate = true;
              diff.change.push(change);
            } else {
              var oldIndexes = oldDef.idxByName;
              var newIndexes = newDef.idxByName;
              var idxName = void 0;
              for (idxName in oldIndexes) {
                if (!newIndexes[idxName])
                  change.del.push(idxName);
              }
              for (idxName in newIndexes) {
                var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                if (!oldIdx)
                  change.add.push(newIdx);
                else if (oldIdx.src !== newIdx.src)
                  change.change.push(newIdx);
              }
              if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                diff.change.push(change);
              }
            }
          }
        }
        return diff;
      }
      function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
        indexes.forEach(function(idx) {
          return addIndex(store, idx);
        });
        return store;
      }
      function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function(tableName) {
          if (!idbtrans.db.objectStoreNames.contains(tableName)) {
            if (debug)
              console.debug("Dexie: Creating missing table", tableName);
            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
          }
        });
      }
      function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
          return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
      }
      function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
      }
      function buildGlobalSchema(db2, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function(storeName) {
          var store = tmpTrans.objectStore(storeName);
          var keyPath = store.keyPath;
          var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
          var indexes = [];
          for (var j = 0; j < store.indexNames.length; ++j) {
            var idbindex = store.index(store.indexNames[j]);
            keyPath = idbindex.keyPath;
            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
            indexes.push(index);
          }
          globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
      }
      function readGlobalSchema(db2, idbdb, tmpTrans) {
        db2.verno = idbdb.version / 10;
        var globalSchema = db2._dbSchema = buildGlobalSchema(db2, idbdb, tmpTrans);
        db2._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db2, [db2._allTables], keys(globalSchema), globalSchema);
      }
      function verifyInstalledSchema(db2, tmpTrans) {
        var installedSchema = buildGlobalSchema(db2, db2.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db2._dbSchema);
        return !(diff.add.length || diff.change.some(function(ch) {
          return ch.add.length || ch.change.length;
        }));
      }
      function adjustToExistingIndexNames(db2, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
          var storeName = storeNames[i];
          var store = idbtrans.objectStore(storeName);
          db2._hasGetAll = "getAll" in store;
          for (var j = 0; j < store.indexNames.length; ++j) {
            var indexName = store.indexNames[j];
            var keyPath = store.index(indexName).keyPath;
            var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
            if (schema[storeName]) {
              var indexSpec = schema[storeName].idxByName[dexieName];
              if (indexSpec) {
                indexSpec.name = indexName;
                delete schema[storeName].idxByName[dexieName];
                schema[storeName].idxByName[indexName] = indexSpec;
              }
            }
          }
        }
        if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
          db2._hasGetAll = false;
        }
      }
      function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(",").map(function(index, indexNum) {
          index = index.trim();
          var name = index.replace(/([&*]|\+\+)/g, "");
          var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
          return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
        });
      }
      var Version = function() {
        function Version2() {
        }
        Version2.prototype._parseStoresSpec = function(stores, outSchema) {
          keys(stores).forEach(function(tableName) {
            if (stores[tableName] !== null) {
              var indexes = parseIndexSyntax(stores[tableName]);
              var primKey = indexes.shift();
              primKey.unique = true;
              if (primKey.multi)
                throw new exceptions.Schema("Primary key cannot be multi-valued");
              indexes.forEach(function(idx) {
                if (idx.auto)
                  throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                if (!idx.keyPath)
                  throw new exceptions.Schema("Index must have a name and cannot be an empty string");
              });
              outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
            }
          });
        };
        Version2.prototype.stores = function(stores) {
          var db2 = this.db;
          this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
          var versions = db2._versions;
          var storesSpec = {};
          var dbschema = {};
          versions.forEach(function(version) {
            extend(storesSpec, version._cfg.storesSource);
            dbschema = version._cfg.dbschema = {};
            version._parseStoresSpec(storesSpec, dbschema);
          });
          db2._dbSchema = dbschema;
          removeTablesApi(db2, [db2._allTables, db2, db2.Transaction.prototype]);
          setApiOnPlace(db2, [db2._allTables, db2, db2.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
          db2._storeNames = keys(dbschema);
          return this;
        };
        Version2.prototype.upgrade = function(upgradeFunction) {
          this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
          return this;
        };
        return Version2;
      }();
      function createVersionConstructor(db2) {
        return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
          this.db = db2;
          this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
          };
        });
      }
      function getDbNamesTable(indexedDB2, IDBKeyRange) {
        var dbNamesDB = indexedDB2["_dbNamesDB"];
        if (!dbNamesDB) {
          dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
            addons: [],
            indexedDB: indexedDB2,
            IDBKeyRange
          });
          dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
      }
      function hasDatabasesNative(indexedDB2) {
        return indexedDB2 && typeof indexedDB2.databases === "function";
      }
      function getDatabaseNames(_a2) {
        var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
        return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
          return infos.map(function(info) {
            return info.name;
          }).filter(function(name) {
            return name !== DBNAMES_DB;
          });
        }) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
      }
      function _onDatabaseCreated(_a2, name) {
        var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
      }
      function _onDatabaseDeleted(_a2, name) {
        var indexedDB2 = _a2.indexedDB, IDBKeyRange = _a2.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
      }
      function vip(fn) {
        return newScope(function() {
          PSD.letThrough = true;
          return fn();
        });
      }
      function idbReady() {
        var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
          return Promise.resolve();
        var intervalId;
        return new Promise(function(resolve) {
          var tryIdb = function() {
            return indexedDB.databases().finally(resolve);
          };
          intervalId = setInterval(tryIdb, 100);
          tryIdb();
        }).finally(function() {
          return clearInterval(intervalId);
        });
      }
      var _a;
      function isEmptyRange(node) {
        return !("from" in node);
      }
      var RangeSet2 = function(fromOrTree, to) {
        if (this) {
          extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        } else {
          var rv = new RangeSet2();
          if (fromOrTree && "d" in fromOrTree) {
            extend(rv, fromOrTree);
          }
          return rv;
        }
      };
      props(RangeSet2.prototype, (_a = {
        add: function(rangeSet) {
          mergeRanges2(this, rangeSet);
          return this;
        },
        addKey: function(key) {
          addRange(this, key, key);
          return this;
        },
        addKeys: function(keys2) {
          var _this = this;
          keys2.forEach(function(key) {
            return addRange(_this, key, key);
          });
          return this;
        },
        hasKey: function(key) {
          var node = getRangeSetIterator(this).next(key).value;
          return node && cmp2(node.from, key) <= 0 && cmp2(node.to, key) >= 0;
        }
      }, _a[iteratorSymbol] = function() {
        return getRangeSetIterator(this);
      }, _a));
      function addRange(target, from, to) {
        var diff = cmp2(from, to);
        if (isNaN(diff))
          return;
        if (diff > 0)
          throw RangeError();
        if (isEmptyRange(target))
          return extend(target, { from, to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp2(to, target.from) < 0) {
          left ? addRange(left, from, to) : target.l = { from, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from, target.to) > 0) {
          right ? addRange(right, from, to) : target.r = { from, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from, target.from) < 0) {
          target.from = from;
          target.l = null;
          target.d = right ? right.d + 1 : 1;
        }
        if (cmp2(to, target.to) > 0) {
          target.to = to;
          target.r = null;
          target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
          mergeRanges2(target, left);
        }
        if (right && rightWasCutOff) {
          mergeRanges2(target, right);
        }
      }
      function mergeRanges2(target, newSet) {
        function _addRangeSet(target2, _a2) {
          var from = _a2.from, to = _a2.to, l = _a2.l, r = _a2.r;
          addRange(target2, from, to);
          if (l)
            _addRangeSet(target2, l);
          if (r)
            _addRangeSet(target2, r);
        }
        if (!isEmptyRange(newSet))
          _addRangeSet(target, newSet);
      }
      function rangesOverlap2(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
          return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
          if (cmp2(b.from, a.to) <= 0 && cmp2(b.to, a.from) >= 0)
            return true;
          cmp2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
        }
        return false;
      }
      function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
          next: function(key) {
            var keyProvided = arguments.length > 0;
            while (state) {
              switch (state.s) {
                case 0:
                  state.s = 1;
                  if (keyProvided) {
                    while (state.n.l && cmp2(key, state.n.from) < 0)
                      state = { up: state, n: state.n.l, s: 1 };
                  } else {
                    while (state.n.l)
                      state = { up: state, n: state.n.l, s: 1 };
                  }
                case 1:
                  state.s = 2;
                  if (!keyProvided || cmp2(key, state.n.to) <= 0)
                    return { value: state.n, done: false };
                case 2:
                  if (state.n.r) {
                    state.s = 3;
                    state = { up: state, n: state.n.r, s: 0 };
                    continue;
                  }
                case 3:
                  state = state.up;
              }
            }
            return { done: true };
          }
        };
      }
      function rebalance(target) {
        var _a2, _b;
        var diff = (((_a2 = target.r) === null || _a2 === void 0 ? void 0 : _a2.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
          var l = r === "r" ? "l" : "r";
          var rootClone = __assign({}, target);
          var oldRootRight = target[r];
          target.from = oldRootRight.from;
          target.to = oldRootRight.to;
          target[r] = oldRootRight[r];
          rootClone[r] = oldRootRight[l];
          target[l] = rootClone;
          rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
      }
      function computeDepth(_a2) {
        var r = _a2.r, l = _a2.l;
        return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
      }
      function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(function(part) {
          if (target[part])
            mergeRanges2(target[part], newSet[part]);
          else
            target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
      }
      function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function(key) {
          return os2[key] && rangesOverlap2(os2[key], os1[key]);
        });
      }
      var cache = {};
      var unsignaledParts = {};
      var isTaskEnqueued = false;
      function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
          isTaskEnqueued = true;
          setTimeout(function() {
            isTaskEnqueued = false;
            var parts = unsignaledParts;
            unsignaledParts = {};
            signalSubscribersNow(parts, false);
          }, 0);
        }
      }
      function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) {
          deleteAffectedCacheEntries = false;
        }
        var queriesToSignal = /* @__PURE__ */ new Set();
        if (updatedParts.all) {
          for (var _i = 0, _a2 = Object.values(cache); _i < _a2.length; _i++) {
            var tblCache = _a2[_i];
            collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
          }
        } else {
          for (var key in updatedParts) {
            var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
            if (parts) {
              var dbName = parts[1], tableName = parts[2];
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (tblCache)
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          }
        }
        queriesToSignal.forEach(function(requery) {
          return requery();
        });
      }
      function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for (var _i = 0, _a2 = Object.entries(tblCache.queries.query); _i < _a2.length; _i++) {
          var _b = _a2[_i], indexName = _b[0], entries = _b[1];
          var filteredEntries = [];
          for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
            var entry = entries_1[_c];
            if (obsSetsOverlap(updatedParts, entry.obsSet)) {
              entry.subscribers.forEach(function(requery) {
                return outQueriesToSignal.add(requery);
              });
            } else if (deleteAffectedCacheEntries) {
              filteredEntries.push(entry);
            }
          }
          if (deleteAffectedCacheEntries)
            updatedEntryLists.push([indexName, filteredEntries]);
        }
        if (deleteAffectedCacheEntries) {
          for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
            var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
            tblCache.queries.query[indexName] = filteredEntries;
          }
        }
      }
      function dexieOpen(db2) {
        var state = db2._state;
        var indexedDB2 = db2._deps.indexedDB;
        if (state.isBeingOpened || db2.idbdb)
          return state.dbReadyPromise.then(function() {
            return state.dbOpenError ? rejection(state.dbOpenError) : db2;
          });
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        var nativeVerToOpen = Math.round(db2.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
          if (state.openCanceller !== openCanceller)
            throw new exceptions.DatabaseClosed("db.open() was cancelled");
        }
        var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = function() {
          return new DexiePromise(function(resolve, reject) {
            throwIfCancelled();
            if (!indexedDB2)
              throw new exceptions.MissingAPI();
            var dbName = db2.name;
            var req = state.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
            if (!req)
              throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap2(db2._fireOnBlocked);
            req.onupgradeneeded = wrap2(function(e) {
              upgradeTransaction = req.transaction;
              if (state.autoSchema && !db2._options.allowEmptyDB) {
                req.onerror = preventDefault;
                upgradeTransaction.abort();
                req.result.close();
                var delreq = indexedDB2.deleteDatabase(dbName);
                delreq.onsuccess = delreq.onerror = wrap2(function() {
                  reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                });
              } else {
                upgradeTransaction.onerror = eventRejectHandler(reject);
                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                wasCreated = oldVer < 1;
                db2.idbdb = req.result;
                if (schemaPatchMode) {
                  patchCurrentVersion(db2, upgradeTransaction);
                }
                runUpgraders(db2, oldVer / 10, upgradeTransaction, reject);
              }
            }, reject);
            req.onsuccess = wrap2(function() {
              upgradeTransaction = null;
              var idbdb = db2.idbdb = req.result;
              var objectStoreNames = slice(idbdb.objectStoreNames);
              if (objectStoreNames.length > 0)
                try {
                  var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                  if (state.autoSchema)
                    readGlobalSchema(db2, idbdb, tmpTrans);
                  else {
                    adjustToExistingIndexNames(db2, db2._dbSchema, tmpTrans);
                    if (!verifyInstalledSchema(db2, tmpTrans) && !schemaPatchMode) {
                      console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                      idbdb.close();
                      nativeVerToOpen = idbdb.version + 1;
                      schemaPatchMode = true;
                      return resolve(tryOpenDB());
                    }
                  }
                  generateMiddlewareStacks(db2, tmpTrans);
                } catch (e) {
                }
              connections.push(db2);
              idbdb.onversionchange = wrap2(function(ev) {
                state.vcFired = true;
                db2.on("versionchange").fire(ev);
              });
              idbdb.onclose = wrap2(function(ev) {
                db2.on("close").fire(ev);
              });
              if (wasCreated)
                _onDatabaseCreated(db2._deps, dbName);
              resolve();
            }, reject);
          }).catch(function(err) {
            switch (err === null || err === void 0 ? void 0 : err.name) {
              case "UnknownError":
                if (state.PR1398_maxLoop > 0) {
                  state.PR1398_maxLoop--;
                  console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                  return tryOpenDB();
                }
                break;
              case "VersionError":
                if (nativeVerToOpen > 0) {
                  nativeVerToOpen = 0;
                  return tryOpenDB();
                }
                break;
            }
            return DexiePromise.reject(err);
          });
        };
        return DexiePromise.race([
          openCanceller,
          (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function() {
          throwIfCancelled();
          state.onReadyBeingFired = [];
          return DexiePromise.resolve(vip(function() {
            return db2.on.ready.fire(db2.vip);
          })).then(function fireRemainders() {
            if (state.onReadyBeingFired.length > 0) {
              var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
              state.onReadyBeingFired = [];
              return DexiePromise.resolve(vip(function() {
                return remainders_1(db2.vip);
              })).then(fireRemainders);
            }
          });
        }).finally(function() {
          if (state.openCanceller === openCanceller) {
            state.onReadyBeingFired = null;
            state.isBeingOpened = false;
          }
        }).catch(function(err) {
          state.dbOpenError = err;
          try {
            upgradeTransaction && upgradeTransaction.abort();
          } catch (_a2) {
          }
          if (openCanceller === state.openCanceller) {
            db2._close();
          }
          return rejection(err);
        }).finally(function() {
          state.openComplete = true;
          resolveDbReady();
        }).then(function() {
          if (wasCreated) {
            var everything_1 = {};
            db2.tables.forEach(function(table) {
              table.schema.indexes.forEach(function(idx) {
                if (idx.name)
                  everything_1["idb://".concat(db2.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet2(-Infinity, [[[]]]);
              });
              everything_1["idb://".concat(db2.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db2.name, "/").concat(table.name, "/:dels")] = new RangeSet2(-Infinity, [[[]]]);
            });
            globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
            signalSubscribersNow(everything_1, true);
          }
          return db2;
        });
      }
      function awaitIterator(iterator) {
        var callNext = function(result) {
          return iterator.next(result);
        }, doThrow = function(error) {
          return iterator.throw(error);
        }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
          return function(val) {
            var next = getNext(val), value = next.value;
            return next.done ? value : !value || typeof value.then !== "function" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
          };
        }
        return step(callNext)();
      }
      function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
          throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while (--i)
          args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [mode, tables, scopeFunc];
      }
      function enterTransactionScope(db2, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function() {
          var transless = PSD.transless || PSD;
          var trans = db2._createTransaction(mode, storeNames, db2._dbSchema, parentTransaction);
          trans.explicit = true;
          var zoneProps = {
            trans,
            transless
          };
          if (parentTransaction) {
            trans.idbtrans = parentTransaction.idbtrans;
          } else {
            try {
              trans.create();
              trans.idbtrans._explicit = true;
              db2._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db2.close({ disableAutoOpen: false });
                return db2.open().then(function() {
                  return enterTransactionScope(db2, mode, storeNames, null, scopeFunc);
                });
              }
              return rejection(ex);
            }
          }
          var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
          if (scopeFuncIsAsync) {
            incrementExpectedAwaits();
          }
          var returnValue;
          var promiseFollowed = DexiePromise.follow(function() {
            returnValue = scopeFunc.call(trans, trans);
            if (returnValue) {
              if (scopeFuncIsAsync) {
                var decrementor = decrementExpectedAwaits.bind(null, null);
                returnValue.then(decrementor, decrementor);
              } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                returnValue = awaitIterator(returnValue);
              }
            }
          }, zoneProps);
          return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
            return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : promiseFollowed.then(function() {
            return returnValue;
          })).then(function(x) {
            if (parentTransaction)
              trans._resolve();
            return trans._completion.then(function() {
              return x;
            });
          }).catch(function(e) {
            trans._reject(e);
            return rejection(e);
          });
        });
      }
      function pad(a, value, count) {
        var result = isArray(a) ? a.slice() : [a];
        for (var i = 0; i < count; ++i)
          result.push(value);
        return result;
      }
      function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: function(tableName) {
          var table = down.table(tableName);
          var schema = table.schema;
          var indexLookup = {};
          var allVirtualIndexes = [];
          function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
            var keyPathAlias = getKeyPathAlias(keyPath);
            var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
            var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
            var isVirtual = keyTail > 0;
            var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
            indexList.push(virtualIndex);
            if (!virtualIndex.isPrimaryKey) {
              allVirtualIndexes.push(virtualIndex);
            }
            if (keyLength > 1) {
              var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
              addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
            }
            indexList.sort(function(a, b) {
              return a.keyTail - b.keyTail;
            });
            return virtualIndex;
          }
          var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
          indexLookup[":id"] = [primaryKey];
          for (var _i = 0, _a2 = schema.indexes; _i < _a2.length; _i++) {
            var index = _a2[_i];
            addVirtualIndexes(index.keyPath, 0, index);
          }
          function findBestIndex(keyPath) {
            var result2 = indexLookup[getKeyPathAlias(keyPath)];
            return result2 && result2[0];
          }
          function translateRange(range, keyTail) {
            return {
              type: range.type === 1 ? 2 : range.type,
              lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
              lowerOpen: true,
              upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
              upperOpen: true
            };
          }
          function translateRequest(req) {
            var index2 = req.query.index;
            return index2.isVirtual ? __assign(__assign({}, req), { query: {
              index: index2.lowLevelIndex,
              range: translateRange(req.query.range, index2.keyTail)
            } }) : req;
          }
          var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function(req) {
            return table.count(translateRequest(req));
          }, query: function(req) {
            return table.query(translateRequest(req));
          }, openCursor: function(req) {
            var _a3 = req.query.index, keyTail = _a3.keyTail, isVirtual = _a3.isVirtual, keyLength = _a3.keyLength;
            if (!isVirtual)
              return table.openCursor(req);
            function createVirtualCursor(cursor) {
              function _continue(key) {
                key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
              }
              var virtualCursor = Object.create(cursor, {
                continue: { value: _continue },
                continuePrimaryKey: {
                  value: function(key, primaryKey2) {
                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                  }
                },
                primaryKey: {
                  get: function() {
                    return cursor.primaryKey;
                  }
                },
                key: {
                  get: function() {
                    var key = cursor.key;
                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                  }
                },
                value: {
                  get: function() {
                    return cursor.value;
                  }
                }
              });
              return virtualCursor;
            }
            return table.openCursor(translateRequest(req)).then(function(cursor) {
              return cursor && createVirtualCursor(cursor);
            });
          } });
          return result;
        } });
      }
      var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
      };
      function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || "";
        keys(a).forEach(function(prop) {
          if (!hasOwn(b, prop)) {
            rv[prfx + prop] = void 0;
          } else {
            var ap = a[prop], bp = b[prop];
            if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
              var apTypeName = toStringTag(ap);
              var bpTypeName = toStringTag(bp);
              if (apTypeName !== bpTypeName) {
                rv[prfx + prop] = b[prop];
              } else if (apTypeName === "Object") {
                getObjectDiff(ap, bp, rv, prfx + prop + ".");
              } else if (ap !== bp) {
                rv[prfx + prop] = b[prop];
              }
            } else if (ap !== bp)
              rv[prfx + prop] = b[prop];
          }
        });
        keys(b).forEach(function(prop) {
          if (!hasOwn(a, prop)) {
            rv[prfx + prop] = b[prop];
          }
        });
        return rv;
      }
      function getEffectiveKeys(primaryKey, req) {
        if (req.type === "delete")
          return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
      }
      var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function(downCore) {
          return __assign(__assign({}, downCore), { table: function(tableName) {
            var downTable = downCore.table(tableName);
            var primaryKey = downTable.schema.primaryKey;
            var tableMiddleware = __assign(__assign({}, downTable), { mutate: function(req) {
              var dxTrans = PSD.trans;
              var _a2 = dxTrans.table(tableName).hook, deleting = _a2.deleting, creating = _a2.creating, updating = _a2.updating;
              switch (req.type) {
                case "add":
                  if (creating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "put":
                  if (creating.fire === nop && updating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "delete":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "deleteRange":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return deleteRange(req);
                  }, true);
              }
              return downTable.mutate(req);
              function addPutOrDelete(req2) {
                var dxTrans2 = PSD.trans;
                var keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
                if (!keys2)
                  throw new Error("Keys missing");
                req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys2 }) : __assign({}, req2);
                if (req2.type !== "delete")
                  req2.values = __spreadArray([], req2.values, true);
                if (req2.keys)
                  req2.keys = __spreadArray([], req2.keys, true);
                return getExistingValues(downTable, req2, keys2).then(function(existingValues) {
                  var contexts = keys2.map(function(key, i) {
                    var existingValue = existingValues[i];
                    var ctx = { onerror: null, onsuccess: null };
                    if (req2.type === "delete") {
                      deleting.fire.call(ctx, key, existingValue, dxTrans2);
                    } else if (req2.type === "add" || existingValue === void 0) {
                      var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                      if (key == null && generatedPrimaryKey != null) {
                        key = generatedPrimaryKey;
                        req2.keys[i] = key;
                        if (!primaryKey.outbound) {
                          setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                        }
                      }
                    } else {
                      var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                      if (additionalChanges_1) {
                        var requestedValue_1 = req2.values[i];
                        Object.keys(additionalChanges_1).forEach(function(keyPath) {
                          if (hasOwn(requestedValue_1, keyPath)) {
                            requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                          } else {
                            setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                          }
                        });
                      }
                    }
                    return ctx;
                  });
                  return downTable.mutate(req2).then(function(_a3) {
                    var failures = _a3.failures, results = _a3.results, numFailures = _a3.numFailures, lastResult = _a3.lastResult;
                    for (var i = 0; i < keys2.length; ++i) {
                      var primKey = results ? results[i] : keys2[i];
                      var ctx = contexts[i];
                      if (primKey == null) {
                        ctx.onerror && ctx.onerror(failures[i]);
                      } else {
                        ctx.onsuccess && ctx.onsuccess(
                          req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                        );
                      }
                    }
                    return { failures, results, numFailures, lastResult };
                  }).catch(function(error) {
                    contexts.forEach(function(ctx) {
                      return ctx.onerror && ctx.onerror(error);
                    });
                    return Promise.reject(error);
                  });
                });
              }
              function deleteRange(req2) {
                return deleteNextChunk(req2.trans, req2.range, 1e4);
              }
              function deleteNextChunk(trans, range, limit) {
                return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a3) {
                  var result = _a3.result;
                  return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                    if (res.numFailures > 0)
                      return Promise.reject(res.failures[0]);
                    if (result.length < limit) {
                      return { failures: [], numFailures: 0, lastResult: void 0 };
                    } else {
                      return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                    }
                  });
                });
              }
            } });
            return tableMiddleware;
          } });
        }
      };
      function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
      }
      function getFromTransactionCache(keys2, cache2, clone) {
        try {
          if (!cache2)
            return null;
          if (cache2.keys.length < keys2.length)
            return null;
          var result = [];
          for (var i = 0, j = 0; i < cache2.keys.length && j < keys2.length; ++i) {
            if (cmp2(cache2.keys[i], keys2[j]) !== 0)
              continue;
            result.push(clone ? deepClone(cache2.values[i]) : cache2.values[i]);
            ++j;
          }
          return result.length === keys2.length ? result : null;
        } catch (_a2) {
          return null;
        }
      }
      var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: function(core) {
          return {
            table: function(tableName) {
              var table = core.table(tableName);
              return __assign(__assign({}, table), { getMany: function(req) {
                if (!req.cache) {
                  return table.getMany(req);
                }
                var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                if (cachedResult) {
                  return DexiePromise.resolve(cachedResult);
                }
                return table.getMany(req).then(function(res) {
                  req.trans["_cache"] = {
                    keys: req.keys,
                    values: req.cache === "clone" ? deepClone(res) : res
                  };
                  return res;
                });
              }, mutate: function(req) {
                if (req.type !== "add")
                  req.trans["_cache"] = null;
                return table.mutate(req);
              } });
            }
          };
        }
      };
      function isCachableContext(ctx, table) {
        return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
      }
      function isCachableRequest(type2, req) {
        switch (type2) {
          case "query":
            return req.values && !req.unique;
          case "get":
            return false;
          case "getMany":
            return false;
          case "count":
            return false;
          case "openCursor":
            return false;
        }
      }
      var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: function(core) {
          var dbName = core.schema.name;
          var FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
          return __assign(__assign({}, core), { transaction: function(stores, mode, options) {
            if (PSD.subscr && mode !== "readonly") {
              throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
            }
            return core.transaction(stores, mode, options);
          }, table: function(tableName) {
            var table = core.table(tableName);
            var schema = table.schema;
            var primaryKey = schema.primaryKey, indexes = schema.indexes;
            var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
            var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index) {
              return index.compound && index.keyPath.includes(primaryKey.keyPath);
            });
            var tableClone = __assign(__assign({}, table), { mutate: function(req) {
              var trans = req.trans;
              var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
              var getRangeSet = function(indexName) {
                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
              };
              var pkRangeSet = getRangeSet("");
              var delsRangeSet = getRangeSet(":dels");
              var type2 = req.type;
              var _a2 = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id) {
                return id;
              }), req.values] : [], keys2 = _a2[0], newObjs = _a2[1];
              var oldCache = req.trans["_cache"];
              if (isArray(keys2)) {
                pkRangeSet.addKeys(keys2);
                var oldObjs = type2 === "delete" || keys2.length === newObjs.length ? getFromTransactionCache(keys2, oldCache) : null;
                if (!oldObjs) {
                  delsRangeSet.addKeys(keys2);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys2) {
                var range = { from: keys2.lower, to: keys2.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach(function(idx) {
                  return getRangeSet(idx.name).add(FULL_RANGE);
                });
              }
              return table.mutate(req).then(function(res) {
                if (keys2 && (req.type === "add" || req.type === "put")) {
                  pkRangeSet.addKeys(res.results);
                  if (indexesWithAutoIncPK) {
                    indexesWithAutoIncPK.forEach(function(idx) {
                      var idxVals = req.values.map(function(v) {
                        return idx.extractKey(v);
                      });
                      var pkPos = idx.keyPath.findIndex(function(prop) {
                        return prop === primaryKey.keyPath;
                      });
                      res.results.forEach(function(pk) {
                        return idxVals[pkPos] = pk;
                      });
                      getRangeSet(idx.name).addKeys(idxVals);
                    });
                  }
                }
                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                return res;
              });
            } });
            var getRange = function(_a2) {
              var _b, _c;
              var _d = _a2.query, index = _d.index, range = _d.range;
              return [
                index,
                new RangeSet2((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
              ];
            };
            var readSubscribers = {
              get: function(req) {
                return [primaryKey, new RangeSet2(req.key)];
              },
              getMany: function(req) {
                return [primaryKey, new RangeSet2().addKeys(req.keys)];
              },
              count: getRange,
              query: getRange,
              openCursor: getRange
            };
            keys(readSubscribers).forEach(function(method) {
              tableClone[method] = function(req) {
                var subscr = PSD.subscr;
                var isLiveQuery = !!subscr;
                var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                var obsSet = cachable ? req.obsSet = {} : subscr;
                if (isLiveQuery) {
                  var getRangeSet = function(indexName) {
                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                    return obsSet[part] || (obsSet[part] = new RangeSet2());
                  };
                  var pkRangeSet_1 = getRangeSet("");
                  var delsRangeSet_1 = getRangeSet(":dels");
                  var _a2 = readSubscribers[method](req), queriedIndex = _a2[0], queriedRanges = _a2[1];
                  if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                    delsRangeSet_1.add(queriedRanges);
                  } else {
                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                  }
                  if (!queriedIndex.isPrimaryKey) {
                    if (method === "count") {
                      delsRangeSet_1.add(FULL_RANGE);
                    } else {
                      var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                      return table[method].apply(this, arguments).then(function(res) {
                        if (method === "query") {
                          if (outbound && req.values) {
                            return keysPromise_1.then(function(_a3) {
                              var resultingKeys = _a3.result;
                              pkRangeSet_1.addKeys(resultingKeys);
                              return res;
                            });
                          }
                          var pKeys = req.values ? res.result.map(extractKey) : res.result;
                          if (req.values) {
                            pkRangeSet_1.addKeys(pKeys);
                          } else {
                            delsRangeSet_1.addKeys(pKeys);
                          }
                        } else if (method === "openCursor") {
                          var cursor_1 = res;
                          var wantValues_1 = req.values;
                          return cursor_1 && Object.create(cursor_1, {
                            key: {
                              get: function() {
                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.key;
                              }
                            },
                            primaryKey: {
                              get: function() {
                                var pkey = cursor_1.primaryKey;
                                delsRangeSet_1.addKey(pkey);
                                return pkey;
                              }
                            },
                            value: {
                              get: function() {
                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.value;
                              }
                            }
                          });
                        }
                        return res;
                      });
                    }
                  }
                }
                return table[method].apply(this, arguments);
              };
            });
            return tableClone;
          } });
        }
      };
      function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
          var rangeSet = getRangeSet(ix.name || "");
          function extractKey(obj) {
            return obj != null ? ix.extractKey(obj) : null;
          }
          var addKeyOrKeys = function(key) {
            return ix.multiEntry && isArray(key) ? key.forEach(function(key2) {
              return rangeSet.addKey(key2);
            }) : rangeSet.addKey(key);
          };
          (oldObjs || newObjs).forEach(function(_, i) {
            var oldKey = oldObjs && extractKey(oldObjs[i]);
            var newKey = newObjs && extractKey(newObjs[i]);
            if (cmp2(oldKey, newKey) !== 0) {
              if (oldKey != null)
                addKeyOrKeys(oldKey);
              if (newKey != null)
                addKeyOrKeys(newKey);
            }
          });
        }
        schema.indexes.forEach(addAffectedIndex);
      }
      function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0)
          return req;
        if (req.type === "deleteRange") {
          return null;
        }
        var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
        if (res.numFailures === numBulkOps) {
          return null;
        }
        var clone = __assign({}, req);
        if (isArray(clone.keys)) {
          clone.keys = clone.keys.filter(function(_, i) {
            return !(i in res.failures);
          });
        }
        if ("values" in clone && isArray(clone.values)) {
          clone.values = clone.values.filter(function(_, i) {
            return !(i in res.failures);
          });
        }
        return clone;
      }
      function isAboveLower(key, range) {
        return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
      }
      function isBelowUpper(key, range) {
        return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
      }
      function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
      }
      function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0)
          return result;
        var index = req.query.index;
        var multiEntry = index.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index.extractKey;
        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
        var finalResult = ops.reduce(function(result2, op) {
          var modifedResult = result2;
          var includedValues = [];
          if (op.type === "add" || op.type === "put") {
            var includedPKs = new RangeSet2();
            for (var i = op.values.length - 1; i >= 0; --i) {
              var value = op.values[i];
              var pk = extractPrimKey(value);
              if (includedPKs.hasKey(pk))
                continue;
              var key = extractIndex(value);
              if (multiEntry && isArray(key) ? key.some(function(k) {
                return isWithinRange(k, queryRange);
              }) : isWithinRange(key, queryRange)) {
                includedPKs.addKey(pk);
                includedValues.push(value);
              }
            }
          }
          switch (op.type) {
            case "add":
              modifedResult = result2.concat(req.values ? includedValues : includedValues.map(function(v) {
                return extractPrimKey(v);
              }));
              break;
            case "put":
              var keySet_1 = new RangeSet2().addKeys(op.values.map(function(v) {
                return extractPrimKey(v);
              }));
              modifedResult = result2.filter(
                function(item) {
                  return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                }
              ).concat(
                req.values ? includedValues : includedValues.map(function(v) {
                  return extractPrimKey(v);
                })
              );
              break;
            case "delete":
              var keysToDelete_1 = new RangeSet2().addKeys(op.keys);
              modifedResult = result2.filter(function(item) {
                return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
              });
              break;
            case "deleteRange":
              var range_1 = op.range;
              modifedResult = result2.filter(function(item) {
                return !isWithinRange(extractPrimKey(item), range_1);
              });
              break;
          }
          return modifedResult;
        }, result);
        if (finalResult === result)
          return result;
        finalResult.sort(function(a, b) {
          return cmp2(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
          if (finalResult.length > req.limit) {
            finalResult.length = req.limit;
          } else if (result.length === req.limit && finalResult.length < req.limit) {
            cacheEntry.dirty = true;
          }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
      }
      function areRangesEqual(r1, r2) {
        return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
      }
      function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === void 0)
          return lower2 !== void 0 ? -1 : 0;
        if (lower2 === void 0)
          return 1;
        var c = cmp2(lower1, lower2);
        if (c === 0) {
          if (lowerOpen1 && lowerOpen2)
            return 0;
          if (lowerOpen1)
            return 1;
          if (lowerOpen2)
            return -1;
        }
        return c;
      }
      function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === void 0)
          return upper2 !== void 0 ? 1 : 0;
        if (upper2 === void 0)
          return -1;
        var c = cmp2(upper1, upper2);
        if (c === 0) {
          if (upperOpen1 && upperOpen2)
            return 0;
          if (upperOpen1)
            return -1;
          if (upperOpen2)
            return 1;
        }
        return c;
      }
      function isSuperRange(r1, r2) {
        return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
      }
      function findCompatibleQuery(dbName, tableName, type2, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache)
          return [];
        var queries = tblCache.queries[type2];
        if (!queries)
          return [null, false, tblCache, null];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ""];
        if (!entries)
          return [null, false, tblCache, null];
        switch (type2) {
          case "query":
            var equalEntry = entries.find(function(entry) {
              return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
            });
            if (equalEntry)
              return [
                equalEntry,
                true,
                tblCache,
                entries
              ];
            var superEntry = entries.find(function(entry) {
              var limit = "limit" in entry.req ? entry.req.limit : Infinity;
              return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
            });
            return [superEntry, false, tblCache, entries];
          case "count":
            var countQuery = entries.find(function(entry) {
              return areRangesEqual(entry.req.query.range, req.query.range);
            });
            return [countQuery, !!countQuery, tblCache, entries];
        }
      }
      function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function() {
          cacheEntry.subscribers.delete(requery);
          if (cacheEntry.subscribers.size === 0) {
            enqueForDeletion(cacheEntry, container);
          }
        });
      }
      function enqueForDeletion(cacheEntry, container) {
        setTimeout(function() {
          if (cacheEntry.subscribers.size === 0) {
            delArrayItem(container, cacheEntry);
          }
        }, 3e3);
      }
      var cacheMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Cache",
        create: function(core) {
          var dbName = core.schema.name;
          var coreMW = __assign(__assign({}, core), { transaction: function(stores, mode, options) {
            var idbtrans = core.transaction(stores, mode, options);
            if (mode === "readwrite") {
              var ac_1 = new AbortController();
              var signal = ac_1.signal;
              var endTransaction = function(wasCommitted) {
                return function() {
                  ac_1.abort();
                  if (mode === "readwrite") {
                    var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                    for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                      var storeName = stores_1[_i];
                      var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                      if (tblCache) {
                        var table = core.table(storeName);
                        var ops = tblCache.optimisticOps.filter(function(op) {
                          return op.trans === idbtrans;
                        });
                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                          for (var _a2 = 0, _b = Object.values(tblCache.queries.query); _a2 < _b.length; _a2++) {
                            var entries = _b[_a2];
                            for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                              var entry = _d[_c];
                              if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                delArrayItem(entries, entry);
                                entry.subscribers.forEach(function(requery) {
                                  return affectedSubscribers_1.add(requery);
                                });
                              }
                            }
                          }
                        } else if (ops.length > 0) {
                          tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                            return op.trans !== idbtrans;
                          });
                          for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                            var entries = _f[_e];
                            for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                              var entry = _h[_g];
                              if (entry.res != null && idbtrans.mutatedParts) {
                                if (wasCommitted && !entry.dirty) {
                                  var freezeResults = Object.isFrozen(entry.res);
                                  var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  } else if (modRes !== entry.res) {
                                    entry.res = modRes;
                                    entry.promise = DexiePromise.resolve({ result: modRes });
                                  }
                                } else {
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                  }
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    affectedSubscribers_1.forEach(function(requery) {
                      return requery();
                    });
                  }
                };
              };
              idbtrans.addEventListener("abort", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("error", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("complete", endTransaction(true), {
                signal
              });
            }
            return idbtrans;
          }, table: function(tableName) {
            var downTable = core.table(tableName);
            var primKey = downTable.schema.primaryKey;
            var tableMW = __assign(__assign({}, downTable), { mutate: function(req) {
              var trans = PSD.trans;
              if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit) {
                return downTable.mutate(req);
              }
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (!tblCache)
                return downTable.mutate(req);
              var promise = downTable.mutate(req);
              if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                return key == null;
              }))) {
                promise.then(function(res) {
                  var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function(value, i) {
                    var _a2;
                    var valueWithKey = ((_a2 = primKey.keyPath) === null || _a2 === void 0 ? void 0 : _a2.includes(".")) ? deepClone(value) : __assign({}, value);
                    setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                    return valueWithKey;
                  }) });
                  var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                  tblCache.optimisticOps.push(adjustedReq);
                  queueMicrotask(function() {
                    return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                });
              } else {
                tblCache.optimisticOps.push(req);
                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                promise.then(function(res) {
                  if (res.numFailures > 0) {
                    delArrayItem(tblCache.optimisticOps, req);
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                    if (adjustedReq) {
                      tblCache.optimisticOps.push(adjustedReq);
                    }
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  }
                });
                promise.catch(function() {
                  delArrayItem(tblCache.optimisticOps, req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                });
              }
              return promise;
            }, query: function(req) {
              var _a2;
              if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                return downTable.query(req);
              var freezeResults = ((_a2 = PSD.trans) === null || _a2 === void 0 ? void 0 : _a2.db._options.cache) === "immutable";
              var _b = PSD, requery = _b.requery, signal = _b.signal;
              var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
              if (cacheEntry && exactMatch) {
                cacheEntry.obsSet = req.obsSet;
              } else {
                var promise = downTable.query(req).then(function(res) {
                  var result = res.result;
                  if (cacheEntry)
                    cacheEntry.res = result;
                  if (freezeResults) {
                    for (var i = 0, l = result.length; i < l; ++i) {
                      Object.freeze(result[i]);
                    }
                    Object.freeze(result);
                  } else {
                    res.result = deepClone(result);
                  }
                  return res;
                }).catch(function(error) {
                  if (container && cacheEntry)
                    delArrayItem(container, cacheEntry);
                  return Promise.reject(error);
                });
                cacheEntry = {
                  obsSet: req.obsSet,
                  promise,
                  subscribers: /* @__PURE__ */ new Set(),
                  type: "query",
                  req,
                  dirty: false
                };
                if (container) {
                  container.push(cacheEntry);
                } else {
                  container = [cacheEntry];
                  if (!tblCache) {
                    tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                      queries: {
                        query: {},
                        count: {}
                      },
                      objs: /* @__PURE__ */ new Map(),
                      optimisticOps: [],
                      unsignaledParts: {}
                    };
                  }
                  tblCache.queries.query[req.query.index.name || ""] = container;
                }
              }
              subscribeToCacheEntry(cacheEntry, container, requery, signal);
              return cacheEntry.promise.then(function(res) {
                return {
                  result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                };
              });
            } });
            return tableMW;
          } });
          return coreMW;
        }
      };
      function vipify(target, vipDb) {
        return new Proxy(target, {
          get: function(target2, prop, receiver) {
            if (prop === "db")
              return vipDb;
            return Reflect.get(target2, prop, receiver);
          }
        });
      }
      var Dexie$1 = function() {
        function Dexie3(name, options) {
          var _this = this;
          this._middlewares = {};
          this.verno = 0;
          var deps = Dexie3.dependencies;
          this._options = options = __assign({
            addons: Dexie3.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange,
            cache: "cloned"
          }, options);
          this._deps = {
            indexedDB: options.indexedDB,
            IDBKeyRange: options.IDBKeyRange
          };
          var addons = options.addons;
          this._dbSchema = {};
          this._versions = [];
          this._storeNames = [];
          this._allTables = {};
          this.idbdb = null;
          this._novip = this;
          var state = {
            dbOpenError: null,
            isBeingOpened: false,
            onReadyBeingFired: null,
            openComplete: false,
            dbReadyResolve: nop,
            dbReadyPromise: null,
            cancelOpen: nop,
            openCanceller: null,
            autoSchema: true,
            PR1398_maxLoop: 3,
            autoOpen: options.autoOpen
          };
          state.dbReadyPromise = new DexiePromise(function(resolve) {
            state.dbReadyResolve = resolve;
          });
          state.openCanceller = new DexiePromise(function(_, reject) {
            state.cancelOpen = reject;
          });
          this._state = state;
          this.name = name;
          this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
          this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
            return function(subscriber, bSticky) {
              Dexie3.vip(function() {
                var state2 = _this._state;
                if (state2.openComplete) {
                  if (!state2.dbOpenError)
                    DexiePromise.resolve().then(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else if (state2.onReadyBeingFired) {
                  state2.onReadyBeingFired.push(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else {
                  subscribe(subscriber);
                  var db_1 = _this;
                  if (!bSticky)
                    subscribe(function unsubscribe() {
                      db_1.on.ready.unsubscribe(subscriber);
                      db_1.on.ready.unsubscribe(unsubscribe);
                    });
                }
              });
            };
          });
          this.Collection = createCollectionConstructor(this);
          this.Table = createTableConstructor(this);
          this.Transaction = createTransactionConstructor(this);
          this.Version = createVersionConstructor(this);
          this.WhereClause = createWhereClauseConstructor(this);
          this.on("versionchange", function(ev) {
            if (ev.newVersion > 0)
              console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
            else
              console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
            _this.close({ disableAutoOpen: false });
          });
          this.on("blocked", function(ev) {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion)
              console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
            else
              console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
          });
          this._maxKey = getMaxKey(options.IDBKeyRange);
          this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
            return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
          };
          this._fireOnBlocked = function(ev) {
            _this.on("blocked").fire(ev);
            connections.filter(function(c) {
              return c.name === _this.name && c !== _this && !c._state.vcFired;
            }).map(function(c) {
              return c.on("versionchange").fire(ev);
            });
          };
          this.use(cacheExistingValuesMiddleware);
          this.use(cacheMiddleware);
          this.use(observabilityMiddleware);
          this.use(virtualIndexMiddleware);
          this.use(hooksMiddleware);
          var vipDB = new Proxy(this, {
            get: function(_, prop, receiver) {
              if (prop === "_vip")
                return true;
              if (prop === "table")
                return function(tableName) {
                  return vipify(_this.table(tableName), vipDB);
                };
              var rv = Reflect.get(_, prop, receiver);
              if (rv instanceof Table)
                return vipify(rv, vipDB);
              if (prop === "tables")
                return rv.map(function(t) {
                  return vipify(t, vipDB);
                });
              if (prop === "_createTransaction")
                return function() {
                  var tx = rv.apply(this, arguments);
                  return vipify(tx, vipDB);
                };
              return rv;
            }
          });
          this.vip = vipDB;
          addons.forEach(function(addon) {
            return addon(_this);
          });
        }
        Dexie3.prototype.version = function(versionNumber) {
          if (isNaN(versionNumber) || versionNumber < 0.1)
            throw new exceptions.Type("Given version is not a positive number");
          versionNumber = Math.round(versionNumber * 10) / 10;
          if (this.idbdb || this._state.isBeingOpened)
            throw new exceptions.Schema("Cannot add version when database is open");
          this.verno = Math.max(this.verno, versionNumber);
          var versions = this._versions;
          var versionInstance = versions.filter(function(v) {
            return v._cfg.version === versionNumber;
          })[0];
          if (versionInstance)
            return versionInstance;
          versionInstance = new this.Version(versionNumber);
          versions.push(versionInstance);
          versions.sort(lowerVersionFirst);
          versionInstance.stores({});
          this._state.autoSchema = false;
          return versionInstance;
        };
        Dexie3.prototype._whenReady = function(fn) {
          var _this = this;
          return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
            if (_this._state.openComplete) {
              return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
            }
            if (!_this._state.isBeingOpened) {
              if (!_this._state.autoOpen) {
                reject(new exceptions.DatabaseClosed());
                return;
              }
              _this.open().catch(nop);
            }
            _this._state.dbReadyPromise.then(resolve, reject);
          }).then(fn);
        };
        Dexie3.prototype.use = function(_a2) {
          var stack = _a2.stack, create = _a2.create, level = _a2.level, name = _a2.name;
          if (name)
            this.unuse({ stack, name });
          var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
          middlewares.push({ stack, create, level: level == null ? 10 : level, name });
          middlewares.sort(function(a, b) {
            return a.level - b.level;
          });
          return this;
        };
        Dexie3.prototype.unuse = function(_a2) {
          var stack = _a2.stack, name = _a2.name, create = _a2.create;
          if (stack && this._middlewares[stack]) {
            this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
              return create ? mw.create !== create : name ? mw.name !== name : false;
            });
          }
          return this;
        };
        Dexie3.prototype.open = function() {
          var _this = this;
          return usePSD(
            globalPSD,
            function() {
              return dexieOpen(_this);
            }
          );
        };
        Dexie3.prototype._close = function() {
          var state = this._state;
          var idx = connections.indexOf(this);
          if (idx >= 0)
            connections.splice(idx, 1);
          if (this.idbdb) {
            try {
              this.idbdb.close();
            } catch (e) {
            }
            this.idbdb = null;
          }
          if (!state.isBeingOpened) {
            state.dbReadyPromise = new DexiePromise(function(resolve) {
              state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function(_, reject) {
              state.cancelOpen = reject;
            });
          }
        };
        Dexie3.prototype.close = function(_a2) {
          var _b = _a2 === void 0 ? { disableAutoOpen: true } : _a2, disableAutoOpen = _b.disableAutoOpen;
          var state = this._state;
          if (disableAutoOpen) {
            if (state.isBeingOpened) {
              state.cancelOpen(new exceptions.DatabaseClosed());
            }
            this._close();
            state.autoOpen = false;
            state.dbOpenError = new exceptions.DatabaseClosed();
          } else {
            this._close();
            state.autoOpen = this._options.autoOpen || state.isBeingOpened;
            state.openComplete = false;
            state.dbOpenError = null;
          }
        };
        Dexie3.prototype.delete = function(closeOptions) {
          var _this = this;
          if (closeOptions === void 0) {
            closeOptions = { disableAutoOpen: true };
          }
          var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
          var state = this._state;
          return new DexiePromise(function(resolve, reject) {
            var doDelete = function() {
              _this.close(closeOptions);
              var req = _this._deps.indexedDB.deleteDatabase(_this.name);
              req.onsuccess = wrap2(function() {
                _onDatabaseDeleted(_this._deps, _this.name);
                resolve();
              });
              req.onerror = eventRejectHandler(reject);
              req.onblocked = _this._fireOnBlocked;
            };
            if (hasInvalidArguments)
              throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
            if (state.isBeingOpened) {
              state.dbReadyPromise.then(doDelete);
            } else {
              doDelete();
            }
          });
        };
        Dexie3.prototype.backendDB = function() {
          return this.idbdb;
        };
        Dexie3.prototype.isOpen = function() {
          return this.idbdb !== null;
        };
        Dexie3.prototype.hasBeenClosed = function() {
          var dbOpenError = this._state.dbOpenError;
          return dbOpenError && dbOpenError.name === "DatabaseClosed";
        };
        Dexie3.prototype.hasFailed = function() {
          return this._state.dbOpenError !== null;
        };
        Dexie3.prototype.dynamicallyOpened = function() {
          return this._state.autoSchema;
        };
        Object.defineProperty(Dexie3.prototype, "tables", {
          get: function() {
            var _this = this;
            return keys(this._allTables).map(function(name) {
              return _this._allTables[name];
            });
          },
          enumerable: false,
          configurable: true
        });
        Dexie3.prototype.transaction = function() {
          var args = extractTransactionArgs.apply(this, arguments);
          return this._transaction.apply(this, args);
        };
        Dexie3.prototype._transaction = function(mode, tables, scopeFunc) {
          var _this = this;
          var parentTransaction = PSD.trans;
          if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
            parentTransaction = null;
          var onlyIfCompatible = mode.indexOf("?") !== -1;
          mode = mode.replace("!", "").replace("?", "");
          var idbMode, storeNames;
          try {
            storeNames = tables.map(function(table) {
              var storeName = table instanceof _this.Table ? table.name : table;
              if (typeof storeName !== "string")
                throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
              return storeName;
            });
            if (mode == "r" || mode === READONLY)
              idbMode = READONLY;
            else if (mode == "rw" || mode == READWRITE)
              idbMode = READWRITE;
            else
              throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
            if (parentTransaction) {
              if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                if (onlyIfCompatible) {
                  parentTransaction = null;
                } else
                  throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              }
              if (parentTransaction) {
                storeNames.forEach(function(storeName) {
                  if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                    if (onlyIfCompatible) {
                      parentTransaction = null;
                    } else
                      throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                  }
                });
              }
              if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                parentTransaction = null;
              }
            }
          } catch (e) {
            return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
              reject(e);
            }) : rejection(e);
          }
          var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
          return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
            return _this._whenReady(enterTransaction);
          }) : this._whenReady(enterTransaction);
        };
        Dexie3.prototype.table = function(tableName) {
          if (!hasOwn(this._allTables, tableName)) {
            throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
          }
          return this._allTables[tableName];
        };
        return Dexie3;
      }();
      var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
      var Observable = function() {
        function Observable2(subscribe) {
          this._subscribe = subscribe;
        }
        Observable2.prototype.subscribe = function(x, error, complete) {
          return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
        };
        Observable2.prototype[symbolObservable] = function() {
          return this;
        };
        return Observable2;
      }();
      var domDeps;
      try {
        domDeps = {
          indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
          IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
      } catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
      }
      function liveQuery2(querier) {
        var hasValue = false;
        var currentValue;
        var observable = new Observable(function(observer) {
          var scopeFuncIsAsync = isAsyncFunction(querier);
          function execute(ctx) {
            var wasRootExec = beginMicroTickScope();
            try {
              if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
              }
              var rv = newScope(querier, ctx);
              if (scopeFuncIsAsync) {
                rv = rv.finally(decrementExpectedAwaits);
              }
              return rv;
            } finally {
              wasRootExec && endMicroTickScope();
            }
          }
          var closed = false;
          var abortController;
          var accumMuts = {};
          var currentObs = {};
          var subscription = {
            get closed() {
              return closed;
            },
            unsubscribe: function() {
              if (closed)
                return;
              closed = true;
              if (abortController)
                abortController.abort();
              if (startedListening)
                globalEvents.storagemutated.unsubscribe(mutationListener);
            }
          };
          observer.start && observer.start(subscription);
          var startedListening = false;
          var doQuery = function() {
            return execInGlobalContext(_doQuery);
          };
          function shouldNotify() {
            return obsSetsOverlap(currentObs, accumMuts);
          }
          var mutationListener = function(parts) {
            extendObservabilitySet(accumMuts, parts);
            if (shouldNotify()) {
              doQuery();
            }
          };
          var _doQuery = function() {
            if (closed || !domDeps.indexedDB) {
              return;
            }
            accumMuts = {};
            var subscr = {};
            if (abortController)
              abortController.abort();
            abortController = new AbortController();
            var ctx = {
              subscr,
              signal: abortController.signal,
              requery: doQuery,
              querier,
              trans: null
            };
            var ret = execute(ctx);
            Promise.resolve(ret).then(function(result) {
              hasValue = true;
              currentValue = result;
              if (closed || ctx.signal.aborted) {
                return;
              }
              accumMuts = {};
              currentObs = subscr;
              if (!objectIsEmpty(currentObs) && !startedListening) {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                startedListening = true;
              }
              execInGlobalContext(function() {
                return !closed && observer.next && observer.next(result);
              });
            }, function(err) {
              hasValue = false;
              if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
                if (!closed)
                  execInGlobalContext(function() {
                    if (closed)
                      return;
                    observer.error && observer.error(err);
                  });
              }
            });
          };
          setTimeout(doQuery, 0);
          return subscription;
        });
        observable.hasValue = function() {
          return hasValue;
        };
        observable.getValue = function() {
          return currentValue;
        };
        return observable;
      }
      var Dexie2 = Dexie$1;
      props(Dexie2, __assign(__assign({}, fullNameExceptions), {
        delete: function(databaseName) {
          var db2 = new Dexie2(databaseName, { addons: [] });
          return db2.delete();
        },
        exists: function(name) {
          return new Dexie2(name, { addons: [] }).open().then(function(db2) {
            db2.close();
            return true;
          }).catch("NoSuchDatabaseError", function() {
            return false;
          });
        },
        getDatabaseNames: function(cb) {
          try {
            return getDatabaseNames(Dexie2.dependencies).then(cb);
          } catch (_a2) {
            return rejection(new exceptions.MissingAPI());
          }
        },
        defineClass: function() {
          function Class(content) {
            extend(this, content);
          }
          return Class;
        },
        ignoreTransaction: function(scopeFunc) {
          return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
        },
        vip,
        async: function(generatorFn) {
          return function() {
            try {
              var rv = awaitIterator(generatorFn.apply(this, arguments));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          };
        },
        spawn: function(generatorFn, args, thiz) {
          try {
            var rv = awaitIterator(generatorFn.apply(thiz, args || []));
            if (!rv || typeof rv.then !== "function")
              return DexiePromise.resolve(rv);
            return rv;
          } catch (e) {
            return rejection(e);
          }
        },
        currentTransaction: {
          get: function() {
            return PSD.trans || null;
          }
        },
        waitFor: function(promiseOrFunction, optionalTimeout) {
          var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie2.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
          return PSD.trans ? PSD.trans.waitFor(promise) : promise;
        },
        Promise: DexiePromise,
        debug: {
          get: function() {
            return debug;
          },
          set: function(value) {
            setDebug(value);
          }
        },
        derive,
        extend,
        props,
        override,
        Events,
        on: globalEvents,
        liveQuery: liveQuery2,
        extendObservabilitySet,
        getByKeyPath,
        setByKeyPath,
        delByKeyPath,
        shallowClone,
        deepClone,
        getObjectDiff,
        cmp: cmp2,
        asap: asap$1,
        minKey,
        addons: [],
        connections,
        errnames,
        dependencies: domDeps,
        cache,
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split(".").map(function(n) {
          return parseInt(n);
        }).reduce(function(p, c, i) {
          return p + c / Math.pow(10, i * 2);
        })
      }));
      Dexie2.maxKey = getMaxKey(Dexie2.dependencies.IDBKeyRange);
      if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
          if (!propagatingLocally) {
            var event_1;
            event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
              detail: updatedParts
            });
            propagatingLocally = true;
            dispatchEvent(event_1);
            propagatingLocally = false;
          }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a2) {
          var detail = _a2.detail;
          if (!propagatingLocally) {
            propagateLocally(detail);
          }
        });
      }
      function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
          propagatingLocally = true;
          globalEvents.storagemutated.fire(updateParts);
          signalSubscribersNow(updateParts, true);
        } finally {
          propagatingLocally = wasMe;
        }
      }
      var propagatingLocally = false;
      var bc;
      var createBC = function() {
      };
      if (typeof BroadcastChannel !== "undefined") {
        createBC = function() {
          bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
          bc.onmessage = function(ev) {
            return ev.data && propagateLocally(ev.data);
          };
        };
        createBC();
        if (typeof bc.unref === "function") {
          bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
          if (!propagatingLocally) {
            bc.postMessage(changedParts);
          }
        });
      }
      if (typeof addEventListener !== "undefined") {
        addEventListener("pagehide", function(event) {
          if (!Dexie$1.disableBfCache && event.persisted) {
            if (debug)
              console.debug("Dexie: handling persisted pagehide");
            bc === null || bc === void 0 ? void 0 : bc.close();
            for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
              var db2 = connections_1[_i];
              db2.close({ disableAutoOpen: false });
            }
          }
        });
        addEventListener("pageshow", function(event) {
          if (!Dexie$1.disableBfCache && event.persisted) {
            if (debug)
              console.debug("Dexie: handling persisted pageshow");
            createBC();
            propagateLocally({ all: new RangeSet2(-Infinity, [[]]) });
          }
        });
      }
      function add2(value) {
        return new PropModification2({ add: value });
      }
      function remove2(value) {
        return new PropModification2({ remove: value });
      }
      function replacePrefix2(a, b) {
        return new PropModification2({ replacePrefix: [a, b] });
      }
      DexiePromise.rejectionMapper = mapError;
      setDebug(debug);
      var namedExports = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery2,
        Entity: Entity2,
        cmp: cmp2,
        PropModSymbol: PropModSymbol2,
        PropModification: PropModification2,
        replacePrefix: replacePrefix2,
        add: add2,
        remove: remove2,
        "default": Dexie$1,
        RangeSet: RangeSet2,
        mergeRanges: mergeRanges2,
        rangesOverlap: rangesOverlap2
      });
      __assign(Dexie$1, namedExports, { default: Dexie$1 });
      return Dexie$1;
    });
  }
});

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, {
          type: "GET",
          path: path.map((p) => p.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, {
        type: "SET",
        path: [...path, prop].map((p) => p.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "APPLY",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "CONSTRUCT",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    ep.addEventListener("message", function l(ev) {
      if (!ev.data || !ev.data.id || ev.data.id !== id) {
        return;
      }
      ep.removeEventListener("message", l);
      resolve(ev.data);
    });
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}

// node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// node_modules/date-fns/addDays.js
function addDays(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/isAfter.js
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}

// node_modules/dexie/import-wrapper.mjs
var import_dexie = __toESM(require_dexie(), 1);
var DexieSymbol = Symbol.for("Dexie");
var Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
if (import_dexie.default.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie.semVer}`);
}
var {
  liveQuery,
  mergeRanges,
  rangesOverlap,
  RangeSet,
  cmp,
  Entity,
  PropModSymbol,
  PropModification,
  replacePrefix,
  add,
  remove
} = Dexie;
var import_wrapper_default = Dexie;

// wasmcode/db.ts
var DatabaseStorage = class extends import_wrapper_default {
  keyValue;
  packageIndex;
  symbolIndex;
  constructor() {
    super("CacheStore");
    this.version(2).stores({
      keyValue: "key",
      packageIndex: "importPath, prefix, name",
      symbolIndex: `
        key,
        packagePath,
        [packageName+prefix],
        [packageName+label],
        [packagePath+prefix]`
    });
  }
};
var KeyValueStore = class {
  constructor(db2) {
    this.db = db2;
  }
  async getItem(key, validate) {
    const entry = await this.db.keyValue.get(key);
    if (entry?.expireAt && isAfter(/* @__PURE__ */ new Date(), entry.expireAt)) {
      void this.deleteItem(key);
      return void 0;
    }
    if (entry && validate && !validate(entry)) {
      void this.deleteItem(key);
      return void 0;
    }
    return entry?.value;
  }
  async deleteItem(key) {
    const n = await this.db.keyValue.where({ key }).delete();
    return n > 0;
  }
  async setItem(key, value, expireAt) {
    await this.deleteItem(key);
    await this.db.keyValue.put({ key, value, expireAt });
  }
  async flush() {
    await this.db.keyValue.clear();
  }
};
var db = new DatabaseStorage();
var keyValue = new KeyValueStore(db);

// wasmcode/language/language.worker.ts
var completionVersionKey = "completionItems.version";
var TTL_DAYS = 7;
var getExpireTime = () => addDays(/* @__PURE__ */ new Date(), TTL_DAYS);
var isPackageQuery = (q) => "packageName" in q;
var WorkerHandler = class {
  cachePopulated = false;
  populatePromise;
  /**
   * Store keeps completions in cache.
   *
   * Using in-memory cache doesn't make sense as Monaco mutates completions after submit.
   * Completions with mutated position are no longer validated, so either each new copy should be done
   * or it's much easier to just query the DB.
   */
  db = db;
  keyValue = keyValue;
  /**
   * Returns whether cache was previously populated.
   */
  isWarmUp() {
    return this.cachePopulated;
  }
  /**
   * Returns list of predefined builtins.
   *
   * Used to speed-up hover operations.
   */
  async getBuiltinNames() {
    await this.checkCacheReady();
    const items = await this.db.symbolIndex.where({ packageName: "builtin" }).toArray();
    return items.map(({ label }) => label);
  }
  buildHoverFilter(query) {
    const isPackageMember = "packageName" in query;
    if (!isPackageMember) {
      return {
        key: `builtin.${query.value}`
      };
    }
    const pkgPath = findPackagePathFromContext(query.context, query.packageName);
    if (pkgPath) {
      return {
        key: `${pkgPath}.${query.value}`
      };
    }
    return {
      packageName: query.packageName,
      label: query.value
    };
  }
  /**
   * Returns hover documentation for a symbol.
   */
  async getHoverValue(query) {
    await this.checkCacheReady();
    const filter = this.buildHoverFilter(query);
    const entry = await this.db.symbolIndex.where(filter).first();
    if (!entry) {
      return null;
    }
    return {
      contents: symbolHoverDoc(entry),
      range: query.context.range
    };
  }
  /**
   * Returns list of known importable Go packages.
   *
   * Returns value from cache if available.
   * @returns
   */
  async getImportSuggestions() {
    return await this.getStandardPackages();
  }
  /**
   * Returns symbol or literal suggestions by prefix and package name.
   */
  async getSymbolSuggestions(query) {
    console.log(query);
    await this.checkCacheReady();
    if (isPackageQuery(query)) {
      return await this.getMemberSuggestion(query);
    }
    return await this.getLiteralSuggestion(query);
  }
  async getMemberSuggestion({ value, packageName, context }) {
    const packagePath = findPackagePathFromContext(context, packageName);
    const filter = packagePath ? {
      packagePath
    } : { packageName };
    if (value) {
      filter.prefix = value.charAt(0).toLowerCase();
    }
    const symbols = await this.db.symbolIndex.where(filter).toArray();
    return symbols.map((symbol) => completionFromSymbol(symbol, context, !!packagePath));
  }
  async getLiteralSuggestion({ value, context }) {
    const packages = await this.db.packageIndex.where("prefix").equals(value).toArray();
    const builtins = await this.db.symbolIndex.where("packagePath").equals("builtin").toArray();
    const packageCompletions = packages.map((item) => completionFromPackage(item, context));
    const symbolsCompletions = builtins.map((item) => completionFromSymbol(item, context, false));
    return packageCompletions.concat(symbolsCompletions);
  }
  async getStandardPackages() {
    await this.checkCacheReady();
    const results = await this.db.packageIndex.toArray();
    return results.map(importCompletionFromPackage);
  }
  async checkCacheReady() {
    if (this.cachePopulated) {
      return true;
    }
    const version = await this.keyValue.getItem(completionVersionKey, (entry) => {
      return typeof entry.expireAt !== "undefined";
    });
    if (!version) {
      await this.populateCache();
      return true;
    }
    const count = await this.db.packageIndex.count();
    this.cachePopulated = count > 0;
    if (!this.cachePopulated) {
      await this.populateCache();
    }
    return this.cachePopulated;
  }
  async populateCache() {
    if (!this.populatePromise) {
      this.populatePromise = (async () => {
        const rsp = await fetch("/static/go-index.json");
        if (!rsp.ok) {
          throw new Error(`${rsp.status} ${rsp.statusText}`);
        }
        const data = await rsp.json();
        if (data.version > 1) {
          console.warn(`unsupported symbol index version: ${data.version}, skip update.`);
          return;
        }
        console.log(data);
        const packages = constructPackages(data.packages);
        const symbols = constructSymbols(data.symbols);
        await Promise.all([
          this.db.packageIndex.clear(),
          this.db.symbolIndex.clear(),
          this.db.packageIndex.bulkAdd(packages),
          this.db.symbolIndex.bulkAdd(symbols),
          this.keyValue.setItem(completionVersionKey, data.go, getExpireTime())
        ]);
        this.cachePopulated = true;
      })();
    }
    await this.populatePromise;
  }
};
expose(new WorkerHandler());
var SymbolSourceKey = /* @__PURE__ */ ((SymbolSourceKey2) => {
  SymbolSourceKey2[SymbolSourceKey2["Name"] = 0] = "Name";
  SymbolSourceKey2[SymbolSourceKey2["Path"] = 1] = "Path";
  return SymbolSourceKey2;
})(SymbolSourceKey || {});
var ImportClauseType = /* @__PURE__ */ ((ImportClauseType2) => {
  ImportClauseType2[ImportClauseType2["None"] = 0] = "None";
  ImportClauseType2[ImportClauseType2["Single"] = 1] = "Single";
  ImportClauseType2[ImportClauseType2["Block"] = 2] = "Block";
  return ImportClauseType2;
})(ImportClauseType || {});
var getPrefix = (str) => str[0]?.toLowerCase() ?? "";
var stubRange = void 0;
var packageCompletionKind = 8;
var discardIfEmpty = (str, defaults) => str.length ? str : defaults;
var stringToMarkdown = (value) => {
  if (!value.length) {
    return void 0;
  }
  return {
    value,
    isTrusted: true
  };
};
var constructPackages = ({ names, paths, docs }) => names.map((name, i) => ({
  name,
  importPath: paths[i],
  prefix: getPrefix(names[i]),
  documentation: stringToMarkdown(docs[i])
}));
var constructSymbols = ({
  names,
  docs,
  details,
  signatures,
  insertTexts,
  insertTextRules,
  kinds,
  packages
}) => names.map((name, i) => ({
  key: `${packages[i][1 /* Path */]}.${name}`,
  label: name,
  detail: discardIfEmpty(details[i], name),
  signature: signatures[i],
  kind: kinds[i],
  insertText: insertTexts[i],
  insertTextRules: insertTextRules[i],
  prefix: getPrefix(name),
  packageName: packages[i][0 /* Name */],
  packagePath: packages[i][1 /* Path */],
  documentation: stringToMarkdown(docs[i])
}));
var importCompletionFromPackage = ({ importPath, name, documentation }) => ({
  label: importPath,
  documentation,
  detail: name,
  insertText: importPath,
  kind: packageCompletionKind,
  range: stubRange
});
var importPackageTextEdit = (importPath, { imports }) => {
  if (!imports.range || imports.allPaths?.has(importPath)) {
    return void 0;
  }
  switch (imports.blockType) {
    case 0 /* None */: {
      const text = `import "${importPath}"
`;
      return [
        {
          text: imports.prependNewLine ? `
${text}` : text,
          range: imports.range,
          forceMoveMarkers: true
        }
      ];
    }
    case 1 /* Single */:
    case 2 /* Block */: {
      const importLines = (imports.blockPaths ?? []).concat(importPath).sort().map((v) => `	"${v}"`).join("\n");
      return [
        {
          text: `import (
${importLines}
)`,
          range: imports.range,
          forceMoveMarkers: true
        }
      ];
    }
  }
};
var completionFromPackage = ({ importPath, name, documentation }, ctx) => ({
  label: name,
  documentation,
  detail: importPath,
  insertText: name,
  kind: packageCompletionKind,
  range: ctx.range,
  additionalTextEdits: importPackageTextEdit(importPath, ctx)
});
var completionFromSymbol = ({ packagePath, ...completionItem }, ctx, textEdits) => ({
  ...completionItem,
  range: ctx.range,
  additionalTextEdits: textEdits ? importPackageTextEdit(packagePath, ctx) : void 0
});
var pkgNameFromPath = (importPath) => {
  const slashPos = importPath.lastIndexOf("/");
  return slashPos === -1 ? importPath : importPath.slice(slashPos + 1);
};
var findPackagePathFromContext = ({ imports }, pkgName) => {
  if (!imports.allPaths) {
    return void 0;
  }
  if (imports.allPaths.has(pkgName)) {
    return pkgName;
  }
  for (const importPath of imports.allPaths.keys()) {
    if (pkgName === pkgNameFromPath(importPath)) {
      return importPath;
    }
  }
};
var goDocDomain = "pkg.go.dev";
var symbolHoverDoc = ({
  label,
  packageName,
  packagePath,
  signature,
  documentation
}) => {
  const doc = [];
  if (signature) {
    doc.push({
      value: "```go\n" + signature + "\n```"
    });
  }
  if (documentation) {
    doc.push(documentation);
  }
  const docLabel = packagePath === "builtin" ? label : `${packageName}.${label}`;
  const linkLabel = `\`${docLabel}\` on ${goDocDomain}`;
  doc.push({
    value: `[${linkLabel}](https://${goDocDomain}/${packagePath}#${label})`,
    isTrusted: true
  });
  return doc;
};
export {
  ImportClauseType,
  SymbolSourceKey,
  WorkerHandler,
  completionFromPackage,
  completionFromSymbol,
  constructPackages,
  constructSymbols,
  findPackagePathFromContext,
  importCompletionFromPackage,
  symbolHoverDoc
};
/*! Bundled license information:

dexie/dist/dexie.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL25vZGVfbW9kdWxlcy8ucG5wbS90c2xpYkAyLjMuMS9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZ2xvYmFscy9nbG9iYWwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvdXRpbHMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9lcnJvcnMvZXJyb3JzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMvZGVidWcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3Byb21pc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvdGVtcC10cmFuc2FjdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvY29uc3RhbnRzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NvbWJpbmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUva2V5cmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvd29ya2Fyb3VuZC11bmRlZmluZWQtcHJpbWtleS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZW50aXR5L0VudGl0eS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9jbXAudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RhYmxlL3RhYmxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9FdmVudHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdGFibGUvdGFibGUtY29uc3RydWN0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1oZWxwZXJzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9wcm9wLW1vZGlmaWNhdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9jb2xsZWN0aW9uL2NvbGxlY3Rpb24tY29uc3RydWN0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY29tcGFyZS1mdW5jdGlvbnMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UtaGVscGVycy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS1jb25zdHJ1Y3Rvci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9pbmRleC1zcGVjLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy90YWJsZS1zY2hlbWEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvcXVpcmtzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1rZXktZXh0cmFjdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2RiY29yZS1pbmRleGVkZGIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3ZlcnNpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdmlwLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9ub2RlX21vZHVsZXMvLnBucG0vc2FmYXJpLTE0LWlkYi1maXhAMy4wLjAvbm9kZV9tb2R1bGVzL3NhZmFyaS0xNC1pZGItZml4L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3Jhbmdlc2V0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L29icy1zZXRzLW92ZXJsYXAudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2NhY2hlL2NhY2hlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9jYWNoZS9zaWduYWxTdWJzY3JpYmVycy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtb3Blbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMveWllbGQtc3VwcG9ydC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdHJhbnNhY3Rpb24taGVscGVycy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2RiY29yZS92aXJ0dWFsLWluZGV4LW1pZGRsZXdhcmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1lZmZlY3RpdmUta2V5cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUvY2FjaGUtZXhpc3RpbmctdmFsdWVzLW1pZGRsZXdhcmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2NhY2hlL2lzLWNhY2hhYmxlLWNvbnRleHQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2NhY2hlL2lzLWNhY2hhYmxlLXJlcXVlc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L29ic2VydmFiaWxpdHktbWlkZGxld2FyZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvY2FjaGUvYWRqdXN0LW9wdGltaXN0aWMtcmVxdWVzdC1mcm9tLWZhaWx1cmVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9jYWNoZS9pcy13aXRoaW4tcmFuZ2UudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2NhY2hlL2FwcGx5LW9wdGltaXN0aWMtb3BzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9jYWNoZS9hcmUtcmFuZ2VzLWVxdWFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9jYWNoZS9pcy1zdXBlci1yYW5nZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvY2FjaGUvZmluZC1jb21wYXRpYmxlLXF1ZXJ5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9jYWNoZS9zdWJzY3JpYmUtY2FjaGVudHJ5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9jYWNoZS9jYWNoZS1taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy92aXBpZnkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2RleGllLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2RleGllLWRvbS1kZXBlbmRlbmNpZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2xpdmUtcXVlcnkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2RleGllLXN0YXRpYy1wcm9wcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvcHJvcGFnYXRlLWxvY2FsbHkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2VuYWJsZS1icm9hZGNhc3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9zdXBwb3J0LWJmY2FjaGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvcHJvcG1vZHMvYWRkLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3Byb3Btb2RzL3JlbW92ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9wcm9wbW9kcy9yZXBsYWNlLXByZWZpeC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaW5kZXgtdW1kLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21saW5rL3NyYy9jb21saW5rLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2NvbnN0cnVjdEZyb20uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3RvRGF0ZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkRGF5cy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNBZnRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvaW1wb3J0LXdyYXBwZXIubWpzIiwgIi4uLy4uLy4uL3dhc21jb2RlL2RiLnRzIiwgIi4uLy4uLy4uL3dhc21jb2RlL2xhbmd1YWdlL2xhbmd1YWdlLndvcmtlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iLCAiZGVjbGFyZSB2YXIgZ2xvYmFsO1xuZXhwb3J0IGNvbnN0IF9nbG9iYWw6IGFueSA9XG4gICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6XG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgIGdsb2JhbDtcbiIsICLvu79pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSBcIi4uL2dsb2JhbHMvZ2xvYmFsXCI7XG5leHBvcnQgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKXtcbiAgICAvLyBJbiBqc2RvbSwgdGhpcyBpdCBjYW4gYmUgdGhlIGNhc2UgdGhhdCBQcm9taXNlIGlzIG5vdCBwdXQgb24gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgLy8gSWYgc28sIHdlIG5lZWQgdG8gcGF0Y2ggdGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSByZXN0IG9mIHRoZSBjb2RlIHRvIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgLy8gT3RoZXIgZGV4aWUgY29kZSBleHBlY3RzIFByb21pc2UgdG8gYmUgb24gdGhlIGdsb2JhbCBvYmplY3QgKGxpa2Ugbm9ybWFsIGJyb3dzZXIgZW52aXJvbm1lbnRzKVxuICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5leHBvcnQgeyBfZ2xvYmFsIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZDxUIGV4dGVuZHMgb2JqZWN0LFggZXh0ZW5kcyBvYmplY3Q+KG9iajogVCwgZXh0ZW5zaW9uOiBYKTogVCAmIFggIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpIHJldHVybiBvYmogYXMgVCAmIFg7XG4gICAga2V5cyhleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmogYXMgVCAmIFg7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmV4cG9ydCBjb25zdCBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BzIChwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnM/KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBleHRlbmQoZnVuY3Rpb25PckdldFNldCAmJiBoYXNPd24oZnVuY3Rpb25PckdldFNldCwgXCJnZXRcIikgJiYgdHlwZW9mIGZ1bmN0aW9uT3JHZXRTZXQuZ2V0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAge2dldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOlxuICAgICAgICB7dmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWV9LCBvcHRpb25zKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG4gICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIGNvbnN0IHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgbGV0IHByb3RvO1xuICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgKHByb3RvLCBwcm9wKTtcbn1cblxuY29uc3QgX3NsaWNlID0gW10uc2xpY2U7XG5leHBvcnQgZnVuY3Rpb24gc2xpY2UoYXJncywgc3RhcnQ/LCBlbmQ/KSB7XG4gICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQgKGIpIHtcbiAgICBpZiAoIWIpIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBGYWlsZWRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2FwKGZuKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSkgc2V0SW1tZWRpYXRlKGZuKTsgZWxzZSBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZUFycmF5KGEpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoKHZhbHVlLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpO1xufVxuXG4vKiogR2VuZXJhdGUgYW4gb2JqZWN0IChoYXNoIG1hcCkgYmFzZWQgb24gZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0gZXh0cmFjdG9yIEZ1bmN0aW9uIHRha2luZyBhbiBhcnJheSBpdGVtIGFuZCBpdHMgaW5kZXggYW5kIHJldHVybmluZyBhbiBhcnJheSBvZiAyIGl0ZW1zIChba2V5LCB2YWx1ZV0pIHRvXG4gKiAgICAgICAgaW5zdGVydCBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdCBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZVxuICogICAgICAgIGN1cnJlbnQgaXRlbSB3b250IGFmZmVjdCB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Q8VCxSPiAoYXJyYXk6IFRbXSwgZXh0cmFjdG9yOiAoeDpULCBpZHg6IG51bWJlcik9PltzdHJpbmcsIFJdKToge1tuYW1lOiBzdHJpbmddOiBSfSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgocmVzdWx0LCBpdGVtLCBpKSA9PiB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeWNhdGNoZXIoZm4sIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5Q2F0Y2goZm46ICguLi5hcmdzOiBhbnlbXSk9PnZvaWQsIG9uZXJyb3IsIGFyZ3M/KSA6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIG9uZXJyb3IgJiYgb25lcnJvcihleCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi8jc3RlcHMtZm9yLWV4dHJhY3RpbmctYS1rZXktZnJvbS1hLXZhbHVlLXVzaW5nLWEta2V5LXBhdGhcbiAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnICYmIGhhc093bihvYmosIGtleVBhdGgpKSByZXR1cm4gb2JqW2tleVBhdGhdOyAvLyBUaGlzIGxpbmUgaXMgbW92ZWQgZnJvbSBsYXN0IHRvIGZpcnN0IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZS5cbiAgICBpZiAoIWtleVBhdGgpIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKSBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSkgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9IGVsc2Ugb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbihrcCkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuICAgIHZhciBydiA9IHt9O1xuICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSkgcnZbbV0gPSBvYmpbbV07XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cblxuY29uc3QgY29uY2F0ID0gW10uY29uY2F0O1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW48VD4gKGE6IChUIHwgVFtdKVtdKSA6IFRbXSB7XG4gICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYSk7XG59XG5cbi8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuY29uc3QgaW50cmluc2ljVHlwZU5hbWVzID1cbiAgICBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAuc3BsaXQoJywnKS5jb25jYXQoXG4gICAgICAgIGZsYXR0ZW4oWzgsMTYsMzIsNjRdLm1hcChudW09PltcIkludFwiLFwiVWludFwiLFwiRmxvYXRcIl0ubWFwKHQ9PnQrbnVtK1wiQXJyYXlcIikpKVxuICAgICkuZmlsdGVyKHQ9Pl9nbG9iYWxbdF0pO1xuY29uc3QgaW50cmluc2ljVHlwZXMgPSBuZXcgU2V0KGludHJpbnNpY1R5cGVOYW1lcy5tYXAodD0+X2dsb2JhbFt0XSkpO1xuXG4vKiogRGVlcCBjbG9uZSBhIHNpbXBsZSBvYmplY3QgdHJlZS5cbiAqIFxuICogQ29waWVzIG9iamVjdCB0cmVlIGRlZXBseSwgYnV0IGRvZXMgbm90IGRlZXAtY29weSBhcnJheXMsXG4gKiB0eXBlZCBhcnJheXMsIERhdGVzIG9yIG90aGVyIGludHJpbnNpYyB0eXBlcy5cbiAqIFxuICogRG9lcyBub3QgY2hlY2sgZm9yIGN5Y2xpYyByZWZlcmVuY2VzLlxuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIDYgdGltZXMgZmFzdGVyIHRoYW4gc3RydWN0dXJlZENsb25lKCkgb24gY2hyb21pdW0gMTExLlxuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBzYWZlbHkgYmUgdXNlZCBmb3IgY2xvbmluZyBPYnNlcnZhYmlsaXR5U2V0cyBhbmQgUmFuZ2VTZXRzLlxuICogXG4gKiBAcGFyYW0gbyBPYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm5zIENsb25lZCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lU2ltcGxlT2JqZWN0VHJlZTxUIGV4dGVuZHMgb2JqZWN0PihvOiBUKTogVCB7XG4gICAgY29uc3QgcnYgPSB7fSBhcyBUO1xuICAgIGZvciAoY29uc3QgayBpbiBvKSBpZiAoaGFzT3duKG8sIGspKSB7XG4gICAgICAgIGNvbnN0IHYgPSBvW2tdO1xuICAgICAgICBydltrXSA9ICF2IHx8IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyB8fCBpbnRyaW5zaWNUeXBlcy5oYXModi5jb25zdHJ1Y3RvcikgPyB2IDogY2xvbmVTaW1wbGVPYmplY3RUcmVlKHYpO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RJc0VtcHR5KG86IG9iamVjdCkge1xuICAgIGZvciAoY29uc3QgayBpbiBvKSBpZiAoaGFzT3duKG8sIGspKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmxldCBjaXJjdWxhclJlZnM6IG51bGwgfCBXZWFrTWFwPGFueSxhbnk+ID0gbnVsbDtcblxuLyoqIERlZXAgY2xvbmUgYW4gb2JqZWN0IG9yIGFycmF5LlxuICogXG4gKiBcbiAqIEBwYXJhbSBhbnkgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZTxUPihhbnk6IFQpOiBUIHtcbiAgICBjaXJjdWxhclJlZnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHJ2ID0gaW5uZXJEZWVwQ2xvbmUoYW55KTtcbiAgICBjaXJjdWxhclJlZnMgPSBudWxsO1xuICAgIHJldHVybiBydjtcbn1cblxuZnVuY3Rpb24gaW5uZXJEZWVwQ2xvbmU8VD4oeDogVCk6IFQge1xuICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHJldHVybiB4O1xuICAgIGxldCBydiA9IGNpcmN1bGFyUmVmcy5nZXQoeCk7IC8vIFJlc29sdmUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGlmIChydikgcmV0dXJuIHJ2O1xuICAgIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICAgIHJ2ID0gW107XG4gICAgICAgIGNpcmN1bGFyUmVmcy5zZXQoeCwgcnYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBydi5wdXNoKGlubmVyRGVlcENsb25lKHhbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW50cmluc2ljVHlwZXMuaGFzKHguY29uc3RydWN0b3IpKSB7XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSwgd2UncmUgbGVzcyBzdHJpY3QgdGhhbiBzdHJ1Y3R1cmVkQ2xvbmUgLSB3ZSdyZSBvbmx5XG4gICAgICAgIC8vIGNsb25pbmcgYXJyYXlzIGFuZCBjdXN0b20gb2JqZWN0cy5cbiAgICAgICAgLy8gVHlwZWQgYXJyYXlzLCBEYXRlcyBldGMgYXJlIG5vdCBjbG9uZWQuXG4gICAgICAgIHJ2ID0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSdyZSBuaWNlciB0byBjdXN0b20gY2xhc3NlcyB0aGFuIHdoYXQgc3RydWN0dXJlZENsb25lKCkgaXMgLVxuICAgICAgICAvLyB3ZSBwcmVzZXJ2ZSB0aGUgcHJvdG8gb2YgZWFjaCBvYmplY3QuXG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8oeCk7XG4gICAgICAgIHJ2ID0gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgPyB7fSA6IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgICBjaXJjdWxhclJlZnMuc2V0KHgsIHJ2KTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB4KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duKHgsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZSh4W3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5cbmNvbnN0IHt0b1N0cmluZ30gPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1RhZyhvOiBPYmplY3QpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG59XG5cbi8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2UsIHJldHVybiBpdCBhcyBhbiBhcnJheVxuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIFN5bWJvbC5pdGVyYXRvciA6XG4gICAgJ0BAaXRlcmF0b3InO1xuZXhwb3J0IGNvbnN0IGdldEl0ZXJhdG9yT2YgPSB0eXBlb2YgaXRlcmF0b3JTeW1ib2wgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGk7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xufSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG5leHBvcnQgY29uc3QgYXN5bmNJdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gICAgPyBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBTeW1ib2wuZm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3JcIilcbiAgICA6ICdAYXN5bmNJdGVyYXRvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxBcnJheUl0ZW0oYTogYW55W10sIHg6IGFueSkge1xuICAgIGNvbnN0IGkgPSBhLmluZGV4T2YoeCk7XG4gICAgaWYgKGkgPj0gMCkgYS5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuIGkgPj0gMDtcbn1cblxuZXhwb3J0IGNvbnN0IE5PX0NIQVJfQVJSQVkgPSB7fTtcbi8vIFRha2VzIG9uZSBvciBzZXZlcmFsIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBhcnJheSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGNyaXRlcmFzOlxuLy8gKiBJZiBzZXZlcmFsIGFyZ3VtZW50cyBwcm92aWRlZCwgcmV0dXJuIGFyZ3VtZW50cyBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgaW4gYSB3YXkgdGhhdFxuLy8gICBzdGlsbCBhbGxvd3MgamF2YXNjcmlwdCBlbmdpbmUgdG8gb3B0aW1pemUgdGhlIGNvZGUuXG4vLyAqIElmIHNpbmdsZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgcmV0dXJuIGEgY2xvbmUgb2YgaXQuXG4vLyAqIElmIHRoaXMtcG9pbnRlciBlcXVhbHMgTk9fQ0hBUl9BUlJBWSwgZG9uJ3QgYWNjZXB0IHN0cmluZ3MgYXMgdmFsaWQgaXRlcmFibGVzIGFzIGEgc3BlY2lhbFxuLy8gICBjYXNlIHRvIHRoZSB0d28gYnVsbGV0cyBiZWxvdy5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGl0ZXJhYmxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheS5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFycmF5LWxpa2UgKGhhcyBsZW5ndGggb2YgdHlwZSBudW1iZXIpLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5LlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5T2YgKGFycmF5TGlrZSkge1xuICAgIHZhciBpLCBhLCB4LCBpdDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKSByZXR1cm4gYXJyYXlMaWtlLnNsaWNlKCk7XG4gICAgICAgIGlmICh0aGlzID09PSBOT19DSEFSX0FSUkFZICYmIHR5cGVvZiBhcnJheUxpa2UgPT09ICdzdHJpbmcnKSByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKSBhLnB1c2goeC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXlMaWtlID09IG51bGwpIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSBhW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgIH1cbiAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIGFbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnQgY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChmbjogRnVuY3Rpb24pID0+IGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJ1xuICAgIDogKCk9PmZhbHNlO1xuIiwgImltcG9ydCB7IGRlcml2ZSwgc2V0UHJvcCB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5cbnZhciBkZXhpZUVycm9yTmFtZXMgPSBbXG4gICAgJ01vZGlmeScsXG4gICAgJ0J1bGsnLFxuICAgICdPcGVuRmFpbGVkJyxcbiAgICAnVmVyc2lvbkNoYW5nZScsXG4gICAgJ1NjaGVtYScsXG4gICAgJ1VwZ3JhZGUnLFxuICAgICdJbnZhbGlkVGFibGUnLFxuICAgICdNaXNzaW5nQVBJJyxcbiAgICAnTm9TdWNoRGF0YWJhc2UnLFxuICAgICdJbnZhbGlkQXJndW1lbnQnLFxuICAgICdTdWJUcmFuc2FjdGlvbicsXG4gICAgJ1Vuc3VwcG9ydGVkJyxcbiAgICAnSW50ZXJuYWwnLFxuICAgICdEYXRhYmFzZUNsb3NlZCcsXG4gICAgJ1ByZW1hdHVyZUNvbW1pdCcsXG4gICAgJ0ZvcmVpZ25Bd2FpdCdcbl07XG5cbnZhciBpZGJEb21FcnJvck5hbWVzID0gW1xuICAgICdVbmtub3duJyxcbiAgICAnQ29uc3RyYWludCcsXG4gICAgJ0RhdGEnLFxuICAgICdUcmFuc2FjdGlvbkluYWN0aXZlJyxcbiAgICAnUmVhZE9ubHknLFxuICAgICdWZXJzaW9uJyxcbiAgICAnTm90Rm91bmQnLFxuICAgICdJbnZhbGlkU3RhdGUnLFxuICAgICdJbnZhbGlkQWNjZXNzJyxcbiAgICAnQWJvcnQnLFxuICAgICdUaW1lb3V0JyxcbiAgICAnUXVvdGFFeGNlZWRlZCcsXG4gICAgJ1N5bnRheCcsXG4gICAgJ0RhdGFDbG9uZSdcbl07XG5cbnZhciBlcnJvckxpc3QgPSBkZXhpZUVycm9yTmFtZXMuY29uY2F0KGlkYkRvbUVycm9yTmFtZXMpO1xuXG52YXIgZGVmYXVsdFRleHRzID0ge1xuICAgIFZlcnNpb25DaGFuZ2VkOiBcIkRhdGFiYXNlIHZlcnNpb24gY2hhbmdlZCBieSBvdGhlciBkYXRhYmFzZSBjb25uZWN0aW9uXCIsXG4gICAgRGF0YWJhc2VDbG9zZWQ6IFwiRGF0YWJhc2UgaGFzIGJlZW4gY2xvc2VkXCIsXG4gICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuICAgIFRyYW5zYWN0aW9uSW5hY3RpdmU6IFwiVHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgY29tcGxldGVkIG9yIGZhaWxlZFwiLFxuICAgIE1pc3NpbmdBUEk6IFwiSW5kZXhlZERCIEFQSSBtaXNzaW5nLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly90aW55dXJsLmNvbS95MnV1dnNrYlwiXG59O1xuXG4vL1xuLy8gRGV4aWVFcnJvciAtIGJhc2UgY2xhc3Mgb2YgYWxsIG91dCBleGNlcHRpb25zLlxuLy9cbmV4cG9ydCBmdW5jdGlvbiBEZXhpZUVycm9yIChuYW1lLCBtc2cpIHtcbiAgICAvLyBSZWFzb24gd2UgZG9uJ3QgdXNlIEVTNiBjbGFzc2VzIGlzIGJlY2F1c2U6XG4gICAgLy8gMS4gSXQgYmxvYXRzIHRyYW5zcGlsZWQgY29kZSBhbmQgaW5jcmVhc2VzIHNpemUgb2YgbWluaWZpZWQgY29kZS5cbiAgICAvLyAyLiBJdCBkb2Vzbid0IGdpdmUgdXMgbXVjaCBpbiB0aGlzIGNhc2UuXG4gICAgLy8gMy4gSXQgd291bGQgcmVxdWlyZSBzdWIgY2xhc3NlcyB0byBjYWxsIHN1cGVyKCksIHdoaWNoXG4gICAgLy8gICAgaXMgbm90IG5lZWRlZCB3aGVuIGRlcml2aW5nIGZyb20gRXJyb3IuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG59XG5cbmRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEVycm9yKS5leHRlbmQoe1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9XG59KTtcblxuZnVuY3Rpb24gZ2V0TXVsdGlFcnJvck1lc3NhZ2UgKG1zZywgZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gbXNnICsgXCIuIEVycm9yczogXCIgKyBPYmplY3Qua2V5cyhmYWlsdXJlcylcbiAgICAgICAgLm1hcChrZXk9PmZhaWx1cmVzW2tleV0udG9TdHJpbmcoKSlcbiAgICAgICAgLmZpbHRlcigodixpLHMpPT5zLmluZGV4T2YodikgPT09IGkpIC8vIE9ubHkgdW5pcXVlIGVycm9yIHN0cmluZ3NcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuXG4vL1xuLy8gTW9kaWZ5RXJyb3IgLSB0aHJvd24gaW4gQ29sbGVjdGlvbi5tb2RpZnkoKVxuLy8gU3BlY2lmaWMgY29uc3RydWN0b3IgYmVjYXVzZSBpdCBjb250YWlucyBtZW1iZXJzIGZhaWx1cmVzIGFuZCBmYWlsZWRLZXlzLlxuLy9cbmV4cG9ydCBmdW5jdGlvbiBNb2RpZnlFcnJvciAobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG4gICAgdGhpcy5mYWlsdXJlcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG4gICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWxrRXJyb3IgKG1zZywgZmFpbHVyZXMpIHtcbiAgICB0aGlzLm5hbWUgPSBcIkJ1bGtFcnJvclwiO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKHBvcyA9PiBmYWlsdXJlc1twb3NdKTtcbiAgICB0aGlzLmZhaWx1cmVzQnlQb3MgPSBmYWlsdXJlcztcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIHRoaXMuZmFpbHVyZXMpO1xufVxuZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcblxuLy9cbi8vXG4vLyBEeW5hbWljYWxseSBnZW5lcmF0ZSBlcnJvciBuYW1lcyBhbmQgZXhjZXB0aW9uIGNsYXNzZXMgYmFzZWRcbi8vIG9uIHRoZSBuYW1lcyBpbiBlcnJvckxpc3QuXG4vL1xuLy9cblxuLy8gTWFwIG9mIHtFcnJvck5hbWUgLT4gRXJyb3JOYW1lICsgXCJFcnJvclwifVxuZXhwb3J0IHZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaixuYW1lKT0+KG9ialtuYW1lXT1uYW1lK1wiRXJyb3JcIixvYmopLHt9KTtcblxuLy8gTmVlZCBhbiBhbGlhcyBmb3IgRGV4aWVFcnJvciBiZWNhdXNlIHdlJ3JlIGdvbm5hIGNyZWF0ZSBzdWJjbGFzc2VzIHdpdGggdGhlIHNhbWUgbmFtZS5cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xuLy8gTWFwIG9mIHtFcnJvck5hbWUgLT4gZXhjZXB0aW9uIGNvbnN0cnVjdG9yfVxuZXhwb3J0IHZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLG5hbWUpPT57XG4gICAgLy8gTGV0IHRoZSBuYW1lIGJlIFwiRGV4aWVFcnJvclwiIGJlY2F1c2UgdGhpcyBuYW1lIG1heVxuICAgIC8vIGJlIHNob3duIGluIGNhbGwgc3RhY2sgYW5kIHdoZW4gZGVidWdnaW5nLiBEZXhpZUVycm9yIGlzXG4gICAgLy8gdGhlIG1vc3QgdHJ1ZSBuYW1lIGJlY2F1c2UgaXQgZGVyaXZlcyBmcm9tIERleGllRXJyb3IsXG4gICAgLy8gYW5kIHdlIGNhbm5vdCBjaGFuZ2UgRnVuY3Rpb24ubmFtZSBwcm9ncmFtYXRpY2FsbHkgd2l0aG91dFxuICAgIC8vIGR5bmFtaWNhbGx5IGNyZWF0ZSBhIEZ1bmN0aW9uIG9iamVjdCwgd2hpY2ggd291bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vICdldmFsLWV2aWwnLlxuICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgZnVuY3Rpb24gRGV4aWVFcnJvciAobXNnT3JJbm5lciwgaW5uZXIpe1xuICAgICAgICB0aGlzLm5hbWUgPSBmdWxsTmFtZTtcbiAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXJ9JHshaW5uZXIgPyAnJyA6ICdcXG4gJyArIGlubmVyfWA7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gaW5uZXIgfHwgbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXIubmFtZX0gJHttc2dPcklubmVyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgIG9ialtuYW1lXT1EZXhpZUVycm9yO1xuICAgIHJldHVybiBvYmo7XG59LHt9KTtcblxuLy8gVXNlIEVDTUFTQ1JJUFQgc3RhbmRhcmQgZXhjZXB0aW9ucyB3aGVyZSBhcHBsaWNhYmxlOlxuZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbmV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbmV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xuXG5leHBvcnQgdmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKChvYmosIG5hbWUpPT57XG4gICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwRXJyb3IgKGRvbUVycm9yLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuICAgICAgICByZXR1cm4gZG9tRXJyb3I7XG4gICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcbiAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG4gICAgICAgIC8vIERlcml2ZSBzdGFjayBmcm9tIGlubmVyIGV4Y2VwdGlvbiBpZiBpdCBoYXMgYSBzdGFja1xuICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHtnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgfX0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5cbmV4cG9ydCB2YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKT0+e1xuICAgIGlmIChbXCJTeW50YXhcIixcIlR5cGVcIixcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbmZ1bGxOYW1lRXhjZXB0aW9ucy5Nb2RpZnlFcnJvciA9IE1vZGlmeUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkJ1bGtFcnJvciA9IEJ1bGtFcnJvcjtcbiIsICJpbXBvcnQge2V4dGVuZH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3AoKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cbmV4cG9ydCBmdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAvLyBFbmFibGVzIGNoYWluZWQgZXZlbnRzIHRoYXQgdGFrZXMgT05FIGFyZ3VtZW50IGFuZCByZXR1cm5zIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIGNoYWluLlxuICAgIC8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGluIHRoZSBob29rKFwicmVhZGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgLy8gRW5hYmxlcyBjaGFpbmVkIGV2ZW50cyB0aGF0IHRha2VzIHNldmVyYWwgYXJndW1lbnRzIGFuZCBtYXkgbW9kaWZ5IGZpcnN0IGFyZ3VtZW50IGJ5IG1ha2luZyBhIG1vZGlmaWNhdGlvbiBhbmQgdGhlbiByZXR1cm5pbmcgdGhlIHNhbWUgaW5zdGFuY2UuXG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgaW4gdGhlIGhvb2soXCJjcmVhdGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT09IG5vcCkgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLCAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbnN1Y2Nlc3NcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7ICAgICAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKSB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKSB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLCAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbnN1Y2Nlc3NcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7ICAgICAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTsgLy8gSWYgZjEgcmV0dXJucyBuZXcgbW9kaWZpY2F0aW9ucywgZXh0ZW5kIGNhbGxlcidzIG1vZGlmaWNhdGlvbnMgd2l0aCB0aGUgcmVzdWx0IGJlZm9yZSBjYWxsaW5nIG5leHQgaW4gY2hhaW4uXG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAgICAgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25lcnJvclxuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAocmVzMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzMikgOlxuICAgICAgICAgICAgKGV4dGVuZChyZXMsIHJlczIpKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vblN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbiIsICIvLyBCeSBkZWZhdWx0LCBkZWJ1ZyB3aWxsIGJlIHRydWUgb25seSBpZiBwbGF0Zm9ybSBpcyBhIHdlYiBwbGF0Zm9ybSBhbmQgaXRzIHBhZ2UgaXMgc2VydmVkIGZyb20gbG9jYWxob3N0LlxuLy8gV2hlbiBkZWJ1ZyA9IHRydWUsIGVycm9yJ3Mgc3RhY2tzIHdpbGwgY29udGFpbiBhc3luY3JvbmljIGxvbmcgc3RhY2tzLlxuZXhwb3J0IHZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgdXNlIGRlYnVnIG1vZGUgaWYgc2VydmVkIGZyb20gbG9jYWxob3N0LlxuICAgICAgICAvXihodHRwfGh0dHBzKTpcXC9cXC8obG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuMSkvLnRlc3QobG9jYXRpb24uaHJlZik7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Zyh2YWx1ZSwgZmlsdGVyKSB7XG4gICAgZGVidWcgPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQ8VD4gKHdoYXQ6IHN0cmluZywgZm46ICguLi5hcmdzKT0+VCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHt3aGF0fSBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9EZXByZWNhdGlvbnN9YCk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gYXMgKC4uLmFyZ3MpPT5UXG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3IERhdmlkIEZhaGxhbmRlclxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cbmltcG9ydCB7IF9nbG9iYWwgfSBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbCc7XG5pbXBvcnQge3RyeUNhdGNoLCBwcm9wcywgc2V0UHJvcCxcbiAgICBnZXRQcm9wZXJ0eURlc2NyaXB0b3IsIGdldEFycmF5T2YsIGV4dGVuZCwgZ2V0UHJvdG99IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQge25vcCwgY2FsbEJvdGgsIG1pcnJvcn0gZnJvbSAnLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQge2RlYnVnfSBmcm9tICcuL2RlYnVnJztcbmltcG9ydCB7ZXhjZXB0aW9uc30gZnJvbSAnLi4vZXJyb3JzJztcblxuLy9cbi8vIFByb21pc2UgYW5kIFpvbmUgKFBTRCkgZm9yIERleGllIGxpYnJhcnlcbi8vXG4vLyBJIHN0YXJ0ZWQgb3V0IHdyaXRpbmcgdGhpcyBQcm9taXNlIGNsYXNzIGJ5IGNvcHlpbmcgcHJvbWlzZS1saWdodCAoaHR0cHM6Ly9naXRodWIuY29tL3RheWxvcmhha2VzL3Byb21pc2UtbGlnaHQpIGJ5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGF5bG9yaGFrZXMgLSBhbiBBKyBhbmQgRUNNQVNDUklQVCA2IGNvbXBsaWFudCBQcm9taXNlIGltcGxlbWVudGF0aW9uLlxuLy9cbi8vIEluIHByZXZpb3VzIHZlcnNpb25zIHRoaXMgd2FzIGZpeGVkIGJ5IG5vdCBjYWxsaW5nIHNldFRpbWVvdXQgd2hlbiBrbm93aW5nIHRoYXQgdGhlIHJlc29sdmUoKSBvciByZWplY3QoKSBjYW1lIGZyb20gYW5vdGhlclxuLy8gdGljay4gSW4gRGV4aWUgdjEuNC4wLCBJJ3ZlIHJld3JpdHRlbiB0aGUgUHJvbWlzZSBjbGFzcyBlbnRpcmVseS4gSnVzdCBzb21lIGZyYWdtZW50cyBvZiBwcm9taXNlLWxpZ2h0IGlzIGxlZnQuIEkgdXNlXG4vLyBhbm90aGVyIHN0cmF0ZWd5IG5vdyB0aGF0IHNpbXBsaWZpZXMgZXZlcnl0aGluZyBhIGxvdDogdG8gYWx3YXlzIGV4ZWN1dGUgY2FsbGJhY2tzIGluIGEgbmV3IG1pY3JvLXRhc2ssIGJ1dCBoYXZlIGFuIG93biBtaWNyby10YXNrXG4vLyBlbmdpbmUgdGhhdCBpcyBpbmRleGVkREIgY29tcGxpYW50IGFjcm9zcyBhbGwgYnJvd3NlcnMuXG4vLyBQcm9taXNlIGNsYXNzIGhhcyBhbHNvIGJlZW4gb3B0aW1pemVkIGEgbG90IHdpdGggaW5zcGlyYXRpb24gZnJvbSBibHVlYmlyZCAtIHRvIGF2b2lkIGNsb3N1cmVzIGFzIG11Y2ggYXMgcG9zc2libGUuXG4vL1xuLy8gU3BlY2lmaWMgbm9uLXN0YW5kYXJkIGZlYXR1cmVzIG9mIHRoaXMgUHJvbWlzZSBjbGFzczpcbi8vICogQ3VzdG9tIHpvbmUgc3VwcG9ydCAoYS5rLmEuIFBTRCkgd2l0aCBhYmlsaXR5IHRvIGtlZXAgem9uZXMgYWxzbyB3aGVuIHVzaW5nIG5hdGl2ZSBwcm9taXNlcyBhcyB3ZWxsIGFzXG4vLyAgIG5hdGl2ZSBhc3luYyAvIGF3YWl0LlxuLy8gKiBQcm9taXNlLmZvbGxvdygpIG1ldGhvZCBidWlsdCB1cG9uIHRoZSBjdXN0b20gem9uZSBlbmdpbmUsIHRoYXQgYWxsb3dzIHVzZXIgdG8gdHJhY2sgYWxsIHByb21pc2VzIGNyZWF0ZWQgZnJvbSBjdXJyZW50IHN0YWNrIGZyYW1lXG4vLyAgIGFuZCBiZWxvdyArIGFsbCBwcm9taXNlcyB0aGF0IHRob3NlIHByb21pc2VzIGNyZWF0ZXMgb3IgYXdhaXRzLlxuLy8gKiBEZXRlY3QgYW55IHVuaGFuZGxlZCBwcm9taXNlIGluIGEgUFNELXNjb3BlIChQU0Qub251bmhhbmRsZWQpLiBcbi8vXG4vLyBEYXZpZCBGYWhsYW5kZXIsIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyXG4vL1xuXG4vLyBKdXN0IGEgcG9pbnRlciB0aGF0IG9ubHkgdGhpcyBtb2R1bGUga25vd3MgYWJvdXQuXG4vLyBVc2VkIGluIFByb21pc2UgY29uc3RydWN0b3IgdG8gZW11bGF0ZSBhIHByaXZhdGUgY29uc3RydWN0b3IuXG52YXIgSU5URVJOQUwgPSB7fTtcblxuY29uc3RcbiAgICBaT05FX0VDSE9fTElNSVQgPSAxMDAsXG4gICAgW3Jlc29sdmVkTmF0aXZlUHJvbWlzZSwgbmF0aXZlUHJvbWlzZVByb3RvLCByZXNvbHZlZEdsb2JhbFByb21pc2VdID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgW10gOlxuICAgICAgICAoKCk9PntcbiAgICAgICAgICAgIGxldCBnbG9iYWxQID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNyeXB0by5zdWJ0bGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtnbG9iYWxQLCBnZXRQcm90byhnbG9iYWxQKSwgZ2xvYmFsUF07XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5hdGl2ZSBwcm9taXNlIChhcyB3aW5kb3cuUHJvbWlzZSBtYXkgaGF2ZSBiZWVuIHBhdGNoZWQpXG4gICAgICAgICAgICBjb25zdCBuYXRpdmVQID0gY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtNTEyXCIsIG5ldyBVaW50OEFycmF5KFswXSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuYXRpdmVQLFxuICAgICAgICAgICAgICAgIGdldFByb3RvKG5hdGl2ZVApLFxuICAgICAgICAgICAgICAgIGdsb2JhbFBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKCksXG4gICAgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG5cbmV4cG9ydCBjb25zdCBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3RvcjtcbmNvbnN0IHBhdGNoR2xvYmFsUHJvbWlzZSA9ICEhcmVzb2x2ZWRHbG9iYWxQcm9taXNlO1xuXG4vKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB1c2VkIG9ubHkgZm9yIHRoZSB2ZXJ5IGZpcnN0IHByb21pc2UgaW4gYSBwcm9taXNlIGNoYWluLlxuICAgQXMgc29vbiBhcyB0aGVuIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQsIGFsbCBuZXh0IHRhc2tzIHdpbGwgYmUgZXhlY3V0ZWQgaW4gbWljcm8gdGlja3NcbiAgIGVtdWxhdGVkIGluIHRoaXMgbW9kdWxlLiBGb3IgaW5kZXhlZERCIGNvbXBhdGliaWxpdHksIHRoaXMgbWVhbnMgdGhhdCBldmVyeSBtZXRob2QgbmVlZHMgdG8gXG4gICBleGVjdXRlIGF0IGxlYXN0IG9uZSBwcm9taXNlIGJlZm9yZSBkb2luZyBhbiBpbmRleGVkREIgb3BlcmF0aW9uLiBEZXhpZSB3aWxsIGFsd2F5cyBjYWxsIFxuICAgZGIucmVhZHkoKS50aGVuKCkgZm9yIGV2ZXJ5IG9wZXJhdGlvbiB0byBtYWtlIHN1cmUgdGhlIGluZGV4ZWREQiBldmVudCBpcyBzdGFydGVkIGluIGFuXG4gICBpbmRleGVkREItY29tcGF0aWJsZSBlbXVsYXRlZCBtaWNybyB0YXNrIGxvb3AuXG4qL1xuZnVuY3Rpb24gc2NoZWR1bGVQaHlzaWNhbFRpY2soKSB7XG4gICAgcXVldWVNaWNyb3Rhc2socGh5c2ljYWxUaWNrKTtcbn1cblxuLy8gQ29uZmlndXJhYmxlIHRocm91Z2ggUHJvbWlzZS5zY2hlZHVsZXIuXG4vLyBEb24ndCBleHBvcnQgYmVjYXVzZSBpdCB3b3VsZCBiZSB1bnNhZmUgdG8gbGV0IHVua25vd25cbi8vIGNvZGUgY2FsbCBpdCB1bmxlc3MgdGhleSBkbyB0cnkuLmNhdGNoIHdpdGhpbiB0aGVpciBjYWxsYmFjay5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHJldHJpZXZlZCB0aHJvdWdoIGdldHRlciBvZiBQcm9taXNlLnNjaGVkdWxlciB0aG91Z2gsXG4vLyBidXQgdXNlcnMgbXVzdCBub3QgZG8gUHJvbWlzZS5zY2hlZHVsZXIgPSBteUZ1bmNUaGF0VGhyb3dzRXhjZXB0aW9uXG52YXIgYXNhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgfVxufTtcblxudmFyIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWUsIC8vIFRydWUgd2hlbiBOT1QgaW4gYSB2aXJ0dWFsIG1pY3JvVGljay5cbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWUsIC8vIFRydWUgd2hlbiBhIHB1c2ggdG8gbWljcm90aWNrUXVldWUgbXVzdCBhbHNvIHNjaGVkdWxlUGh5c2ljYWxUaWNrKClcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXSwgLy8gUmVqZWN0ZWQgcHJvbWlzZXMgdGhhdCBoYXMgb2NjdXJlZC4gVXNlZCBmb3IgdHJpZ2dlcmluZyAndW5oYW5kbGVkcmVqZWN0aW9uJy5cbiAgICByZWplY3RpbmdFcnJvcnMgPSBbXSwgLy8gVHJhY2tzIGlmIGVycm9ycyBhcmUgYmVpbmcgcmUtcmVqZWN0ZWQgZHVyaW5nIG9uUmVqZWN0ZWQgY2FsbGJhY2suXG4gICAgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yOyAvLyBSZW1vdmUgaW4gbmV4dCBtYWpvciB3aGVuIHJlbW92aW5nIGVycm9yIG1hcHBpbmcgb2YgRE9NRXJyb3JzIGFuZCBET01FeGNlcHRpb25zXG4gICAgXG5leHBvcnQgdmFyIGdsb2JhbFBTRCA9IHtcbiAgICBpZDogJ2dsb2JhbCcsXG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIHJlZjogMCxcbiAgICB1bmhhbmRsZWRzOiBbXSxcbiAgICBvbnVuaGFuZGxlZDogbm9wLFxuICAgIHBncDogZmFsc2UsXG4gICAgZW52OiB7fSxcbiAgICBmaW5hbGl6ZTogbm9wXG59O1xuXG5leHBvcnQgdmFyIFBTRCA9IGdsb2JhbFBTRDtcblxuZXhwb3J0IHZhciBtaWNyb3RpY2tRdWV1ZSA9IFtdOyAvLyBDYWxsYmFja3MgdG8gY2FsbCBpbiB0aGlzIG9yIG5leHQgcGh5c2ljYWwgdGljay5cbmV4cG9ydCB2YXIgbnVtU2NoZWR1bGVkQ2FsbHMgPSAwOyAvLyBOdW1iZXIgb2YgbGlzdGVuZXItY2FsbHMgbGVmdCB0byBkbyBpbiB0aGlzIHBoeXNpY2FsIHRpY2suXG5leHBvcnQgdmFyIHRpY2tGaW5hbGl6ZXJzID0gW107IC8vIEZpbmFsaXplcnMgdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGFzeW5jIGNhbGxzIHNjaGVkdWxlZCB3aXRoaW4gY3VycmVudCBwaHlzaWNhbCB0aWNrLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZXhpZVByb21pc2UoZm4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTsgICAgXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgXG4gICAgLy8gQSBsaWJyYXJ5IG1heSBzZXQgYHByb21pc2UuX2xpYiA9IHRydWU7YCBhZnRlciBwcm9taXNlIGlzIGNyZWF0ZWQgdG8gbWFrZSByZXNvbHZlKCkgb3IgcmVqZWN0KClcbiAgICAvLyBleGVjdXRlIHRoZSBtaWNyb3Rhc2sgZW5naW5lIGltcGxpY2l0ZWx5IHdpdGhpbiB0aGUgY2FsbCB0byByZXNvbHZlKCkgb3IgcmVqZWN0KCkuXG4gICAgLy8gVG8gcmVtYWluIEErIGNvbXBsaWFudCwgYSBsaWJyYXJ5IG11c3Qgb25seSBzZXQgYF9saWI9dHJ1ZWAgaWYgaXQgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSBzdGFja1xuICAgIC8vIG9ubHkgY29udGFpbnMgbGlicmFyeSBjb2RlIHdoZW4gY2FsbGluZyByZXNvbHZlKCkgb3IgcmVqZWN0KCkuXG4gICAgLy8gUlVMRSBPRiBUSFVNQjogT05MWSBzZXQgX2xpYiA9IHRydWUgZm9yIHByb21pc2VzIGV4cGxpY2l0ZWx5IHJlc29sdmluZy9yZWplY3RpbmcgZGlyZWN0bHkgZnJvbVxuICAgIC8vIGdsb2JhbCBzY29wZSAoZXZlbnQgaGFuZGxlciwgdGltZXIgZXRjKSFcbiAgICB0aGlzLl9saWIgPSBmYWxzZTtcbiAgICAvLyBDdXJyZW50IGFzeW5jIHNjb3BlXG4gICAgdmFyIHBzZCA9ICh0aGlzLl9QU0QgPSBQU0QpO1xuICAgIFxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvciAoSU5URVJOQUwsIHN0YXRlLCB2YWx1ZSkuXG4gICAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBieSBQcm9taXNlLnJlc29sdmUoKSBhbmQgUHJvbWlzZS5yZWplY3QoKS5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHRoaXMsIHRoaXMuX3ZhbHVlKTsgLy8gTWFwIGVycm9yLCBzZXQgc3RhY2sgYW5kIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IoKS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7IC8vIG51bGwgKD1wZW5kaW5nKSwgZmFsc2UgKD1yZWplY3RlZCkgb3IgdHJ1ZSAoPXJlc29sdmVkKVxuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDsgLy8gZXJyb3Igb3IgcmVzdWx0XG4gICAgKytwc2QucmVmOyAvLyBSZWZjb3VudGluZyBjdXJyZW50IHNjb3BlXG4gICAgZXhlY3V0ZVByb21pc2VUYXNrKHRoaXMsIGZuKTtcbn1cblxuLy8gUHJlcGFyZSBhIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcHV0IG9udG8gUHJvbWlzZS5wcm90b3R5cGUudGhlblxuY29uc3QgdGhlblByb3AgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcblxuICAgICAgICBmdW5jdGlvbiB0aGVuIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwc2QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnNvbGVUYXNrKSBydi5fY29uc29sZVRhc2sgPSB0aGlzLl9jb25zb2xlVGFzaztcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7IC8vIEZvciBpZGVtcG90ZW5zZSwgc2VlIHNldHRlciBiZWxvdy5cblxuICAgICAgICByZXR1cm4gdGhlbjtcbiAgICB9LFxuICAgIC8vIEJlIGlkZW1wb3RlbnQgYW5kIGFsbG93IGFub3RoZXIgZnJhbWV3b3JrIChzdWNoIGFzIHpvbmUuanMgb3IgYW5vdGhlciBpbnN0YW5jZSBvZiBhIERleGllLlByb21pc2UgbW9kdWxlKSB0byByZXBsYWNlIFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICAvLyBhbmQgd2hlbiB0aGF0IGZyYW1ld29yayB3YW50cyB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSwgd2UgbXVzdCBpZGVudGlmeSB0aGF0IGFuZCByZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHNldFByb3AgKHRoaXMsICd0aGVuJywgdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlID09PSBJTlRFUk5BTCA/XG4gICAgICAgICAgICB0aGVuUHJvcCA6IC8vIFJlc3RvcmUgdG8gb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gR2V0dGVyIHJldHVybmluZyBwcm92aWRlZCB2YWx1ZSAoYmVoYXZlcyBsaWtlIHZhbHVlIGlzIGp1c3QgY2hhbmdlZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0IC8vIEtlZXAgYSBzZXR0ZXIgdGhhdCBpcyBwcmVwYXJlZCB0byByZXN0b3JlIG9yaWdpbmFsLlxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbnByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICB0aGVuOiB0aGVuUHJvcCwgLy8gRGVmaW5lZCBhYm92ZS5cbiAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIEEgbGl0dGxlIHRpbmllciB2ZXJzaW9uIG9mIHRoZW4oKSB0aGF0IGRvbid0IGhhdmUgdG8gY3JlYXRlIGEgcmVzdWx0aW5nIHByb21pc2UuXG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTsgICAgICAgIFxuICAgIH0sXG5cbiAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIC8vIEZpcnN0IGFyZ3VtZW50IGlzIHRoZSBFcnJvciB0eXBlIHRvIGNhdGNoXG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIGJ5IGl0cyBjb25zdHJ1Y3RvciB0eXBlIChzaW1pbGFyIHRvIGphdmEgLyBjKysgLyBjIylcbiAgICAgICAgICAgIC8vIFNhbXBsZTogcHJvbWlzZS5jYXRjaChUeXBlRXJyb3IsIGZ1bmN0aW9uIChlKSB7IC4uLiB9KTtcbiAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpXG4gICAgICAgIDogdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIGJ5IHRoZSBlcnJvci5uYW1lIHByb3BlcnR5LiBNYWtlcyBzZW5zZSBmb3IgaW5kZXhlZERCIHdoZXJlIGVycm9yIHR5cGVcbiAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBET01FcnJvciBidXQgd2hlcmUgZS5uYW1lIHRlbGxzIHRoZSBhY3R1YWwgZXJyb3IgdHlwZS5cbiAgICAgICAgICAgIC8vIFNhbXBsZTogcHJvbWlzZS5jYXRjaCgnQ29uc3RyYWludEVycm9yJywgZnVuY3Rpb24gKGUpIHsgLi4uIH0pO1xuICAgICAgICAgICAgZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpKTtcbiAgICB9LFxuXG4gICAgZmluYWxseTogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbkZpbmFsbHkoKSkudGhlbigoKT0+dmFsdWUpO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKCgpPT5Qcm9taXNlUmVqZWN0KGVycikpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpLCBtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCkuZmluYWxseShjbGVhclRpbWVvdXQuYmluZChudWxsLCBoYW5kbGUpKTtcbiAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICB9XG59KTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICBzZXRQcm9wKERleGllUHJvbWlzZS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgJ0RleGllLlByb21pc2UnKTtcblxuLy8gTm93IHRoYXQgUHJvbWlzZS5wcm90b3R5cGUgaXMgZGVmaW5lZCwgd2UgaGF2ZSBhbGwgaXQgdGFrZXMgdG8gc2V0IGdsb2JhbFBTRC5lbnYuXG4vLyBFbnZpcm9ubWVudCBnbG9iYWxzIHNuYXBzaG90dGVkIG9uIGxlYXZpbmcgZ2xvYmFsIHpvbmVcbmdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuXG5mdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5wc2QgPSB6b25lO1xufVxuXG4vLyBQcm9taXNlIFN0YXRpYyBQcm9wZXJ0aWVzXG5wcm9wcyAoRGV4aWVQcm9taXNlLCB7XG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgLy8gU3VwcG9ydHMgaXRlcmFibGVzLCBpbXBsaWNpdCBhcmd1bWVudHMgYW5kIGFycmF5LWxpa2UuXG4gICAgICAgICAgICAubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7IC8vIEhhbmRsZSBwYXJhbGxlbGwgYXN5bmMvYXdhaXRzIFxuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKChhLGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKSByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICB9LCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICByZXNvbHZlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIFxuICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICBcbiAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5tYXAodmFsdWUgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBQU0Q6IHtcbiAgICAgICAgZ2V0OiAoKT0+UFNELFxuICAgICAgICBzZXQ6IHZhbHVlID0+IFBTRCA9IHZhbHVlXG4gICAgfSxcblxuICAgIHRvdGFsRWNob2VzOiB7Z2V0OiAoKT0+dG90YWxFY2hvZXN9LFxuXG4gICAgLy90YXNrOiB7Z2V0OiAoKT0+dGFza30sXG4gICAgXG4gICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICBcbiAgICB1c2VQU0Q6IHVzZVBTRCxcbiAgICBcbiAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBhc2FwLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHthc2FwID0gdmFsdWV9XG4gICAgfSxcbiAgICBcbiAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZWplY3Rpb25NYXBwZXIsXG4gICAgICAgIHNldDogdmFsdWUgPT4ge3JlamVjdGlvbk1hcHBlciA9IHZhbHVlO30gLy8gTWFwIHJlamVjdCBmYWlsdXJlc1xuICAgIH0sXG4gICAgICAgICAgICBcbiAgICBmb2xsb3c6IChmbiwgem9uZVByb3BzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29wZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHBzZCA9IFBTRDtcbiAgICAgICAgICAgICAgICBwc2QudW5oYW5kbGVkcyA9IFtdOyAvLyBGb3IgdW5oYW5kbGVkIHN0YW5kYXJkLSBvciAzcmQgcGFydHkgUHJvbWlzZXMuIENoZWNrZWQgYXQgcHNkLmZpbmFsaXplKClcbiAgICAgICAgICAgICAgICBwc2Qub251bmhhbmRsZWQgPSByZWplY3Q7IC8vIFRyaWdnZXJlZCBkaXJlY3RseSBvbiB1bmhhbmRsZWQgcHJvbWlzZXMgb2YgdGhpcyBsaWJyYXJ5LlxuICAgICAgICAgICAgICAgIHBzZC5maW5hbGl6ZSA9IGNhbGxCb3RoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5oYW5kbGVkIHN0YW5kYXJkIG9yIDNyZCBwYXJ0IHByb21pc2VzIGFyZSBwdXQgaW4gUFNELnVuaGFuZGxlZHMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4YW1pbmVkIHVwb24gc2NvcGUgY29tcGxldGlvbiB3aGlsZSB1bmhhbmRsZWQgcmVqZWN0aW9ucyBpbiB0aGlzIFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB0cmlnZ2VyIGRpcmVjdGx5IHRocm91Z2ggcHNkLm9udW5oYW5kbGVkXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QodGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuaWYgKE5hdGl2ZVByb21pc2UpIHtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbGxTZXR0bGVkKSBzZXRQcm9wIChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKFxuICAgICAgICAgICAgICAgIHZhbHVlID0+IHJlc3VsdHNbaV0gPSB7c3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZX0sXG4gICAgICAgICAgICAgICAgcmVhc29uID0+IHJlc3VsdHNbaV0gPSB7c3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbn0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCk9Pi0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cykpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKE5hdGl2ZVByb21pc2UuYW55ICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFueVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKSByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKFxuICAgICAgICAgICAgICAgIHZhbHVlID0+IHJlc29sdmUodmFsdWUpLFxuICAgICAgICAgICAgICAgIGZhaWx1cmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlc1tpXSA9IGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoZmFpbHVyZXMpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4qXG4qIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiovXG5mdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2sgKHByb21pc2UsIGZuKSB7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgIHRyeSB7XG4gICAgICAgIGZuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbCkgcmV0dXJuOyAvLyBBbHJlYWR5IHNldHRsZWRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihyZXNvbHZlLCByZWplY3QpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKSBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7IC8vIElmIEZ1bmN0aW9uLmJpbmQgaXMgbm90IHN1cHBvcnRlZC4gRXhjZXB0aW9uIGlzIGhhbmRsZWQgaW4gY2F0Y2ggYmVsb3dcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uIChwcm9taXNlLCByZWFzb24pIHtcbiAgICByZWplY3RpbmdFcnJvcnMucHVzaChyZWFzb24pO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcbiAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcbiAgICAvLyBBZGQgdGhlIGZhaWx1cmUgdG8gYSBsaXN0IG9mIHBvc3NpYmx5IHVuY2F1Z2h0IGVycm9yc1xuICAgIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSk7XG4gICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgIGlmIChzaG91bGRFeGVjdXRlVGljaykgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzIChwcm9taXNlKSB7XG4gICAgLy9kZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSk7XG4gICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcbiAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAtLXBzZC5yZWYgfHwgcHNkLmZpbmFsaXplKCk7IC8vIGlmIHBzZC5yZWYgcmVhY2hlcyB6ZXJvLCBjYWxsIHBzZC5maW5hbGl6ZSgpO1xuICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuICAgICAgICAvLyBJZiBudW1TY2hlZHVsZWRDYWxscyBpcyAwLCBpdCBtZWFucyB0aGF0IG91ciBzdGFjayBpcyBub3QgaW4gYSBjYWxsYmFjayBvZiBhIHNjaGVkdWxlZCBjYWxsLFxuICAgICAgICAvLyBhbmQgdGhhdCBubyBkZWZlcnJlZHMgd2hlcmUgbGlzdGVuaW5nIHRvIHRoaXMgcmVqZWN0aW9uIG9yIHN1Y2Nlc3MuXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIGEgcmlzayB0aGF0IG91ciBzdGFjayBjYW4gY29udGFpbiBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgbWF5XG4gICAgICAgIC8vIGRvIHN0dWZmIGFmdGVyIHRoaXMgY29kZSBpcyBmaW5pc2hlZCB0aGF0IG1heSBnZW5lcmF0ZSBuZXcgY2FsbHMsIHdlIGNhbm5vdFxuICAgICAgICAvLyBjYWxsIGZpbmFsaXplcnMgaGVyZS5cbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCgoKT0+e1xuICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7IC8vIFdpbGwgZGV0ZWN0IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSBwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLm9uRnVsZmlsbGVkIDogbGlzdGVuZXIub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBMaXN0ZW5lciBkb2VzbnQgaGF2ZSBhIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgYmVpbmcgdHJpZ2dlcmVkIChvbkZ1bGZpbGxlZCBvciBvblJlamVjdCkgc28gbGV0cyBmb3J3YXJkIHRoZSBldmVudCB0byBhbnkgZXZlbnR1YWwgbGlzdGVuZXJzIG9uIHRoZSBQcm9taXNlIGluc3RhbmNlIHJldHVybmVkIGJ5IHRoZW4oKSBvciBjYXRjaCgpXG4gICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KSAocHJvbWlzZS5fdmFsdWUpO1xuICAgIH1cbiAgICArK2xpc3RlbmVyLnBzZC5yZWY7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwIChjYWxsTGlzdGVuZXIsIFtjYiwgcHJvbWlzZSwgbGlzdGVuZXJdKTtcbn1cblxuZnVuY3Rpb24gY2FsbExpc3RlbmVyIChjYiwgcHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDYWxsIGNhbGxiYWNrIGFuZCByZXNvbHZlIG91ciBsaXN0ZW5lciB3aXRoIGl0J3MgcmV0dXJuIHZhbHVlLlxuICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICAgICAgXG4gICAgICAgIGlmICghcHJvbWlzZS5fc3RhdGUgJiYgcmVqZWN0aW5nRXJyb3JzLmxlbmd0aCkgcmVqZWN0aW5nRXJyb3JzID0gW107XG4gICAgICAgIC8vIGNiIGlzIG9uUmVzb2x2ZWRcbiAgICAgICAgcmV0ID0gZGVidWcgJiYgcHJvbWlzZS5fY29uc29sZVRhc2sgPyBwcm9taXNlLl9jb25zb2xlVGFzay5ydW4oKCk9PmNiICh2YWx1ZSkpIDogY2IgKHZhbHVlKTtcbiAgICAgICAgaWYgKCFwcm9taXNlLl9zdGF0ZSAmJiByZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSk7IC8vIENhbGxiYWNrIGRpZG50IGRvIFByb21pc2UucmVqZWN0KGVycikgbm9yIHJlamVjdChlcnIpIG9udG8gYW5vdGhlciBwcm9taXNlLlxuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyLnJlc29sdmUocmV0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gaW4gY2FsbGJhY2suIFJlamVjdCBvdXIgbGlzdGVuZXIuXG4gICAgICAgIGxpc3RlbmVyLnJlamVjdChlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMCkgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuICAgIH1cbn1cblxuLyogVGhlIGNhbGxiYWNrIHRvIHNjaGVkdWxlIHdpdGggcXVldWVNaWNyb3Rhc2soKS5cbiAgIEl0IHJ1bnMgYSB2aXJ0dWFsIG1pY3JvdGljayBhbmQgZXhlY3V0ZXMgYW55IGNhbGxiYWNrIHJlZ2lzdGVyZWQgaW4gbWljcm90aWNrUXVldWUuXG4gKi9cbmZ1bmN0aW9uIHBoeXNpY2FsVGljaygpIHtcbiAgICB1c2VQU0QoZ2xvYmFsUFNELCAoKT0+e1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVzZXQgdGhlIGFzeW5jIGNvbnRleHQgdG8gZ2xvYmFsUFNEIGJlZm9yZVxuICAgICAgICAvLyBleGVjdXRpbmcgYW55IG9mIHRoZSBtaWNyb3RpY2sgc3Vic2NyaWJlcnMuXG4gICAgICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG59XG5cbi8qIEV4ZWN1dGVzIG1pY3JvLXRpY2tzIHdpdGhvdXQgZG9pbmcgdHJ5Li5jYXRjaC5cbiAgIFRoaXMgY2FuIGJlIHBvc3NpYmxlIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBpbnRlcm5hbGx5IGFuZFxuICAgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGFyZSBleGNlcHRpb24tc2FmZSAodGhleSBkbyB0cnkuLmNhdGNoXG4gICBpbnRlcm5hbGx5IGJlZm9yZSBjYWxsaW5nIGFueSBleHRlcm5hbCBtZXRob2QpLiBJZiByZWdpc3RlcmluZ1xuICAgZnVuY3Rpb25zIGluIHRoZSBtaWNyb3RpY2tRdWV1ZSB0aGF0IGFyZSBub3QgZXhjZXB0aW9uLXNhZmUsIHRoaXNcbiAgIHdvdWxkIGRlc3Ryb3kgdGhlIGZyYW1ld29yayBhbmQgbWFrZSBpdCBpbnN0YWJsZS4gU28gd2UgZG9uJ3QgZXhwb3J0XG4gICBvdXIgYXNhcCBtZXRob2QuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZE1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciBjYWxsYmFja3MsIGksIGw7XG4gICAgZG8ge1xuICAgICAgICB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gbWljcm90aWNrUXVldWU7XG4gICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgaXRlbVswXS5hcHBseShudWxsLCBpdGVtWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApO1xuICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWU7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcbiAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgZmluYWxpemVycyA9IHRpY2tGaW5hbGl6ZXJzLnNsaWNlKDApOyAvLyBDbG9uZSBmaXJzdCBiZWNhdXNlIGZpbmFsaXplciBtYXkgcmVtb3ZlIGl0c2VsZiBmcm9tIGxpc3QuXG4gICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkgZmluYWxpemVyc1stLWldKCk7ICAgIFxufVxuXG5mdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrIChmbikge1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGlja0ZpbmFsaXplcnMuc3BsaWNlKHRpY2tGaW5hbGl6ZXJzLmluZGV4T2YoZmluYWxpemVyKSwgMSk7XG4gICAgfVxuICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoKCk9PntcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcbiAgICAvLyBPbmx5IGFkZCB0byB1bmhhbmRsZWRFcnJvcnMgaWYgbm90IGFscmVhZHkgdGhlcmUuIFRoZSBmaXJzdCBvbmUgdG8gYWRkIHRvIHRoaXMgbGlzdFxuICAgIC8vIHdpbGwgYmUgdXBvbiB0aGUgZmlyc3QgcmVqZWN0aW9uIHNvIHRoYXQgdGhlIHJvb3QgY2F1c2UgKGZpcnN0IHByb21pc2UgaW4gdGhlXG4gICAgLy8gcmVqZWN0aW9uIGNoYWluKSBpcyB0aGUgb25lIGxpc3RlZC5cbiAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKHAgPT4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgLy8gQ2FsbGVkIHdoZW4gYSByZWplY3QgaGFuZGxlZCBpcyBhY3R1YWxseSBiZWluZyBjYWxsZWQuXG4gICAgLy8gU2VhcmNoIGluIHVuaGFuZGxlZEVycm9ycyBmb3IgYW55IHByb21pc2Ugd2hvcyBfdmFsdWUgaXMgdGhpcyBwcm9taXNlX3ZhbHVlIChsaXN0XG4gICAgLy8gY29udGFpbnMgb25seSByZWplY3RlZCBwcm9taXNlcywgYW5kIG9ubHkgb25lIGl0ZW0gcGVyIGVycm9yKVxuICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgLy8gRm91bmQgYSBwcm9taXNlIHRoYXQgZmFpbGVkIHdpdGggdGhpcyBzYW1lIGVycm9yIG9iamVjdCBwb2ludGVyLFxuICAgICAgICAvLyBSZW1vdmUgdGhhdCBzaW5jZSB0aGVyZSBpcyBhIGxpc3RlbmVyIHRoYXQgYWN0dWFsbHkgdGFrZXMgY2FyZSBvZiBpdC5cbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZVJlamVjdCAocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcCAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksXG4gICAgICAgICAgICBvdXRlclNjb3BlID0gUFNEO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYykgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLy9cbi8vIHZhcmlhYmxlcyB1c2VkIGZvciBuYXRpdmUgYXdhaXQgc3VwcG9ydFxuLy9cbmNvbnN0IHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMH07IC8vIFRoZSBvbmdvaW5nIG1hY3JvLXRhc2sgd2hlbiB1c2luZyB6b25lLWVjaG9pbmcuXG52YXIgdGFza0NvdW50ZXIgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtYWNybyB0YXNrcy5cbnZhciB6b25lU3RhY2sgPSBbXTsgLy8gU3RhY2sgb2YgbGVmdCB6b25lcyB0byByZXN0b3JlIGFzeW5jaHJvbmljYWxseS5cbnZhciB6b25lRWNob2VzID0gMDsgLy8gV2hlbiA+IDAsIHpvbmVMZWF2ZUVjaG8gaXMgcXVldWVkLiBXaGVuIDAgYW5kIHRhc2suZWNob2VzIGlzIGFsc28gMCwgbm90aGluZyBpcyBxdWV1ZWQuXG52YXIgdG90YWxFY2hvZXMgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtaWNyby10YXNrcy4gVXNlZCB0byBkZXRlY3QgcG9zc2libGUgbmF0aXZlIGF3YWl0IGluIG91ciBQcm9taXNlLnByb3RvdHlwZS50aGVuLlxuXG5cbnZhciB6b25lX2lkX2NvdW50ZXIgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld1Njb3BlIChmbiwgcHJvcHMsIGExLCBhMikge1xuICAgIHZhciBwYXJlbnQgPSBQU0QsXG4gICAgICAgIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgIHBzZC5yZWYgPSAwO1xuICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcbiAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICAvLyBQcmVwYXJlIGZvciBwcm9taXNlIHBhdGNoaW5nIChkb25lIGluIHVzZVBTRCk6XG4gICAgdmFyIGdsb2JhbEVudiA9IGdsb2JhbFBTRC5lbnY7XG4gICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLCAvLyBDaGFuZ2luZyB3aW5kb3cuUHJvbWlzZSBjb3VsZCBiZSBvbWl0dGVkIGZvciBDaHJvbWUgYW5kIEVkZ2UsIHdoZXJlIElEQitQcm9taXNlIHBsYXlzIHdlbGwhXG4gICAgICAgIFByb21pc2VQcm9wOiB7dmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogRGV4aWVQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IERleGllUHJvbWlzZS5hbGxTZXR0bGVkLFxuICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG4gICAgICAgIHJlc29sdmU6IERleGllUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IERleGllUHJvbWlzZS5yZWplY3QsXG4gICAgfSA6IHt9O1xuICAgIGlmIChwcm9wcykgZXh0ZW5kKHBzZCwgcHJvcHMpO1xuICAgIFxuICAgIC8vIHVuaGFuZGxlZHMgYW5kIG9udW5oYW5kbGVkIHNob3VsZCBub3QgYmUgc3BlY2lmaWNhbGx5IHNldCBoZXJlLlxuICAgIC8vIExlYXZlIHRoZW0gb24gcGFyZW50IHByb3RvdHlwZS5cbiAgICAvLyB1bmhhbmRsZWRzLnB1c2goZXJyKSB3aWxsIHB1c2ggdG8gcGFyZW50J3MgcHJvdG90eXBlXG4gICAgLy8gb251bmhhbmRsZWQoKSB3aWxsIGNhbGwgcGFyZW50cyBvbnVuaGFuZGxlZCAod2l0aCB0aGlzIHNjb3BlJ3MgdGhpcy1wb2ludGVyIHRob3VnaCEpXG4gICAgKytwYXJlbnQucmVmO1xuICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICB9XG4gICAgdmFyIHJ2ID0gdXNlUFNEIChwc2QsIGZuLCBhMSwgYTIpO1xuICAgIGlmIChwc2QucmVmID09PSAwKSBwc2QuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcnY7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNhbGwgaWYgc2NvcGVGdW5jIHJldHVybnMgTmF0aXZlUHJvbWlzZVxuLy8gQWxzbyBmb3IgZWFjaCBOYXRpdmVQcm9taXNlIGluIHRoZSBhcmd1bWVudHMgdG8gUHJvbWlzZS5hbGwoKVxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuICAgIGlmICghdGFzay5pZCkgdGFzay5pZCA9ICsrdGFza0NvdW50ZXI7XG4gICAgKyt0YXNrLmF3YWl0cztcbiAgICB0YXNrLmVjaG9lcyArPSBaT05FX0VDSE9fTElNSVQ7XG4gICAgcmV0dXJuIHRhc2suaWQ7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiAndGhlbicgY2FsbHMgYmFjayBvbiBhIG5hdGl2ZSBwcm9taXNlIHdoZXJlIG9uQXdhaXRFeHBlY3RlZCgpIGhhZCBiZWVuIGNhbGxlZC5cbi8vIEFsc28gY2FsbCB0aGlzIHdoZW4gYSBuYXRpdmUgYXdhaXQgY2FsbHMgdGhlbiBtZXRob2Qgb24gYSBwcm9taXNlLiBJbiB0aGF0IGNhc2UsIGRvbid0IHN1cHBseVxuLy8gc291cmNlVGFza0lkIGJlY2F1c2Ugd2UgYWxyZWFkeSBrbm93IGl0IHJlZmVycyB0byBjdXJyZW50IHRhc2suXG5leHBvcnQgZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmF3YWl0cykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKSB0YXNrLmlkID0gMDtcbiAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzICogWk9ORV9FQ0hPX0xJTUlUOyAvLyBXaWxsIHJlc2V0IGVjaG9lcyB0byAwIGlmIGF3YWl0cyBpcyAwLlxuICAgIHJldHVybiB0cnVlO1xufVxuXG5pZiAoKCcnK25hdGl2ZVByb21pc2VUaGVuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7XG4gICAgLy8gSWYgdGhlIG5hdGl2ZSBwcm9taXNlJyBwcm90b3R5cGUgaXMgcGF0Y2hlZCwgd2UgY2Fubm90IHJlbHkgb24gem9uZSBlY2hvaW5nLlxuICAgIC8vIERpc2FibGUgdGhhdCBoZXJlOlxuICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBub3A7XG59XG5cbi8vIENhbGwgZnJvbSBQcm9taXNlLmFsbCgpIGFuZCBQcm9taXNlLnJhY2UoKVxuZXhwb3J0IGZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyAocG9zc2libGVQcm9taXNlKSB7XG4gICAgaWYgKHRhc2suZWNob2VzICYmIHBvc3NpYmxlUHJvbWlzZSAmJiBwb3NzaWJsZVByb21pc2UuY29uc3RydWN0b3IgPT09IE5hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTsgXG4gICAgICAgIHJldHVybiBwb3NzaWJsZVByb21pc2UudGhlbih4ID0+IHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuICAgICsrdG90YWxFY2hvZXM7XG4gICAgLy9jb25zb2xlLmxvZyhcIlRvdGFsIGVjaG9lcyBcIiwgdG90YWxFY2hvZXMpO1xuICAgIC8vaWYgKHRhc2suZWNob2VzID09PSAxKSBjb25zb2xlLndhcm4oXCJDYW5jZWxsaW5nIGVjaG9pbmcgb2YgYXN5bmMgY29udGV4dC5cIik7XG4gICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG4gICAgICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgPSB0YXNrLmlkID0gMDsgLy8gQ2FuY2VsIGVjaG9pbmcuXG4gICAgfVxuXG4gICAgem9uZVN0YWNrLnB1c2goUFNEKTtcbiAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHpvbmVMZWF2ZUVjaG8oKSB7XG4gICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aC0xXTtcbiAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoVG9ab25lICh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICAvLyBFbnRlciBvciBsZWF2ZSB6b25lIGFzeW5jaHJvbmljYWxseSBhcyB3ZWxsLCBzbyB0aGF0IHRhc2tzIGluaXRpYXRlZCBkdXJpbmcgY3VycmVudCB0aWNrXG4gICAgICAgIC8vIHdpbGwgYmUgc3Vycm91bmRlZCBieSB0aGUgem9uZSB3aGVuIHRoZXkgYXJlIGludm9rZWQuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRCkgcmV0dXJuO1xuXG4gICAgUFNEID0gdGFyZ2V0Wm9uZTsgLy8gVGhlIGFjdHVhbCB6b25lIHN3aXRjaCBvY2N1cnMgYXQgdGhpcyBsaW5lLlxuXG4gICAgLy8gU25hcHNob3Qgb24gZXZlcnkgbGVhdmUgZnJvbSBnbG9iYWwgem9uZS5cbiAgICBpZiAoY3VycmVudFpvbmUgPT09IGdsb2JhbFBTRCkgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5cbiAgICBpZiAocGF0Y2hHbG9iYWxQcm9taXNlKSB7XG4gICAgICAgIC8vIExldCdzIHBhdGNoIHRoZSBnbG9iYWwgYW5kIG5hdGl2ZSBQcm9taXNlcyAobWF5IGJlIHNhbWUgb3IgbWF5IGJlIGRpZmZlcmVudClcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIC8vIFN3aWNoIGVudmlyb25tZW50cyAobWF5IGJlIFBTRC16b25lIG9yIHRoZSBnbG9iYWwgem9uZS4gQm90aCBhcHBseS4pXG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcblxuICAgICAgICBpZiAoY3VycmVudFpvbmUuZ2xvYmFsIHx8IHRhcmdldFpvbmUuZ2xvYmFsKSB7XG4gICAgICAgICAgICAvLyBMZWF2aW5nIG9yIGVudGVyaW5nIGdsb2JhbCB6b25lLiBJdCdzIHRpbWUgdG8gcGF0Y2ggLyByZXN0b3JlIGdsb2JhbCBQcm9taXNlLlxuXG4gICAgICAgICAgICAvLyBTZXQgdGhpcyBQcm9taXNlIHRvIHdpbmRvdy5Qcm9taXNlIHNvIHRoYXQgdHJhbnNpbGVkIGFzeW5jIGZ1bmN0aW9ucyB3aWxsIHdvcmsgb24gRmlyZWZveCwgU2FmYXJpIGFuZCBJRSwgYXMgd2VsbCBhcyB3aXRoIFpvbmVqcyBhbmQgYW5ndWxhci5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZ2xvYmFsLCAnUHJvbWlzZScsIHRhcmdldEVudi5Qcm9taXNlUHJvcCk7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQgUHJvbWlzZS5hbGwoKSBldGMgdG8gd29yayBpbmRleGVkREItc2FmZSBhbHNvIHdoZW4gcGVvcGxlIGFyZSBpbmNsdWRpbmcgZXM2LXByb21pc2UgYXMgYSBtb2R1bGUgKHRoZXkgbWlnaHRcbiAgICAgICAgICAgIC8vIG5vdCBiZSBhY2Nlc3NpbmcgZ2xvYmFsLlByb21pc2UgYnV0IGEgbG9jYWwgcmVmZXJlbmNlIHRvIGl0KVxuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGwgPSB0YXJnZXRFbnYuYWxsO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlc29sdmUgPSB0YXJnZXRFbnYucmVzb2x2ZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVqZWN0ID0gdGFyZ2V0RW52LnJlamVjdDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYWxsU2V0dGxlZCkgR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkID0gdGFyZ2V0RW52LmFsbFNldHRsZWQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFueSkgR2xvYmFsUHJvbWlzZS5hbnkgPSB0YXJnZXRFbnYuYW55O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzbmFwU2hvdCAoKSB7XG4gICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgcmV0dXJuIHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogR2xvYmFsUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICBhbGw6IEdsb2JhbFByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBHbG9iYWxQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBHbG9iYWxQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogR2xvYmFsUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgIH0gOiB7fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBTRCAocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRlclpvbmUgPSBQU0Q7XG4gICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KSBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwKSBxdWV1ZU1pY3JvdGFzayhkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiogRXhlY3V0ZSBjYWxsYmFjayBpbiBnbG9iYWwgY29udGV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNJbkdsb2JhbENvbnRleHQoY2IpIHtcbiAgICBpZiAoUHJvbWlzZSA9PT0gTmF0aXZlUHJvbWlzZSAmJiB0YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICBpZiAoem9uZUVjaG9lcyA9PT0gMCkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soY2IpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgfVxufVxuXG5leHBvcnQgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbmV4cG9ydCB7RGV4aWVQcm9taXNlfTtcbiIsICJpbXBvcnQgeyBQU0QsIHJlamVjdGlvbiwgbmV3U2NvcGUgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBEZXhpZU9wdGlvbnMgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RleGllLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyBlcnJuYW1lcywgZXhjZXB0aW9ucyB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gXCIuL2NoYWluaW5nLWZ1bmN0aW9uc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vY2xhc3Nlcy90cmFuc2FjdGlvblwiO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9jbGFzc2VzL2RleGllJztcblxuLyogR2VuZXJhdGUgYSB0ZW1wb3JhcnkgdHJhbnNhY3Rpb24gd2hlbiBkYiBvcGVyYXRpb25zIGFyZSBkb25lIG91dHNpZGUgYSB0cmFuc2FjdGlvbiBzY29wZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uIChcbiAgZGI6IERleGllLFxuICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICBmbjogKHJlc29sdmUsIHJlamVjdCwgdHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBhbnkpXG4gIC8vIExhc3QgYXJndW1lbnQgaXMgXCJ3cml0ZUxvY2tlZFwiLiBCdXQgdGhpcyBkb2VzbnQgYXBwbHkgdG8gb25lc2hvdCBkaXJlY3QgZGIgb3BlcmF0aW9ucywgc28gd2UgaWdub3JlIGl0Llxue1xuICBpZiAoIWRiLmlkYmRiIHx8ICghZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSAmJiAoIVBTRC5sZXRUaHJvdWdoICYmICFkYi5fdmlwKSkpIHtcbiAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgLy8gZGIuaWRiZGIgaXMgZmFsc3kgYnV0IG9wZW5Db21wbGV0ZSBpcyB0cnVlLiBNdXN0IGhhdmUgYmVlbiBhbiBleGNlcHRpb24gZHVyaW4gb3Blbi5cbiAgICAgIC8vIERvbid0IHdhaXQgZm9yIG9wZW5Db21wbGV0ZSBhcyBpdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3AuXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgIH1cbiAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICBpZiAoIWRiLl9zdGF0ZS5hdXRvT3BlbilcbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgIH1cbiAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oKCkgPT4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgIHRyeSB7XG4gICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgIGRiLmNsb3NlKHtkaXNhYmxlQXV0b09wZW46IGZhbHNlfSk7XG4gICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKT0+dGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4geyAvLyBPUFRJTUlaQVRJT04gUE9TU0lCTEU/IG5ld1Njb3BlKCkgbm90IG5lZWRlZCBiZWNhdXNlIGl0J3MgYWxyZWFkeSBkb25lIGluIF9wcm9taXNlLlxuICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICAgICAgcmV0dXJuIGZuKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gSW5zdGVhZCBvZiByZXNvbHZpbmcgdmFsdWUgZGlyZWN0bHksIHdhaXQgd2l0aCByZXNvbHZpbmcgaXQgdW50aWwgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgIC8vIE90aGVyd2lzZSB0aGUgZGF0YSB3b3VsZCBub3QgYmUgaW4gdGhlIERCIGlmIHJlcXVlc3RpbmcgaXQgaW4gdGhlIHRoZW4oKSBvcGVyYXRpb24uXG4gICAgICAvLyBTcGVjaWZpY2FsbHksIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiB3aWxsIHdvcms6XG4gICAgICAvL1xuICAgICAgLy8gICBkYi5mcmllbmRzLnB1dCh7bmFtZTogXCJBcm5lXCJ9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgICAgIGRiLmZyaWVuZHMud2hlcmUoXCJuYW1lXCIpLmVxdWFscyhcIkFybmVcIikuY291bnQoZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIC8vICAgICAgICAgICBhc3NlcnQgKGNvdW50ID09PSAxKTtcbiAgICAgIC8vICAgICAgIH0pO1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vXG4gICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpIHRyeSB7dHJhbnMuaWRidHJhbnMuY29tbWl0KCk7fSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIG1vZGUgPT09ICdyZWFkb25seScgPyByZXN1bHQgOiB0cmFucy5fY29tcGxldGlvbi50aGVuKCgpID0+IHJlc3VsdCk7XG4gICAgfSk7LyouY2F0Y2goZXJyID0+IHsgLy8gRG9uJ3QgZG8gdGhpcyBhcyBvZiBub3cuIElmIHdvdWxkIGFmZmVjdCBidWxrLSBhbmQgbW9kaWZ5IG1ldGhvZHMgaW4gYSB3YXkgdGhhdCBjb3VsZCBiZSBtb3JlIGludHVpdGl2ZS4gQnV0IHdhaXQhIE1heWJlIGNoYW5nZSBpbiBuZXh0IG1ham9yLlxuICAgICAgICAgIHRyYW5zLl9yZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgICB9KTsqL1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tIFwiLi4vY2xhc3Nlcy9kZXhpZVwiO1xuXG5leHBvcnQgY29uc3QgREVYSUVfVkVSU0lPTiA9ICd7dmVyc2lvbn0nOyAvLyBSZXBsYWNlZCBieSBidWlsZC1zY3JpcHQuXG5leHBvcnQgY29uc3QgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG5leHBvcnQgY29uc3QgbWluS2V5ID0gLUluZmluaXR5OyAvLyBtaW5LZXkgY2FuIGJlIGNvbnN0YW50LiBtYXhLZXkgbXVzdCBiZSBhIHByb3Agb2YgRGV4aWUgKF9tYXhLZXkpXG5leHBvcnQgY29uc3QgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPVxuICBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbmV4cG9ydCBjb25zdCBTVFJJTkdfRVhQRUNURUQgPSBcIlN0cmluZyBleHBlY3RlZC5cIjtcbmV4cG9ydCBjb25zdCBjb25uZWN0aW9uczogRGV4aWVbXSA9IFtdO1xuZXhwb3J0IGNvbnN0IGRleGllU3RhY2tGcmFtZUZpbHRlciA9IGZyYW1lID0+ICEvKGRleGllXFwuanN8ZGV4aWVcXC5taW5cXC5qcykvLnRlc3QoZnJhbWUpO1xuZXhwb3J0IGNvbnN0IERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbmV4cG9ydCBjb25zdCBSRUFET05MWSA9ICdyZWFkb25seSc7XG5leHBvcnQgY29uc3QgUkVBRFdSSVRFID0gJ3JlYWR3cml0ZSc7XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICBmaWx0ZXIyID9cbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgIGZpbHRlcjI7XG59XG4iLCAiaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UsIERCQ29yZVJhbmdlVHlwZSB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuXG5leHBvcnQgY29uc3QgQW55UmFuZ2U6IERCQ29yZUtleVJhbmdlID0ge1xuICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuQW55LFxuICBsb3dlcjogLUluZmluaXR5LFxuICBsb3dlck9wZW46IGZhbHNlLFxuICB1cHBlcjogW1tdXSxcbiAgdXBwZXJPcGVuOiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgTmV2ZXJSYW5nZTogREJDb3JlS2V5UmFuZ2UgPSB7XG4gIHR5cGU6IERCQ29yZVJhbmdlVHlwZS5OZXZlcixcbiAgbG93ZXI6IC1JbmZpbml0eSxcbiAgbG93ZXJPcGVuOiB0cnVlLFxuICB1cHBlcjogLUluZmluaXR5LFxuICB1cHBlck9wZW46IHRydWVcbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUsIGRlbEJ5S2V5UGF0aCwgZ2V0QnlLZXlQYXRoIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBuZWVkZWQgc2luY2Ugb2JqIGNvdWxkIGJlIGEgY3VzdG9tLWNsYXNzIGluc3RhbmNlIHdpdGggYW5cbi8vIHVuaW5pdGlhbGl6ZWQga2V5UGF0aC4gU2VlIHRoZSBmb2xsb3dpbmcgY29tbWVudCBmb3IgbW9yZSBjb250ZXh0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzEyODAjaXNzdWVjb21tZW50LTgyMzU1Nzg4MVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGg6IHN0cmluZyB8IEFycmF5TGlrZTxzdHJpbmc+KSB7XG4gIC8vIFdvcmthcm91bmQgb25seSBuZWVkZWQgZm9yIHBsYWluIG5vbi1kb3R0ZWQga2V5UGF0aHNcbiAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSBcInN0cmluZ1wiICYmICEvXFwuLy50ZXN0KGtleVBhdGgpIFxuICA/IChvYmo6IG9iamVjdCkgPT4ge1xuICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG4gICAgICAvLyBwcm9wZXJ0eSBleGlzdHMgYnV0IGlzIHVuZGVmaW5lZC4gVGhpcyB3aWxsIG5vdCBiZSBsaWtlZCBieSBJbmRleGVkZGIuXG4gICAgICAvLyBOZWVkIHRvIHJlbW92ZSB0aGUgcHJvcGVydHkgYmVmb3JlIGFkZGluZyBpdCBidXQgd2UgbmVlZCB0byBjbG9uZSBpdCBiZWZvcmVcbiAgICAgIC8vIGRvaW5nIHRoYXQgdG8gbm90IGJlIGludHJ1c2l2ZS5cbiAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICA6IChvYmo6IG9iamVjdCkgPT4gb2JqO1xufSIsICJpbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSBcIi4uLy4uL2Vycm9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gRW50aXR5KCl7XG4gIHRocm93IGV4Y2VwdGlvbnMuVHlwZSgpO1xufVxuIiwgIi8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREItMy8jY29tcGFyZS10d28ta2V5c1xuXG5pbXBvcnQgeyB0b1N0cmluZ1RhZyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyAuLi4gd2l0aCB0aGUgYWRqdXN0bWVudCB0byByZXR1cm4gTmFOIGluc3RlYWQgb2YgdGhyb3dpbmcuXG5leHBvcnQgZnVuY3Rpb24gY21wKGE6IGFueSwgYjogYW55KTogbnVtYmVyIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YSA9IHR5cGUoYSk7XG4gICAgY29uc3QgdGIgPSB0eXBlKGIpO1xuICAgIGlmICh0YSAhPT0gdGIpIHtcbiAgICAgIGlmICh0YSA9PT0gJ0FycmF5JykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgPT09ICdBcnJheScpIHJldHVybiAtMTtcbiAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpIHJldHVybiAxO1xuICAgICAgaWYgKHRiID09PSAnYmluYXJ5JykgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRhID09PSAnc3RyaW5nJykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgPT09ICdzdHJpbmcnKSByZXR1cm4gLTE7XG4gICAgICBpZiAodGEgPT09ICdEYXRlJykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgIT09ICdEYXRlJykgcmV0dXJuIE5hTjtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgc3dpdGNoICh0YSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXlzKGdldFVpbnQ4QXJyYXkoYSksIGdldFVpbnQ4QXJyYXkoYikpO1xuICAgICAgfVxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhhLCBiKTtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIE5hTjsgLy8gUmV0dXJuIHZhbHVlIGlmIGFueSBnaXZlbiBhcmdzIGFyZSB2YWxpZCBrZXlzLlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhOiBhbnlbXSwgYjogYW55W10pOiBudW1iZXIge1xuICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuICAgIGlmIChyZXMgIT09IDApIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKFxuICBhOiBVaW50OEFycmF5LFxuICBiOiBVaW50OEFycmF5XG4pIHtcbiAgY29uc3QgYWwgPSBhLmxlbmd0aDtcbiAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgY29uc3QgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XG4gIH1cbiAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuXG4vLyBJbXBsZW1lbnRhdGlvbiBvZiBodHRwczovL3d3dy53My5vcmcvVFIvSW5kZXhlZERCLTMvI2tleS10eXBlXG5mdW5jdGlvbiB0eXBlKHg6IGFueSkge1xuICBjb25zdCB0ID0gdHlwZW9mIHg7XG4gIGlmICh0ICE9PSAnb2JqZWN0JykgcmV0dXJuIHQ7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpIHJldHVybiAnYmluYXJ5JztcbiAgY29uc3QgdHNUYWcgPSB0b1N0cmluZ1RhZyh4KTsgLy8gQ2Fubm90IHVzZSBpbnN0YW5jZW9mIGluIFNhZmFyaVxuICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6ICh0c1RhZyBhcyAnQXJyYXknIHwgJ0RhdGUnKTtcbn1cblxudHlwZSBCaW5hcnlUeXBlID1cbiAgfCBBcnJheUJ1ZmZlclxuICB8IERhdGFWaWV3XG4gIHwgVWludDhDbGFtcGVkQXJyYXlcbiAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgfCBVaW50OEFycmF5XG4gIHwgSW50OEFycmF5XG4gIHwgVWludDE2QXJyYXlcbiAgfCBJbnQxNkFycmF5XG4gIHwgVWludDMyQXJyYXlcbiAgfCBJbnQzMkFycmF5XG4gIHwgRmxvYXQzMkFycmF5XG4gIHwgRmxvYXQ2NEFycmF5XG4gIHwgQmlnSW50NjRBcnJheSBcbiAgfCBCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gZ2V0VWludDhBcnJheShhOiBCaW5hcnlUeXBlKTogVWludDhBcnJheSB7XG4gIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpXG4gICAgLy8gVHlwZWRBcnJheSBvciBEYXRhVmlld1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSk7IC8vIEFycmF5QnVmZmVyXG59XG4iLCAiaW1wb3J0IHsgQnVsa0Vycm9yLCBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IFRhYmxlIGFzIElUYWJsZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZSc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWEnO1xuaW1wb3J0IHsgVGFibGVIb29rcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1ob29rcyc7XG5pbXBvcnQgeyBEZXhpZVByb21pc2UgYXMgUHJvbWlzZSwgUFNELCBuZXdTY29wZSwgcmVqZWN0aW9uLCBiZWdpbk1pY3JvVGlja1Njb3BlLCBlbmRNaWNyb1RpY2tTY29wZSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgdGVtcFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3RlbXAtdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgaXNBcnJheSwga2V5cywgZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGgsIGV4dGVuZCwgZ2V0UHJvdG8gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgbWF4U3RyaW5nIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tYmluZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lJztcbmltcG9ydCB7IFByb21pc2VFeHRlbmRlZCB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvcHJvbWlzZS1leHRlbmRlZFwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgREJDb3JlVGFibGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IEFueVJhbmdlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2tleXJhbmdlJztcbmltcG9ydCB7IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3dvcmthcm91bmQtdW5kZWZpbmVkLXByaW1rZXknO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi4vZW50aXR5L0VudGl0eSc7XG5pbXBvcnQgeyBVcGRhdGVTcGVjIH0gZnJvbSAnLi4vLi4vcHVibGljJztcbmltcG9ydCB7IGNtcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jbXAnO1xuXG4vKiogY2xhc3MgVGFibGVcbiAqIFxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZVxuICovXG5leHBvcnQgY2xhc3MgVGFibGUgaW1wbGVtZW50cyBJVGFibGU8YW55LCBJbmRleGFibGVUeXBlPiB7XG4gIGRiOiBEZXhpZTtcbiAgX3R4PzogVHJhbnNhY3Rpb247XG4gIG5hbWU6IHN0cmluZztcbiAgc2NoZW1hOiBUYWJsZVNjaGVtYTtcbiAgaG9vazogVGFibGVIb29rcztcbiAgY29yZTogREJDb3JlVGFibGU7XG5cbiAgX3RyYW5zKFxuICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICBmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkLFxuICAgIHdyaXRlTG9ja2VkPzogYm9vbGVhbiB8IHN0cmluZykgOiBQcm9taXNlRXh0ZW5kZWQ8YW55PlxuICB7XG4gICAgY29uc3QgdHJhbnM6IFRyYW5zYWN0aW9uID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcbiAgICAvLyBAdHMtaWdub3JlOiBVc2UgQ2hyb21lJ3MgQXN5bmMgU3RhY2sgVGFnZ2luZyBBUEkgdG8gYWxsb3cgdHJhY2luZyBhbmQgc2ltcGxpZnkgZGVidWdnaW5nIGZvciBkZXhpZSB1c2Vycy5cbiAgICBjb25zdCB0YXNrID0gZGVidWcgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuY3JlYXRlVGFzayAmJiBjb25zb2xlLmNyZWF0ZVRhc2soYERleGllOiAke21vZGUgPT09ICdyZWFkb25seScgPyAncmVhZCcgOiAnd3JpdGUnIH0gJHt0aGlzLm5hbWV9YCk7XG4gICAgXG4gICAgZnVuY3Rpb24gY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCB0cmFuczogVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdHJhbnMuc2NoZW1hW3RhYmxlTmFtZV0pXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpIGFzIFByb21pc2U8YW55PjtcbiAgICB9XG4gICAgLy8gU3Vycm91bmQgYWxsIGluIGEgbWljcm90aWNrIHNjb3BlLlxuICAgIC8vIFJlYXNvbjogQnJvd3NlcnMgKG1vZGVybiBTYWZhcmkgKyBvbGRlciBvdGhlcnMpXG4gICAgLy8gc3RpbGwgYXMgb2YgMjAxOC0xMC0xMCBoYXMgcHJvYmxlbXMga2VlcGluZyBhIHRyYW5zYWN0aW9uXG4gICAgLy8gYWxpdmUgYmV0d2VlbiBtaWNybyB0aWNrcy4gU2FmYXJpIGJlY2F1c2UgaWYgdHJhbnNhY3Rpb25cbiAgICAvLyBpcyBjcmVhdGVkIGJ1dCBub3QgdXNlZCBpbiBzYW1lIG1pY3JvdGljaywgaXQgd2lsbCBnb1xuICAgIC8vIGF3YXkuIFRoYXQgc3BlY2lmaWMgaXNzdWUgY291bGQgYmUgc29sdmVkIGluIERCQ29yZVxuICAgIC8vIGJ5IG9wZW5pbmcgdGhlIHRyYW5zYWN0aW9uIGp1c3QgYmVmb3JlIHVzaW5nIGl0IGluc3RlYWQuXG4gICAgLy8gQnV0IG9sZGVyIEZpcmVmb3hlcyBhbmQgSUUxMSAod2l0aCBQcm9taXNlIHBvbHlmaWxscylcbiAgICAvLyB3aWxsIHN0aWxsIGhhdmUgcHJvYnMuXG4gICAgLy8gVGhlIGJlZ2luTWljcm90aWNrU2NvcGUoKS9lbmRNaWNyb3RpY2tTY29wZSgpIHdvcmtzXG4gICAgLy8gaW4gY29vcGVyYXRpb24gd2l0aCBEZXhpZS5Qcm9taXNlIHRvIG9yY2hlc3RyYXRlXG4gICAgLy8gdGhlIG1pY3JvLXRpY2tzIGluIGVuZE1pY3JvdGlja1Njb3BlKCkgcmF0aGVyIHRoYW5cbiAgICAvLyBpbiBuYXRpdmUgZW5naW5lLlxuICAgIGNvbnN0IHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgcCA9IHRyYW5zICYmIHRyYW5zLmRiLl9ub3ZpcCA9PT0gdGhpcy5kYi5fbm92aXAgP1xuICAgICAgICB0cmFucyA9PT0gUFNELnRyYW5zID9cbiAgICAgICAgICB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpIDpcbiAgICAgICAgICBuZXdTY29wZSgoKSA9PiB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpLCB7IHRyYW5zOiB0cmFucywgdHJhbnNsZXNzOiBQU0QudHJhbnNsZXNzIHx8IFBTRCB9KSA6XG4gICAgICAgIHRlbXBUcmFuc2FjdGlvbih0aGlzLmRiLCBtb2RlLCBbdGhpcy5uYW1lXSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24pO1xuICAgICAgaWYgKHRhc2spIHsgLy8gRGV4aWUuZGVidWcgPSB0cnVlIHNvIHdlIHRyYWNlIGVycm9yc1xuICAgICAgICBwLl9jb25zb2xlVGFzayA9IHRhc2s7XG4gICAgICAgIHAgPSBwLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDsgIFxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAod2FzUm9vdEV4ZWMpIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRhYmxlLmdldCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmdldCgpXG4gICAqIFxuICAgKiovXG4gIGdldChrZXlPckNyaXQsIGNiPykge1xuICAgIGlmIChrZXlPckNyaXQgJiYga2V5T3JDcml0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG4gICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQgYXMgeyBba2V5OiBzdHJpbmddOiBJbmRleGFibGVUeXBlIH0pLmZpcnN0KGNiKTtcbiAgICBpZiAoa2V5T3JDcml0ID09IG51bGwpIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHlwZShgSW52YWxpZCBhcmd1bWVudCB0byBUYWJsZS5nZXQoKWApKTtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCAodHJhbnMpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0KHt0cmFucywga2V5OiBrZXlPckNyaXR9KVxuICAgICAgICAudGhlbihyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKTtcbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS53aGVyZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLndoZXJlKClcbiAgICogXG4gICAqKi9cbiAgd2hlcmUoaW5kZXhPckNyaXQ6IHN0cmluZyB8IHN0cmluZ1tdIHwgeyBba2V5OiBzdHJpbmddOiBJbmRleGFibGVUeXBlIH0pIHtcbiAgICBpZiAodHlwZW9mIGluZGV4T3JDcml0ID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpbmRleE9yQ3JpdCk7XG4gICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGBbJHtpbmRleE9yQ3JpdC5qb2luKCcrJyl9XWApO1xuICAgIC8vIGluZGV4T3JDcml0IGlzIGFuIG9iamVjdCBtYXAgb2Yge1trZXlQYXRoXTp2YWx1ZX0gXG4gICAgY29uc3Qga2V5UGF0aHMgPSBrZXlzKGluZGV4T3JDcml0KTtcbiAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgLy8gT25seSBvbmUgY3JpdGVyYS4gVGhpcyB3YXMgdGhlIGVhc3kgY2FzZTpcbiAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIC53aGVyZShrZXlQYXRoc1swXSlcbiAgICAgICAgLmVxdWFscyhpbmRleE9yQ3JpdFtrZXlQYXRoc1swXV0pO1xuXG4gICAgLy8gTXVsdGlwbGUgY3JpdGVyaWFzLlxuICAgIC8vIExldCdzIHRyeSBmaW5kaW5nIGEgY29tcG91bmQgaW5kZXggdGhhdCBtYXRjaGVzIGFsbCBrZXlQYXRocyBpblxuICAgIC8vIGFyYnJpdGFyeSBvcmRlcjpcbiAgICBjb25zdCBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGl4ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgaXguY29tcG91bmQgJiZcbiAgICAgICAga2V5UGF0aHMuZXZlcnkoa2V5UGF0aCA9PiBpeC5rZXlQYXRoLmluZGV4T2Yoa2V5UGF0aCkgPj0gMCkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8a2V5UGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChrZXlQYXRocy5pbmRleE9mKGl4LmtleVBhdGhbaV0pID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KS5zb3J0KChhLGIpID0+IGEua2V5UGF0aC5sZW5ndGggLSBiLmtleVBhdGgubGVuZ3RoKVswXTtcbiAgICAgICAgICAgIFxuICAgIGlmIChjb21wb3VuZEluZGV4ICYmIHRoaXMuZGIuX21heEtleSAhPT0gbWF4U3RyaW5nKSB7XG4gICAgICAvLyBDb29sISBXZSBmb3VuZCBzdWNoIGNvbXBvdW5kIGluZGV4XG4gICAgICAvLyBhbmQgdGhpcyBicm93c2VyIHN1cHBvcnRzIGNvbXBvdW5kIGluZGV4ZXMgKG1heEtleSAhPT0gbWF4U3RyaW5nKSFcbiAgICAgIGNvbnN0IGtleVBhdGhzSW5WYWxpZE9yZGVyID0gKGNvbXBvdW5kSW5kZXgua2V5UGF0aCBhcyBzdHJpbmdbXSkuc2xpY2UoMCwga2V5UGF0aHMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIC53aGVyZShrZXlQYXRoc0luVmFsaWRPcmRlcilcbiAgICAgICAgLmVxdWFscyhrZXlQYXRoc0luVmFsaWRPcmRlci5tYXAoa3AgPT4gaW5kZXhPckNyaXRba3BdKSk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21wb3VuZEluZGV4ICYmIGRlYnVnKSBjb25zb2xlLndhcm4oXG4gICAgICBgVGhlIHF1ZXJ5ICR7SlNPTi5zdHJpbmdpZnkoaW5kZXhPckNyaXQpfSBvbiAke3RoaXMubmFtZX0gd291bGQgYmVuZWZpdCBmcm9tIGEgYCArXG4gICAgICBgY29tcG91bmQgaW5kZXggWyR7a2V5UGF0aHMuam9pbignKycpfV1gKTtcblxuICAgIC8vIE9rLCBub3cgbGV0J3MgZmFsbGJhY2sgdG8gZmluZGluZyBhdCBsZWFzdCBvbmUgbWF0Y2hpbmcgaW5kZXhcbiAgICAvLyBhbmQgZmlsdGVyIHRoZSByZXN0LlxuICAgIGNvbnN0IHsgaWR4QnlOYW1lIH0gPSB0aGlzLnNjaGVtYTtcbiAgICBjb25zdCBpZGIgPSB0aGlzLmRiLl9kZXBzLmluZGV4ZWREQjtcblxuICAgIGZ1bmN0aW9uIGVxdWFscyAoYSwgYikge1xuICAgICAgcmV0dXJuIGlkYi5jbXAoYSxiKSA9PT0gMDsgLy8gV29ya3Mgd2l0aCBhbGwgaW5kZXhhYmxlIHR5cGVzIGluY2x1ZGluZyBiaW5hcnkga2V5cy5cbiAgICB9XG5cbiAgICBjb25zdCBbaWR4LCBmaWx0ZXJGdW5jdGlvbl0gPSBrZXlQYXRocy5yZWR1Y2UoKFtwcmV2SW5kZXgsIHByZXZGaWx0ZXJGbl0sIGtleVBhdGgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaWR4QnlOYW1lW2tleVBhdGhdO1xuICAgICAgY29uc3QgdmFsdWUgPSBpbmRleE9yQ3JpdFtrZXlQYXRoXTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHByZXZJbmRleCB8fCBpbmRleCwgLy8gaWR4Ojo9UGljayBpbmRleCBvZiBmaXJzdCBtYXRjaGluZyBrZXlwYXRoXG4gICAgICAgIHByZXZJbmRleCB8fCAhaW5kZXggPyAvLyBmaWx0ZXI6Oj1udWxsIGlmIG5vdCBuZWVkZWQsIG90aGVyd2lzZSBjb21iaW5lIGZ1bmN0aW9uIGZpbHRlclxuICAgICAgICAgIGNvbWJpbmUoXG4gICAgICAgICAgICBwcmV2RmlsdGVyRm4sXG4gICAgICAgICAgICBpbmRleCAmJiBpbmRleC5tdWx0aSA/XG4gICAgICAgICAgICAgIHggPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkocHJvcCkgJiYgcHJvcC5zb21lKGl0ZW0gPT4gZXF1YWxzKHZhbHVlLCBpdGVtKSk7XG4gICAgICAgICAgICAgIH0gOiB4ID0+IGVxdWFscyh2YWx1ZSwgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpKSlcbiAgICAgICAgICA6IHByZXZGaWx0ZXJGblxuICAgICAgXTtcbiAgICB9LCBbbnVsbCwgbnVsbF0pO1xuXG4gICAgcmV0dXJuIGlkeCA/XG4gICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuICAgICAgICAuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG4gICAgICBjb21wb3VuZEluZGV4ID9cbiAgICAgICAgdGhpcy5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDogLy8gSGFzIGNvbXBvdW5kIGJ1dCBicm93c2VyIGJhZC4gQWxsb3cgZmlsdGVyLlxuICAgICAgICB0aGlzLndoZXJlKGtleVBhdGhzKS5lcXVhbHMoJycpOyAvLyBObyBpbmRleCBhdCBhbGwuIEZhaWwgbGF6aWx5IHdpdGggXCJbYStiK2NdIGlzIG5vdCBpbmRleGVkXCJcbiAgfVxuXG4gIC8qKiBUYWJsZS5maWx0ZXIoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5maWx0ZXIoKVxuICAgKiBcbiAgICoqL1xuICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb246IChvYmo6IGFueSkgPT4gYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmFuZChmaWx0ZXJGdW5jdGlvbik7XG4gIH1cblxuICAvKiogVGFibGUuY291bnQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5jb3VudCgpXG4gICAqIFxuICAgKiovXG4gIGNvdW50KHRoZW5TaG9ydGN1dD86IGFueSkge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmNvdW50KHRoZW5TaG9ydGN1dCk7XG4gIH1cblxuICAvKiogVGFibGUub2Zmc2V0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUub2Zmc2V0KClcbiAgICogXG4gICAqKi9cbiAgb2Zmc2V0KG9mZnNldDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkub2Zmc2V0KG9mZnNldCk7XG4gIH1cblxuICAvKiogVGFibGUubGltaXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5saW1pdCgpXG4gICAqIFxuICAgKiovXG4gIGxpbWl0KG51bVJvd3M6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmxpbWl0KG51bVJvd3MpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmVhY2goKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5lYWNoKClcbiAgICogXG4gICAqKi9cbiAgZWFjaChjYWxsYmFjazogKG9iajogYW55LCBjdXJzb3I6IHsga2V5OiBJbmRleGFibGVUeXBlLCBwcmltYXJ5S2V5OiBJbmRleGFibGVUeXBlIH0pID0+IGFueSkge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqIFRhYmxlLnRvQXJyYXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS50b0FycmF5KClcbiAgICogXG4gICAqKi9cbiAgdG9BcnJheSh0aGVuU2hvcnRjdXQ/OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS50b0FycmF5KHRoZW5TaG9ydGN1dCk7XG4gIH1cblxuICAvKiogVGFibGUudG9Db2xsZWN0aW9uKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUudG9Db2xsZWN0aW9uKClcbiAgICogXG4gICAqKi9cbiAgdG9Db2xsZWN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMpKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5vcmRlckJ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUub3JkZXJCeSgpXG4gICAqIFxuICAgKiovXG4gIG9yZGVyQnkoaW5kZXg6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24oXG4gICAgICBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpc0FycmF5KGluZGV4KSA/XG4gICAgICAgIGBbJHtpbmRleC5qb2luKCcrJyl9XWAgOlxuICAgICAgICBpbmRleCkpO1xuICB9XG5cbiAgLyoqIFRhYmxlLnJldmVyc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5yZXZlcnNlKClcbiAgICogXG4gICAqKi9cbiAgcmV2ZXJzZSgpOiBDb2xsZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG4gIH1cblxuICAvKiogVGFibGUubWFwVG9DbGFzcygpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLm1hcFRvQ2xhc3MoKVxuICAgKiBcbiAgICoqL1xuICBtYXBUb0NsYXNzKGNvbnN0cnVjdG9yOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IHtkYiwgbmFtZTogdGFibGVOYW1lfSA9IHRoaXM7XG4gICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcbiAgICBpZiAoY29uc3RydWN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRW50aXR5KSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IGNsYXNzIGV4dGVuZHMgKGNvbnN0cnVjdG9yIGFzIGFueSkge1xuICAgICAgICBnZXQgZGIgKCkgeyByZXR1cm4gZGI7IH1cbiAgICAgICAgdGFibGUoKSB7IHJldHVybiB0YWJsZU5hbWU7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29sbGVjdCBhbGwgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzIChpbmNsdWRpbmcgbWV0aG9kIG5hbWVzKSBieVxuICAgIC8vIHdhbGtpbmcgdGhlIHByb3RvdHlwZSBjaGFpbi4gVGhpcyBpcyB0byBhdm9pZCBvdmVyd3JpdGluZyB0aGVtIGZyb21cbiAgICAvLyBkYXRhYmFzZSBkYXRhIC0gc28gYXBwbGljYXRpb24gY29kZSBjYW4gcmVseSBvbiBpbmhlcml0ZWQgcHJvcHMgbmV2ZXJcbiAgICAvLyBiZWNvbWluZyBzaGFkb3dlZCBieSBkYXRhYmFzZSBvYmplY3QgcHJvcHMuXG4gICAgY29uc3QgaW5oZXJpdGVkUHJvcHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGxldCBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTsgcHJvdG87IHByb3RvID0gZ2V0UHJvdG8ocHJvdG8pKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChwcm9wTmFtZSA9PiBpbmhlcml0ZWRQcm9wcy5hZGQocHJvcE5hbWUpKTtcbiAgICB9XG4gIFxuICAgIC8vIE5vdywgc3Vic2NyaWJlIHRvIHRoZSB3aGVuKFwicmVhZGluZ1wiKSBldmVudCB0byBtYWtlIGFsbCBvYmplY3RzIHRoYXQgY29tZSBvdXQgZnJvbSB0aGlzIHRhYmxlIGluaGVyaXQgZnJvbSBnaXZlbiBjbGFzc1xuICAgIC8vIG5vIG1hdHRlciB3aGljaCBtZXRob2QgdG8gdXNlIGZvciByZWFkaW5nIChUYWJsZS5nZXQoKSBvciBUYWJsZS53aGVyZSguLi4pLi4uIClcbiAgICBjb25zdCByZWFkSG9vayA9IChvYmo6IE9iamVjdCkgPT4ge1xuICAgICAgaWYgKCFvYmopIHJldHVybiBvYmo7IC8vIE5vIHZhbGlkIG9iamVjdC4gKFZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkKS4gUmV0dXJuIGFzIGlzLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0aGF0IGRlcml2ZXMgZnJvbSBjb25zdHJ1Y3RvcjpcbiAgICAgIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUoY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgIC8vIENsb25lIG1lbWJlcnMgKGJ1dCBuZXZlciB0aG9zZSB0aGF0IGNvbGxpZGUgd2l0aCBhIHByb3BlcnR5IGluIHRoZSBwcm90b3R5cGVcbiAgICAgIC8vIGhpZXJjaGFyeSAoTVVTVCBCRSBBQkxFIFRPIFJFTFkgT04gRW50aXR5IG1ldGhvZHMgYW5kIHByb3BzISkpOlxuICAgICAgZm9yIChsZXQgbSBpbiBvYmopIGlmICghaW5oZXJpdGVkUHJvcHMuaGFzKG0pKSB0cnkgeyByZXNbbV0gPSBvYmpbbV07IH0gY2F0Y2ggKF8pIHsgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG4gICAgICB0aGlzLmhvb2sucmVhZGluZy51bnN1YnNjcmliZSh0aGlzLnNjaGVtYS5yZWFkSG9vayk7XG4gICAgfVxuICAgIHRoaXMuc2NoZW1hLnJlYWRIb29rID0gcmVhZEhvb2s7XG4gICAgdGhpcy5ob29rKFwicmVhZGluZ1wiLCByZWFkSG9vayk7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGRlZmluZUNsYXNzKCkge1xuICAgIGZ1bmN0aW9uIENsYXNzIChjb250ZW50KXtcbiAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLm1hcFRvQ2xhc3MoQ2xhc3MpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmFkZCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmFkZCgpXG4gICAqIFxuICAgKiovXG4gIGFkZChvYmosIGtleT86IEluZGV4YWJsZVR5cGUpOiBQcm9taXNlRXh0ZW5kZWQ8SW5kZXhhYmxlVHlwZT4ge1xuICAgIGNvbnN0IHthdXRvLCBrZXlQYXRofSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgbGV0IG9ialRvQWRkID0gb2JqO1xuICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCwgdmFsdWVzOiBbb2JqVG9BZGRdfSk7XG4gICAgfSkudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0KVxuICAgIC50aGVuKGxhc3RSZXN1bHQgPT4ge1xuICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgLy8gVGhpcyBwYXJ0IHNob3VsZCBiZSBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICAvLyBJZiBldmVyIGZlZWxpbmcgdG9vIGJhZCBhYm91dCB0aGlzLCBwbGVhc2Ugd2FpdCB0byBhIG5ldyBtYWpvciBiZWZvcmUgcmVtb3ZpbmcgaXQsXG4gICAgICAgIC8vIGFuZCBkb2N1bWVudCB0aGUgY2hhbmdlIHRob3JvdWdobHkuXG4gICAgICAgIHRyeXtzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTt9Y2F0Y2goXyl7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRhYmxlLnVwZGF0ZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLnVwZGF0ZSgpXG4gICAqIFxuICAgKiovXG4gIHVwZGF0ZShrZXlPck9iamVjdCwgbW9kaWZpY2F0aW9uczogeyBba2V5UGF0aDogc3RyaW5nXTogYW55OyB9IHwgKChvYmo6IGFueSwgY3R4Ont2YWx1ZTogYW55LCBwcmltS2V5OiBJbmRleGFibGVUeXBlfSkgPT4gdm9pZCB8IGJvb2xlYW4pKTogUHJvbWlzZUV4dGVuZGVkPG51bWJlcj4ge1xuICAgIGlmICh0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGtleU9yT2JqZWN0KSkge1xuICAgICAgY29uc3Qga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcbiAgICAgICAgXCJHaXZlbiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBpdHMgcHJpbWFyeSBrZXlcIikpO1xuICAgICAgLyovLyBvYmplY3QgdG8gbW9kaWZ5LiBBbHNvIG1vZGlmeSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpY2F0aW9uczpcbiAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgIC8vIElmIGV2ZXIgZmVlbGluZyB0b28gYmFkIGFib3V0IG11dGF0aW5nIGdpdmVuIG9iamVjdCwgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgLy8gYW5kIGRvY3VtZW50IHRoZSBjaGFuZ2UgdGhvcm91Z2hseS4gVE9ETzogRG9jdW1lbnQgdGhpcyBjaGFuZ2UhXG4gICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbihrZXlPck9iamVjdCkpIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAga2V5cyhtb2RpZmljYXRpb25zKS5mb3JFYWNoKGtleVBhdGggPT4ge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCBrZXlQYXRoLCBtb2RpZmljYXRpb25zW2tleVBhdGhdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3cgc2luY2Ugd2Ugc3VwcG9ydCBmdW5jdGlvbiBhcmd1bWVudCwgd2Ugc2hvdWxkIGhhdmUgYSBzaW1pbGFyIGJlaGF2aW9yIGhlcmUgYXMgd2VsbFxuICAgICAgICAgIC8vIChhcyBsb25nIGFzIHdlIGRvIHRoaXMgbXV0YWJpbGl0eSBzdHVmZiBvbiB0aGUgZ2l2ZW4gb2JqZWN0KVxuICAgICAgICAgIG1vZGlmaWNhdGlvbnMoa2V5T3JPYmplY3QsIHt2YWx1ZToga2V5T3JPYmplY3QsIHByaW1LZXk6IGtleX0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gTWF5YmUgZ2l2ZW4gb2JqZWN0IHdhcyBmcm96ZW4uXG4gICAgICAgIC8vIFRoaXMgcGFydCBpcyBub3QgZXNzZW50aWFsLiBKdXN0IG1vdmUgb24gYXMgbm90aGluZyBoYXBwZW5lZC4uLlxuICAgICAgfSovXG4gICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtleSB0byBtb2RpZnlcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXlPck9iamVjdCkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUYWJsZS5wdXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5wdXQoKVxuICAgKiBcbiAgICoqL1xuICBwdXQob2JqLCBrZXk/OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGU+IHtcbiAgICBjb25zdCB7YXV0bywga2V5UGF0aH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFucyhcbiAgICAgICdyZWFkd3JpdGUnLFxuICAgICAgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsfSkpXG4gICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgdGhpcywgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgICB0cnl7c2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7fWNhdGNoKF8pe307XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5kZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5kZWxldGUoKVxuICAgKiBcbiAgICoqL1xuICBkZWxldGUoa2V5OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsXG4gICAgICB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldfSkpXG4gICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmNsZWFyKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuY2xlYXIoKVxuICAgKiBcbiAgICoqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsXG4gICAgICB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlfSkpXG4gICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5idWxrR2V0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYnVsa0dldCgpXG4gICAqIFxuICAgKiBAcGFyYW0ga2V5cyBcbiAgICovXG4gIGJ1bGtHZXQoa2V5czogSW5kZXhhYmxlVHlwZVtdKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIHRyYW5zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0TWFueSh7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHRyYW5zXG4gICAgICB9KS50aGVuKHJlc3VsdCA9PiByZXN1bHQubWFwKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5idWxrQWRkKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYnVsa0FkZCgpXG4gICAqIFxuICAgKiovXG4gIGJ1bGtBZGQoXG4gICAgb2JqZWN0czogcmVhZG9ubHkgYW55W10sXG4gICAga2V5c09yT3B0aW9ucz86IFJlYWRvbmx5QXJyYXk8SW5kZXhhYmxlVHlwZT4gfCB7IGFsbEtleXM/OiBib29sZWFuIH0sXG4gICAgb3B0aW9ucz86IHsgYWxsS2V5cz86IGJvb2xlYW4gfVxuICApIHsgICAgXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyBhcyB7IGFsbEtleXM/OiBib29sZWFuIH0pO1xuICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblxuICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoOyAvLyBQaWNrIGxlbmd0aCBoZXJlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbiBvZiBvYmplY3RzIGxhdGVyXG4gICAgICBsZXQgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgb2JqZWN0cztcbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKFxuICAgICAgICB7dHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzIGFzIEluZGV4YWJsZVR5cGVbXSwgdmFsdWVzOiBvYmplY3RzVG9BZGQsIHdhbnRSZXN1bHRzfVxuICAgICAgKVxuICAgICAgICAudGhlbigoe251bUZhaWx1cmVzLCByZXN1bHRzLGxhc3RSZXN1bHQsIGZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtBZGQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa1B1dCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtQdXQoKVxuICAgKiBcbiAgICoqL1xuICBidWxrUHV0KFxuICAgIG9iamVjdHM6IHJlYWRvbmx5IGFueVtdLFxuICAgIGtleXNPck9wdGlvbnM/OiBSZWFkb25seUFycmF5PEluZGV4YWJsZVR5cGU+IHwgeyBhbGxLZXlzPzogYm9vbGVhbiB9LFxuICAgIG9wdGlvbnM/OiB7IGFsbEtleXM/OiBib29sZWFuIH1cbiAgKSB7ICAgXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyBhcyB7IGFsbEtleXM/OiBib29sZWFuIH0pO1xuICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblxuICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoOyAvLyBQaWNrIGxlbmd0aCBoZXJlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbiBvZiBvYmplY3RzIGxhdGVyXG4gICAgICBsZXQgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgb2JqZWN0cztcblxuICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoXG4gICAgICAgIHt0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMgYXMgSW5kZXhhYmxlVHlwZVtdLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHN9XG4gICAgICApXG4gICAgICAgIC50aGVuKCh7bnVtRmFpbHVyZXMsIHJlc3VsdHMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtQdXQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa1VwZGF0ZSgpXG4gICAqXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUuVGFibGUuYnVsa1VwZGF0ZSgpXG4gICAqL1xuICAgYnVsa1VwZGF0ZShcbiAgICBrZXlzQW5kQ2hhbmdlczogcmVhZG9ubHkgeyBrZXk6IGFueTsgY2hhbmdlczogVXBkYXRlU3BlYzxhbnk+IH1bXVxuICApOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPiB7XG4gICAgY29uc3QgY29yZVRhYmxlID0gdGhpcy5jb3JlO1xuICAgIGNvbnN0IGtleXMgPSBrZXlzQW5kQ2hhbmdlcy5tYXAoKGVudHJ5KSA9PiBlbnRyeS5rZXkpO1xuICAgIGNvbnN0IGNoYW5nZVNwZWNzID0ga2V5c0FuZENoYW5nZXMubWFwKChlbnRyeSkgPT4gZW50cnkuY2hhbmdlcyk7XG4gICAgY29uc3Qgb2Zmc2V0TWFwOiBudW1iZXJbXSA9IFtdO1xuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgKHRyYW5zKSA9PiB7XG4gICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoeyB0cmFucywga2V5cywgY2FjaGU6ICdjbG9uZScgfSkudGhlbigob2JqcykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHRLZXlzOiBhbnlbXSA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHRPYmpzOiBhbnlbXSA9IFtdO1xuICAgICAgICBrZXlzQW5kQ2hhbmdlcy5mb3JFYWNoKCh7IGtleSwgY2hhbmdlcyB9LCBpZHgpID0+IHtcbiAgICAgICAgICBjb25zdCBvYmogPSBvYmpzW2lkeF07XG4gICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXlQYXRoIG9mIE9iamVjdC5rZXlzKGNoYW5nZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgICAgaWYgKGtleVBhdGggPT09IHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjbXAodmFsdWUsIGtleSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkNvbnN0cmFpbnQoXG4gICAgICAgICAgICAgICAgICAgIGBDYW5ub3QgdXBkYXRlIHByaW1hcnkga2V5IGluIGJ1bGtVcGRhdGUoKWBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0TWFwLnB1c2goaWR4KTtcbiAgICAgICAgICAgIHJlc3VsdEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgcmVzdWx0T2Jqcy5wdXNoKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbnVtRW50cmllcyA9IHJlc3VsdEtleXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29yZVRhYmxlXG4gICAgICAgICAgLm11dGF0ZSh7XG4gICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAga2V5czogcmVzdWx0S2V5cyxcbiAgICAgICAgICAgIHZhbHVlczogcmVzdWx0T2JqcyxcbiAgICAgICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgICAgY2hhbmdlU3BlY3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCh7IG51bUZhaWx1cmVzLCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApIHJldHVybiBudW1FbnRyaWVzO1xuICAgICAgICAgICAgLy8gRmFpbHVyZS4gYnVsa1B1dCgpIG1heSBoYXZlIGEgc3Vic2V0IG9mIGtleXNcbiAgICAgICAgICAgIC8vIHNvIHdlIG11c3QgdHJhbnNsYXRlIHJldHVybmVkICdmYWlsdXRlcycgaW50byB0aGUgb2Zmc2V0cyBvZiBnaXZlbiBhcmd1bWVudDpcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2Zmc2V0IG9mIE9iamVjdC5rZXlzKGZhaWx1cmVzKSkge1xuICAgICAgICAgICAgICBjb25zdCBtYXBwZWRPZmZzZXQgPSBvZmZzZXRNYXBbTnVtYmVyKG9mZnNldCldO1xuICAgICAgICAgICAgICBpZiAobWFwcGVkT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlID0gZmFpbHVyZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZmFpbHVyZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBmYWlsdXJlc1ttYXBwZWRPZmZzZXRdID0gZmFpbHVyZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcbiAgICAgICAgICAgICAgYCR7dGhpcy5uYW1lfS5idWxrVXBkYXRlKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtRW50cmllc30gb3BlcmF0aW9ucyBmYWlsZWRgLFxuICAgICAgICAgICAgICBmYWlsdXJlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRhYmxlLmJ1bGtEZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5idWxrRGVsZXRlKClcbiAgICogXG4gICAqKi9cbiAgYnVsa0RlbGV0ZShrZXlzOiBSZWFkb25seUFycmF5PEluZGV4YWJsZVR5cGU+KTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIGFzIEluZGV4YWJsZVR5cGVbXX0pO1xuICAgIH0pLnRoZW4oKHtudW1GYWlsdXJlcywgbGFzdFJlc3VsdCwgZmFpbHVyZXN9KSA9PiB7XG4gICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcbiAgICAgICAgYCR7dGhpcy5uYW1lfS5idWxrRGVsZXRlKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtS2V5c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsICJpbXBvcnQge2tleXMsIGlzQXJyYXksIGFzYXB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQge25vcCwgbWlycm9yLCByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbn0gZnJvbSAnLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQge2V4Y2VwdGlvbnN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV2ZW50cyhjdHgpIHtcbiAgICB2YXIgZXZzID0ge307XG4gICAgdmFyIHJ2ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlLiBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGFuIGp1c3QgdGhlIHN1YnNjcmliZXIgd2FzIHByb3ZpZGVkLCBmb3J3YXJkIHRoZW0gYXMgd2VsbC5cbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGV2c1tldmVudE5hbWVdLnN1YnNjcmliZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGludGVyZmFjZSBhbGxvd2luZyB0byBmaXJlIG9yIHVuc3Vic2NyaWJlIGZyb20gZXZlbnRcbiAgICAgICAgICAgIHJldHVybiBldnNbZXZlbnROYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcnYuYWRkRXZlbnRUeXBlID0gYWRkO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJ2O1xuXG4gICAgZnVuY3Rpb24gYWRkKGV2ZW50TmFtZSwgY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JykgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKSBjaGFpbkZ1bmN0aW9uID0gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW47XG4gICAgICAgIGlmICghZGVmYXVsdEZ1bmN0aW9uKSBkZWZhdWx0RnVuY3Rpb24gPSBub3A7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICAvLyBldmVudHModGhpcywge3JlYWRpbmc6IFtmdW5jdGlvbkNoYWluLCBub3BdfSk7XG4gICAgICAgIGtleXMoY2ZnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gY2ZnW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFkZChldmVudE5hbWUsIGNmZ1tldmVudE5hbWVdWzBdLCBjZmdbZXZlbnROYW1lXVsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MgPT09ICdhc2FwJykge1xuICAgICAgICAgICAgICAgIC8vIFJhdGhlciB0aGFuIGFwcHJvYWNoaW5nIGV2ZW50IHN1YnNjcmlwdGlvbiB1c2luZyBhIGZ1bmN0aW9uYWwgYXBwcm9hY2gsIHdlIGhlcmUgZG8gaXQgaW4gYSBmb3ItbG9vcCB3aGVyZSBzdWJzY3JpYmVyIGlzIGV4ZWN1dGVkIGluIGl0cyBvd24gc3RhY2tcbiAgICAgICAgICAgICAgICAvLyBlbmFibGluZyB0aGF0IGFueSBleGNlcHRpb24gdGhhdCBvY2N1ciB3b250IGRpc3R1cmIgdGhlIGluaXRpYXRvciBhbmQgYWxzbyBub3QgbmVzY2Vzc2FyeSBiZSBjYXRjaGVkIGFuZCBmb3Jnb3R0ZW4uXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhZGQoZXZlbnROYW1lLCBtaXJyb3IsIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltYXphdGlvbi1zYWZlIGNsb25pbmcgb2YgYXJndW1lbnRzIGludG8gYXJncy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZWFjaCBzdWJzY3JpYmVyOlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2FwKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGFycmF5VG9PYmplY3QsIGRlcml2ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcjxUQ29uc3RydWN0b3I+IChwcm90b3R5cGU6IE9iamVjdCwgY29uc3RydWN0b3I6IEZ1bmN0aW9uKSB7XG4gIC8qY29uc3QgcHJvcGVydHlEZXNjcmlwdG9yTWFwID0gYXJyYXlUb09iamVjdChcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpLFxuICAgIHByb3BLZXkgPT4gW3Byb3BLZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wS2V5KV0pO1xuXG4gIC8vIEJvdGggZGVyaXZlIGFuZCBjbG9uZSB0aGUgcHJvdG90eXBlLlxuICAvLyAgIGRlcml2ZTogU28gdGhhdCB4IGluc3RhbmNlb2YgVCByZXR1cm5zIHRydWUgd2hlbiBUIGlzIHRoZSBjbGFzcyB0ZW1wbGF0ZS5cbiAgLy8gICBjbG9uZTogT3B0aW1pemVzIG1ldGhvZCBhY2Nlc3MgYSBiaXQgKGJ1dCBhY3R1YWxseSBub3QgbmVzY2Vzc2FyeSlcbiAgY29uc3QgZGVyaXZlZFByb3RvdHlwZUNsb25lID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnR5RGVzY3JpcHRvck1hcCk7XG4gIGRlcml2ZWRQcm90b3R5cGVDbG9uZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBkZXJpdmVkUHJvdG90eXBlQ2xvbmU7XG4gIHJldHVybiBjb25zdHJ1Y3RvciBhcyBhbnkgYXMgVENvbnN0cnVjdG9yOyovXG5cbiAgLy8gS2VlcCB0aGUgYWJvdmUgY29kZSBpbiBjYXNlIHdlIHdhbnQgdG8gY2xvbmUgQU5EIGRlcml2ZSB0aGUgcGFyZW50IHByb3RvdHlwZS5cbiAgLy8gUmVhc29uIHdvdWxkIGJlIG9wdGltaXphdGlvbiBvZiBwcm9wZXJ0eSBhY2Nlc3MuXG4gIC8vIFRoZSBjb2RlIGJlbG93IHdpbGwgb25seSBjcmVhdGUgYSBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGZyb20gZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgLy8gdG8gZ2l2ZW4gcHJvdG90eXBlLlxuICBkZXJpdmUoY29uc3RydWN0b3IpLmZyb20oe3Byb3RvdHlwZX0pO1xuICByZXR1cm4gY29uc3RydWN0b3IgYXMgYW55IGFzIFRDb25zdHJ1Y3RvcjsgIFxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgaG9va0NyZWF0aW5nQ2hhaW4sIHB1cmVGdW5jdGlvbkNoYWluLCBub3AsIG1pcnJvciwgaG9va1VwZGF0aW5nQ2hhaW4sIGhvb2tEZWxldGluZ0NoYWluIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBUYWJsZUhvb2tzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLWhvb2tzJztcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi90YWJsZSc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2hlbHBlcnMvRXZlbnRzJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ29uc3RydWN0b3Ige1xuICBuZXcgKG5hbWU6IHN0cmluZywgdGFibGVTY2hlbWE6IFRhYmxlU2NoZW1hLCBvcHRpb25hbFRyYW5zPzogVHJhbnNhY3Rpb24pIDogVGFibGU7XG4gIHByb3RvdHlwZTogVGFibGU7XG59XG5cbi8qKiBHZW5lcmF0ZXMgYSBUYWJsZSBjb25zdHJ1Y3RvciBib3VuZCB0byBnaXZlbiBEZXhpZSBpbnN0YW5jZS5cbiAqIFxuICogVGhlIHB1cnBvc2Ugb2YgaGF2aW5nIGR5bmFtaWNhbGx5IGNyZWF0ZWQgY29uc3RydWN0b3JzLCBpcyB0byBhbGxvd1xuICogYWRkb25zIHRvIGV4dGVuZCBjbGFzc2VzIGZvciBhIGNlcnRhaW4gRGV4aWUgaW5zdGFuY2Ugd2l0aG91dCBhZmZlY3RpbmdcbiAqIG90aGVyIGRiIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IgKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VGFibGVDb25zdHJ1Y3Rvcj4oXG4gICAgVGFibGUucHJvdG90eXBlLFxuXG4gICAgZnVuY3Rpb24gVGFibGUgKHRoaXM6IFRhYmxlLCBuYW1lOiBzdHJpbmcsIHRhYmxlU2NoZW1hOiBUYWJsZVNjaGVtYSwgdHJhbnM/OiBUcmFuc2FjdGlvbikge1xuICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgdGhpcy5fdHggPSB0cmFucztcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgdGhpcy5ob29rID0gZGIuX2FsbFRhYmxlc1tuYW1lXSA/IGRiLl9hbGxUYWJsZXNbbmFtZV0uaG9vayA6IEV2ZW50cyhudWxsLCB7XG4gICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICBcInJlYWRpbmdcIjogW3B1cmVGdW5jdGlvbkNoYWluLCBtaXJyb3JdLFxuICAgICAgICBcInVwZGF0aW5nXCI6IFtob29rVXBkYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgIH0pIGFzIFRhYmxlSG9va3M7XG4gICAgfVxuXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgY29tYmluZSB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvY29tYmluZVwiO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gXCIuLi8uLi9lcnJvcnNcIjtcbmltcG9ydCB7IGhhc093biB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IHdyYXAgfSBmcm9tIFwiLi4vLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgREJDb3JlQ3Vyc29yLCBEQkNvcmVUYWJsZSwgREJDb3JlVHJhbnNhY3Rpb24sIERCQ29yZVRhYmxlU2NoZW1hLCBEQkNvcmVSYW5nZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IG5vcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuXG50eXBlIENvbGxlY3Rpb25Db250ZXh0ID0gQ29sbGVjdGlvbltcIl9jdHhcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UgKGN0eDogQ29sbGVjdGlvbkNvbnRleHQsIGlnbm9yZUxpbWl0RmlsdGVyPzogYm9vbGVhbikge1xuICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbn0gICAgXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRGaWx0ZXIoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgZm46IEZ1bmN0aW9uKSB7XG4gIGN0eC5maWx0ZXIgPSBjb21iaW5lKGN0eC5maWx0ZXIsIGZuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlcGxheUZpbHRlciAoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcj8pIHtcbiAgdmFyIGN1cnIgPSBjdHgucmVwbGF5RmlsdGVyO1xuICBjdHgucmVwbGF5RmlsdGVyID0gY3VyciA/ICgpPT5jb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKSA6IGZhY3Rvcnk7XG4gIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTWF0Y2hGaWx0ZXIoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgZm4pIHtcbiAgY3R4LmlzTWF0Y2ggPSBjb21iaW5lKGN0eC5pc01hdGNoLCBmbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgY29yZVNjaGVtYTogREJDb3JlVGFibGVTY2hlbWEpIHtcbiAgLy8gVE9ETzogUmV3cml0ZSB0aGlzLiBObyBuZWVkIHRvIGtub3cgY3R4LmlzUHJpbUtleS4gY3R4LmluZGV4IHNob3VsZCBob2xkIHRoZSBrZXlwYXRoLlxuICAvLyBTdGlsbCwgdGhyb3cgaWYgbm90IGZvdW5kIVxuICBpZiAoY3R4LmlzUHJpbUtleSkgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgY29uc3QgaW5kZXggPSBjb3JlU2NoZW1hLmdldEluZGV4QnlLZXlQYXRoKGN0eC5pbmRleCk7XG4gIGlmICghaW5kZXgpIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIktleVBhdGggXCIgKyBjdHguaW5kZXggKyBcIiBvbiBvYmplY3Qgc3RvcmUgXCIgKyBjb3JlU2NoZW1hLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkN1cnNvcihjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBjb3JlVGFibGU6IERCQ29yZVRhYmxlLCB0cmFuczogREJDb3JlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKTtcbiAgcmV0dXJuIGNvcmVUYWJsZS5vcGVuQ3Vyc29yKHtcbiAgICB0cmFucyxcbiAgICB2YWx1ZXM6ICFjdHgua2V5c09ubHksXG4gICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuICAgIHVuaXF1ZTogISFjdHgudW5pcXVlLFxuICAgIHF1ZXJ5OiB7XG4gICAgICBpbmRleCwgXG4gICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXIgKFxuICBjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBcbiAgZm46IChpdGVtLCBjdXJzb3I6IERCQ29yZUN1cnNvciwgYWR2YW5jZTogRnVuY3Rpb24pPT52b2lkLFxuICBjb3JlVHJhbnM6IERCQ29yZVRyYW5zYWN0aW9uLFxuICBjb3JlVGFibGU6IERCQ29yZVRhYmxlKTogUHJvbWlzZTxhbnk+XG57XG4gIGNvbnN0IGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICBpZiAoIWN0eC5vcikge1xuICAgICAgcmV0dXJuIGl0ZXJhdGUoXG4gICAgICAgIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksXG4gICAgICAgIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcbiAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNldCA9IHt9O1xuXG4gICAgICBjb25zdCB1bmlvbiA9IChpdGVtOiBhbnksIGN1cnNvcjogREJDb3JlQ3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZSwgcmVzdWx0PT5jdXJzb3Iuc3RvcChyZXN1bHQpLCBlcnIgPT4gY3Vyc29yLmZhaWwoZXJyKSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykga2V5ID0gJycgKyBuZXcgVWludDhBcnJheShwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd24oc2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBjdHgub3IuX2l0ZXJhdGUodW5pb24sIGNvcmVUcmFucyksXG4gICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuICAgICAgXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlOiBQcm9taXNlPERCQ29yZUN1cnNvcj4sIGZpbHRlciwgZm4sIHZhbHVlTWFwcGVyKTogUHJvbWlzZTxhbnk+IHtcbiAgXG4gIC8vIEFwcGx5IHZhbHVlTWFwcGVyIChob29rKCdyZWFkaW5nJykgb3IgbWFwcHBlZCBjbGFzcylcbiAgdmFyIG1hcHBlZEZuID0gdmFsdWVNYXBwZXIgPyAoeCxjLGEpID0+IGZuKHZhbHVlTWFwcGVyKHgpLGMsYSkgOiBmbjtcbiAgLy8gV3JhcCBmbiB3aXRoIFBTRCBhbmQgbWljcm90aWNrIHN0dWZmIGZyb20gUHJvbWlzZS5cbiAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuICBcbiAgcmV0dXJuIGN1cnNvclByb21pc2UudGhlbihjdXJzb3IgPT4ge1xuICAgIGlmIChjdXJzb3IpIHtcbiAgICAgIHJldHVybiBjdXJzb3Iuc3RhcnQoKCk9PntcbiAgICAgICAgdmFyIGMgPSAoKT0+Y3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlciwgdmFsPT57Y3Vyc29yLnN0b3AodmFsKTtjPW5vcH0sIGUgPT4ge2N1cnNvci5mYWlsKGUpO2MgPSBub3A7fSkpXG4gICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBhZHZhbmNlciA9PiBjID0gYWR2YW5jZXIpO1xuICAgICAgICBjKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBQcm9wTW9kU3BlYyB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvcHJvcC1tb2RpZmljYXRpb25cIjtcblxuZXhwb3J0IGNvbnN0IFByb3BNb2RTeW1ib2w6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woKTtcblxuLyoqIENvbnNpc3RlbnQgY2hhbmdlIHByb3BhZ2F0aW9uIGFjcm9zcyBvZmZsaW5lIHN5bmNlZCBkYXRhLlxuICogXG4gKiBUaGlzIGNsYXNzIGlzIGV4ZWN1dGVkIGNsaWVudC0gYW5kIHNlcnZlciBzaWRlIG9uIHN5bmMsIG1ha2luZ1xuICogYW4gb3BlcmF0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIHN5bmMgZm9yIGZ1bGwgY29uc2lzdGVuY3kgYW5kIGFjY3VyYWN5LlxuICogXG4gKiBFeGFtcGxlOiBBbiBvYmplY3QgcmVwcmVzZW50cyBhIGJhbmsgYWNjb3VudCB3aXRoIGEgYmFsYW5jZS5cbiAqIE9uZSBvZmZsaW5lIHVzZXIgYWRkcyAkIDEuMDAgdG8gdGhlIGJhbGFuY2UuXG4gKiBBbm90aGVyIHVzZXIgKG9ubGluZSkgYWRkcyAkIDIuMDAgdG8gdGhlIGJhbGFuY2UuXG4gKiBXaGVuIGZpcnN0IHVzZXIgc3luY3MsIHRoZSBiYWxhbmNlIGJlY29tZXMgdGhlIHN1bSBvZiBldmVyeSBvcGVyYXRpb24gKDMuMDApLlxuICogXG4gKiAtLSBpbml0aWFsOiBiYWxhbmNlIGlzIDBcbiAqIDEuIGRiLmJhbmtBY2NvdW50cy51cGRhdGUoMSwgeyBiYWxhbmNlOiBuZXcgUHJvZE1vZGlmaWNhdGlvbih7YWRkOiAxMDB9KX0pIC8vIHVzZXIgMSAob2ZmbGluZSlcbiAqIDIuIGRiLmJhbmtBY2NvdW50cy51cGRhdGUoMSwgeyBiYWxhbmNlOiBuZXcgUHJvZE1vZGlmaWNhdGlvbih7YWRkOiAyMDB9KX0pIC8vIHVzZXIgMiAob25saW5lKVxuICogLS0gYmVmb3JlIHVzZXIgMSBzeW5jcywgYmFsYW5jZSBpcyAyMDAgKHJlcHJlc2VudGluZyBtb25leSB3aXRoIGludGVnZXJzICogMTAwIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcylcbiAqIDx1c2VyIDEgc3luY3M+XG4gKiAtLSBiYWxhbmNlIGlzIDMwMFxuICogXG4gKiBXaGVuIG5ldyBvcGVyYXRpb25zIGFyZSBhZGRlZCwgdGhleSBuZWVkIHRvIGJlIGFkZGVkIHRvOlxuICogMS4gUHJvcE1vZFNwZWMgaW50ZXJmYWNlXG4gKiAyLiBIZXJlIGluIFByb3BNb2RpZmljYXRpb24gd2l0aCB0aGUgbG9naWMgdGhleSByZXByZXNlbnRcbiAqIDMuIChPcHRpb25hbGx5KSBhIHN1Z2FyIGZ1bmN0aW9uIGZvciBpdCwgc3VjaCBhcyBjb25zdCBtYXRoQWRkID0gKGFtb3VudDogbnVtYmVyIHwgQmlnSW50KSA9PiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7bWF0aEFkZDogYW1vdW50fSlcbiAqL1xuZXhwb3J0IGNsYXNzIFByb3BNb2RpZmljYXRpb24gaW1wbGVtZW50cyBQcm9wTW9kU3BlYyB7XG4gIFtQcm9wTW9kU3ltYm9sXT86IHRydWU7XG4gIHJlcGxhY2VQcmVmaXg/OiBbc3RyaW5nLCBzdHJpbmddO1xuICBhZGQ/OiBudW1iZXIgfCBiaWdpbnQgfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+O1xuICByZW1vdmU/OiBudW1iZXIgfCBiaWdpbnQgfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+O1xuXG4gIGV4ZWN1dGUodmFsdWU6IGFueSk6IGFueSB7XG4gICAgLy8gYWRkIChtYXRoZW1hdGljYWwgb3Igc2V0LXdpc2UpXG4gICAgaWYgKHRoaXMuYWRkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlcm0gPSB0aGlzLmFkZDtcbiAgICAgIC8vIFNldC1hZGRpdGlvbiBvbiBhcnJheSByZXByZXNlbnRpbmcgYSBzZXQgb2YgcHJpbWl0aXZlIHR5cGVzIChzdHJpbmdzLCBudW1iZXJzKVxuICAgICAgaWYgKGlzQXJyYXkodGVybSkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi4oaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKSwgLi4udGVybV0uc29ydCgpO1xuICAgICAgfVxuICAgICAgLy8gTWF0aGVtYXRpY2FsIGFkZGl0aW9uOlxuICAgICAgaWYgKHR5cGVvZiB0ZXJtID09PSAnbnVtYmVyJykgcmV0dXJuIChOdW1iZXIodmFsdWUpIHx8IDApICsgdGVybTsgLy8gaWYgdmFsdWUgaXMgbm90IGNvbnZlcnRpYmxlIHRvIG51bWJlciwgcmV0dXJuIDAgKyB0ZXJtXG4gICAgICBpZiAodHlwZW9mIHRlcm0gPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgKyB0ZXJtO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gQmlnSW50KDApICsgdGVybTsgLy8gVW5saWtlIE51bWJlcih2YWx1ZSkgdGhhdCBjYW4gcmV0dXJuIE5hTiwgQmlnSW50KHZhbHVlKSB0aHJvd3MgaWYgdmFsdWUgaXMgbm90IEJpZ0ludCwgTnVtYmVyIG9yIG51bWVyaWMgc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdGVybSAke3Rlcm19YCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIChtYXRoZW1hdGljYWwgb3Igc2V0LXdpc2UpXG4gICAgaWYgKHRoaXMucmVtb3ZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHN1YnRyYWhlbmQgPSB0aGlzLnJlbW92ZTtcbiAgICAgIC8vIFNldC1hZGRpdGlvbiBvbiBhcnJheSByZXByZXNlbnRpbmcgYSBzZXQgb2YgcHJpbWl0aXZlIHR5cGVzIChzdHJpbmdzLCBudW1iZXJzKVxuICAgICAgaWYgKGlzQXJyYXkoc3VidHJhaGVuZCkpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUuZmlsdGVyKGl0ZW0gPT4gIXN1YnRyYWhlbmQuaW5jbHVkZXMoaXRlbSkpLnNvcnQoKSA6IFtdO1xuICAgICAgfSAgICAgICAgXG4gICAgICAvLyBNYXRoZW1hdGljYWwgYWRkaXRpb246XG4gICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmQgPT09ICdudW1iZXInKSByZXR1cm4gTnVtYmVyKHZhbHVlKSAtIHN1YnRyYWhlbmQ7XG4gICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgLSBzdWJ0cmFoZW5kO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gQmlnSW50KDApIC0gc3VidHJhaGVuZDsgLy8gVW5saWtlIE51bWJlcih2YWx1ZSkgdGhhdCBjYW4gcmV0dXJuIE5hTiwgQmlnSW50KHZhbHVlKSB0aHJvd3MgaWYgdmFsdWUgaXMgbm90IEJpZ0ludCwgTnVtYmVyIG9yIG51bWVyaWMgc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc3VidHJhaGVuZCAke3N1YnRyYWhlbmR9YCk7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSBhIHByZWZpeDpcbiAgICBjb25zdCBwcmVmaXhUb1JlcGxhY2UgPSB0aGlzLnJlcGxhY2VQcmVmaXg/LlswXTtcbiAgICBpZiAocHJlZml4VG9SZXBsYWNlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuc3RhcnRzV2l0aChwcmVmaXhUb1JlcGxhY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUHJlZml4WzFdICsgdmFsdWUuc3Vic3RyaW5nKHByZWZpeFRvUmVwbGFjZS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzcGVjOiBQcm9wTW9kU3BlYykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3BlYyk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBDb2xsZWN0aW9uIGFzIElDb2xsZWN0aW9uIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9jb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gXCIuLi9kZXhpZVwiO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tIFwiLi4vdGFibGVcIjtcbmltcG9ydCB7IEluZGV4YWJsZVR5cGUsIEluZGV4YWJsZVR5cGVBcnJheVJlYWRvbmx5IH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZVwiO1xuaW1wb3J0IHsgUHJvbWlzZUV4dGVuZGVkIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9wcm9taXNlLWV4dGVuZGVkXCI7XG5pbXBvcnQgeyBpdGVyLCBpc1BsYWluS2V5UmFuZ2UsIGdldEluZGV4T3JTdG9yZSwgYWRkUmVwbGF5RmlsdGVyLCBhZGRGaWx0ZXIsIGFkZE1hdGNoRmlsdGVyIH0gZnJvbSBcIi4vY29sbGVjdGlvbi1oZWxwZXJzXCI7XG5pbXBvcnQgeyByZWplY3Rpb24gfSBmcm9tIFwiLi4vLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBjb21iaW5lIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lXCI7XG5pbXBvcnQgeyBleHRlbmQsIGhhc093biwgZGVlcENsb25lLCBrZXlzLCBzZXRCeUtleVBhdGgsIGdldEJ5S2V5UGF0aCB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IE1vZGlmeUVycm9yIH0gZnJvbSBcIi4uLy4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgVGhlblNob3J0Y3V0IH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy90aGVuLXNob3J0Y3V0XCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERCQ29yZUN1cnNvciwgREJDb3JlVHJhbnNhY3Rpb24sIERCQ29yZVJhbmdlVHlwZSwgREJDb3JlTXV0YXRlUmVzcG9uc2UsIERCQ29yZUtleVJhbmdlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tIFwiLi4vLi4vZnVuY3Rpb25zL2NtcFwiO1xuaW1wb3J0IHsgUHJvcE1vZGlmaWNhdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb3AtbW9kaWZpY2F0aW9uXCI7XG5pbXBvcnQgeyBVcGRhdGVTcGVjIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy91cGRhdGUtc3BlY1wiO1xuXG4vKiogY2xhc3MgQ29sbGVjdGlvblxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvblxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbiBpbXBsZW1lbnRzIElDb2xsZWN0aW9uIHtcbiAgZGI6IERleGllO1xuICBfY3R4OiB7XG4gICAgdGFibGU6IFRhYmxlO1xuICAgIGluZGV4Pzogc3RyaW5nIHwgbnVsbDtcbiAgICBpc1ByaW1LZXk/OiBib29sZWFuO1xuICAgIHJhbmdlOiBEQkNvcmVLZXlSYW5nZTtcbiAgICBrZXlzT25seTogYm9vbGVhbjtcbiAgICBkaXI6IFwibmV4dFwiIHwgXCJwcmV2XCI7XG4gICAgdW5pcXVlOiBcIlwiIHwgXCJ1bmlxdWVcIjtcbiAgICBhbGdvcml0aG0/OiBGdW5jdGlvbiB8IG51bGw7XG4gICAgZmlsdGVyPzogRnVuY3Rpb24gfCBudWxsO1xuICAgIHJlcGxheUZpbHRlcjogRnVuY3Rpb24gfCBudWxsO1xuICAgIGp1c3RMaW1pdDogYm9vbGVhbjsgLy8gVHJ1ZSBpZiBhIHJlcGxheUZpbHRlciBpcyBqdXN0IGEgZmlsdGVyIHRoYXQgcGVyZm9ybXMgYSBcImxpbWl0XCIgb3BlcmF0aW9uIChvciBub25lIGF0IGFsbClcbiAgICBpc01hdGNoOiBGdW5jdGlvbiB8IG51bGw7XG4gICAgb2Zmc2V0OiBudW1iZXIsXG4gICAgbGltaXQ6IG51bWJlcixcbiAgICBlcnJvcjogYW55LCAvLyBJZiBzZXQsIGFueSBwcm9taXNlIG11c3QgYmUgcmVqZWN0ZWQgd2l0aCB0aGlzIGVycm9yXG4gICAgb3I6IENvbGxlY3Rpb24sXG4gICAgdmFsdWVNYXBwZXI6IChhbnkpID0+IGFueVxuICB9XG4gIFxuICBfb25kaXJlY3Rpb25jaGFuZ2U/OiBGdW5jdGlvbjtcblxuICBfcmVhZDxUPihmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPFQ+LCBjYj8pOiBQcm9taXNlRXh0ZW5kZWQ8VD4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuICB9XG5cbiAgX3dyaXRlPFQ+KGZuOiAoaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uLCBkeFRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlRXh0ZW5kZWQ8VD4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWR3cml0ZScsIGZuLCBcImxvY2tlZFwiKTsgLy8gV2hlbiBkb2luZyB3cml0ZSBvcGVyYXRpb25zIG9uIGNvbGxlY3Rpb25zLCBhbHdheXMgbG9jayB0aGUgb3BlcmF0aW9uIHNvIHRoYXQgdXBjb21pbmcgb3BlcmF0aW9ucyBnZXRzIHF1ZXVlZC5cbiAgfVxuXG4gIF9hZGRBbGdvcml0aG0oZm4pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcbiAgfVxuXG4gIF9pdGVyYXRlKFxuICAgIGZuOiAoaXRlbSwgY3Vyc29yOiBEQkNvcmVDdXJzb3IsIGFkdmFuY2U6IEZ1bmN0aW9uKSA9PiB2b2lkLFxuICAgIGNvcmVUcmFuczogREJDb3JlVHJhbnNhY3Rpb24pIDogUHJvbWlzZTxhbnk+XG4gIHtcbiAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmNsb25lKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmNsb25lKClcbiAgICogXG4gICAqKi9cbiAgY2xvbmUocHJvcHM/KTogdGhpcyB7XG4gICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksXG4gICAgICBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG4gICAgaWYgKHByb3BzKSBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgcnYuX2N0eCA9IGN0eDtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5yYXcoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucmF3KClcbiAgICogXG4gICAqKi9cbiAgcmF3KCk6IHRoaXMge1xuICAgIHRoaXMuX2N0eC52YWx1ZU1hcHBlciA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmVhY2goKVxuICAgKiBcbiAgICoqL1xuICBlYWNoKGZuOiAob2JqLCBjdXJzb3I6IERCQ29yZUN1cnNvcikgPT4gYW55KTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmNvdW50KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmNvdW50KClcbiAgICogXG4gICAqKi9cbiAgY291bnQoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHBsYWluIGtleSByYW5nZS4gV2UgY2FuIHVzZSB0aGUgY291bnQoKSBtZXRob2QgaWYgdGhlIGluZGV4LlxuICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihjb3VudCA9PiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbGdvcml0aG1zLCBmaWx0ZXJzIG9yIGV4cHJlc3Npb25zIGFyZSBhcHBsaWVkLiBOZWVkIHRvIGNvdW50IG1hbnVhbGx5LlxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gaXRlcihjdHgsICgpID0+IHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAudGhlbigoKT0+Y291bnQpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uc29ydEJ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnNvcnRCeSgpXG4gICAqIFxuICAgKiovXG4gIHNvcnRCeShrZXlQYXRoOiBzdHJpbmcpOiBQcm9taXNlRXh0ZW5kZWQ8YW55W10+O1xuICBzb3J0Qnk8Uj4oa2V5UGF0aDogc3RyaW5nLCB0aGVuU2hvcnRjdXQ6IFRoZW5TaG9ydGN1dDxhbnlbXSwgUj4pIDogUHJvbWlzZUV4dGVuZGVkPFI+O1xuICBzb3J0Qnkoa2V5UGF0aDogc3RyaW5nLCBjYj86IFRoZW5TaG9ydGN1dDxhbnlbXSwgYW55Pikge1xuICAgIGNvbnN0IHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSxcbiAgICAgIGxhc3RQYXJ0ID0gcGFydHNbMF0sXG4gICAgICBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgIGlmIChpKSByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcblxuICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICB2YXIgYVZhbCA9IGdldHZhbChhLCBsYXN0SW5kZXgpLFxuICAgICAgICBiVmFsID0gZ2V0dmFsKGIsIGxhc3RJbmRleCk7XG4gICAgICByZXR1cm4gYVZhbCA8IGJWYWwgPyAtb3JkZXIgOiBhVmFsID4gYlZhbCA/IG9yZGVyIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24udG9BcnJheSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi50b0FycmF5KClcbiAgICogXG4gICAqKi9cbiAgdG9BcnJheShjYj8pOiBQcm9taXNlRXh0ZW5kZWQ8YW55W10+IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgb3B0aW1hdGlvbiBpZiB3ZSBjb3VsZCB1c2UgSURCT2JqZWN0U3RvcmUuZ2V0QWxsKCkgb3JcbiAgICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsKCk6XG4gICAgICAgIGNvbnN0IHt2YWx1ZU1hcHBlcn0gPSBjdHg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKCh7cmVzdWx0fSkgPT4gdmFsdWVNYXBwZXIgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyKSA6IHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXR0aW5nIGFycmF5IHRocm91Z2ggYSBjdXJzb3IuXG4gICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBpdGVtID0+IGEucHVzaChpdGVtKSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKCgpPT5hKTtcbiAgICAgIH1cbiAgICB9LCBjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5vZmZzZXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ub2Zmc2V0KClcbiAgICogXG4gICAqKi9cbiAgb2Zmc2V0KG9mZnNldDogbnVtYmVyKSA6IENvbGxlY3Rpb257XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBpZiAob2Zmc2V0IDw9IDApIHJldHVybiB0aGlzO1xuICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0OyAvLyBGb3IgY291bnQoKVxuICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSkge1xuICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgKCkgPT4ge1xuICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIChjdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHsgLS1vZmZzZXRMZWZ0OyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9mZnNldExlZnQpO1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiAoKSA9PiAoLS1vZmZzZXRMZWZ0IDwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5saW1pdCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5saW1pdCgpXG4gICAqIFxuICAgKiovXG4gIGxpbWl0KG51bVJvd3M6IG51bWJlcikgOiBDb2xsZWN0aW9uIHtcbiAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpOyAvLyBGb3IgY291bnQoKVxuICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsICgpID0+IHtcbiAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICBpZiAoLS1yb3dzTGVmdCA8PSAwKSBhZHZhbmNlKHJlc29sdmUpOyAvLyBTdG9wIGFmdGVyIHRoaXMgaXRlbSBoYXMgYmVlbiBpbmNsdWRlZFxuICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDsgLy8gSWYgbnVtUm93cyBpcyBhbHJlYWR5IGJlbG93IDAsIHJldHVybiBmYWxzZSBiZWNhdXNlIHRoZW4gMCB3YXMgcGFzc2VkIHRvIG51bVJvd3MgaW5pdGlhbGx5LiBPdGhlcndpc2Ugd2Ugd291bGRudCBjb21lIGhlcmUuXG4gICAgICB9O1xuICAgIH0sIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24udW50aWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udW50aWwoKVxuICAgKiBcbiAgICoqL1xuICB1bnRpbChmaWx0ZXJGdW5jdGlvbjogKHgpID0+IGJvb2xlYW4sIGJJbmNsdWRlU3RvcEVudHJ5Pykge1xuICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiBiSW5jbHVkZVN0b3BFbnRyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZmlyc3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZmlyc3QoKVxuICAgKiBcbiAgICoqL1xuICBmaXJzdChjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmxhc3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ubGFzdCgpXG4gICAqIFxuICAgKiovXG4gIGxhc3QoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0KGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmZpbHRlcigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5maWx0ZXIoKVxuICAgKiBcbiAgICoqL1xuICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb246ICh4KSA9PiBib29sZWFuKTogQ29sbGVjdGlvbiB7XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwianNGdW5jdGlvbkZpbHRlclwiIHR5cGU9XCJGdW5jdGlvblwiPmZ1bmN0aW9uKHZhbCl7cmV0dXJuIHRydWUvZmFsc2V9PC9wYXJhbT5cbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICB9KTtcbiAgICAvLyBtYXRjaCBmaWx0ZXJzIG5vdCB1c2VkIGluIERleGllLmpzIGJ1dCBjYW4gYmUgdXNlZCBieSAzcmQgcGFydCBsaWJyYXJpZXMgdG8gdGVzdCBhXG4gICAgLy8gY29sbGVjdGlvbiBmb3IgYSBtYXRjaCB3aXRob3V0IHF1ZXJ5aW5nIERCLiBVc2VkIGJ5IERleGllLk9ic2VydmFibGUuXG4gICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5hbmQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uYW5kKClcbiAgICogXG4gICAqKi9cbiAgYW5kKGZpbHRlcjogKHgpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLm9yKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm9yKClcbiAgICogXG4gICAqKi9cbiAgb3IoaW5kZXhOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucmV2ZXJzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5yZXZlcnNlKClcbiAgICogXG4gICAqKi9cbiAgcmV2ZXJzZSgpIHtcbiAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKSB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmRlc2MoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGVzYygpXG4gICAqIFxuICAgKiovXG4gIGRlc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZWFjaEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoS2V5KClcbiAgICogXG4gICAqKi9cbiAgZWFjaEtleShjYj8pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmVhY2hVbmlxdWVLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZWFjaFVuaXF1ZUtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hVbmlxdWVLZXkoY2I/KSB7XG4gICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoUHJpbWFyeUtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoUHJpbWFyeUtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hQcmltYXJ5S2V5KGNiPykge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IpOyB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ua2V5cygpXG4gICAqIFxuICAgKiovXG4gIGtleXMoY2I/KSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgdmFyIGEgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucHJpbWFyeUtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucHJpbWFyeUtleXMoKVxuICAgKiBcbiAgICoqL1xuICBwcmltYXJ5S2V5cyhjYj8pIDogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGVbXT4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAvLyBTcGVjaWFsIG9wdGltYXRpb24gaWYgd2UgY291bGQgdXNlIElEQk9iamVjdFN0b3JlLmdldEFsbEtleXMoKSBvclxuICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsS2V5cygpOlxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfX0pO1xuICAgICAgfSkudGhlbigoe3Jlc3VsdH0pPT5yZXN1bHQpLnRoZW4oY2IpO1xuICAgIH1cbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgdmFyIGEgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgIGEucHVzaChjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnVuaXF1ZUtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udW5pcXVlS2V5cygpXG4gICAqIFxuICAgKiovXG4gIHVuaXF1ZUtleXMoY2I/KSB7XG4gICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5maXJzdEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5maXJzdEtleSgpXG4gICAqIFxuICAgKiovXG4gIGZpcnN0S2V5KGNiPykge1xuICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ubGFzdEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5sYXN0S2V5KClcbiAgICogXG4gICAqKi9cbiAgbGFzdEtleShjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZGlzdGluY3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGlzdGluY3QoKVxuICAgKiBcbiAgICoqL1xuICBkaXN0aW5jdCgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG4gICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSkgcmV0dXJuIHRoaXM7IC8vIGRpc3RpbmN0KCkgb25seSBtYWtlcyBkaWZmZXJlbmNpZXMgb24gbXVsdGlFbnRyeSBpbmRleGVzLlxuICAgIHZhciBzZXQgPSB7fTtcbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yOiBEQkNvcmVDdXJzb3IpIHtcbiAgICAgIHZhciBzdHJLZXkgPSBjdXJzb3IucHJpbWFyeUtleS50b1N0cmluZygpOyAvLyBDb252ZXJ0cyBhbnkgRGF0ZSB0byBTdHJpbmcsIFN0cmluZyB0byBTdHJpbmcsIE51bWJlciB0byBTdHJpbmcgYW5kIEFycmF5IHRvIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmdcbiAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG4gICAgICByZXR1cm4gIWZvdW5kO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy9cbiAgLy8gTWV0aG9kcyB0aGF0IG11dGF0ZSBzdG9yYWdlXG4gIC8vXG5cbiAgLyoqIENvbGxlY3Rpb24ubW9kaWZ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm1vZGlmeSgpXG4gICAqIFxuICAgKiovXG4gIG1vZGlmeShjaGFuZ2VzOiBVcGRhdGVTcGVjPGFueT4gfCAoKG9iajogYW55LCBjdHg6e3ZhbHVlOiBhbnksIHByaW1LZXk6IEluZGV4YWJsZVR5cGV9KSA9PiB2b2lkIHwgYm9vbGVhbikpOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPiB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGUodHJhbnMgPT4ge1xuICAgICAgdmFyIG1vZGlmeWVyOiAob2JqOiBhbnksIGN0eDp7dmFsdWU6IGFueSwgcHJpbUtleTogSW5kZXhhYmxlVHlwZX0pID0+IHZvaWQgfCBib29sZWFuXG4gICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQ2hhbmdlcyBpcyBhIGZ1bmN0aW9uIHRoYXQgbWF5IHVwZGF0ZSwgYWRkIG9yIGRlbGV0ZSBwcm9wdGVydGllcyBvciBldmVuIHJlcXVpcmUgYSBkZWxldGlvbiB0aGUgb2JqZWN0IGl0c2VsZiAoZGVsZXRlIHRoaXMuaXRlbSlcbiAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzIGFzIChvYmo6IGFueSwgY3R4Ont2YWx1ZTogYW55LCBwcmltS2V5OiBJbmRleGFibGVUeXBlfSkgPT4gdm9pZCB8IGJvb2xlYW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGFuZ2VzIGlzIGEgc2V0IG9mIHtrZXlQYXRoOiB2YWx1ZX0gYW5kIG5vIG9uZSBpcyBsaXN0ZW5pbmcgdG8gdGhlIHVwZGF0aW5nIGhvb2suXG4gICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoY2hhbmdlcyk7XG4gICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgbGV0IGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgbGV0IGtleVBhdGggPSBrZXlQYXRoc1tpXTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgbGV0IG9yaWdWYWwgPSBnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCk7XG5cbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9wTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwuZXhlY3V0ZShvcmlnVmFsKSk7XG4gICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnVmFsICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbCk7IC8vIEFkZGluZyB7a2V5UGF0aDogdW5kZWZpbmVkfSBtZWFucyB0aGF0IHRoZSBrZXlQYXRoIHNob3VsZCBiZSBkZWxldGVkLiBIYW5kbGVkIGJ5IHNldEJ5S2V5UGF0aFxuICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgY29uc3Qge291dGJvdW5kLCBleHRyYWN0S2V5fSA9IGNvcmVUYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5kYi5fb3B0aW9ucy5tb2RpZnlDaHVua1NpemUgfHwgMjAwO1xuICAgICAgY29uc3QgdG90YWxGYWlsdXJlcyA9IFtdO1xuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBjb25zdCBmYWlsZWRLZXlzOiBJbmRleGFibGVUeXBlW10gPSBbXTtcbiAgICAgIGNvbnN0IGFwcGx5TXV0YXRlUmVzdWx0ID0gKGV4cGVjdGVkQ291bnQ6IG51bWJlciwgcmVzOiBEQkNvcmVNdXRhdGVSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCB7ZmFpbHVyZXMsIG51bUZhaWx1cmVzfSA9IHJlcztcbiAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGV4cGVjdGVkQ291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIGtleXMoZmFpbHVyZXMpKSB7XG4gICAgICAgICAgdG90YWxGYWlsdXJlcy5wdXNoKGZhaWx1cmVzW3Bvc10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnByaW1hcnlLZXlzKCkudGhlbihrZXlzID0+IHtcbiAgICAgICAgY29uc3QgY3JpdGVyaWEgPSBpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgICAgIGN0eC5saW1pdCA9PT0gSW5maW5pdHkgJiZcbiAgICAgICAgICAodHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbicgfHwgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spICYmIHtcbiAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBuZXh0Q2h1bmsgPSAob2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxpbWl0LCBrZXlzLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHtcbiAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAga2V5czoga2V5cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KSxcbiAgICAgICAgICAgIGNhY2hlOiBcImltbXV0YWJsZVwiIC8vIE9wdGltaXplIGZvciAyIHRoaW5nczpcbiAgICAgICAgICAgIC8vIDEpIG9ic2VydmFiaWxpdHktbWlkZGxld2FyZSBjYW4gdHJhY2sgY2hhbmdlcyBiZXR0ZXIuXG4gICAgICAgICAgICAvLyAyKSBob29rcyBtaWRkbGV3YXJlIGRvbid0IGhhdmUgdG8gcXVlcnkgdGhlIGV4aXN0aW5nIHZhbHVlcyBhZ2FpbiB3aGVuIHRyYWNraW5nIGNoYW5nZXMuXG4gICAgICAgICAgICAvLyBXZSBjYW4gdXNlIFwiaW1tdXRhYmxlXCIgYmVjYXVzZSB3ZSBwcm9taXNlIHRvIG5vdCB0b3VjaCB0aGUgdmFsdWVzIHdlIHJldHJpZXZlIGhlcmUhXG4gICAgICAgICAgfSkudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkVmFsdWVzID0gW107XG4gICAgICAgICAgICBjb25zdCBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHB1dEtleXMgPSBvdXRib3VuZCA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICBwcmltS2V5OiBrZXlzW29mZnNldCtpXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAobW9kaWZ5ZXIuY2FsbChjdHgsIGN0eC52YWx1ZSwgY3R4KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZWRcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghb3V0Ym91bmQgJiYgY21wKGV4dHJhY3RLZXkob3JpZ1ZhbHVlKSwgZXh0cmFjdEtleShjdHgudmFsdWUpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlZCBwcmltYXJ5IGtleSBvZiBpbmJvdW5kXG4gICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQraV0pO1xuICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4LnZhbHVlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VkIHZhbHVlXG4gICAgICAgICAgICAgICAgICBwdXRWYWx1ZXMucHVzaChjdHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKSBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQraV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZFZhbHVlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe3RyYW5zLCB0eXBlOiAnYWRkJywgdmFsdWVzOiBhZGRWYWx1ZXN9KVxuICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGRlbGV0ZUtleXMgdGhlIGtleSBvZiB0aGUgb2JqZWN0IHRoYXQgZmFpbGVkIHRvIGNoYW5nZSBpdHMgcHJpbWFyeSBrZXlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5zcGxpY2UocGFyc2VJbnQocG9zKSwgMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLnRoZW4oKCk9PihwdXRWYWx1ZXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgdHlwZW9mIGNoYW5nZXMgPT09ICdvYmplY3QnKSkgJiZcbiAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICBrZXlzOiBwdXRLZXlzLFxuICAgICAgICAgICAgICAgICAgdmFsdWVzOiBwdXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzPT5hcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpKVxuICAgICAgICAgICAgKS50aGVuKCgpPT4oZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykpICYmXG4gICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAga2V5czogZGVsZXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgICAgaXNBZGRpdGlvbmFsQ2h1bms6IG9mZnNldCA+IDBcbiAgICAgICAgICAgICAgICB9KS50aGVuKHJlcz0+YXBwbHlNdXRhdGVSZXN1bHQoZGVsZXRlS2V5cy5sZW5ndGgsIHJlcykpXG4gICAgICAgICAgICApLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gb2Zmc2V0ICsgY291bnQgJiYgbmV4dENodW5rKG9mZnNldCArIGxpbWl0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRDaHVuaygwKS50aGVuKCgpPT57XG4gICAgICAgICAgaWYgKHRvdGFsRmFpbHVyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkVycm9yIG1vZGlmeWluZyBvbmUgb3IgbW9yZSBvYmplY3RzXCIsIHRvdGFsRmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cyBhcyBJbmRleGFibGVUeXBlQXJyYXlSZWFkb25seSk7XG5cbiAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmRlbGV0ZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5kZWxldGUoKVxuICAgKiBcbiAgICoqL1xuICBkZWxldGUoKSA6IFByb21pc2VFeHRlbmRlZDxudW1iZXI+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgcmFuZ2UgPSBjdHgucmFuZ2U7XG4gICAgICAvL2RlbGV0aW5nSG9vayA9IGN0eC50YWJsZS5ob29rLmRlbGV0aW5nLmZpcmUsXG4gICAgICAvL2hhc0RlbGV0ZUhvb2sgPSBkZWxldGluZ0hvb2sgIT09IG5vcDtcbiAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgIChjdHguaXNQcmltS2V5IHx8IHJhbmdlLnR5cGUgPT09IERCQ29yZVJhbmdlVHlwZS5BbnkpKSAvLyBpZiBubyByYW5nZSwgd2UnbGwgdXNlIGNsZWFyKCkuXG4gICAge1xuICAgICAgLy8gTWF5IHVzZSBJREJPYmplY3RTdG9yZS5kZWxldGUoSURCS2V5UmFuZ2UpIGluIHRoaXMgY2FzZSAoSXNzdWUgIzIwOClcbiAgICAgIC8vIEZvciBjaHJvbWl1bSwgdGhpcyBpcyB0aGUgd2F5IG1vc3Qgb3B0aW1pemVkIHZlcnNpb24uXG4gICAgICAvLyBGb3IgSUUvRWRnZSwgdGhpcyBjb3VsZCBoYW5nIHRoZSBpbmRleGVkREIgZW5naW5lIGFuZCBtYWtlIG9wZXJhdGluZyBzeXN0ZW0gaW5zdGFibGVcbiAgICAgIC8vIChodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kZmFobGFuZGVyLzVhMzkzMjhmMDI5ZGUxODIyMmNmMjEyNWQ1NmMzOGY3KVxuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKHRyYW5zID0+IHtcbiAgICAgICAgLy8gT3VyIEFQSSBjb250cmFjdCBpcyB0byByZXR1cm4gYSBjb3VudCBvZiBkZWxldGVkIGl0ZW1zLCBzbyB3ZSBoYXZlIHRvIGNvdW50KCkgYmVmb3JlIGRlbGV0ZSgpLlxuICAgICAgICBjb25zdCB7cHJpbWFyeUtleX0gPSBjdHgudGFibGUuY29yZS5zY2hlbWE7XG4gICAgICAgIGNvbnN0IGNvcmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUuY291bnQoe3RyYW5zLCBxdWVyeToge2luZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogY29yZVJhbmdlfX0pLnRoZW4oY291bnQgPT4ge1xuICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5tdXRhdGUoe3RyYW5zLCB0eXBlOiAnZGVsZXRlUmFuZ2UnLCByYW5nZTogY29yZVJhbmdlfSlcbiAgICAgICAgICAudGhlbigoe2ZhaWx1cmVzLCBsYXN0UmVzdWx0LCByZXN1bHRzLCBudW1GYWlsdXJlc30pID0+IHtcbiAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcykgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiQ291bGQgbm90IGRlbGV0ZSBzb21lIHZhbHVlc1wiLFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKHBvcyA9PiBmYWlsdXJlc1twb3NdKSxcbiAgICAgICAgICAgICAgY291bnQgLSBudW1GYWlsdXJlcyk7XG4gICAgICAgICAgICByZXR1cm4gY291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tb2RpZnkoZGVsZXRlQ2FsbGJhY2spO1xuICB9XG59XG5cbmNvbnN0IGRlbGV0ZUNhbGxiYWNrID0gKHZhbHVlLCBjdHgpID0+IGN0eC52YWx1ZSA9IG51bGw7XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi8uLi9jbGFzc2VzL2RleGllJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBXaGVyZUNsYXVzZSB9IGZyb20gJy4uL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UnO1xuaW1wb3J0IHsgQW55UmFuZ2UgfSBmcm9tICcuLi8uLi9kYmNvcmUva2V5cmFuZ2UnO1xuaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IG1pcnJvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuXG4vKiogQ29uc3RydWN0cyBhIENvbGxlY3Rpb24gaW5zdGFuY2UuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbGxlY3Rpb25Db25zdHJ1Y3RvciB7XG4gIG5ldyh3aGVyZUNsYXVzZT86IFdoZXJlQ2xhdXNlIHwgbnVsbCwga2V5UmFuZ2VHZW5lcmF0b3I/OiAoKSA9PiBEQkNvcmVLZXlSYW5nZSk6IENvbGxlY3Rpb247XG4gIHByb3RvdHlwZTogQ29sbGVjdGlvbjtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIENvbGxlY3Rpb24gY29uc3RydWN0b3IgYm91bmQgdG8gZ2l2ZW4gRGV4aWUgaW5zdGFuY2UuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IoZGI6IERleGllKSB7XG4gIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcjxDb2xsZWN0aW9uQ29uc3RydWN0b3I+KFxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLFxuXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbihcbiAgICAgIHRoaXM6IENvbGxlY3Rpb24sXG4gICAgICB3aGVyZUNsYXVzZT86IFdoZXJlQ2xhdXNlIHwgbnVsbCxcbiAgICAgIGtleVJhbmdlR2VuZXJhdG9yPzogKCkgPT4gREJDb3JlS2V5UmFuZ2UpXG4gICAge1xuICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgbGV0IGtleVJhbmdlID0gQW55UmFuZ2UsIGVycm9yID0gbnVsbDtcbiAgICAgIGlmIChrZXlSYW5nZUdlbmVyYXRvcikgdHJ5IHtcbiAgICAgICAga2V5UmFuZ2UgPSBrZXlSYW5nZUdlbmVyYXRvcigpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2hlcmVDdHggPSB3aGVyZUNsYXVzZS5fY3R4O1xuICAgICAgY29uc3QgdGFibGUgPSB3aGVyZUN0eC50YWJsZTtcbiAgICAgIGNvbnN0IHJlYWRpbmdIb29rID0gdGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG4gICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgaW5kZXg6IHdoZXJlQ3R4LmluZGV4LFxuICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgcmFuZ2U6IGtleVJhbmdlLFxuICAgICAgICBrZXlzT25seTogZmFsc2UsXG4gICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgIHVuaXF1ZTogXCJcIixcbiAgICAgICAgYWxnb3JpdGhtOiBudWxsLFxuICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgIHJlcGxheUZpbHRlcjogbnVsbCxcbiAgICAgICAganVzdExpbWl0OiB0cnVlLCAvLyBUcnVlIGlmIGEgcmVwbGF5RmlsdGVyIGlzIGp1c3QgYSBmaWx0ZXIgdGhhdCBwZXJmb3JtcyBhIFwibGltaXRcIiBvcGVyYXRpb24gKG9yIG5vbmUgYXQgYWxsKVxuICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxpbWl0OiBJbmZpbml0eSxcbiAgICAgICAgZXJyb3I6IGVycm9yLCAvLyBJZiBzZXQsIGFueSBwcm9taXNlIG11c3QgYmUgcmVqZWN0ZWQgd2l0aCB0aGlzIGVycm9yXG4gICAgICAgIG9yOiB3aGVyZUN0eC5vcixcbiAgICAgICAgdmFsdWVNYXBwZXI6IHJlYWRpbmdIb29rICE9PSBtaXJyb3IgPyByZWFkaW5nSG9vayA6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICApO1xufVxuIiwgImltcG9ydCB7IEluZGV4YWJsZVR5cGUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvaW5kZXhhYmxlLXR5cGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cbiIsICJpbXBvcnQgeyBXaGVyZUNsYXVzZSB9IGZyb20gJy4vd2hlcmUtY2xhdXNlJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IFNUUklOR19FWFBFQ1RFRCB9IGZyb20gJy4uLy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IHNpbXBsZUNvbXBhcmUsIHNpbXBsZUNvbXBhcmVSZXZlcnNlIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NvbXBhcmUtZnVuY3Rpb25zJztcbmltcG9ydCB7IEluZGV4YWJsZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMnO1xuaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UsIERCQ29yZVJhbmdlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZmFpbChjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTogQ29sbGVjdGlvbiB8IFdoZXJlQ2xhdXNlLCBlcnIsIFQ/KSB7XG4gIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG4gICAgICBuZXcgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UuQ29sbGVjdGlvbiAoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcbiAgICAgIGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlO1xuICAgICAgXG4gIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5Q29sbGVjdGlvbih3aGVyZUNsYXVzZTogV2hlcmVDbGF1c2UpIHtcbiAgcmV0dXJuIG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uICh3aGVyZUNsYXVzZSwgKCkgPT4gcmFuZ2VFcXVhbChcIlwiKSkubGltaXQoMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cHBlckZhY3RvcnkoZGlyOiAnbmV4dCcgfCAncHJldicpIHtcbiAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgIChzOiBzdHJpbmcpID0+IHMudG9VcHBlckNhc2UoKSA6XG4gICAgKHM6IHN0cmluZykgPT4gcy50b0xvd2VyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcjogJ25leHQnIHwgJ3ByZXYnKSB7XG4gIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAoczogc3RyaW5nKSA9PiBzLnRvTG93ZXJDYXNlKCkgOlxuICAgIChzOiBzdHJpbmcpID0+IHMudG9VcHBlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGUsIGxvd2VyTmVlZGxlLCBjbXAsIGRpcikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oa2V5Lmxlbmd0aCwgbG93ZXJOZWVkbGUubGVuZ3RoKTtcbiAgdmFyIGxscCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbHdyS2V5Q2hhciA9IGxvd2VyS2V5W2ldO1xuICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG4gICAgICAgICAgaWYgKGNtcChrZXlbaV0sIHVwcGVyTmVlZGxlW2ldKSA8IDApIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgdXBwZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKSByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIGxvd2VyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICBpZiAobGxwID49IDApIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMCkgbGxwID0gaTtcbiAgfVxuICBpZiAobGVuZ3RoIDwgbG93ZXJOZWVkbGUubGVuZ3RoICYmIGRpciA9PT0gXCJuZXh0XCIpIHJldHVybiBrZXkgKyB1cHBlck5lZWRsZS5zdWJzdHIoa2V5Lmxlbmd0aCk7XG4gIGlmIChsZW5ndGggPCBrZXkubGVuZ3RoICYmIGRpciA9PT0gXCJwcmV2XCIpIHJldHVybiBrZXkuc3Vic3RyKDAsIHVwcGVyTmVlZGxlLmxlbmd0aCk7XG4gIHJldHVybiAobGxwIDwgMCA/IG51bGwgOiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlck5lZWRsZVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlLCBtYXRjaCwgbmVlZGxlcywgc3VmZml4KSB7XG4gIC8vLyA8cGFyYW0gbmFtZT1cIm5lZWRsZXNcIiB0eXBlPVwiQXJyYXlcIiBlbGVtZW50VHlwZT1cIlN0cmluZ1wiPjwvcGFyYW0+XG4gIHZhciB1cHBlciwgbG93ZXIsIGNvbXBhcmUsIHVwcGVyTmVlZGxlcywgbG93ZXJOZWVkbGVzLCBkaXJlY3Rpb24sIG5leHRLZXlTdWZmaXgsXG4gICAgICBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG4gIGlmICghbmVlZGxlcy5ldmVyeShzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHJldHVybiBmYWlsKHdoZXJlQ2xhdXNlLCBTVFJJTkdfRVhQRUNURUQpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICB1cHBlciA9IHVwcGVyRmFjdG9yeShkaXIpO1xuICAgICAgbG93ZXIgPSBsb3dlckZhY3RvcnkoZGlyKTtcbiAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG4gICAgICB2YXIgbmVlZGxlQm91bmRzID0gbmVlZGxlcy5tYXAoZnVuY3Rpb24gKG5lZWRsZSl7XG4gICAgICAgICAgcmV0dXJuIHtsb3dlcjogbG93ZXIobmVlZGxlKSwgdXBwZXI6IHVwcGVyKG5lZWRsZSl9O1xuICAgICAgfSkuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgIH0pO1xuICAgICAgdXBwZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuICAgICAgbG93ZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpeyByZXR1cm4gbmIubG93ZXI7IH0pO1xuICAgICAgZGlyZWN0aW9uID0gZGlyO1xuICAgICAgbmV4dEtleVN1ZmZpeCA9IChkaXIgPT09IFwibmV4dFwiID8gXCJcIiA6IHN1ZmZpeCk7XG4gIH1cbiAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG5cbiAgdmFyIGMgPSBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbiAoXG4gICAgICB3aGVyZUNsYXVzZSxcbiAgICAgICgpPT5jcmVhdGVSYW5nZSh1cHBlck5lZWRsZXNbMF0sIGxvd2VyTmVlZGxlc1tuZWVkbGVzTGVuLTFdICsgc3VmZml4KVxuICApO1xuXG4gIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgLy8gVGhpcyBldmVudCBvbmx5cyBvY2N1ciBiZWZvcmUgZmlsdGVyIGlzIGNhbGxlZCB0aGUgZmlyc3QgdGltZS5cbiAgICAgIGluaXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IDA7XG5cbiAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImN1cnNvclwiIHR5cGU9XCJJREJDdXJzb3JcIj48L3BhcmFtPlxuICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWR2YW5jZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXNvbHZlXCIgdHlwZT1cIkZ1bmN0aW9uXCI+PC9wYXJhbT5cbiAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbG93ZXJLZXkgPSBsb3dlcihrZXkpO1xuICAgICAgaWYgKG1hdGNoKGxvd2VyS2V5LCBsb3dlck5lZWRsZXMsIGZpcnN0UG9zc2libGVOZWVkbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaT1maXJzdFBvc3NpYmxlTmVlZGxlOyBpPG5lZWRsZXNMZW47ICsraSkge1xuICAgICAgICAgICAgICB2YXIgY2FzaW5nID0gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZXNbaV0sIGxvd2VyTmVlZGxlc1tpXSwgY29tcGFyZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKGNhc2luZyA9PT0gbnVsbCAmJiBsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIGZpcnN0UG9zc2libGVOZWVkbGUgPSBpICsgMTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwgfHwgY29tcGFyZShsb3dlc3RQb3NzaWJsZUNhc2luZywgY2FzaW5nKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gY2FzaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICsgbmV4dEtleVN1ZmZpeCk7IH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfSk7XG4gIHJldHVybiBjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmFuZ2UgKGxvd2VyOiBJbmRleGFibGVUeXBlLCB1cHBlcjogSW5kZXhhYmxlVHlwZSwgbG93ZXJPcGVuPzogYm9vbGVhbiwgdXBwZXJPcGVuPzogYm9vbGVhbik6IERCQ29yZUtleVJhbmdlIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuUmFuZ2UsXG4gICAgICAgIGxvd2VyLFxuICAgICAgICB1cHBlcixcbiAgICAgICAgbG93ZXJPcGVuLFxuICAgICAgICB1cHBlck9wZW5cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VFcXVhbCAodmFsdWU6IEluZGV4YWJsZVR5cGUpIDogREJDb3JlS2V5UmFuZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IERCQ29yZVJhbmdlVHlwZS5FcXVhbCxcbiAgICAgICAgbG93ZXI6IHZhbHVlLFxuICAgICAgICB1cHBlcjogdmFsdWVcbiAgICB9O1xufVxuIiwgImltcG9ydCB7IFdoZXJlQ2xhdXNlIGFzIElXaGVyZUNsYXVzZSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvd2hlcmUtY2xhdXNlXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSBcIi4uL2NvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSBcIi4uL3RhYmxlXCI7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZVwiO1xuaW1wb3J0IHsgZW1wdHlDb2xsZWN0aW9uLCBmYWlsLCBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtLCBjcmVhdGVSYW5nZSwgcmFuZ2VFcXVhbCB9IGZyb20gJy4vd2hlcmUtY2xhdXNlLWhlbHBlcnMnO1xuaW1wb3J0IHsgSU5WQUxJRF9LRVlfQVJHVU1FTlQsIFNUUklOR19FWFBFQ1RFRCwgbWF4U3RyaW5nLCBtaW5LZXkgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRBcnJheU9mLCBOT19DSEFSX0FSUkFZIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIGFzIElDb2xsZWN0aW9ufSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2NvbGxlY3Rpb25cIjtcblxuLyoqIGNsYXNzIFdoZXJlQ2xhdXNlXG4gKiBcbiAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2VcbiAqL1xuZXhwb3J0IGNsYXNzIFdoZXJlQ2xhdXNlIGltcGxlbWVudHMgSVdoZXJlQ2xhdXNlIHtcbiAgZGI6IERleGllO1xuICBfSURCS2V5UmFuZ2U6IHR5cGVvZiBJREJLZXlSYW5nZTtcbiAgX2N0eDoge1xuICAgIHRhYmxlOiBUYWJsZTtcbiAgICBpbmRleDogc3RyaW5nO1xuICAgIG9yOiBDb2xsZWN0aW9uO1xuICB9XG4gIF9jbXA6IChhOiBJbmRleGFibGVUeXBlLCBiOiBJbmRleGFibGVUeXBlKSA9PiBudW1iZXI7XG4gIF9hc2NlbmRpbmc6IChhOiBJbmRleGFibGVUeXBlLCBiOiBJbmRleGFibGVUeXBlKSA9PiBudW1iZXI7XG4gIF9kZXNjZW5kaW5nOiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gbnVtYmVyO1xuICBfbWluOiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gSW5kZXhhYmxlVHlwZTtcbiAgX21heDogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IEluZGV4YWJsZVR5cGU7XG5cbiAgZ2V0IENvbGxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eC50YWJsZS5kYi5Db2xsZWN0aW9uO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmJldHdlZW4oKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5iZXR3ZWVuKClcbiAgICogXG4gICAqKi9cbiAgYmV0d2Vlbihsb3dlcjogSW5kZXhhYmxlVHlwZSwgdXBwZXI6IEluZGV4YWJsZVR5cGUsIGluY2x1ZGVMb3dlcj86IGJvb2xlYW4sIGluY2x1ZGVVcHBlcj86IGJvb2xlYW4pIHtcbiAgICBpbmNsdWRlTG93ZXIgPSBpbmNsdWRlTG93ZXIgIT09IGZhbHNlOyAgIC8vIERlZmF1bHQgdG8gdHJ1ZVxuICAgIGluY2x1ZGVVcHBlciA9IGluY2x1ZGVVcHBlciA9PT0gdHJ1ZTsgICAgLy8gRGVmYXVsdCB0byBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBpZiAoKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID4gMCkgfHxcbiAgICAgICAgKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID09PSAwICYmIChpbmNsdWRlTG93ZXIgfHwgaW5jbHVkZVVwcGVyKSAmJiAhKGluY2x1ZGVMb3dlciAmJiBpbmNsdWRlVXBwZXIpKSlcbiAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTsgLy8gV29ya2Fyb3VuZCBmb3IgaWRpb3RpYyBXM0MgU3BlY2lmaWNhdGlvbiB0aGF0IERhdGFFcnJvciBtdXN0IGJlIHRocm93biBpZiBsb3dlciA+IHVwcGVyLiBUaGUgbmF0dXJhbCByZXN1bHQgd291bGQgYmUgdG8gcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb24uXG4gICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKT0+Y3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCAhaW5jbHVkZUxvd2VyLCAhaW5jbHVkZVVwcGVyKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5lcXVhbHMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5lcXVhbHMoKVxuICAgKiBcbiAgICoqL1xuICBlcXVhbHModmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IHJhbmdlRXF1YWwodmFsdWUpKSBhcyBJQ29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5hYm92ZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmFib3ZlKClcbiAgICogXG4gICAqKi9cbiAgYWJvdmUodmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIHRydWUpKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5hYm92ZU9yRXF1YWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5hYm92ZU9yRXF1YWwoKVxuICAgKiBcbiAgICoqL1xuICBhYm92ZU9yRXF1YWwodmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIGZhbHNlKSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYmVsb3coKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5iZWxvdygpXG4gICAqIFxuICAgKiovXG4gIGJlbG93KHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmJlbG93T3JFcXVhbCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmJlbG93T3JFcXVhbCgpXG4gICAqIFxuICAgKiovXG4gIGJlbG93T3JFcXVhbCh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSkpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLnN0YXJ0c1dpdGgoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5zdGFydHNXaXRoKClcbiAgICogXG4gICAqKi9cbiAgc3RhcnRzV2l0aChzdHI6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhaWwodGhpcywgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKHN0ciwgc3RyICsgbWF4U3RyaW5nLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5zdGFydHNXaXRoSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLnN0YXJ0c1dpdGhJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgc3RhcnRzV2l0aElnbm9yZUNhc2Uoc3RyOiBzdHJpbmcpIHtcbiAgICBpZiAoc3RyID09PSBcIlwiKSByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IHguaW5kZXhPZihhWzBdKSA9PT0gMCwgW3N0cl0sIG1heFN0cmluZyk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuZXF1YWxzSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmVxdWFsc0lnbm9yZUNhc2UoKVxuICAgKiBcbiAgICoqL1xuICBlcXVhbHNJZ25vcmVDYXNlKHN0cjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IHggPT09IGFbMF0sIFtzdHJdLCBcIlwiKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5hbnlPZklnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5hbnlPZklnbm9yZUNhc2UoKVxuICAgKiBcbiAgICoqL1xuICBhbnlPZklnbm9yZUNhc2UoLi4udmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIGFueU9mSWdub3JlQ2FzZSh2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgYW55T2ZJZ25vcmVDYXNlKCkge1xuICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgaWYgKHNldC5sZW5ndGggPT09IDApIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IGEuaW5kZXhPZih4KSAhPT0gLTEsIHNldCwgXCJcIik7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLnN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoKVxuICAgKiBcbiAgICoqL1xuICBzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKC4uLnZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKHZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKCkge1xuICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgaWYgKHNldC5sZW5ndGggPT09IDApIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IGEuc29tZShuID0+IHguaW5kZXhPZihuKSA9PT0gMCksIHNldCwgbWF4U3RyaW5nKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5hbnlPZigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmFueU9mKClcbiAgICogXG4gICAqKi9cbiAgYW55T2YoLi4udmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIGFueU9mKHZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBhbnlPZigpIHtcbiAgICBjb25zdCBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgbGV0IGNvbXBhcmUgPSB0aGlzLl9jbXA7XG4gICAgdHJ5IHsgc2V0LnNvcnQoY29tcGFyZSk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpOyB9XG4gICAgaWYgKHNldC5sZW5ndGggPT09IDApIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgY29uc3QgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2Uoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKSk7XG5cbiAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGRpcmVjdGlvbiA9PiB7XG4gICAgICBjb21wYXJlID0gKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIgP1xuICAgICAgICB0aGlzLl9hc2NlbmRpbmcgOlxuICAgICAgICB0aGlzLl9kZXNjZW5kaW5nKTtcbiAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgIH07XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgYy5fYWRkQWxnb3JpdGhtKChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG4gICAgICB3aGlsZSAoY29tcGFyZShrZXksIHNldFtpXSkgPiAwKSB7XG4gICAgICAgIC8vIFRoZSBjdXJzb3IgaGFzIHBhc3NlZCBiZXlvbmQgdGhpcyBrZXkuIENoZWNrIG5leHQuXG4gICAgICAgICsraTtcbiAgICAgICAgaWYgKGkgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXh0LiBTdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGN1cnNvciB2YWx1ZSBzaG91bGQgYmUgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjb250aW51ZSBhIHNpbmdsZSBzdGVwIGluIGNhc2UgbmV4dCBpdGVtIGhhcyB0aGUgc2FtZSBrZXkgb3IgcG9zc2libHkgb3VyIG5leHQga2V5IGluIHNldC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjdXJzb3Iua2V5IG5vdCB5ZXQgYXQgc2V0W2ldLiBGb3J3YXJkIGN1cnNvciB0byB0aGUgbmV4dCBrZXkgdG8gaHVudCBmb3IuXG4gICAgICAgIGFkdmFuY2UoKCkgPT4geyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5ub3RFcXVhbCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLm5vdEVxdWFsKClcbiAgICogXG4gICAqKi9cbiAgbm90RXF1YWwodmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKFtbbWluS2V5LCB2YWx1ZV0sIFt2YWx1ZSwgdGhpcy5kYi5fbWF4S2V5XV0sIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLm5vbmVPZigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLm5vbmVPZigpXG4gICAqIFxuICAgKiovXG4gIG5vbmVPZiguLi52YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgbm9uZU9mKHZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBub25lT2YoKSB7XG4gICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzKTsgLy8gUmV0dXJuIGVudGlyZSBjb2xsZWN0aW9uLlxuICAgIHRyeSB7IHNldC5zb3J0KHRoaXMuX2FzY2VuZGluZyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpOyB9XG4gICAgLy8gVHJhbnNmb3JtIFtcImFcIixcImJcIixcImNcIl0gdG8gYSBzZXQgb2YgcmFuZ2VzIGZvciBiZXR3ZWVuL2Fib3ZlL2JlbG93OiBbW21pbktleSxcImFcIl0sIFtcImFcIixcImJcIl0sIFtcImJcIixcImNcIl0sIFtcImNcIixtYXhLZXldXVxuICAgIGNvbnN0IHJhbmdlcyA9IHNldC5yZWR1Y2UoXG4gICAgICAocmVzLCB2YWwpID0+IHJlcyA/XG4gICAgICAgIHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOlxuICAgICAgICBbW21pbktleSwgdmFsXV0sXG4gICAgICBudWxsKTtcbiAgICByYW5nZXMucHVzaChbc2V0W3NldC5sZW5ndGggLSAxXSwgdGhpcy5kYi5fbWF4S2V5XSk7XG4gICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShyYW5nZXMsIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmluQW55UmFuZ2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5pbkFueVJhbmdlKClcbiAgICogXG4gICAqKi9cbiAgaW5BbnlSYW5nZShcbiAgICByYW5nZXM6IFJlYWRvbmx5QXJyYXk8eyAwOiBJbmRleGFibGVUeXBlLCAxOiBJbmRleGFibGVUeXBlIH0+LFxuICAgIG9wdGlvbnM/OiB7IGluY2x1ZGVMb3dlcnM/OiBib29sZWFuLCBpbmNsdWRlVXBwZXJzPzogYm9vbGVhbiB9KVxuICB7XG4gICAgY29uc3QgY21wID0gdGhpcy5fY21wLFxuICAgICAgICAgIGFzY2VuZGluZyA9IHRoaXMuX2FzY2VuZGluZyxcbiAgICAgICAgICBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZyxcbiAgICAgICAgICBtaW4gPSB0aGlzLl9taW4sXG4gICAgICAgICAgbWF4ID0gdGhpcy5fbWF4O1xuXG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgaWYgKCFyYW5nZXMuZXZlcnkocmFuZ2UgPT5cbiAgICAgIHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHJhbmdlWzFdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGFzY2VuZGluZyhyYW5nZVswXSwgcmFuZ2VbMV0pIDw9IDApKSB7XG4gICAgICByZXR1cm4gZmFpbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJGaXJzdCBhcmd1bWVudCB0byBpbkFueVJhbmdlKCkgbXVzdCBiZSBhbiBBcnJheSBvZiB0d28tdmFsdWUgQXJyYXlzIFtsb3dlcix1cHBlcl0gd2hlcmUgdXBwZXIgbXVzdCBub3QgYmUgbG93ZXIgdGhhbiBsb3dlclwiLFxuICAgICAgICBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlOyAgIC8vIERlZmF1bHQgdG8gdHJ1ZVxuICAgIGNvbnN0IGluY2x1ZGVVcHBlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVVwcGVycyA9PT0gdHJ1ZTsgICAgLy8gRGVmYXVsdCB0byBmYWxzZVxuXG4gICAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2VzLCBuZXdSYW5nZSkge1xuICAgICAgbGV0IGkgPSAwLCBsID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICBpZiAoY21wKG5ld1JhbmdlWzBdLCByYW5nZVsxXSkgPCAwICYmIGNtcChuZXdSYW5nZVsxXSwgcmFuZ2VbMF0pID4gMCkge1xuICAgICAgICAgIHJhbmdlWzBdID0gbWluKHJhbmdlWzBdLCBuZXdSYW5nZVswXSk7XG4gICAgICAgICAgcmFuZ2VbMV0gPSBtYXgocmFuZ2VbMV0sIG5ld1JhbmdlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcbiAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuXG4gICAgbGV0IHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgZnVuY3Rpb24gcmFuZ2VTb3J0ZXIoYSwgYikgeyByZXR1cm4gc29ydERpcmVjdGlvbihhWzBdLCBiWzBdKTsgfVxuXG4gICAgLy8gSm9pbiBvdmVybGFwcGluZyByYW5nZXNcbiAgICBsZXQgc2V0O1xuICAgIHRyeSB7XG4gICAgICBzZXQgPSByYW5nZXMucmVkdWNlKGFkZFJhbmdlLCBbXSk7XG4gICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICB9XG5cbiAgICBsZXQgcmFuZ2VQb3MgPSAwO1xuICAgIGNvbnN0IGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG4gICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPiAwIDpcbiAgICAgIGtleSA9PiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+PSAwO1xuXG4gICAgY29uc3Qga2V5SXNCZWZvcmVDdXJyZW50RW50cnkgPSBpbmNsdWRlTG93ZXJzID9cbiAgICAgIGtleSA9PiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPiAwIDpcbiAgICAgIGtleSA9PiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPj0gMDtcblxuICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcbiAgICAgIHJldHVybiAha2V5SXNCZXlvbmRDdXJyZW50RW50cnkoa2V5KSAmJiAha2V5SXNCZWZvcmVDdXJyZW50RW50cnkoa2V5KTtcbiAgICB9XG5cbiAgICBsZXQgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcblxuICAgIGNvbnN0IGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKFxuICAgICAgdGhpcyxcbiAgICAgICgpID0+IGNyZWF0ZVJhbmdlKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKSk7XG5cbiAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGRpcmVjdGlvbiA9PiB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcIm5leHRcIikge1xuICAgICAgICBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgc29ydERpcmVjdGlvbiA9IGRlc2NlbmRpbmc7XG4gICAgICB9XG4gICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgfTtcblxuICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgIHdoaWxlIChjaGVja0tleShrZXkpKSB7XG4gICAgICAgIC8vIFRoZSBjdXJzb3IgaGFzIHBhc3NlZCBiZXlvbmQgdGhpcyBrZXkuIENoZWNrIG5leHQuXG4gICAgICAgICsrcmFuZ2VQb3M7XG4gICAgICAgIGlmIChyYW5nZVBvcyA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5leHQuIFN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkpIHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgY3Vyc29yIHZhbHVlIHNob3VsZCBiZSBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNvbnRpbnVlIGEgc2luZ2xlIHN0ZXAgaW4gY2FzZSBuZXh0IGl0ZW0gaGFzIHRoZSBzYW1lIGtleSBvciBwb3NzaWJseSBvdXIgbmV4dCBrZXkgaW4gc2V0LlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPT09IDAgfHwgdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPT09IDApIHtcbiAgICAgICAgLy8gaW5jbHVkZVVwcGVyIG9yIGluY2x1ZGVMb3dlciBpcyBmYWxzZSBzbyBrZXlXaXRoaW5DdXJyZW50UmFuZ2UoKSByZXR1cm5zIGZhbHNlIGV2ZW4gdGhvdWdoIHdlIGFyZSBhdCByYW5nZSBib3JkZXIuXG4gICAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQga2V5IGJ1dCBkb24ndCBpbmNsdWRlIHRoaXMgb25lLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjdXJzb3Iua2V5IG5vdCB5ZXQgYXQgc2V0W2ldLiBGb3J3YXJkIGN1cnNvciB0byB0aGUgbmV4dCBrZXkgdG8gaHVudCBmb3IuXG4gICAgICAgIGFkdmFuY2UoKCkgPT4ge1xuICAgICAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSBhc2NlbmRpbmcpIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzBdKTtcbiAgICAgICAgICBlbHNlIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5zdGFydHNXaXRoQW55T2YoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5zdGFydHNXaXRoQW55T2YoKVxuICAgKiBcbiAgICoqL1xuICBzdGFydHNXaXRoQW55T2YoLi4ucHJlZml4ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgc3RhcnRzV2l0aEFueU9mKHByZWZpeGVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIHN0YXJ0c1dpdGhBbnlPZigpIHtcbiAgICBjb25zdCBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoIXNldC5ldmVyeShzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJzdGFydHNXaXRoQW55T2YoKSBvbmx5IHdvcmtzIHdpdGggc3RyaW5nc1wiKTtcbiAgICB9XG4gICAgaWYgKHNldC5sZW5ndGggPT09IDApIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHNldC5tYXAoKHN0cjogc3RyaW5nKSA9PiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddKSk7XG4gIH1cblxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBXaGVyZUNsYXVzZSB9IGZyb20gJy4vd2hlcmUtY2xhdXNlJztcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi4vdGFibGUnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY21wJztcblxuZXhwb3J0IGludGVyZmFjZSBXaGVyZUNsYXVzZUNvbnN0cnVjdG9yIHtcbiAgbmV3KHRhYmxlOiBUYWJsZSwgaW5kZXg/OiBzdHJpbmcsIG9yQ29sbGVjdGlvbj86IENvbGxlY3Rpb24pOiBXaGVyZUNsYXVzZTtcbiAgcHJvdG90eXBlOiBXaGVyZUNsYXVzZTtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIFdoZXJlQ2xhdXNlIGNvbnN0cnVjdG9yLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYjogRGV4aWUpIHtcbiAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yPFdoZXJlQ2xhdXNlQ29uc3RydWN0b3I+KFxuICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZSxcblxuICAgIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRoaXM6IFdoZXJlQ2xhdXNlLCB0YWJsZTogVGFibGUsIGluZGV4Pzogc3RyaW5nLCBvckNvbGxlY3Rpb24/OiBDb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgaW5kZXg6IGluZGV4ID09PSBcIjppZFwiID8gbnVsbCA6IGluZGV4LFxuICAgICAgICBvcjogb3JDb2xsZWN0aW9uXG4gICAgICB9O1xuICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gY21wO1xuICAgICAgdGhpcy5fZGVzY2VuZGluZyA9IChhLCBiKSA9PiBjbXAoYiwgYSk7XG4gICAgICB0aGlzLl9tYXggPSAoYSwgYikgPT4gY21wKGEsYikgPiAwID8gYSA6IGI7XG4gICAgICB0aGlzLl9taW4gPSAoYSwgYikgPT4gY21wKGEsYikgPCAwID8gYSA6IGI7XG4gICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuICAgICAgaWYgKCF0aGlzLl9JREJLZXlSYW5nZSkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgIH1cbiAgKTtcbn1cbiIsICJpbXBvcnQgeyB3cmFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgIHJlamVjdCAoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVudFN1Y2Nlc3NIYW5kbGVyIChyZXNvbHZlKSB7XG4gIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCl7XG4gICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciAocmVqZWN0KSB7XG4gIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gU2VlIGNvbW1lbnQgb24gaG9va2VkRXZlbnRTdWNjZXNzSGFuZGxlcigpIHdoeSB3cmFwKCkgaXMgbmVlZGVkIG9ubHkgd2hlbiBzdXBwb3J0aW5nIGhvb2tzLlxuICAgICAgXG4gICAgICB2YXIgcmVxID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICAgIGVyciA9IHJlcS5lcnJvcixcbiAgICAgICAgICBjdHggPSByZXEuX2hvb2tDdHgsLy8gQ29udGFpbnMgdGhlIGhvb2sgZXJyb3IgaGFuZGxlci4gUHV0IGhlcmUgaW5zdGVhZCBvZiBjbG9zdXJlIHRvIGJvb3N0IHBlcmZvcm1hbmNlLlxuICAgICAgICAgIGhvb2tFcnJvckhhbmRsZXIgPSBjdHggJiYgY3R4Lm9uZXJyb3I7XG4gICAgICBob29rRXJyb3JIYW5kbGVyICYmIGhvb2tFcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgIHJlamVjdCAoZXJyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKHJlc29sdmUpIHtcbiAgLy8gd3JhcCgpIGlzIG5lZWRlZCB3aGVuIGNhbGxpbmcgaG9va3MgYmVjYXVzZSB0aGUgcmFyZSBzY2VuYXJpbyBvZjpcbiAgLy8gICogaG9vayBkb2VzIGEgZGIgb3BlcmF0aW9uIHRoYXQgZmFpbHMgaW1tZWRpYXRlbHkgKElEQiB0aHJvd3MgZXhjZXB0aW9uKVxuICAvLyAgICBGb3IgY2FsbGluZyBkYiBvcGVyYXRpb25zIG9uIGNvcnJlY3QgdHJhbnNhY3Rpb24sIHdyYXAgbWFrZXMgc3VyZSB0byBzZXQgUFNEIGNvcnJlY3RseS5cbiAgLy8gICAgd3JhcCgpIHdpbGwgYWxzbyBleGVjdXRlIGluIGEgdmlydHVhbCB0aWNrLlxuICAvLyAgKiBJZiBub3Qgd3JhcHBlZCBpbiBhIHZpcnR1YWwgdGljaywgZGlyZWN0IGV4Y2VwdGlvbiB3aWxsIGxhdW5jaCBhIG5ldyBwaHlzaWNhbCB0aWNrLlxuICAvLyAgKiBJZiB0aGlzIHdhcyB0aGUgbGFzdCBldmVudCBpbiB0aGUgYnVsaywgdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIGFmdGVyIGEgcGh5c2ljYWwgdGlja1xuICAvLyAgICBhbmQgdGhlIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZSBjb21taXR0ZWQgYWxyZWFkeS5cbiAgLy8gSWYgbm8gaG9vaywgdGhlIHZpcnR1YWwgdGljayB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSByZWplY3QoKS9yZXNvbHZlIG9mIHRoZSBmaW5hbCBwcm9taXNlLFxuICAvLyBiZWNhdXNlIGl0IGlzIGFsd2F5cyBtYXJrZWQgd2l0aCBfbGliID0gdHJ1ZSB3aGVuIGNyZWF0ZWQgdXNpbmcgVHJhbnNhY3Rpb24uX3Byb21pc2UoKS5cbiAgcmV0dXJuIHdyYXAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgY3R4ID0gcmVxLl9ob29rQ3R4LC8vIENvbnRhaW5zIHRoZSBob29rIGVycm9yIGhhbmRsZXIuIFB1dCBoZXJlIGluc3RlYWQgb2YgY2xvc3VyZSB0byBib29zdCBwZXJmb3JtYW5jZS5cbiAgICAgICAgICByZXN1bHQgPSBjdHgudmFsdWUgfHwgcmVxLnJlc3VsdCwgLy8gUGFzcyB0aGUgb2JqZWN0IHZhbHVlIG9uIHVwZGF0ZXMuIFRoZSByZXN1bHQgZnJvbSBJREIgaXMgdGhlIHByaW1hcnkga2V5LlxuICAgICAgICAgIGhvb2tTdWNjZXNzSGFuZGxlciA9IGN0eCAmJiBjdHgub25zdWNjZXNzO1xuICAgICAgaG9va1N1Y2Nlc3NIYW5kbGVyICYmIGhvb2tTdWNjZXNzSGFuZGxlcihyZXN1bHQpO1xuICAgICAgcmVzb2x2ZSAmJiByZXNvbHZlKHJlc3VsdCk7XG4gIH0sIHJlc29sdmUpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSAvLyBJbmRleGVkREJTaGltIGRvZXNudCBzdXBwb3J0IHRoaXMgb24gU2FmYXJpIDggYW5kIGJlbG93LlxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkgLy8gSW5kZXhlZERCU2hpbSBkb2VzbnQgc3VwcG9ydCB0aGlzIG9uIFNhZmFyaSA4IGFuZCBiZWxvdy5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBkb25lPywgc3VwcG9ydEhvb2tzPykge1xuICByZXR1cm4gKHN1cHBvcnRIb29rcyA/IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciA6IGV2ZW50UmVqZWN0SGFuZGxlcikoZSA9PiB7XG4gICAgICBlcnJvckxpc3QucHVzaChlKTtcbiAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9KTtcbn1cblxuIiwgImltcG9ydCBFdmVudHMgZnJvbSAnLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IHsgR2xvYmFsRGV4aWVFdmVudHMgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzJztcblxuZXhwb3J0IGNvbnN0IERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FID0gJ3N0b3JhZ2VtdXRhdGVkJyBhcyAnc3RvcmFnZW11dGF0ZWQnO1xuXG4vLyBOYW1lIG9mIHRoZSBnbG9iYWwgZXZlbnQgZmlyZWQgdXNpbmcgRE9NIGRpc3BhdGNoRXZlbnQgKGlmIG5vdCBpbiBub2RlKS5cbi8vIFJlYXNvbiBmb3IgcHJvcGFnYXRpbmcgdGhpcyBhcyBhIERPTSBldmVudCBpcyBmb3IgZ2V0dGluZyByZWFjdGl2aXR5IGFjcm9zc1xuLy8gbXVsdGlwbGUgdmVyc2lvbnMgb2YgRGV4aWUgd2l0aGluIHRoZSBzYW1lIGFwcCAoYXMgbG9uZyBhcyB0aGV5IGFyZVxuLy8gY29tcGF0aWJsZSB3aXRoIHJlZ2FyZHMgdG8gdGhlIGV2ZW50IGRhdGEpLlxuLy8gSWYgdGhlIE9ic2VydmFiaWxpdHlTZXQgcHJvdG9jb2wgY2hhbmdlIGluIGEgd2F5IHRoYXQgd291bGQgbm90IGJlIGJhY2t3YXJkXG4vLyBjb21wYXRpYmxlLCBtYWtlIHN1cmUgYWxzbyB1cGRhdGUgdGhlIGV2ZW50IG5hbWUgdG8gYSBuZXcgbnVtYmVyIGF0IHRoZSBlbmRcbi8vIHNvIHRoYXQgdHdvIERleGllIGluc3RhbmNlcyBvZiBkaWZmZXJlbnQgdmVyc2lvbnMgY29udGludWUgdG8gd29yayB0b2dldGhlclxuLy8gIC0gbWF5YmUgbm90IGFibGUgdG8gY29tbXVuaWNhdGUgYnV0IHdvbid0IGZhaWwgZHVlIHRvIHVuZXhwZWN0ZWQgZGF0YSBpblxuLy8gdGhlIGRldGFpbCBwcm9wZXJ0eSBvZiB0aGUgQ3VzdG9tRXZlbnQuIElmIHNvLCBhbHNvIG1ha2Ugc3VyZSB0byB1ZHBhdGVcbi8vIGRvY3MgYW5kIGV4cGxhaW4gYXQgd2hpY2ggRGV4aWUgdmVyc2lvbiB0aGUgbmV3IG5hbWUgYW5kIGZvcm1hdCBvZiB0aGUgZXZlbnRcbi8vIGlzIGJlaW5nIHVzZWQuXG5leHBvcnQgY29uc3QgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FID0gJ3gtc3RvcmFnZW11dGF0ZWQtMSc7XG5cbmV4cG9ydCBjb25zdCBnbG9iYWxFdmVudHMgPSBFdmVudHMobnVsbCwgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpIGFzIEdsb2JhbERleGllRXZlbnRzO1xuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uIGFzIElUcmFuc2FjdGlvbiB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBEZXhpZVByb21pc2UsIHdyYXAsIHJlamVjdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5pbXBvcnQgeyBhc3NlcnQsIGhhc093biB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBQU0QsIHVzZVBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgc2FmYXJpTXVsdGlTdG9yZUZpeCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IHsgbmV3U2NvcGUgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgRGVidWcgZnJvbSAnLi4vLi4vaGVscGVycy9kZWJ1Zyc7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gJy4uL3RhYmxlJztcbmltcG9ydCB7IGdsb2JhbEV2ZW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5cbi8qKiBUcmFuc2FjdGlvblxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RyYW5zYWN0aW9uL1RyYW5zYWN0aW9uXG4gKiBcbiAqKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiBpbXBsZW1lbnRzIElUcmFuc2FjdGlvbiB7XG4gIGRiOiBEZXhpZTtcbiAgYWN0aXZlOiBib29sZWFuO1xuICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGU7XG4gIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTogQ2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5O1xuICBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb247XG4gIHN0b3JlTmFtZXM6IHN0cmluZ1tdO1xuICBleHBsaWNpdD86IGJvb2xlYW47XG4gIG9uOiBhbnk7XG4gIHBhcmVudD86IFRyYW5zYWN0aW9uO1xuICBzY2hlbWE6IERiU2NoZW1hO1xuICBfbWVtb2l6ZWRUYWJsZXM6IHtbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZX07XG5cbiAgX3JlY3Vsb2NrOiBudW1iZXI7XG4gIF9ibG9ja2VkRnVuY3M6IHsgMDogKCkgPT4gYW55LCAxOiBhbnkgfVtdO1xuICBfcmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgX3JlamVjdDogKEVycm9yKSA9PiB2b2lkO1xuICBfd2FpdGluZ0ZvcjogRGV4aWVQcm9taXNlOyAvLyBmb3Igd2FpdEZvcigpXG4gIF93YWl0aW5nUXVldWU6IEZ1bmN0aW9uW107IC8vIGZvciB3YWl0Rm9yKClcbiAgX3NwaW5Db3VudDogbnVtYmVyOyAvLyBKdXN0IGZvciBkZWJ1Z2dpbmcgd2FpdEZvcigpXG4gIF9jb21wbGV0aW9uOiBEZXhpZVByb21pc2U7XG5cbiAgLy9cbiAgLy8gVHJhbnNhY3Rpb24gaW50ZXJuYWwgbWV0aG9kcyAobm90IHJlcXVpcmVkIGJ5IEFQSSB1c2VycywgYnV0IG5lZWRlZCBpbnRlcm5hbGx5IGFuZCBldmVudHVhbGx5IGJ5IGRleGllIGV4dGVuc2lvbnMpXG4gIC8vXG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9sb2NrKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC5cbiAgICovXG4gIF9sb2NrKCkge1xuICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICAvLyBUZW1wb3Jhcnkgc2V0IGFsbCByZXF1ZXN0cyBpbnRvIGEgcGVuZGluZyBxdWV1ZSBpZiB0aGV5IGFyZSBjYWxsZWQgYmVmb3JlIGRhdGFiYXNlIGlzIHJlYWR5LlxuICAgICsrdGhpcy5fcmVjdWxvY2s7IC8vIFJlY3Vyc2l2ZSByZWFkL3dyaXRlIGxvY2sgcGF0dGVybiB1c2luZyBQU0QgKFByb21pc2UgU3BlY2lmaWMgRGF0YSkgaW5zdGVhZCBvZiBUTFMgKFRocmVhZCBMb2NhbCBTdG9yYWdlKVxuICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbCkgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX3VubG9jaygpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfdW5sb2NrKCkge1xuICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgaWYgKCFQU0QuZ2xvYmFsKSBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgIHdoaWxlICh0aGlzLl9ibG9ja2VkRnVuY3MubGVuZ3RoID4gMCAmJiAhdGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7IHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pOyB9IGNhdGNoIChlKSB7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX2xvY2soKVxuICAgKiBcbiAgICogSW50ZXJuYWwgbWV0aG9kLlxuICAgKi9cbiAgX2xvY2tlZCgpIHtcbiAgICAvLyBDaGVja3MgaWYgYW55IHdyaXRlLWxvY2sgaXMgYXBwbGllZCBvbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBEZXhpZSBBUEkgZm9yIGV4dGVuc2lvbiBpbXBsZW1lbnRhdGlvbnMsIHdlIHN1cHBvcnQgcmVjdXJzaXZlIGxvY2tzLlxuICAgIC8vIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IHVzaW5nIFwiUHJvbWlzZSBTcGVjaWZpYyBEYXRhXCIgKFBTRCkuXG4gICAgLy8gUFNEIGRhdGEgaXMgYm91bmQgdG8gYSBQcm9taXNlIGFuZCBhbnkgY2hpbGQgUHJvbWlzZSBlbWl0dGVkIHRocm91Z2ggdGhlbigpIG9yIHJlc29sdmUoIG5ldyBQcm9taXNlKCkgKS5cbiAgICAvLyBQU0QgaXMgbG9jYWwgdG8gY29kZSBleGVjdXRpbmcgb24gdG9wIG9mIHRoZSBjYWxsIHN0YWNrcyBvZiBhbnkgb2YgYW55IGNvZGUgZXhlY3V0ZWQgYnkgUHJvbWlzZSgpOlxuICAgIC8vICAgICAgICAgKiBjYWxsYmFjayBnaXZlbiB0byB0aGUgUHJvbWlzZSgpIGNvbnN0cnVjdG9yICAoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7Li4ufSlcbiAgICAvLyAgICAgICAgICogY2FsbGJhY2tzIGdpdmVuIHRvIHRoZW4oKS9jYXRjaCgpL2ZpbmFsbHkoKSBtZXRob2RzIChmdW5jdGlvbiAodmFsdWUpey4uLn0pXG4gICAgLy8gSWYgY3JlYXRpbmcgYSBuZXcgaW5kZXBlbmRhbnQgUHJvbWlzZSBpbnN0YW5jZSBmcm9tIHdpdGhpbiBhIFByb21pc2UgY2FsbCBzdGFjaywgdGhlIG5ldyBQcm9taXNlIHdpbGwgZGVyaXZlIHRoZSBQU0QgZnJvbSB0aGUgY2FsbCBzdGFjayBvZiB0aGUgcGFyZW50IFByb21pc2UuXG4gICAgLy8gRGVyaXZhdGlvbiBpcyBkb25lIHNvIHRoYXQgdGhlIGlubmVyIFBTRCBfX3Byb3RvX18gcG9pbnRzIHRvIHRoZSBvdXRlciBQU0QuXG4gICAgLy8gUFNELmxvY2tPd25lckZvciB3aWxsIHBvaW50IHRvIGN1cnJlbnQgdHJhbnNhY3Rpb24gb2JqZWN0IGlmIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIFBTRCBzY29wZSBvd25zIHRoZSBsb2NrLlxuICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLmNyZWF0ZSgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqIFxuICAgKi9cbiAgY3JlYXRlKGlkYnRyYW5zPzogSURCVHJhbnNhY3Rpb24gJiB7W3Byb3A6IHN0cmluZ106IGFueX0pIHtcbiAgICBpZiAoIXRoaXMubW9kZSkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgYXNzZXJ0KCF0aGlzLmlkYnRyYW5zKTtcbiAgICBpZiAoIWlkYnRyYW5zICYmICFpZGJkYikge1xuICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJEYXRhYmFzZUNsb3NlZEVycm9yXCI6XG4gICAgICAgICAgLy8gRXJyb3JzIHdoZXJlIGl0IGlzIG5vIGRpZmZlcmVuY2Ugd2hldGhlciBpdCB3YXMgY2F1c2VkIGJ5IHRoZSB1c2VyIG9wZXJhdGlvbiBvciBhbiBlYXJsaWVyIGNhbGwgdG8gZGIub3BlbigpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgLy8gRXJyb3JzIHdoZXJlIGl0IGlzIG5vIGRpZmZlcmVuY2Ugd2hldGhlciBpdCB3YXMgY2F1c2VkIGJ5IHRoZSB1c2VyIG9wZXJhdGlvbiBvciBhbiBlYXJsaWVyIGNhbGwgdG8gZGIub3BlbigpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gTWFrZSBpdCBjbGVhciB0aGF0IHRoZSB1c2VyIG9wZXJhdGlvbiB3YXMgbm90IHdoYXQgY2F1c2VkIHRoZSBlcnJvciAtIHRoZSBlcnJvciBoYWQgb2NjdXJyZWQgZWFybGllciBvbiBkYi5vcGVuKCkhXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5hY3RpdmUpIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpOyAvLyBDb21wbGV0aW9uIFByb21pc2UgbXVzdCBzdGlsbCBiZSBwZW5kaW5nLlxuXG4gICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICh0aGlzLmRiLmNvcmUgXG4gICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlIGFzICdyZWFkd3JpdGUnIHwgJ3JlYWRvbmx5JywgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuICAgICAgICA6IGlkYmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICApIGFzIElEQlRyYW5zYWN0aW9uO1xuXG4gICAgaWRidHJhbnMub25lcnJvciA9IHdyYXAoZXYgPT4ge1xuICAgICAgcHJldmVudERlZmF1bHQoZXYpOy8vIFByb2hpYml0IGRlZmF1bHQgYnViYmxpbmcgdG8gd2luZG93LmVycm9yXG4gICAgICB0aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgIH0pO1xuICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGV2ID0+IHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgIHRoaXMuYWN0aXZlICYmIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMub24oXCJhYm9ydFwiKS5maXJlKGV2KTtcbiAgICB9KTtcbiAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcCgoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgaWYgKCdtdXRhdGVkUGFydHMnIGluIGlkYnRyYW5zKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi5fcHJvbWlzZSgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfcHJvbWlzZShcbiAgICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgZm46IChyZXNvbHZlLCByZWplY3QsIHRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8YW55PiB8IHZvaWQsXG4gICAgYldyaXRlTG9jaz86IHN0cmluZyB8IGJvb2xlYW4pOiBEZXhpZVByb21pc2VcbiAge1xuICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcblxuICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG5cbiAgICBpZiAodGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goWygpID0+IHtcbiAgICAgICAgICB0aGlzLl9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIFBTRF0pO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKGJXcml0ZUxvY2spIHtcbiAgICAgIHJldHVybiBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9jaygpO1xuICAgICAgICAgIGNvbnN0IHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbikgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcC5maW5hbGx5KCgpID0+IHRoaXMuX3VubG9jaygpKTtcbiAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIHRoaXMpO1xuICAgICAgICBpZiAocnYgJiYgcnYudGhlbikgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9yb290KClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC4gUmV0cmlldmVzIHRoZSByb290IHRyYW5zYWN0aW9uIGluIHRoZSB0cmVlIG9mIHN1YiB0cmFuc2FjdGlvbnMuXG4gICAqL1xuICBfcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi53YWl0Rm9yKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC4gQ2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIHB1YmxpYyBBUEkgdGhyb3VnaFxuICAgKiBEZXhpZS53YWl0Rm9yKCk6IGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvRGV4aWUvRGV4aWUud2FpdEZvcigpXG4gICAqIFxuICAgKiovXG4gIHdhaXRGb3IocHJvbWlzZUxpa2U6IFByb21pc2VMaWtlPGFueT4pIHtcbiAgICAvLyBBbHdheXMgb3BlcmF0ZSBvbiB0aGUgcm9vdCB0cmFuc2FjdGlvbiAoaW4gY2FzZSB0aGlzIGlzIGEgc3ViIHN0cmFuc2FjdGlvbilcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAvLyBGb3Igc3RhYmlsaXR5IHJlYXNvbnMsIGNvbnZlcnQgcGFyYW1ldGVyIHRvIHByb21pc2Ugbm8gbWF0dGVyIHdoYXQgdHlwZSBpcyBwYXNzZWQgdG8gd2FpdEZvcigpLlxuICAgIC8vIChXZSBtdXN0IGJlIGFibGUgdG8gY2FsbCAudGhlbigpIG9uIGl0LilcbiAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSB7XG4gICAgICAvLyBBbHJlYWR5IGNhbGxlZCB3YWl0Rm9yKCkuIFdhaXQgZm9yIGJvdGggdG8gY29tcGxldGUuXG4gICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKCgpID0+IHByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBub3QgaW4gd2FpdGluZyBzdGF0ZS4gU3RhcnQgd2FpdGluZyBzdGF0ZS5cbiAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAvLyBTdGFydCBpbnRlcmFjdGluZyB3aXRoIGluZGV4ZWREQiB1bnRpbCBwcm9taXNlIGNvbXBsZXRlczpcbiAgICAgIHZhciBzdG9yZSA9IHJvb3QuaWRidHJhbnMub2JqZWN0U3RvcmUocm9vdC5zdG9yZU5hbWVzWzBdKTtcbiAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDsgLy8gRm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKSAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgfSgpKTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICByZXMgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpLFxuICAgICAgICBlcnIgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSlcbiAgICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAvLyBObyBvbmUgYWRkZWQgYSB3YWl0IGFmdGVyIHVzLiBTYWZlIHRvIHN0b3AgdGhlIHNwaW5uaW5nLlxuICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAgXG5cbiAgLyoqIFRyYW5zYWN0aW9uLmFib3J0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVHJhbnNhY3Rpb24vVHJhbnNhY3Rpb24uYWJvcnQoKVxuICAgKi9cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWRidHJhbnMpIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcbiAgICB9XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24udGFibGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UcmFuc2FjdGlvbi9UcmFuc2FjdGlvbi50YWJsZSgpXG4gICAqL1xuICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcbiAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgIGNvbnN0IHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7ICAgICAgICBcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkJvdW5kVGFibGUgPSBuZXcgdGhpcy5kYi5UYWJsZSh0YWJsZU5hbWUsIHRhYmxlU2NoZW1hLCB0aGlzKTtcbiAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IFByb21pc2UsIHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkNvbnN0cnVjdG9yPFQgZXh0ZW5kcyBUcmFuc2FjdGlvbj1UcmFuc2FjdGlvbj4ge1xuICBuZXcgKFxuICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksXG4gICAgcGFyZW50PzogVHJhbnNhY3Rpb24pIDogVDtcbiAgcHJvdG90eXBlOiBUO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgVHJhbnNhY3Rpb24gY29uc3RydWN0b3IgYm91bmQgdG8gZ2l2ZW4gRGV4aWUgaW5zdGFuY2UuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjxUcmFuc2FjdGlvbj4+KFxuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZSxcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbiAoXG4gICAgICB0aGlzOiBUcmFuc2FjdGlvbixcbiAgICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICAgIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgZGJzY2hlbWE6IERiU2NoZW1hLFxuICAgICAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksXG4gICAgICBwYXJlbnQ/OiBUcmFuc2FjdGlvbilcbiAgICB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSA9IGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTtcbiAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7IC8vIEp1c3QgZm9yIGRlYnVnZ2luZyB3YWl0Rm9yKClcbiAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oXG4gICAgICAgICAgKCk9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcbiAgICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiB0aGlzLmlkYnRyYW5zICYmIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTsgLy8gSW5kaWNhdGUgd2UgYWN0dWFsbHkgRE8gTk9UIGNhdGNoIHRoaXMgZXJyb3IuXG4gICAgICAgICAgfSk7XG4gICAgXG4gICAgfSk7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5kZXhTcGVjKFxuICBuYW1lOiBzdHJpbmcsXG4gIGtleVBhdGg6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB1bmlxdWU6IGJvb2xlYW4sXG4gIG11bHRpOiBib29sZWFuLFxuICBhdXRvOiBib29sZWFuLFxuICBjb21wb3VuZDogYm9vbGVhbixcbiAgaXNQcmltS2V5OiBib29sZWFuXG4pOiBJbmRleFNwZWMge1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAga2V5UGF0aCxcbiAgICB1bmlxdWUsXG4gICAgbXVsdGksXG4gICAgYXV0byxcbiAgICBjb21wb3VuZCxcbiAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21LZXlQYXRoIChrZXlQYXRoPzogc3RyaW5nIHwgc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICBrZXlQYXRoIDpcbiAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IGNyZWF0ZUluZGV4U3BlYyB9IGZyb20gJy4vaW5kZXgtc3BlYyc7XG5pbXBvcnQgeyBhcnJheVRvT2JqZWN0IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlU2NoZW1hIChcbiAgbmFtZTogc3RyaW5nLFxuICBwcmltS2V5OiBJbmRleFNwZWMsXG4gIGluZGV4ZXM6IEluZGV4U3BlY1tdXG4pOiBUYWJsZVNjaGVtYSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmltS2V5LFxuICAgIGluZGV4ZXMsXG4gICAgbWFwcGVkQ2xhc3M6IG51bGwsXG4gICAgaWR4QnlOYW1lOiBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGluZGV4ID0+IFtpbmRleC5uYW1lLCBpbmRleF0pXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgbWF4U3RyaW5nIH0gZnJvbSAnLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FmYXJpTXVsdGlTdG9yZUZpeChzdG9yZU5hbWVzOiBzdHJpbmdbXSkge1xuICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hdGl2ZUdldERhdGFiYXNlTmFtZXNGbihpbmRleGVkREIpIHtcbiAgdmFyIGZuID0gaW5kZXhlZERCICYmIChpbmRleGVkREIuZ2V0RGF0YWJhc2VOYW1lcyB8fCBpbmRleGVkREIud2Via2l0R2V0RGF0YWJhc2VOYW1lcyk7XG4gIHJldHVybiBmbiAmJiBmbi5iaW5kKGluZGV4ZWREQik7XG59XG5cbmV4cG9ydCBsZXQgZ2V0TWF4S2V5ID0gKElkYktleVJhbmdlOiB0eXBlb2YgSURCS2V5UmFuZ2UpID0+IHtcbiAgdHJ5IHtcbiAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuICAgIGdldE1heEtleSA9ICgpID0+IFtbXV07XG4gICAgcmV0dXJuIFtbXV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBnZXRNYXhLZXkgPSAoKSA9PiBtYXhTdHJpbmc7XG4gICAgcmV0dXJuIG1heFN0cmluZztcbiAgfVxufVxuIiwgImltcG9ydCB7IGdldEJ5S2V5UGF0aCB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlFeHRyYWN0b3IgKGtleVBhdGg6IG51bGwgfCBzdHJpbmcgfCBzdHJpbmdbXSkgOiAoYTogYW55KSA9PiBhbnkge1xuICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGg6IHN0cmluZykge1xuICBjb25zdCBzcGxpdCA9IGtleVBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBvYmogPT4gb2JqW2tleVBhdGhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZUN1cnNvcixcbiAgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlSW5kZXgsXG4gIERCQ29yZUtleVJhbmdlLFxuICBEQkNvcmVRdWVyeVJlc3BvbnNlLFxuICBEQkNvcmVSYW5nZVR5cGUsXG4gIERCQ29yZVNjaGVtYSxcbiAgREJDb3JlVGFibGVTY2hlbWEsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZXZlbnRSZWplY3RIYW5kbGVyLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycyc7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGdldE1heEtleSB9IGZyb20gJy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgZ2V0S2V5RXh0cmFjdG9yIH0gZnJvbSAnLi9nZXQta2V5LWV4dHJhY3Rvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeTxUPihhcnJheUxpa2U6IHtsZW5ndGg6IG51bWJlciwgW2luZGV4OiBudW1iZXJdOiBUfSk6IFRbXSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGljazxULFByb3AgZXh0ZW5kcyBrZXlvZiBUPihvYmo6IFQsIHByb3BzOiBQcm9wW10pOiBQaWNrPFQsIFByb3A+IHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgUGljazxULCBQcm9wPjtcbiAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmxldCBfaWRfY291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aDogbnVsbCB8IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuICAgIFwiOmlkXCIgOlxuICAgIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICBrZXlQYXRoIDpcbiAgICAgIGBbJHtrZXlQYXRoLmpvaW4oJysnKX1dYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURCQ29yZSAoXG4gIGRiOiBJREJEYXRhYmFzZSxcbiAgSWRiS2V5UmFuZ2U6IHR5cGVvZiBJREJLZXlSYW5nZSxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKSA6IERCQ29yZVxue1xuICBmdW5jdGlvbiBleHRyYWN0U2NoZW1hKGRiOiBJREJEYXRhYmFzZSwgdHJhbnM6IElEQlRyYW5zYWN0aW9uKSA6IHtzY2hlbWE6IERCQ29yZVNjaGVtYSwgaGFzR2V0QWxsOiBib29sZWFufSB7XG4gICAgY29uc3QgdGFibGVzID0gYXJyYXlpZnkoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYToge1xuICAgICAgICBuYW1lOiBkYi5uYW1lLFxuICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAodGFibGUgPT4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpKS5tYXAoc3RvcmUgPT4ge1xuICAgICAgICAgIGNvbnN0IHtrZXlQYXRoLCBhdXRvSW5jcmVtZW50fSA9IHN0b3JlO1xuICAgICAgICAgIGNvbnN0IGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICBjb25zdCBpbmRleEJ5S2V5UGF0aDoge1trZXlQYXRoQWxpYXM6IHN0cmluZ106IERCQ29yZUluZGV4fSA9IHt9O1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWU6IHN0b3JlLm5hbWUsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgb3V0Ym91bmQsXG4gICAgICAgICAgICAgIGNvbXBvdW5kLFxuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50LFxuICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG4gICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgfSBhcyBEQkNvcmVJbmRleCxcbiAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChpbmRleE5hbWUgPT4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKSlcbiAgICAgICAgICAgICAgLm1hcChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge25hbWUsIHVuaXF1ZSwgbXVsdGlFbnRyeSwga2V5UGF0aH0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBEQkNvcmVJbmRleCA9IHtcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pID0+IGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKGtleVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG4gICAgICAgICEodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNCkgLy8gQnVnIHdpdGggZ2V0QWxsKCkgb24gU2FmYXJpIHZlcjw2MDQuIFNlZSBkaXNjdXNzaW9uIGZvbGxvd2luZyBQUiAjNTc5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZSAocmFuZ2U6IERCQ29yZUtleVJhbmdlKSA6IElEQktleVJhbmdlIHwgbnVsbCB7XG4gICAgaWYgKHJhbmdlLnR5cGUgPT09IERCQ29yZVJhbmdlVHlwZS5BbnkpIHJldHVybiBudWxsO1xuICAgIGlmIChyYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuTmV2ZXIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgY29uc3Qge2xvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW59ID0gcmFuZ2U7XG4gICAgY29uc3QgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICBudWxsIDogLy9JREJLZXlSYW5nZS5sb3dlckJvdW5kKC1JbmZpbml0eSwgZmFsc2UpIDogLy8gQW55IHJhbmdlIChUT0RPOiBTaG91bGQgd2UgcmV0dXJuIG51bGwgaW5zdGVhZD8pXG4gICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6IC8vIGJlbG93XG4gICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgSWRiS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgISFsb3dlck9wZW4pIDogLy8gYWJvdmVcbiAgICAgICAgSWRiS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCAhIWxvd2VyT3BlbiwgISF1cHBlck9wZW4pO1xuICAgIHJldHVybiBpZGJSYW5nZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hOiBEQkNvcmVUYWJsZVNjaGVtYSk6IERCQ29yZVRhYmxlIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZVNjaGVtYS5uYW1lO1xuXG4gICAgZnVuY3Rpb24gbXV0YXRlICh7dHJhbnMsIHR5cGUsIGtleXMsIHZhbHVlcywgcmFuZ2V9KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICBjb25zdCBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgY29uc3QgaXNBZGRPclB1dCA9IHR5cGUgPT09IFwicHV0XCIgfHwgdHlwZSA9PT0gXCJhZGRcIjtcbiAgICAgICAgaWYgKCFpc0FkZE9yUHV0ICYmIHR5cGUgIT09ICdkZWxldGUnICYmIHR5cGUgIT09ICdkZWxldGVSYW5nZScpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIChcIkludmFsaWQgb3BlcmF0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG5cbiAgICAgICAgY29uc3Qge2xlbmd0aH0gPSBrZXlzIHx8IHZhbHVlcyB8fCB7bGVuZ3RoOiAxfTsgLy8ga2V5cy5sZW5ndGggaWYga2V5cy4gdmFsdWVzLmxlbmd0aCBpZiB2YWx1ZXMuIDEgaWYgcmFuZ2UuXG4gICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIGtleXMgYXJyYXkgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGdpdmVuIHZhbHVlcyBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAvLyBObyBpdGVtcyB0byB3cml0ZS4gRG9uJ3QgZXZlbiBib3RoZXIhXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoe251bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9KTtcblxuICAgICAgICBsZXQgcmVxOiBJREJSZXF1ZXN0O1xuICAgICAgICBjb25zdCByZXFzOiBJREJSZXF1ZXN0W10gPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgZmFpbHVyZXM6IHtbb3BlcmF0aW9uTnVtYmVyOiBudW1iZXJdOiBFcnJvcn0gPSBbXTtcbiAgICAgICAgbGV0IG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gXG4gICAgICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAvLyBIZXJlIHRoZSBhcmd1bWVudCBpcyB0aGUgcmFuZ2VcbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLk5ldmVyKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe251bUZhaWx1cmVzLCBmYWlsdXJlcywgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZH0pOyAvLyBEZWxldGluZyB0aGUgTmV2ZXIgcmFuZ2Ugc2hvdWxudCBkbyBhbnl0aGluZy5cbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLkFueSlcbiAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTsgLy8gRGVsZXRpbmcgdGhlIEFueSByYW5nZSBpcyBlcXVpdmFsZW50IHRvIHN0b3JlLmNsZWFyKClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBtYXR0ZXIgYWRkLCBwdXQgb3IgZGVsZXRlIC0gZmluZCBvdXQgYXJyYXlzIG9mIGZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnRzIHRvIGl0LlxuICAgICAgICAgIGNvbnN0IFthcmdzMSwgYXJnczJdID0gaXNBZGRPclB1dCA/XG4gICAgICAgICAgICBvdXRib3VuZCA/XG4gICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcbiAgICAgICAgICAgICAgW3ZhbHVlcywgbnVsbF0gOlxuICAgICAgICAgICAgW2tleXMsIG51bGxdO1xuXG4gICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gKGFyZ3MyICYmIGFyZ3MyW2ldICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkgYXMgSURCUmVxdWVzdCk7XG4gICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSBhcyBJREJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbmUgPSBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgcmVxcy5mb3JFYWNoKChyZXEsIGkpID0+IHJlcS5lcnJvciAhPSBudWxsICYmIChmYWlsdXJlc1tpXSA9IHJlcS5lcnJvcikpO1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgbnVtRmFpbHVyZXMsXG4gICAgICAgICAgICBmYWlsdXJlcyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAocmVxID0+IHJlcS5yZXN1bHQpLFxuICAgICAgICAgICAgbGFzdFJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudCA9PiB7IC8vIHdyYXAoKSBub3QgbmVlZGVkLiBBbGwgcGF0aHMgY2FsbGluZyBvdXRzaWRlIHdpbGwgd3JhcCFcbiAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIGRvbmUoZXZlbnQpO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gb3BlbkN1cnNvciAoe3RyYW5zLCB2YWx1ZXMsIHF1ZXJ5LCByZXZlcnNlLCB1bmlxdWV9OiBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCk6IFByb21pc2U8REJDb3JlQ3Vyc29yPlxuICAgIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICBjb25zdCB7aW5kZXgsIHJhbmdlfSA9IHF1ZXJ5O1xuICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgLy8gc291cmNlXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/XG4gICAgICAgICAgc3RvcmUgOlxuICAgICAgICAgIHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG4gICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgIFwicHJldnVuaXF1ZVwiIDpcbiAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgXCJuZXh0XCI7XG4gICAgICAgIC8vIHJlcXVlc3RcbiAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbikgOlxuICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbik7XG4gICAgICAgICAgXG4gICAgICAgIC8vIGl0ZXJhdGlvblxuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiB7XG5cbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0IGFzIHVua25vd24gYXMgREJDb3JlQ3Vyc29yO1xuICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoY3Vyc29yIGFzIGFueSkuX19faWQgPSArK19pZF9jb3VudGVyO1xuICAgICAgICAgIChjdXJzb3IgYXMgYW55KS5kb25lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBsZXQgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkpIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBjb25zdCBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkID0gKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0YXJ0ZWRcIik7fVxuICAgICAgICAgIGNvbnN0IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSAoKT0+e3Rocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTt9XG4gICAgICAgICAgKGN1cnNvciBhcyBhbnkpLnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuICAgICAgICAgIGN1cnNvci5uZXh0ID0gZnVuY3Rpb24gKHRoaXM6IERCQ29yZUN1cnNvcikge1xuICAgICAgICAgICAgLy8gbmV4dCgpIG11c3Qgd29yayB3aXRoIFwidGhpc1wiIHBvaW50ZXIgaW4gb3JkZXIgdG8gZnVuY3Rpb24gY29ycmVjdGx5IGZvciBQcm94eUN1cnNvcnMgKGRlcml2ZWQgb2JqZWN0cylcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlLWRlZmluZSBuZXh0KCkgb24gZWFjaCBjaGlsZC5cbiAgICAgICAgICAgIGxldCBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKCkgPT4gZ290T25lLS0gPyB0aGlzLmNvbnRpbnVlKCkgOiB0aGlzLnN0b3AoKSkudGhlbigoKSA9PiB0aGlzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1cnNvci5zdGFydCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGN1cnNvclwiLCAoY3Vyc29yIGFzIGFueSkuX19faWQpO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pID0+e1xuICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0SXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSByZWplY3RJdGVyYXRpb247XG4gICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDdXJzb3Igc3RvcFwiLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm93IGNoYW5nZSByZXEub25zdWNjZXNzIHRvIGEgY2FsbGJhY2sgdGhhdCBkb2Vzbid0IGNhbGwgaW5pdEN1cnNvciBidXQganVzdCBvYnNlcnZlci5uZXh0KClcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTmV4dCByZXN1bHRcIiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChjdXJzb3IgYXMgYW55KS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSAoKT0+e3Rocm93IG5ldyBFcnJvcihcIkN1cnNvciBiZWhpbmQgbGFzdCBlbnRyeVwiKTt9XG4gICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAvL2N1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlID0gX2N1cnNvckNvbnRpbnVlO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgfSwgcmVqZWN0KTsgXG4gICAgICB9KTtcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIHF1ZXJ5IChoYXNHZXRBbGw6IGJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAocmVxdWVzdDogREJDb3JlUXVlcnlSZXF1ZXN0KSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxEQkNvcmVRdWVyeVJlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgY29uc3Qge3RyYW5zLCB2YWx1ZXMsIGxpbWl0LCBxdWVyeX0gPSByZXF1ZXN0O1xuICAgICAgICAgIGNvbnN0IG5vbkluZmluaXRMaW1pdCA9IGxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IGxpbWl0O1xuICAgICAgICAgIGNvbnN0IHtpbmRleCwgcmFuZ2V9ID0gcXVlcnk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSAodHJhbnMgYXMgSURCVHJhbnNhY3Rpb24pLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSAwKSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0OiBbXX0pO1xuICAgICAgICAgIGlmIChoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyA/XG4gICAgICAgICAgICAgICAgKHNvdXJjZSBhcyBhbnkpLmdldEFsbChpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KSA6XG4gICAgICAgICAgICAgICAgKHNvdXJjZSBhcyBhbnkpLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSh7cmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0fSk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihpZGJLZXlSYW5nZSlcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdCBhcyBJREJDdXJzb3JXaXRoVmFsdWU7XG4gICAgICAgICAgICAgIGlmICghY3Vyc29yKSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0fSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlcyA/IGN1cnNvci52YWx1ZSA6IGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxpbWl0KSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0fSk7XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICBcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0YWJsZVNjaGVtYSxcbiAgICAgIFxuICAgICAgbXV0YXRlLFxuXG4gICAgICBnZXRNYW55ICh7dHJhbnMsIGtleXN9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnlbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgbGV0IGNhbGxiYWNrQ291bnQgPSAwO1xuICAgICAgICAgIGxldCB2YWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICBsZXQgcmVxOiBJREJSZXF1ZXN0ICYge19wb3M/OiBudW1iZXJ9O1xuICAgIFxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKChyZXN1bHRbcmVxLl9wb3NdID0gcmVxLnJlc3VsdCkgIT0gbnVsbCkgKyt2YWx1ZUNvdW50O1xuICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgIFxuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5c1tpXSk7XG4gICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcbiAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgKytrZXlDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleUNvdW50ID09PSAwKSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgZ2V0ICh7dHJhbnMsIGtleX0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwIChyZXNvbHZlKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSgoZXZlbnQudGFyZ2V0IGFzIGFueSkucmVzdWx0KTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgXG4gICAgICBvcGVuQ3Vyc29yLFxuXG4gICAgICBjb3VudCAoe3F1ZXJ5LCB0cmFuc30pIHtcbiAgICAgICAgY29uc3Qge2luZGV4LCByYW5nZX0gPSBxdWVyeTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPG51bWJlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgY29uc3QgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIGNvbnN0IHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHJlc29sdmUoKGV2LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQpKTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge3NjaGVtYSwgaGFzR2V0QWxsfSA9IGV4dHJhY3RTY2hlbWEoZGIsIHRtcFRyYW5zKTtcbiAgY29uc3QgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAodGFibGVTY2hlbWEgPT4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpKTtcbiAgY29uc3QgdGFibGVNYXA6IHtbbmFtZTogc3RyaW5nXTogREJDb3JlVGFibGV9ID0ge307XG4gIHRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGUpO1xuICByZXR1cm4ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIFxuICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcblxuICAgIHRhYmxlKG5hbWU6IHN0cmluZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGFibGVNYXBbbmFtZV07XG4gICAgICBpZiAoIXJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgfSxcblxuICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcblxuICAgIE1BWF9LRVk6IGdldE1heEtleShJZGJLZXlSYW5nZSksXG5cbiAgICBzY2hlbWFcblxuICB9O1xufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgY3JlYXRlREJDb3JlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2RiY29yZS1pbmRleGVkZGInO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBEZXhpZURPTURlcGVuZGVuY2llcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1kb20tZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IERleGllU3RhY2tzLCBNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjazxUU3RhY2sgZXh0ZW5kcyB7c3RhY2s6IHN0cmluZ30+KFxuICBzdGFja0ltcGw6IHtzdGFjazogc3RyaW5nfSxcbiAgbWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8e3N0YWNrOiBzdHJpbmd9PltdKTogVFN0YWNrIHtcbiAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZSgoZG93biwge2NyZWF0ZX0pID0+ICh7Li4uZG93biwgLi4uY3JlYXRlKGRvd24pfSksIHN0YWNrSW1wbCkgYXMgVFN0YWNrO1xufSBcblxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhcbiAgbWlkZGxld2FyZXM6IHtbU3RhY2tOYW1lIGluIGtleW9mIERleGllU3RhY2tzXT86IE1pZGRsZXdhcmU8RGV4aWVTdGFja3NbU3RhY2tOYW1lXT5bXX0sXG4gIGlkYmRiOiBJREJEYXRhYmFzZSxcbiAge0lEQktleVJhbmdlLCBpbmRleGVkREJ9OiBEZXhpZURPTURlcGVuZGVuY2llcyxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKToge1tTdGFja05hbWUgaW4ga2V5b2YgRGV4aWVTdGFja3NdPzogRGV4aWVTdGFja3NbU3RhY2tOYW1lXX1cbntcbiAgY29uc3QgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrPERCQ29yZT4oXG4gICAgY3JlYXRlREJDb3JlKGlkYmRiLCBJREJLZXlSYW5nZSwgdG1wVHJhbnMpLFxuICAgIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gIFxuICAvLyBUT0RPOiBDcmVhdGUgb3RoZXIgc3RhY2tzIHRoZSBzYW1lIHdheSBhcyBhYm92ZS4gVGhleSBtaWdodCBiZSBkZXBlbmRhbnQgb24gdGhlIHJlc3VsdFxuICAvLyBvZiBjcmVhdGluZyBkYmNvcmUgc3RhY2suXG5cbiAgcmV0dXJuIHtcbiAgICBkYmNvcmVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYjogRGV4aWUsIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICBjb25zdCBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuICBjb25zdCBzdGFja3MgPSBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLl9taWRkbGV3YXJlcywgaWRiZGIsIGRiLl9kZXBzLCB0bXBUcmFucyk7XG4gIGRiLmNvcmUgPSBzdGFja3MuZGJjb3JlITtcbiAgZGIudGFibGVzLmZvckVhY2godGFibGUgPT4ge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLm5hbWU7XG4gICAgaWYgKGRiLmNvcmUuc2NoZW1hLnRhYmxlcy5zb21lKHRibCA9PiB0YmwubmFtZSA9PT0gdGFibGVOYW1lKSkge1xuICAgICAgdGFibGUuY29yZSA9IGRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgIGlmIChkYlt0YWJsZU5hbWVdIGluc3RhbmNlb2YgZGIuVGFibGUpIHtcbiAgICAgICAgICBkYlt0YWJsZU5hbWVdLmNvcmUgPSB0YWJsZS5jb3JlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBEYlNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYi1zY2hlbWEnO1xuaW1wb3J0IHsgX2dsb2JhbCB9IGZyb20gXCIuLi8uLi9nbG9iYWxzL2dsb2JhbFwiO1xuaW1wb3J0IHsgc2V0UHJvcCwga2V5cywgc2xpY2UsIGlzQXJyYXksIHNoYWxsb3dDbG9uZSwgaXNBc3luY0Z1bmN0aW9uLCBkZWZpbmVQcm9wZXJ0eSwgZ2V0UHJvcGVydHlEZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5pbXBvcnQgUHJvbWlzZSwgeyBQU0QsIG5ld1Njb3BlLCBOYXRpdmVQcm9taXNlLCBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cywgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWEnO1xuaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgY3JlYXRlSW5kZXhTcGVjLCBuYW1lRnJvbUtleVBhdGggfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgY3JlYXRlVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MgfSBmcm9tICcuLi9kZXhpZS9nZW5lcmF0ZS1taWRkbGV3YXJlLXN0YWNrcyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgUHJvbWlzZUV4dGVuZGVkIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3Byb21pc2UtZXh0ZW5kZWQnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0QXBpT25QbGFjZShkYjogRGV4aWUsIG9ianM6IE9iamVjdFtdLCB0YWJsZU5hbWVzOiBzdHJpbmdbXSwgZGJzY2hlbWE6IERiU2NoZW1hKSB7XG4gIHRhYmxlTmFtZXMuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgIGNvbnN0IHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG4gICAgb2Jqcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICBjb25zdCBwcm9wRGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHRhYmxlTmFtZSk7XG4gICAgICBpZiAoIXByb3BEZXNjIHx8IChcInZhbHVlXCIgaW4gcHJvcERlc2MgJiYgcHJvcERlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLy8gRWl0aGVyIHRoZSBwcm9wIGlzIG5vdCBkZWNsYXJlZCwgb3IgaXQgaXMgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkLlxuICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAvLyBvYmogaXMgYSBUcmFuc2FjdGlvbiBwcm90b3R5cGUgKG9yIHByb3RvdHlwZSBvZiBhIHN1YmNsYXNzIHRvIFRyYW5zYWN0aW9uKVxuICAgICAgICAgIC8vIE1ha2UgdGhlIEFQSSBhIGdldHRlciB0aGF0IHJldHVybnMgdGhpcy50YWJsZSh0YWJsZU5hbWUpXG4gICAgICAgICAgc2V0UHJvcChvYmosIHRhYmxlTmFtZSwge1xuICAgICAgICAgICAgZ2V0KHRoaXM6IFRyYW5zYWN0aW9uKSB7IHJldHVybiB0aGlzLnRhYmxlKHRhYmxlTmFtZSk7IH0sXG4gICAgICAgICAgICBzZXQodmFsdWU6IGFueSkge1xuICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTAzOVxuICAgICAgICAgICAgICAvLyBMZXQgXCJ0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1wiIGFuZCBvdGhlciBwcm9wcyBpbiB0cmFuc2FjdGlvbiBjb25zdHJ1Y3RvciB3b3JrIGV2ZW4gaWYgdGhlcmUncyBhIG5hbWUgY29sbGlzaW9uIHdpdGggdGhlIHRhYmxlIG5hbWUuXG4gICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHRhYmxlTmFtZSwge3ZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGFibGUgd2lsbCBub3QgYmUgYm91bmQgdG8gYSB0cmFuc2FjdGlvbiAod2lsbCB1c2UgRGV4aWUuY3VycmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgIG9ialt0YWJsZU5hbWVdID0gbmV3IGRiLlRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRhYmxlc0FwaShkYjogRGV4aWUsIG9ianM6IE9iamVjdFtdKSB7XG4gIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIGRiLlRhYmxlKSBkZWxldGUgb2JqW2tleV07XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGE6IFZlcnNpb24sIGI6IFZlcnNpb24pIHtcbiAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW5VcGdyYWRlcnMoZGI6IERleGllLCBvbGRWZXJzaW9uOiBudW1iZXIsIGlkYlVwZ3JhZGVUcmFuczogSURCVHJhbnNhY3Rpb24sIHJlamVjdCkge1xuICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gIGlmIChpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSAmJiAhZ2xvYmFsU2NoZW1hLiRtZXRhKSB7XG4gICAgZ2xvYmFsU2NoZW1hLiRtZXRhID0gY3JlYXRlVGFibGVTY2hlbWEoXCIkbWV0YVwiLCBwYXJzZUluZGV4U3ludGF4KFwiXCIpWzBdLCBbXSk7XG4gICAgZGIuX3N0b3JlTmFtZXMucHVzaCgnJG1ldGEnKTtcbiAgfVxuICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG4gIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuICBjb25zdCByZWplY3RUcmFuc2FjdGlvbiA9IHRyYW5zLl9yZWplY3QuYmluZCh0cmFucyk7XG4gIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICBuZXdTY29wZSgoKSA9PiB7XG4gICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcbiAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgLy8gQ3JlYXRlIHRhYmxlczpcbiAgICAgIGtleXMoZ2xvYmFsU2NoZW1hKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgIH0pO1xuICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgUHJvbWlzZS5mb2xsb3coKCkgPT4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucykpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmVyc2lvbihkYiwgdHJhbnMsIG9sZFZlcnNpb24pXG4gICAgICAgIC50aGVuKG9sZFZlcnNpb24gPT4gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucykpXG4gICAgICAgIC5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHR5cGUgVXBncmFkZVF1ZXVlSXRlbSA9IChpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDdXJyZW50VmVyc2lvbihkYjogRGV4aWUsIGlkYlVwZ3JhZGVUcmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgY3JlYXRlTWlzc2luZ1RhYmxlcyhkYi5fZGJTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gIGlmIChpZGJVcGdyYWRlVHJhbnMuZGIudmVyc2lvbiAlIDEwID09PSAwICYmICFpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSkge1xuICAgIC8vIFJvbGxlZCBvdmVyIHRvIHRoZSBuZXh0IDEwLWllcyBkdWUgdG8gbWFueSBzY2hlbWEgdXBncmFkZXMgd2l0aG91dCBidW1waW5nIHZlcnNpb24uXG4gICAgLy8gTm8gcHJvYmxlbSEgV2UgcGluIHRoZSBkYXRhYmFzZSB0byBpdHMgZXhwZWN0ZWQgdmVyc2lvbiBieSBhZGRpbmcgdGhlICRtZXRhIHRhYmxlIHNvIHRoYXQgbmV4dFxuICAgIC8vIHRpbWUgdGhlIHByb2dyYW1tZXIgYnVtcHMgdGhlIHZlcnNpb24gYW5kIGF0dGFjaGVzLCBhbiB1cGdyYWRlciwgdGhhdCB1cGdyYWRlciB3aWxsIGluZGVlZCBydW4sXG4gICAgLy8gYXMgd2VsbCBhbnkgZnVydGhlciB1cGdyYWRlcnMgY29taW5nIGFmdGVyIHRoYXQuXG4gICAgaWRiVXBncmFkZVRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKCckbWV0YScpLmFkZChNYXRoLmNlaWwoKGlkYlVwZ3JhZGVUcmFucy5kYi52ZXJzaW9uIC8gMTApIC0gMSksICd2ZXJzaW9uJyk7XG4gIH1cbiAgY29uc3QgZ2xvYmFsU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICBjb25zdCBkaWZmID0gZ2V0U2NoZW1hRGlmZihnbG9iYWxTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gIGZvciAoY29uc3QgdGFibGVDaGFuZ2Ugb2YgZGlmZi5jaGFuZ2UpIHtcbiAgICBpZiAodGFibGVDaGFuZ2UuY2hhbmdlLmxlbmd0aCB8fCB0YWJsZUNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gcGF0Y2ggaW5kZXhlcyBvZiB0YWJsZSAke3RhYmxlQ2hhbmdlLm5hbWV9IGJlY2F1c2UgaXQgaGFzIGNoYW5nZXMgb24gdGhlIHR5cGUgb2YgaW5kZXggb3IgcHJpbWFyeSBrZXkuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKHRhYmxlQ2hhbmdlLm5hbWUpO1xuICAgIHRhYmxlQ2hhbmdlLmFkZC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICBpZiAoZGVidWcpIGNvbnNvbGUuZGVidWcoYERleGllIHVwZ3JhZGUgcGF0Y2g6IENyZWF0aW5nIG1pc3NpbmcgaW5kZXggJHt0YWJsZUNoYW5nZS5uYW1lfS4ke2lkeC5zcmN9YCk7XG4gICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ZlcnNpb24oZGI6IERleGllLCB0cmFuczogVHJhbnNhY3Rpb24sIG9sZFZlcnNpb246IG51bWJlcik6IFByb21pc2VFeHRlbmRlZDxudW1iZXI+IHtcbiAgLy8gSW4gbm9ybWFsIGNhc2UsIGV4aXN0aW5nIHZlcnNpb24gaXMgdGhlIG5hdGl2ZSBpbnN0YWxsZWQgdmVyc2lvbiBkaXZpZGVkIGJ5IDEwLlxuICAvLyBIb3dldmVyLCBpbiBjYXNlIG1vcmUgdGhhbiAxMCBzY2hlbWEgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSBvbiB0aGUgc2FtZSB2ZXJzaW9uIChzdWNoIGFzIHdoaWxlXG4gIC8vIGRldmVsb3BpbmcgYW4gYXBwKSwgdGhlIG5hdGl2ZSB2ZXJzaW9uIG1heSBoYXZlIHBhc3NlZCBiZXlvbmQgYSBtdWx0aXBsZSBvZiAxMCB3aXRoaW4gdGhlIHNhbWUgdmVyc2lvbi5cbiAgLy8gV2hlbiB0aGF0IGhhcHBlbnMsIGEgdGFibGUgJG1ldGEgd2lsbCBoYXZlIGJlZW4gY3JlYXRlZCwgY29udGFpbmluZyBhIHNpbmdsZSBlbnRyeSB3aXRoIGtleSBcInZlcnNpb25cIlxuICAvLyBhbmQgdGhlIHZhbHVlIG9mIHRoZSByZWFsIG9sZCB2ZXJzaW9uIHRvIHVzZSB3aGVuIHJ1bm5pbmcgdXBncmFkZXJzIGdvaW5nIGZvcndhcmQuXG4gIGlmICh0cmFucy5zdG9yZU5hbWVzLmluY2x1ZGVzKCckbWV0YScpKSB7XG4gICAgcmV0dXJuIHRyYW5zLnRhYmxlKCckbWV0YScpLmdldCgndmVyc2lvbicpLnRoZW4obWV0YVZlcnNpb24gPT4ge1xuICAgICAgcmV0dXJuIG1ldGFWZXJzaW9uICE9IG51bGwgPyBtZXRhVmVyc2lvbiA6IG9sZFZlcnNpb25cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob2xkVmVyc2lvbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhcbiAgZGI6IERleGllLFxuICBvbGRWZXJzaW9uOiBudW1iZXIsXG4gIHRyYW5zOiBUcmFuc2FjdGlvbixcbiAgaWRiVXBncmFkZVRyYW5zOiBJREJUcmFuc2FjdGlvbilcbntcbiAgLy8gVXBncmFkZSB2ZXJzaW9uIHRvIHZlcnNpb24sIHN0ZXAtYnktc3RlcCBmcm9tIG9sZGVzdCB0byBuZXdlc3QgdmVyc2lvbi5cbiAgLy8gRWFjaCB0cmFuc2FjdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSB0YWJsZSBzZXQgdGhhdCB3YXMgY3VycmVudCBpbiB0aGF0IHZlcnNpb24gKGJ1dCBhbHNvIG5vdC15ZXQtZGVsZXRlZCB0YWJsZXMgZnJvbSBpdHMgcHJldmlvdXMgdmVyc2lvbilcbiAgY29uc3QgcXVldWU6IFVwZ3JhZGVRdWV1ZUl0ZW1bXSA9IFtdO1xuICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgbGV0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgbGV0IGFueUNvbnRlbnRVcGdyYWRlckhhc1J1biA9IGZhbHNlO1xuICBcbiAgY29uc3QgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gdi5fY2ZnLnZlcnNpb24gPj0gb2xkVmVyc2lvbik7XG4gIGlmICh2ZXJzVG9SdW4ubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSW1wb3J0YW50IG5vdCB0byBjb250aW51ZSBhdCB0aGlzIHBvaW50LlxuICAgIC8vIENvbWluZyBoZXJlIG1lYW5zIHdlJ3ZlIGFscmVhZHkgcGF0Y2hlZCBzY2hlbWEgaW4gcGF0Y2hDdXJyZW50VmVyc2lvbigpIGFmdGVyIGhhdmluZ1xuICAgIC8vIGluY3JlbWVudGVkIG5hdGl2ZSB2ZXJzaW9uIHRvIGEgdmFsdWUgYWJvdmUgdGhlIGRlY2xhcmVkIGhpZ2hlc3QgdmVyc2lvbi5cbiAgICAvLyBXaGVuIGJlaW5nIGluIHRoaXMgbW9kZSwgaXQgbWVhbnMgdGhhdCB0aGVyZSBtaWdodCBiZSBkaWZmZXJlbnQgdmVyc2lvbnMgdGhlIGRiIGNvbXBldGluZ1xuICAgIC8vIGFib3V0IGl0IHdpdGggZGlmZmVyZW50IHZlcnNpb24gb2YgdGhlIHNjaGVtYS4gVGhlcmVmb3JlLCB3ZSBtdXN0IGF2b2lkIGRlbGV0aW5nIHRhYmxlc1xuICAgIC8vIG9yIGluZGV4ZXMgaGVyZSBzbyB0aGF0IGJvdGggdmVyc2lvbnMgY2FuIGNvLWV4aXN0IHVudGlsIHRoZSBhcHBsaWNhdGlvbiBoYXMgYmVlbiB1cGdyYWRlZCB0b1xuICAgIC8vIGEgdmVyc2lvbiB0aGF0IGRlY2xhcmVzIG5vIGxvd2VyIHRoYW4gdGhlIG5hdGl2ZSB2ZXJzaW9uLlxuICAgIC8vIElmIGFmdGVyIHRoYXQsIGEgZG93bmdyYWRlIGhhcHBlbnMgYWdhaW4sIHdlJ2xsIGVuZCB1cCBoZXJlIGFnYWluLCBhY2NlcHRpbmcgYm90aCB2ZXJzaW9uc1xuICAgIC8vIEFuZCB3ZSdsbCBzdGF5IGluIHRoaXMgc3RhdGUgdW50aWwgYXBwIGRldmVsb3BlciByZWxlYXNlcyBhIG5ldyBkZWNsYXJlZCB2ZXJzaW9uLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgXG4gIH1cbiAgXG4gIHZlcnNUb1J1bi5mb3JFYWNoKHZlcnNpb24gPT4ge1xuICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgY29uc3Qgb2xkU2NoZW1hID0gZ2xvYmFsU2NoZW1hO1xuICAgICAgY29uc3QgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG9sZFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cbiAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG5ld1NjaGVtYTtcblxuICAgICAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpO1xuICAgICAgLy8gQWRkIHRhYmxlcyAgICAgICAgICAgXG4gICAgICBkaWZmLmFkZC5mb3JFYWNoKHR1cGxlID0+IHtcbiAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG4gICAgICB9KTtcbiAgICAgIC8vIENoYW5nZSB0YWJsZXNcbiAgICAgIGRpZmYuY2hhbmdlLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKGNoYW5nZS5uYW1lKTtcbiAgICAgICAgICAvLyBBZGQgaW5kZXhlc1xuICAgICAgICAgIGNoYW5nZS5hZGQuZm9yRWFjaChpZHggPT4gYWRkSW5kZXgoc3RvcmUsIGlkeCkpO1xuICAgICAgICAgIC8vIFVwZGF0ZSBpbmRleGVzXG4gICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICBzdG9yZS5kZWxldGVJbmRleChpZHgubmFtZSk7XG4gICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBEZWxldGUgaW5kZXhlc1xuICAgICAgICAgIGNoYW5nZS5kZWwuZm9yRWFjaChpZHhOYW1lID0+IHN0b3JlLmRlbGV0ZUluZGV4KGlkeE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuXG4gICAgICBpZiAoY29udGVudFVwZ3JhZGUgJiYgdmVyc2lvbi5fY2ZnLnZlcnNpb24gPiBvbGRWZXJzaW9uKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBkYi5jb3JlIHdpdGggbmV3IHRhYmxlcyBhbmQgaW5kZXhlczpcbiAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTsgLy8gSW52YWxpZGF0ZSBtZW1vaXphdGlvbiBhcyB0cmFuc2FjdGlvbiBzaGFwZSBtYXkgY2hhbmdlIGJldHdlZW4gdmVyc2lvbnMuXG5cbiAgICAgICAgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBBZGQgdG8tYmUtZGVsZXRlZCB0YWJsZXMgdG8gY29udGVudFVwZ3JhZGUgdHJhbnNhY3Rpb25cbiAgICAgICAgbGV0IHVwZ3JhZGVTY2hlbWEgPSBzaGFsbG93Q2xvbmUobmV3U2NoZW1hKTtcbiAgICAgICAgZGlmZi5kZWwuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgICAgdXBncmFkZVNjaGVtYVt0YWJsZV0gPSBvbGRTY2hlbWFbdGFibGVdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTYWZlIHRvIGFmZmVjdCBUcmFuc2FjdGlvbi5wcm90b3R5cGUgZ2xvYmFsbHkgaW4gdGhpcyBtb21lbnQsXG4gICAgICAgIC8vIGJlY2F1c2Ugd2hlbiB0aGlzIGNvZGUgcnVucywgdGhlcmUgbWF5IG5vdCBiZSBhbnkgb3RoZXIgY29kZVxuICAgICAgICAvLyB0aGF0IGNhbiBhY2Nlc3MgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlLCBlbHNlIHRoYW4gdGhpcyBwYXJ0aWN1bGFyXG4gICAgICAgIC8vIHVwZ3JhZGVyIGZ1bmN0aW9uLlxuICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYSksIHVwZ3JhZGVTY2hlbWEpO1xuICAgICAgICB0cmFucy5zY2hlbWEgPSB1cGdyYWRlU2NoZW1hO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIG5hdGl2ZSBhc3luYyBhd2FpdC5cbiAgICAgICAgY29uc3QgY29udGVudFVwZ3JhZGVJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKGNvbnRlbnRVcGdyYWRlKTtcbiAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTogYW55O1xuICAgICAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBQcm9taXNlLmZvbGxvdygoKSA9PiB7XG4gICAgICAgICAgLy8gRmluYWxseSwgY2FsbCB0aGUgc2NvcGUgZnVuY3Rpb24gd2l0aCBvdXIgdGFibGUgYW5kIHRyYW5zYWN0aW9uIGFyZ3VtZW50cy5cbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNvbnRlbnRVcGdyYWRlKHRyYW5zKTtcbiAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgLy8gY29udGVudFVwZ3JhZGUgaXMgYSBuYXRpdmUgYXN5bmMgZnVuY3Rpb24gLSB3ZSBrbm93IGZvciBzdXJlIHJldHVyblZhbHVlIGlzIG5hdGl2ZSBwcm9taXNlLlxuICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpPT5yZXR1cm5WYWx1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlLnB1c2goaWRidHJhbnMgPT4ge1xuICAgICAgY29uc3QgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgLy8gRGVsZXRlIG9sZCB0YWJsZXNcbiAgICAgIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucyk7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBmaW5hbCBBUElcbiAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGRiLl9zdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgdHJhbnMuc2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgIH0pO1xuICAgIC8vIE1haW50YWluIHRoZSAkbWV0YSB0YWJsZSBhZnRlciB0aGlzIHZlcnNpb24ncyB0YWJsZXMgYW5kIGluZGV4ZXMgaGFzIGJlZW4gY3JlYXRlZCBhbmQgY29udGVudCB1cGdyYWRlcnMgaGF2ZSBydW4uXG4gICAgcXVldWUucHVzaChpZGJ0cmFucyA9PiB7XG4gICAgICBpZiAoZGIuaWRiZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSkge1xuICAgICAgICBpZiAoTWF0aC5jZWlsKGRiLmlkYmRiLnZlcnNpb24gLyAxMCkgPT09IHZlcnNpb24uX2NmZy52ZXJzaW9uKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlICRtZXRhIHRhYmxlIGlmIGl0J3Mgbm8gbW9yZSBuZWVkZWQgLSB3ZSBhcmUgaW4gbGluZSB3aXRoIHRoZSBuYXRpdmUgdmVyc2lvblxuICAgICAgICAgIGRiLmlkYmRiLmRlbGV0ZU9iamVjdFN0b3JlKCckbWV0YScpO1xuICAgICAgICAgIGRlbGV0ZSBkYi5fZGJTY2hlbWEuJG1ldGE7XG4gICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBkYi5fc3RvcmVOYW1lcy5maWx0ZXIobmFtZSA9PiBuYW1lICE9PSAnJG1ldGEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSdyZSBzdGlsbCBub3QgaW4gbGluZSB3aXRoIHRoZSBuYXRpdmUgdmVyc2lvbi4gTWFrZSBzdXJlIHRvIHVwZGF0ZSB0aGUgdmlydHVhbCB2ZXJzaW9uXG4gICAgICAgICAgLy8gdG8gdGhlIHN1Y2Nlc3NmdWxseSBydW4gdmVyc2lvblxuICAgICAgICAgIGlkYnRyYW5zLm9iamVjdFN0b3JlKCckbWV0YScpLnB1dCh2ZXJzaW9uLl9jZmcudmVyc2lvbiwgJ3ZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyBcbiAgfSk7XG5cbiAgLy8gTm93LCBjcmVhdGUgYSBxdWV1ZSBleGVjdXRpb24gZW5naW5lXG4gIGZ1bmN0aW9uIHJ1blF1ZXVlKCkge1xuICAgIHJldHVybiBxdWV1ZS5sZW5ndGggPyBQcm9taXNlLnJlc29sdmUocXVldWUuc2hpZnQoKSh0cmFucy5pZGJ0cmFucykpLnRoZW4ocnVuUXVldWUpIDpcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHJ1blF1ZXVlKCkudGhlbigoKSA9PiB7XG4gICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhnbG9iYWxTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7IC8vIEF0IGxhc3QsIG1ha2Ugc3VyZSB0byBjcmVhdGUgYW55IG1pc3NpbmcgdGFibGVzLiAoTmVlZGVkIGJ5IGFkZG9ucyB0aGF0IGFkZCBzdG9yZXMgdG8gREIgd2l0aG91dCBzcGVjaWZ5aW5nIHZlcnNpb24pXG4gIH0pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVtYURpZmYge1xuICBkZWw6IHN0cmluZ1tdLFxuICBhZGQ6IFtzdHJpbmcsIFRhYmxlU2NoZW1hXVtdO1xuICBjaGFuZ2U6IFRhYmxlU2NoZW1hRGlmZltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU2NoZW1hRGlmZiB7XG4gIG5hbWU6IHN0cmluZyxcbiAgcmVjcmVhdGU6IGJvb2xlYW4sXG4gIGRlbDogc3RyaW5nW10sXG4gIGFkZDogSW5kZXhTcGVjW10sXG4gIGNoYW5nZTogSW5kZXhTcGVjW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hOiBEYlNjaGVtYSwgbmV3U2NoZW1hOiBEYlNjaGVtYSk6IFNjaGVtYURpZmYge1xuICBjb25zdCBkaWZmOiBTY2hlbWFEaWZmID0ge1xuICAgIGRlbDogW10sIC8vIEFycmF5IG9mIHRhYmxlIG5hbWVzXG4gICAgYWRkOiBbXSwgLy8gQXJyYXkgb2YgW3RhYmxlTmFtZSwgbmV3RGVmaW5pdGlvbl1cbiAgICBjaGFuZ2U6IFtdIC8vIEFycmF5IG9mIHtuYW1lOiB0YWJsZU5hbWUsIHJlY3JlYXRlOiBuZXdEZWZpbml0aW9uLCBkZWw6IGRlbEluZGV4TmFtZXMsIGFkZDogbmV3SW5kZXhEZWZzLCBjaGFuZ2U6IGNoYW5nZWRJbmRleERlZnN9XG4gIH07XG4gIGxldCB0YWJsZTogc3RyaW5nO1xuICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuICAgIGlmICghbmV3U2NoZW1hW3RhYmxlXSkgZGlmZi5kZWwucHVzaCh0YWJsZSk7XG4gIH1cbiAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcbiAgICBjb25zdCBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLFxuICAgICAgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcbiAgICBpZiAoIW9sZERlZikge1xuICAgICAgZGlmZi5hZGQucHVzaChbdGFibGUsIG5ld0RlZl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgIG5hbWU6IHRhYmxlLFxuICAgICAgICBkZWY6IG5ld0RlZixcbiAgICAgICAgcmVjcmVhdGU6IGZhbHNlLFxuICAgICAgICBkZWw6IFtdLFxuICAgICAgICBhZGQ6IFtdLFxuICAgICAgICBjaGFuZ2U6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKFxuICAgICAgICAgIChcbiAgICAgICAgICAgICAvLyBjb21wYXJlIGtleVBhdGhzIG5vIG1hdHRlciBpZiBzdHJpbmcgb3Igc3RyaW5nW11cbiAgICAgICAgICAgICAvLyBjb21wYXJlIGZhbHN5IGtleXBhdGhzIHNhbWUgbm8gbWF0dGVyIGlmIHRoZXkgYXJlIG51bGwgb3IgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgJycrKG9sZERlZi5wcmltS2V5LmtleVBhdGh8fCcnKVxuICAgICAgICAgICkgIT09IChcbiAgICAgICAgICAgICcnKyhuZXdEZWYucHJpbUtleS5rZXlQYXRofHwnJylcbiAgICAgICAgICApIHx8XG4gICAgICAgICAgICAvLyBDb21wYXJlIHRoZSBhdXRvSW5jcmVtZW50IGZsYWcgYWxzb1xuICAgICAgICAgIChvbGREZWYucHJpbUtleS5hdXRvICE9PSBuZXdEZWYucHJpbUtleS5hdXRvKSlcbiAgICAgIHtcbiAgICAgICAgLy8gUHJpbWFyeSBrZXkgaGFzIGNoYW5nZWQuIFJlbW92ZSBhbmQgcmUtYWRkIHRhYmxlLlxuICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTYW1lIHByaW1hcnkga2V5LiBKdXN0IGZpbmQgb3V0IHdoYXQgZGlmZmVyczpcbiAgICAgICAgY29uc3Qgb2xkSW5kZXhlcyA9IG9sZERlZi5pZHhCeU5hbWU7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuICAgICAgICBsZXQgaWR4TmFtZTogc3RyaW5nO1xuICAgICAgICBmb3IgKGlkeE5hbWUgaW4gb2xkSW5kZXhlcykge1xuICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSkgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaWR4TmFtZSBpbiBuZXdJbmRleGVzKSB7XG4gICAgICAgICAgY29uc3Qgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSxcbiAgICAgICAgICAgIG5ld0lkeCA9IG5ld0luZGV4ZXNbaWR4TmFtZV07XG4gICAgICAgICAgaWYgKCFvbGRJZHgpIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuICAgICAgICAgIGVsc2UgaWYgKG9sZElkeC5zcmMgIT09IG5ld0lkeC5zcmMpIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2UuZGVsLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmFkZC5sZW5ndGggPiAwIHx8IGNoYW5nZS5jaGFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlKFxuICBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24sXG4gIHRhYmxlTmFtZTogc3RyaW5nLFxuICBwcmltS2V5OiBJbmRleFNwZWMsXG4gIGluZGV4ZXM6IEluZGV4U3BlY1tdXG4pIHtcbiAgY29uc3Qgc3RvcmUgPSBpZGJ0cmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZShcbiAgICB0YWJsZU5hbWUsXG4gICAgcHJpbUtleS5rZXlQYXRoID9cbiAgICAgIHsga2V5UGF0aDogcHJpbUtleS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSA6XG4gICAgICB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9XG4gICk7XG4gIGluZGV4ZXMuZm9yRWFjaChpZHggPT4gYWRkSW5kZXgoc3RvcmUsIGlkeCkpO1xuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNaXNzaW5nVGFibGVzKG5ld1NjaGVtYTogRGJTY2hlbWEsIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgIGlmICghaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG4gICAgICBpZiAoZGVidWcpIGNvbnNvbGUuZGVidWcoJ0RleGllOiBDcmVhdGluZyBtaXNzaW5nIHRhYmxlJywgdGFibGVOYW1lKTtcbiAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYTogRGJTY2hlbWEsIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICBbXS5zbGljZS5jYWxsKGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMpLmZvckVhY2goc3RvcmVOYW1lID0+XG4gICAgbmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCAmJiBpZGJ0cmFucy5kYi5kZWxldGVPYmplY3RTdG9yZShzdG9yZU5hbWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEluZGV4KHN0b3JlOiBJREJPYmplY3RTdG9yZSwgaWR4OiBJbmRleFNwZWMpIHtcbiAgc3RvcmUuY3JlYXRlSW5kZXgoaWR4Lm5hbWUsIGlkeC5rZXlQYXRoLCB7IHVuaXF1ZTogaWR4LnVuaXF1ZSwgbXVsdGlFbnRyeTogaWR4Lm11bHRpIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZEdsb2JhbFNjaGVtYShcbiAgZGI6IERleGllLFxuICBpZGJkYjogSURCRGF0YWJhc2UsXG4gIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvblxuKSB7XG4gIGNvbnN0IGdsb2JhbFNjaGVtYSA9IHt9O1xuICBjb25zdCBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgZGJTdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHRtcFRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgbGV0IGtleVBhdGggPSBzdG9yZS5rZXlQYXRoO1xuICAgIGNvbnN0IHByaW1LZXkgPSBjcmVhdGVJbmRleFNwZWMoXG4gICAgICBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCksXG4gICAgICBrZXlQYXRoIHx8IFwiXCIsXG4gICAgICB0cnVlLFxuICAgICAgZmFsc2UsXG4gICAgICAhIXN0b3JlLmF1dG9JbmNyZW1lbnQsXG4gICAgICBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgaW5kZXhlczogSW5kZXhTcGVjW10gPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG4gICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhcbiAgICAgICAgaWRiaW5kZXgubmFtZSxcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgISFpZGJpbmRleC51bmlxdWUsXG4gICAgICAgICEhaWRiaW5kZXgubXVsdGlFbnRyeSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICB9KTtcbiAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoZGI6IERleGllLCBpZGJkYjogSURCRGF0YWJhc2UsIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICBkYi52ZXJubyA9IGlkYmRiLnZlcnNpb24gLyAxMDtcbiAgY29uc3QgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiOiBEZXhpZSwgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKTogYm9vbGVhbiB7XG4gIGNvbnN0IGluc3RhbGxlZFNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgdG1wVHJhbnMpO1xuICBjb25zdCBkaWZmID0gZ2V0U2NoZW1hRGlmZihpbnN0YWxsZWRTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gIHJldHVybiAhKGRpZmYuYWRkLmxlbmd0aCB8fCBkaWZmLmNoYW5nZS5zb21lKGNoID0+IGNoLmFkZC5sZW5ndGggfHwgY2guY2hhbmdlLmxlbmd0aCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGI6IERleGllLCBzY2hlbWE6IERiU2NoZW1hLCBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgLy8gSXNzdWUgIzMwIFByb2JsZW0gd2l0aCBleGlzdGluZyBkYiAtIGFkanVzdCB0byBleGlzdGluZyBpbmRleCBuYW1lcyB3aGVuIG1pZ3JhdGluZyBmcm9tIG5vbi1kZXhpZSBkYlxuICBjb25zdCBzdG9yZU5hbWVzID0gaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuICAgIGNvbnN0IHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBkYi5faGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG4gICAgICBjb25zdCBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgY29uc3QgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG4gICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgY29uc3QgaW5kZXhTcGVjID0gc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgIGlmIChpbmRleFNwZWMpIHtcbiAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2luZGV4TmFtZV0gPSBpbmRleFNwZWM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCdWcgd2l0aCBnZXRBbGwoKSBvbiBTYWZhcmkgdmVyPDYwNCBvbiBXb3JrZXJzIG9ubHksIHNlZSBkaXNjdXNzaW9uIGZvbGxvd2luZyBQUiAjNTc5XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJiBfZ2xvYmFsIGluc3RhbmNlb2YgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG4gIHtcbiAgICBkYi5faGFzR2V0QWxsID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXM6IHN0cmluZyk6IEluZGV4U3BlY1tdIHtcbiAgcmV0dXJuIHByaW1LZXlBbmRJbmRleGVzLnNwbGl0KCcsJykubWFwKChpbmRleCwgaW5kZXhOdW0pID0+IHtcbiAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcbiAgICBjb25zdCBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTsgLy8gUmVtb3ZlIFwiJlwiLCBcIisrXCIgYW5kIFwiKlwiXG4gICAgLy8gTGV0IGtleVBhdGggb2YgXCJbYStiXVwiIGJlIFtcImFcIixcImJcIl06XG4gICAgY29uc3Qga2V5UGF0aCA9IC9eXFxbLy50ZXN0KG5hbWUpID8gbmFtZS5tYXRjaCgvXlxcWyguKilcXF0kLylbMV0uc3BsaXQoJysnKSA6IG5hbWU7XG5cbiAgICByZXR1cm4gY3JlYXRlSW5kZXhTcGVjKFxuICAgICAgbmFtZSxcbiAgICAgIGtleVBhdGggfHwgbnVsbCxcbiAgICAgIC9cXCYvLnRlc3QoaW5kZXgpLFxuICAgICAgL1xcKi8udGVzdChpbmRleCksXG4gICAgICAvXFwrXFwrLy50ZXN0KGluZGV4KSxcbiAgICAgIGlzQXJyYXkoa2V5UGF0aCksXG4gICAgICBpbmRleE51bSA9PT0gMFxuICAgICk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IFZlcnNpb24gYXMgSVZlcnNpb24gfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdmVyc2lvbic7XG5pbXBvcnQgeyBEYlNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYi1zY2hlbWEnO1xuaW1wb3J0IHsgZXh0ZW5kLCBrZXlzIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyByZW1vdmVUYWJsZXNBcGksIHNldEFwaU9uUGxhY2UsIHBhcnNlSW5kZXhTeW50YXggfSBmcm9tICcuL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgY3JlYXRlVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBub3AsIHByb21pc2FibGVDaGFpbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuXG4vKiogY2xhc3MgVmVyc2lvblxuICpcbiAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVmVyc2lvbi9WZXJzaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBWZXJzaW9uIGltcGxlbWVudHMgSVZlcnNpb24ge1xuICBkYjogRGV4aWU7XG4gIF9jZmc6IHtcbiAgICB2ZXJzaW9uOiBudW1iZXIsXG4gICAgc3RvcmVzU291cmNlOiB7IFt0YWJsZU5hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bGwgfSxcbiAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgdGFibGVzOiB7fSxcbiAgICBjb250ZW50VXBncmFkZTogRnVuY3Rpb24gfCBudWxsXG4gIH1cblxuICBfcGFyc2VTdG9yZXNTcGVjKHN0b3JlczogeyBbdGFibGVOYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBudWxsIH0sIG91dFNjaGVtYTogRGJTY2hlbWEpOiBhbnkge1xuICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgIHZhciBwcmltS2V5ID0gaW5kZXhlcy5zaGlmdCgpO1xuICAgICAgICAgIHByaW1LZXkudW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJpbUtleS5tdWx0aSkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpLXZhbHVlZFwiKTtcbiAgICAgICAgICBpbmRleGVzLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJPbmx5IHByaW1hcnkga2V5IGNhbiBiZSBtYXJrZWQgYXMgYXV0b0luY3JlbWVudCAoKyspXCIpO1xuICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJJbmRleCBtdXN0IGhhdmUgYSBuYW1lIGFuZCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG91dFNjaGVtYVt0YWJsZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0b3JlcyhzdG9yZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVsbDsgfSk6IElWZXJzaW9uIHtcbiAgICBjb25zdCBkYiA9IHRoaXMuZGI7XG4gICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgP1xuICAgICAgZXh0ZW5kKHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UsIHN0b3JlcykgOlxuICAgICAgc3RvcmVzO1xuICAgIGNvbnN0IHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuXG4gICAgLy8gRGVyaXZlIHN0b3JlcyBmcm9tIGVhcmxpZXIgdmVyc2lvbnMgaWYgdGhleSBhcmUgbm90IGV4cGxpY2l0ZWx5IHNwZWNpZmllZCBhcyBudWxsIG9yIGEgbmV3IHN5bnRheC5cbiAgICBjb25zdCBzdG9yZXNTcGVjOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfSA9IHt9O1xuICAgIGxldCBkYnNjaGVtYSA9IHt9O1xuICAgIHZlcnNpb25zLmZvckVhY2godmVyc2lvbiA9PiB7IC8vICd2ZXJzaW9ucycgaXMgYWx3YXlzIHNvcnRlZCBieSBsb3dlc3QgdmVyc2lvbiBmaXJzdC5cbiAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgIGRic2NoZW1hID0gKHZlcnNpb24uX2NmZy5kYnNjaGVtYSA9IHt9KTtcbiAgICAgIHZlcnNpb24uX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG4gICAgfSk7XG4gICAgLy8gVXBkYXRlIHRoZSBsYXRlc3Qgc2NoZW1hIHRvIHRoaXMgdmVyc2lvblxuICAgIGRiLl9kYlNjaGVtYSA9IGRic2NoZW1hO1xuICAgIC8vIFVwZGF0ZSBBUElzXG4gICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB0aGlzLl9jZmcudGFibGVzXSwga2V5cyhkYnNjaGVtYSksIGRic2NoZW1hKTtcbiAgICBkYi5fc3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBncmFkZSh1cGdyYWRlRnVuY3Rpb246ICh0cmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkKTogVmVyc2lvbiB7XG4gICAgdGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlID0gcHJvbWlzYWJsZUNoYWluKHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSB8fCBub3AsIHVwZ3JhZGVGdW5jdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvbkNvbnN0cnVjdG9yIHtcbiAgbmV3KHZlcnNpb25OdW1iZXI6IG51bWJlcik6IFZlcnNpb247XG4gIHByb3RvdHlwZTogVmVyc2lvbjtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIFZlcnNpb24gY29uc3RydWN0b3IgYm91bmQgdG8gZ2l2ZW4gRGV4aWUgaW5zdGFuY2UuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IoZGI6IERleGllKSB7XG4gIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcjxWZXJzaW9uQ29uc3RydWN0b3I+KFxuICAgIFZlcnNpb24ucHJvdG90eXBlLFxuXG4gICAgZnVuY3Rpb24gVmVyc2lvbih0aGlzOiBWZXJzaW9uLCB2ZXJzaW9uTnVtYmVyOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgIHRoaXMuX2NmZyA9IHtcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbk51bWJlcixcbiAgICAgICAgc3RvcmVzU291cmNlOiBudWxsLFxuICAgICAgICBkYnNjaGVtYToge30sXG4gICAgICAgIHRhYmxlczoge30sXG4gICAgICAgIGNvbnRlbnRVcGdyYWRlOiBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuXG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tIFwiLi4vY2xhc3Nlcy9kZXhpZS9kZXhpZVwiO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL3RhYmxlXCI7XG5pbXBvcnQgeyBEQk5BTUVTX0RCIH0gZnJvbSBcIi4uL2dsb2JhbHMvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBEZXhpZURPTURlcGVuZGVuY2llcyB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llc1wiO1xuaW1wb3J0IHsgbm9wIH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnNcIjtcblxudHlwZSBJREJLZXlOYW1lc1ZhciA9IHR5cGVvZiBJREJLZXlSYW5nZTtcblxuZnVuY3Rpb24gZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQjogSURCRmFjdG9yeSwgSURCS2V5UmFuZ2U6IElEQktleU5hbWVzVmFyKSB7XG4gIGxldCBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdO1xuICBpZiAoIWRiTmFtZXNEQikge1xuICAgIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl0gPSBuZXcgRGV4aWUoREJOQU1FU19EQiwge1xuICAgICAgYWRkb25zOiBbXSxcbiAgICAgIGluZGV4ZWREQixcbiAgICAgIElEQktleVJhbmdlLFxuICAgIH0pO1xuICAgIGRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6IFwibmFtZVwiIH0pO1xuICB9XG4gIHJldHVybiBkYk5hbWVzREIudGFibGUoXCJkYm5hbWVzXCIpIGFzIFRhYmxlPHsgbmFtZTogc3RyaW5nIH0sIHN0cmluZz47XG59XG5cbmZ1bmN0aW9uIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREI6IElEQkZhY3RvcnkpIHtcbiAgcmV0dXJuIGluZGV4ZWREQiAmJiB0eXBlb2YgaW5kZXhlZERCLmRhdGFiYXNlcyA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YWJhc2VOYW1lcyh7XG4gIGluZGV4ZWREQixcbiAgSURCS2V5UmFuZ2UsXG59OiBEZXhpZURPTURlcGVuZGVuY2llcykge1xuICByZXR1cm4gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQilcbiAgICA/IFByb21pc2UucmVzb2x2ZShpbmRleGVkREIuZGF0YWJhc2VzKCkpLnRoZW4oKGluZm9zKSA9PlxuICAgICAgICBpbmZvc1xuICAgICAgICAgIC8vIFNlbGVjdCBuYW1lIHByb3Agb2YgaW5mb3M6XG4gICAgICAgICAgLm1hcCgoaW5mbykgPT4gaW5mby5uYW1lKVxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgREJOQU1FU19EQiBhcyBwcmV2aW91cyBEZXhpZSBvciBicm93c2VyIHZlcnNpb24gd291bGQgbm90IGhhdmUgaW5jbHVkZWQgaXQgaW4gdGhlIHJlc3VsdC5cbiAgICAgICAgICAuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSBEQk5BTUVTX0RCKVxuICAgICAgKVxuICAgIDogZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnRvQ29sbGVjdGlvbigpLnByaW1hcnlLZXlzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfb25EYXRhYmFzZUNyZWF0ZWQoXG4gIHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSB9OiBEZXhpZURPTURlcGVuZGVuY2llcyxcbiAgbmFtZTogc3RyaW5nXG4pIHtcbiAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5wdXQoe25hbWV9KS5jYXRjaChub3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX29uRGF0YWJhc2VEZWxldGVkKFxuICB7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UgfTogRGV4aWVET01EZXBlbmRlbmNpZXMsXG4gIG5hbWU6IHN0cmluZ1xuKSB7XG4gICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkuZGVsZXRlKG5hbWUpLmNhdGNoKG5vcCk7XG59XG4iLCAiaW1wb3J0IHsgbmV3U2NvcGUgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHZpcCAoZm4pIHtcbiAgLy8gVG8gYmUgdXNlZCBieSBzdWJzY3JpYmVycyB0byB0aGUgb24oJ3JlYWR5JykgZXZlbnQuXG4gIC8vIFRoaXMgd2lsbCBsZXQgY2FsbGVyIHRocm91Z2ggdG8gYWNjZXNzIERCIGV2ZW4gd2hlbiBpdCBpcyBibG9ja2VkIHdoaWxlIHRoZSBkYi5yZWFkeSgpIHN1YnNjcmliZXJzIGFyZSBmaXJpbmcuXG4gIC8vIFRoaXMgd291bGQgaGF2ZSB3b3JrZWQgYXV0b21hdGljYWxseSBpZiB3ZSB3ZXJlIGNlcnRhaW4gdGhhdCB0aGUgUHJvdmlkZXIgd2FzIHVzaW5nIERleGllLlByb21pc2UgZm9yIGFsbCBhc3luY3JvbmljIG9wZXJhdGlvbnMuIFRoZSBwcm9taXNlIFBTRFxuICAvLyBmcm9tIHRoZSBwcm92aWRlci5jb25uZWN0KCkgY2FsbCB3b3VsZCB0aGVuIGJlIGRlcml2ZWQgYWxsIHRoZSB3YXkgdG8gd2hlbiBwcm92aWRlciB3b3VsZCBjYWxsIGxvY2FsRGF0YWJhc2UuYXBwbHlDaGFuZ2VzKCkuIEJ1dCBzaW5jZVxuICAvLyB0aGUgcHJvdmlkZXIgbW9yZSBsaWtlbHkgaXMgdXNpbmcgbm9uLXByb21pc2UgYXN5bmMgQVBJcyBvciBvdGhlciB0aGVuYWJsZSBpbXBsZW1lbnRhdGlvbnMsIHdlIGNhbm5vdCBhc3N1bWUgdGhhdC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZnVsIGZvciBvbigncmVhZHknKSBzdWJzY3JpYmVycyB0aGF0IGlzIHJldHVybmluZyBhIFByb21pc2UgZnJvbSB0aGUgZXZlbnQuIElmIG5vdCB1c2luZyB2aXAoKVxuICAvLyB0aGUgZGF0YWJhc2UgY291bGQgZGVhZGxvY2sgc2luY2UgaXQgd29udCBvcGVuIHVudGlsIHRoZSByZXR1cm5lZCBQcm9taXNlIGlzIHJlc29sdmVkLCBhbmQgYW55IG5vbi1WSVBlZCBvcGVyYXRpb24gc3RhcnRlZCBieVxuICAvLyB0aGUgY2FsbGVyIHdpbGwgbm90IHJlc29sdmUgdW50aWwgZGF0YWJhc2UgaXMgb3BlbmVkLlxuICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgIFBTRC5sZXRUaHJvdWdoID0gdHJ1ZTsgLy8gTWFrZSBzdXJlIHdlIGFyZSBsZXQgdGhyb3VnaCBpZiBzdGlsbCBibG9ja2luZyBkYiBkdWUgdG8gb25yZWFkeSBpcyBmaXJpbmcuXG4gICAgcmV0dXJuIGZuKCk7XG4gIH0pO1xufVxuXG4iLCAiLyoqXG4gKiBXb3JrIGFyb3VuZCBTYWZhcmkgMTQgSW5kZXhlZERCIG9wZW4gYnVnLlxuICpcbiAqIFNhZmFyaSBoYXMgYSBob3JyaWJsZSBidWcgd2hlcmUgSURCIHJlcXVlc3RzIGNhbiBoYW5nIHdoaWxlIHRoZSBicm93c2VyIGlzIHN0YXJ0aW5nIHVwLiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2NTQ3XG4gKiBUaGUgb25seSBzb2x1dGlvbiBpcyB0byBrZWVwIG51ZGdpbmcgaXQgdW50aWwgaXQncyBhd2FrZS5cbiAqL1xuZnVuY3Rpb24gaWRiUmVhZHkoKSB7XG4gICAgdmFyIGlzU2FmYXJpID0gIW5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmXG4gICAgICAgIC9TYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgIS9DaHJvbShlfGl1bSlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgLy8gTm8gcG9pbnQgcHV0dGluZyBvdGhlciBicm93c2VycyBvciBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgdGhyb3VnaCB0aGlzIG1lc3MuXG4gICAgaWYgKCFpc1NhZmFyaSB8fCAhaW5kZXhlZERCLmRhdGFiYXNlcylcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBpbnRlcnZhbElkO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgdHJ5SWRiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhlZERCLmRhdGFiYXNlcygpLmZpbmFsbHkocmVzb2x2ZSk7IH07XG4gICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0cnlJZGIsIDEwMCk7XG4gICAgICAgIHRyeUlkYigpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTsgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkYlJlYWR5O1xuIiwgImltcG9ydCB7IGNtcCB9IGZyb20gXCIuLi9mdW5jdGlvbnMvY21wXCI7XG5pbXBvcnQgeyBleHRlbmQsIGl0ZXJhdG9yU3ltYm9sLCBwcm9wcyB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vcHVibGljJztcbmltcG9ydCB7XG4gIEVtcHR5UmFuZ2UsXG4gIEludGVydmFsVHJlZSxcbiAgSW50ZXJ2YWxUcmVlTm9kZSxcbiAgUmFuZ2VTZXRDb25zdHJ1Y3RvcixcbiAgUmFuZ2VTZXRQcm90b3R5cGUsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvcmFuZ2VzZXRcIjtcblxuLyogQW4gaW50ZXJ2YWwgdHJlZSBpbXBsZW1lbnRhdGlvbiB0byBlZmZpY2llbnRseSBkZXRlY3Qgb3ZlcmxhcHBpbmcgcmFuZ2VzIG9mIHF1ZXJpZWQgaW5kZXhlcy5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVlXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZTogSW50ZXJ2YWxUcmVlIHwge2Zyb206IEluZGV4YWJsZVR5cGUsIHRvOiBJbmRleGFibGVUeXBlfSk6IG5vZGUgaXMgRW1wdHlSYW5nZSB7XG4gIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xufVxuXG5leHBvcnQgdHlwZSBSYW5nZVNldCA9IFJhbmdlU2V0UHJvdG90eXBlICYgSW50ZXJ2YWxUcmVlO1xuXG5leHBvcnQgY29uc3QgUmFuZ2VTZXQgPSBmdW5jdGlvbihmcm9tT3JUcmVlOiBhbnksIHRvPzogYW55KSB7XG4gIGlmICh0aGlzKSB7XG4gICAgLy8gQ2FsbGVkIHdpdGggbmV3KClcbiAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHtkOjEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZX0gOiB7ZDowfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FsbGVkIHdpdGhvdXQgbmV3KClcbiAgICBjb25zdCBydiA9IG5ldyBSYW5nZVNldCgpO1xuICAgIGlmIChmcm9tT3JUcmVlICYmIChcImRcIiBpbiBmcm9tT3JUcmVlKSkge1xuICAgICAgZXh0ZW5kKHJ2LCBmcm9tT3JUcmVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG59IGFzIFJhbmdlU2V0Q29uc3RydWN0b3I7XG5cbnByb3BzKFJhbmdlU2V0LnByb3RvdHlwZSwge1xuICBhZGQocmFuZ2VTZXQ6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pIHtcbiAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEtleShrZXk6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEtleXMoa2V5czogSW5kZXhhYmxlVHlwZVtdKSB7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBoYXNLZXkoa2V5OiBJbmRleGFibGVUeXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcykubmV4dChrZXkpLnZhbHVlO1xuICAgIHJldHVybiBub2RlICYmIGNtcChub2RlLmZyb20sIGtleSkgPD0gMCAmJiBjbXAobm9kZS50bywga2V5KSA+PSAwO1xuICB9LFxuXG4gIFtpdGVyYXRvclN5bWJvbF0oKTogSXRlcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRSYW5nZSh0YXJnZXQ6IEludGVydmFsVHJlZSwgZnJvbTogSW5kZXhhYmxlVHlwZSwgdG86IEluZGV4YWJsZVR5cGUpIHtcbiAgY29uc3QgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gIC8vIGNtcCgpIHJldHVybnMgTmFOIGlmIG9uZSBvZiB0aGUgYXJncyBhcmUgSURCLWludmFsaWQga2V5cy5cbiAgLy8gQXZvaWQgc3RvcmluZyBpbnZhbGlkIGtleXMgaW4gcmFuZ2VzZXQ6XG4gIGlmIChpc05hTihkaWZmKSkgcmV0dXJuO1xuXG4gIC8vIENhbGxlciBpcyB0cnlpbmcgdG8gYWRkIGEgcmFuZ2Ugd2hlcmUgZnJvbSBpcyBncmVhdGVyIHRoYW4gdG86XG4gIGlmIChkaWZmID4gMCkgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICBcbiAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKSByZXR1cm4gZXh0ZW5kKHRhcmdldCwgeyBmcm9tLCB0bywgZDogMSB9KTtcbiAgY29uc3QgbGVmdCA9IHRhcmdldC5sO1xuICBjb25zdCByaWdodCA9IHRhcmdldC5yO1xuICBpZiAoY21wKHRvLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgbGVmdFxuICAgICAgPyBhZGRSYW5nZShsZWZ0LCBmcm9tLCB0bylcbiAgICAgIDogKHRhcmdldC5sID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gIH1cbiAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuICAgIHJpZ2h0XG4gICAgICA/IGFkZFJhbmdlKHJpZ2h0LCBmcm9tLCB0bylcbiAgICAgIDogKHRhcmdldC5yID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gIH1cbiAgLy8gTm93IHdlIGhhdmUgc29tZSBraW5kIG9mIG92ZXJsYXAuIFdlIHdpbGwgYmUgYWJsZSB0byBtZXJnZSB0aGUgbmV3IHJhbmdlIGludG8gdGhlIG5vZGUgb3IgbGV0IGl0IGJlIHN3YWxsb3dlZC5cblxuICAvLyBHcm93IGxlZnQ/XG4gIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgIHRhcmdldC5mcm9tID0gZnJvbTtcbiAgICB0YXJnZXQubCA9IG51bGw7IC8vIEN1dCBvZmYgZm9yIG5vdy4gUmUtYWRkIGxhdGVyLlxuICAgIHRhcmdldC5kID0gcmlnaHQgPyByaWdodC5kICsgMSA6IDE7XG4gIH1cbiAgLy8gR3JvdyByaWdodD9cbiAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICB0YXJnZXQudG8gPSB0bztcbiAgICB0YXJnZXQuciA9IG51bGw7IC8vIEN1dCBvZmYgZm9yIG5vdy4gUmUtYWRkIGxhdGVyLlxuICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gIH1cbiAgY29uc3QgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG4gIC8vIFJlLWFkZCBsZWZ0P1xuICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAvL1JhbmdlcyB0byB0aGUgbGVmdCBtYXkgYmUgc3dhbGxvd2VkLiBDdXQgaXQgb2YgYW5kIHJlLWFkZCBhbGwuXG4gICAgLy9Db3VsZCBwcm9iYWJseSBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkhXG4gICAgbWVyZ2VSYW5nZXModGFyZ2V0LCBsZWZ0KTtcbiAgfVxuICAvLyBSZS1hZGQgcmlnaHQ/XG4gIGlmIChyaWdodCAmJiByaWdodFdhc0N1dE9mZikge1xuICAgIC8vUmFuZ2VzIHRvIHRoZSByaWdodCBtYXkgYmUgc3dhbGxvd2VkLiBDdXQgaXQgb2YgYW5kIHJlLWFkZCBhbGwuXG4gICAgLy9Db3VsZCBwcm9iYWJseSBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkhXG4gICAgbWVyZ2VSYW5nZXModGFyZ2V0LCByaWdodCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHRhcmdldDogSW50ZXJ2YWxUcmVlLCBuZXdTZXQ6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pIHtcbiAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KFxuICAgIHRhcmdldDogSW50ZXJ2YWxUcmVlLFxuICAgIHsgZnJvbSwgdG8sIGwsIHIgfTogSW50ZXJ2YWxUcmVlTm9kZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZSwgbD86IHVuZGVmaW5lZCwgcj86IHVuZGVmaW5lZH1cbiAgKSB7XG4gICAgYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0byk7XG4gICAgaWYgKGwpIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgIGlmIChyKSBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcbiAgfVxuXG4gIGlmKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSkgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAoXG4gIHJhbmdlU2V0MTogSW50ZXJ2YWxUcmVlLFxuICByYW5nZVNldDI6IEludGVydmFsVHJlZVxuKTogYm9vbGVhbiB7XG4gICAgLy8gU3RhcnQgaXRlcmF0aW5nIG90aGVyIGZyb20gc2NyYXRjaC5cbiAgICBjb25zdCBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcbiAgICBsZXQgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgaWYgKG5leHRSZXN1bHQxLmRvbmUpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuXG4gICAgLy8gU3RhcnQgaXRlcmF0aW5nIHRoaXMgZnJvbSBzdGFydCBvZiBvdGhlclxuICAgIGNvbnN0IGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuICAgIGxldCBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTsgLy8gU3RhcnQgZnJvbSBiZWdpbm5pbmcgb2Ygb3RoZXIgcmFuZ2VcbiAgICBsZXQgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuXG4gICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICBpZiAoY21wKGIhLmZyb20sIGEudG8pIDw9IDAgJiYgY21wKGIhLnRvLCBhLmZyb20pID49IDApIHJldHVybiB0cnVlO1xuICAgICAgY21wKGEuZnJvbSwgYiEuZnJvbSkgPCAwXG4gICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIhLmZyb20pKS52YWx1ZSEpIC8vIGEgaXMgYmVoaW5kLiBmb3J3YXJkIGl0IHRvIGJlZ2lubmluZyBvZiBuZXh0IGItcmFuZ2VcbiAgICAgICAgOiAoYiA9IChuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKSkudmFsdWUpOyAvLyBiIGlzIGJlaGluZC4gZm9yd2FyZCBpdCB0byBiZWdpbm5pbmcgb2YgbmV4dCBhLXJhbmdlXG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnR5cGUgUmFuZ2VTZXRJdGVyYXRvclN0YXRlID1cbiAgfCB7XG4gICAgICB1cD86IFJhbmdlU2V0SXRlcmF0b3JTdGF0ZTtcbiAgICAgIG46IEludGVydmFsVHJlZU5vZGU7XG4gICAgICBzOiAwIHwgMSB8IDIgfCAzO1xuICAgIH1cbiAgfCB1bmRlZmluZWRcbiAgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlU2V0SXRlcmF0b3IoXG4gIG5vZGU6IEVtcHR5UmFuZ2UgfCBJbnRlcnZhbFRyZWVOb2RlXG4pOiBHZW5lcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlIHwgdW5kZWZpbmVkPiB7XG4gIGxldCBzdGF0ZTogUmFuZ2VTZXRJdGVyYXRvclN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuXG4gIHJldHVybiB7XG4gICAgbmV4dChrZXk/KSB7XG4gICAgICBjb25zdCBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgd2hpbGUgKHN0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUucykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIEluaXRpYWwgc3RhdGUgZm9yIG5vZGUuXG4gICAgICAgICAgICAvLyBGYXN0IGZvcndhcmQgdG8gbGVmdG1vc3Qgbm9kZS5cbiAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwgJiYgY21wKGtleSwgc3RhdGUubi5mcm9tKSA8IDApXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKSBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGZhbGwgaW50byBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gV2UncmUgb24gYSBub2RlIHdoZXJlIGl0J3MgbGVmdCBwYXJ0IGlzIGFscmVhZHkgaGFuZGxlZCBvciBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgIHN0YXRlLnMgPSAyO1xuICAgICAgICAgICAgaWYgKCFrZXlQcm92aWRlZCB8fCBjbXAoa2V5LCBzdGF0ZS5uLnRvKSA8PSAwKVxuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RhdGUubiwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBXZSd2ZSBlbWl0dGVkIG91ciBub2RlIGFuZCBzaG91bGQgY29udGludWUgd2l0aCB0aGUgcmlnaHQgcGFydCBvciBsZXQgcGFyZW50IHRha2Ugb3ZlciBmcm9tIGl0J3Mgc3RhdGUgMVxuICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuICAgICAgICAgICAgICBzdGF0ZS5zID0gMzsgLy8gU28gd2hlbiBjaGlsZCBpcyBkb25lLCB3ZSBrbm93IHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gV2lsbCBmYWxsIGluIHRvIGNhc2UgMCB3aXRoIGZhc3QgZm9yd2FyZCB0byBsZWZ0IGxlYWYgb2YgdGhpcyBzdWJ0cmVlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZmFsbCBpbnRvIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgfSxcbiAgfSBhcyBHZW5lcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlPjtcbn1cblxuZnVuY3Rpb24gcmViYWxhbmNlKHRhcmdldDogSW50ZXJ2YWxUcmVlTm9kZSkge1xuICBjb25zdCBkaWZmID0gKHRhcmdldC5yPy5kIHx8IDApIC0gKHRhcmdldC5sPy5kIHx8IDApO1xuICBjb25zdCByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcbiAgaWYgKHIpIHtcblxuICAgIC8vIFJvdGF0ZSAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV9yb3RhdGlvbilcbiAgICAvL1xuICAgIC8vIFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBbT0xEUk9PVF1cbiAgICAvLyAgICAgICBbT0xEUk9PVC5MXSAgICAgICAgICAgIFtORVdST09UXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgW05FV1JPT1QuTF0gW05FV1JPT1QuUl1cbiAgICAvL1xuICAgIC8vIElzIGdvaW5nIHRvIGJlY29tZTpcbiAgICAvL1xuICAgIC8vIFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBbTkVXUk9PVF1cbiAgICAvLyAgICAgICAgW09MRFJPT1RdICAgICAgICAgICAgIFtORVdST09ULlJdXG4gICAgLy8gW09MRFJPT1QuTF0gW05FV1JPT1QuTF0gIFxuXG4gICAgLy8gKiBjbG9uZSBub3cgaGFzIHRoZSBwcm9wcyBvZiBPTERST09UXG4gICAgLy8gUGxhbjpcbiAgICAvLyAqIHRhcmdldCBtdXN0IGJlIGdpdmVuIHRoZSBwcm9wcyBvZiBORVdST09UXG4gICAgLy8gKiB0YXJnZXRbbF0gbXVzdCBwb2ludCB0byBhIG5ldyBPTERST09UXG4gICAgLy8gKiB0YXJnZXRbcl0gbXVzdCBwb2ludCB0byBORVdST09ULlJcbiAgICAvLyAqIE9MRFJPT1Rbcl0gbXVzdCBwb2ludCB0byBORVdST09ULkxcbiAgICBjb25zdCBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiOyAvLyBTdXBwb3J0IGJvdGggbGVmdC9yaWdodCByb3RhdGlvblxuICAgIGNvbnN0IHJvb3RDbG9uZSA9IHsgLi4udGFyZ2V0IH07XG4gICAgLy8gV2UncmUgZ29ubmEgY29weSBwcm9wcyBmcm9tIHRhcmdldCdzIHJpZ2h0IG5vZGUgaW50byB0YXJnZXQgc28gdGhhdCB0YXJnZXQgd2lsbFxuICAgIC8vIGhhdmUgc2FtZSByYW5nZSBhcyBvbGQgdGFyZ2V0W3JdIChpbnN0ZWFkIG9mIGNoYW5naW5nIHBvaW50ZXJzLCB3ZSBjb3B5IHZhbHVlcy5cbiAgICAvLyB0aGF0IHdheSB3ZSBkbyBub3QgbmVlZCB0byBhZGp1c3QgcG9pbnRlcnMgaW4gcGFyZW50cykuXG4gICAgY29uc3Qgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdOyBcbiAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgIHRhcmdldC50byA9IG9sZFJvb3RSaWdodC50bztcbiAgICB0YXJnZXRbcl0gPSBvbGRSb290UmlnaHRbcl07XG4gICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgIHRhcmdldFtsXSA9IHJvb3RDbG9uZTtcbiAgICByb290Q2xvbmUuZCA9IGNvbXB1dGVEZXB0aChyb290Q2xvbmUpO1xuICB9XG4gIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZXB0aCh7IHIsIGwgfTogUGljazxJbnRlcnZhbFRyZWVOb2RlLCBcImxcIiB8IFwiclwiPikge1xuICByZXR1cm4gKHIgPyAobCA/IE1hdGgubWF4KHIuZCwgbC5kKSA6IHIuZCkgOiBsID8gbC5kIDogMCkgKyAxO1xufVxuIiwgImltcG9ydCB7IGNsb25lU2ltcGxlT2JqZWN0VHJlZSwgZGVlcENsb25lLCBrZXlzLCBvYmplY3RJc0VtcHR5IH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgbWVyZ2VSYW5nZXMsIFJhbmdlU2V0IH0gZnJvbSBcIi4uL2hlbHBlcnMvcmFuZ2VzZXRcIjtcbmltcG9ydCB7IE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChcbiAgdGFyZ2V0OiBPYnNlcnZhYmlsaXR5U2V0LFxuICBuZXdTZXQ6IE9ic2VydmFiaWxpdHlTZXRcbik6IE9ic2VydmFiaWxpdHlTZXQge1xuICBrZXlzKG5ld1NldCkuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBpZiAodGFyZ2V0W3BhcnRdKSBtZXJnZVJhbmdlcyh0YXJnZXRbcGFydF0sIG5ld1NldFtwYXJ0XSk7XG4gICAgZWxzZSB0YXJnZXRbcGFydF0gPSBjbG9uZVNpbXBsZU9iamVjdFRyZWUobmV3U2V0W3BhcnRdKTsgLy8gU29tZXdoYXQgZmFzdGVyXG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwgImltcG9ydCB7IHJhbmdlc092ZXJsYXAgfSBmcm9tICcuLi9oZWxwZXJzL3Jhbmdlc2V0JztcbmltcG9ydCB7IE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG9ic1NldHNPdmVybGFwKG9zMTogT2JzZXJ2YWJpbGl0eVNldCwgb3MyOiBPYnNlcnZhYmlsaXR5U2V0KSB7XG4gIHJldHVybiBvczEuYWxsIHx8IG9zMi5hbGwgfHwgT2JqZWN0LmtleXMob3MxKS5zb21lKFxuICAgIChrZXkpID0+IG9zMltrZXldICYmIHJhbmdlc092ZXJsYXAob3MyW2tleV0sIG9zMVtrZXldKVxuICApO1xufVxuIiwgImltcG9ydCB7IHR5cGUgR2xvYmFsUXVlcnlDYWNoZSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvY2FjaGVcIjtcblxuZXhwb3J0IGNvbnN0IGNhY2hlOiBHbG9iYWxRdWVyeUNhY2hlID0ge31cbiIsICJpbXBvcnQgeyBDYWNoZUVudHJ5LCBUYmxRdWVyeUNhY2hlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2NhY2hlJztcbmltcG9ydCB7IE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzJztcbmltcG9ydCB7IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tICcuLi9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXQnO1xuaW1wb3J0IHsgb2JzU2V0c092ZXJsYXAgfSBmcm9tICcuLi9vYnMtc2V0cy1vdmVybGFwJztcbmltcG9ydCB7IGNhY2hlIH0gZnJvbSAnLi9jYWNoZSc7XG5cbmxldCB1bnNpZ25hbGVkUGFydHM6IE9ic2VydmFiaWxpdHlTZXQgPSB7fTtcbmxldCBpc1Rhc2tFbnF1ZXVlZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocGFydDogT2JzZXJ2YWJpbGl0eVNldCwgb3B0aW1pc3RpYyA9IGZhbHNlKSB7XG4gIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodW5zaWduYWxlZFBhcnRzLCBwYXJ0KTtcbiAgaWYgKCFpc1Rhc2tFbnF1ZXVlZCkge1xuICAgIGlzVGFza0VucXVldWVkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlzVGFza0VucXVldWVkID0gZmFsc2U7XG4gICAgICBjb25zdCBwYXJ0cyA9IHVuc2lnbmFsZWRQYXJ0cztcbiAgICAgIHVuc2lnbmFsZWRQYXJ0cyA9IHt9O1xuICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3cocGFydHMsIGZhbHNlKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbmFsU3Vic2NyaWJlcnNOb3coXG4gIHVwZGF0ZWRQYXJ0czogT2JzZXJ2YWJpbGl0eVNldCxcbiAgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMgPSBmYWxzZVxuKSB7XG4gIGNvbnN0IHF1ZXJpZXNUb1NpZ25hbCA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKTtcbiAgaWYgKHVwZGF0ZWRQYXJ0cy5hbGwpIHtcbiAgICAvLyBTaWduYWwgYWxsIHN1YnNjcmliZXJzIHRvIHJlcXVlcnkuXG4gICAgZm9yIChjb25zdCB0YmxDYWNoZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlKSkge1xuICAgICAgY29sbGVjdFRhYmxlU3Vic2NyaWJlcnMoXG4gICAgICAgIHRibENhY2hlLFxuICAgICAgICB1cGRhdGVkUGFydHMsXG4gICAgICAgIHF1ZXJpZXNUb1NpZ25hbCxcbiAgICAgICAgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXNcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZWRQYXJ0cykge1xuICAgICAgY29uc3QgcGFydHMgPSAvXmlkYlxcOlxcL1xcLyguKilcXC8oLiopXFwvLy5leGVjKGtleSk7XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgY29uc3QgWywgZGJOYW1lLCB0YWJsZU5hbWVdID0gcGFydHM7XG4gICAgICAgIGNvbnN0IHRibENhY2hlID0gY2FjaGVbYGlkYjovLyR7ZGJOYW1lfS8ke3RhYmxlTmFtZX1gXTtcbiAgICAgICAgaWYgKHRibENhY2hlKVxuICAgICAgICAgIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKFxuICAgICAgICAgICAgdGJsQ2FjaGUsXG4gICAgICAgICAgICB1cGRhdGVkUGFydHMsXG4gICAgICAgICAgICBxdWVyaWVzVG9TaWduYWwsXG4gICAgICAgICAgICBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE5vdyB3aGVuIGFmZmVjdGVkIGNhY2hlIGVudHJpZXMgYXJlIHJlbW92ZWQsIHNpZ25hbCBjb2xsZWN0ZWQgc3Vic2NyaWJlcnMgdG8gcmVxdWVyeS5cbiAgcXVlcmllc1RvU2lnbmFsLmZvckVhY2goKHJlcXVlcnkpID0+IHJlcXVlcnkoKSk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKFxuICB0YmxDYWNoZTogVGJsUXVlcnlDYWNoZSxcbiAgdXBkYXRlZFBhcnRzOiBPYnNlcnZhYmlsaXR5U2V0LFxuICBvdXRRdWVyaWVzVG9TaWduYWw6IFNldDwoKSA9PiB2b2lkPixcbiAgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXM6IGJvb2xlYW5cbikge1xuICBjb25zdCB1cGRhdGVkRW50cnlMaXN0czogW3N0cmluZywgQ2FjaGVFbnRyeVtdXVtdID0gW107XG4gIGZvciAoY29uc3QgW2luZGV4TmFtZSwgZW50cmllc10gb2YgT2JqZWN0LmVudHJpZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSkpIHtcbiAgICBjb25zdCBmaWx0ZXJlZEVudHJpZXM6IENhY2hlRW50cnlbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgaWYgKG9ic1NldHNPdmVybGFwKHVwZGF0ZWRQYXJ0cywgZW50cnkub2JzU2V0KSkge1xuICAgICAgICAvLyBUaGlzIHF1ZXJ5IGlzIGFmZmVjdGVkIGJ5IHRoZSBtdXRhdGlvbi4gUmVtb3ZlIGl0IGZyb20gY2FjaGVcbiAgICAgICAgLy8gYW5kIHNpZ25hbCBhbGwgc3Vic2NyaWJlcnMgdG8gcmVxdWVyeS5cbiAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaCgocmVxdWVyeSkgPT4gb3V0UXVlcmllc1RvU2lnbmFsLmFkZChyZXF1ZXJ5KSk7XG4gICAgICB9IGVsc2UgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG4gICAgICAgIGZpbHRlcmVkRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29sbGVjdCBjYWNoZSBlbnRyaWVzIHRvIGJlIHVwZGF0ZWRcbiAgICBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpXG4gICAgICB1cGRhdGVkRW50cnlMaXN0cy5wdXNoKFtpbmRleE5hbWUsIGZpbHRlcmVkRW50cmllc10pO1xuICB9XG4gIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgIGZvciAoY29uc3QgW2luZGV4TmFtZSwgZmlsdGVyZWRFbnRyaWVzXSBvZiB1cGRhdGVkRW50cnlMaXN0cykge1xuICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVtpbmRleE5hbWVdID0gZmlsdGVyZWRFbnRyaWVzO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi9kZXhpZSc7XG5pbXBvcnQgKiBhcyBEZWJ1ZyBmcm9tICcuLi8uLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGV2ZW50UmVqZWN0SGFuZGxlciwgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IFByb21pc2UsIHsgd3JhcCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBjb25uZWN0aW9ucyB9IGZyb20gJy4uLy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IHJ1blVwZ3JhZGVycywgcmVhZEdsb2JhbFNjaGVtYSwgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMsIHZlcmlmeUluc3RhbGxlZFNjaGVtYSwgcGF0Y2hDdXJyZW50VmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24vc2NoZW1hLWhlbHBlcnMnO1xuaW1wb3J0IHsgc2FmYXJpTXVsdGlTdG9yZUZpeCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgX29uRGF0YWJhc2VDcmVhdGVkIH0gZnJvbSAnLi4vLi4vaGVscGVycy9kYXRhYmFzZS1lbnVtZXJhdG9yJztcbmltcG9ydCB7IHZpcCB9IGZyb20gJy4vdmlwJztcbmltcG9ydCB7IHByb21pc2FibGVDaGFpbiwgbm9wIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MgfSBmcm9tICcuL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzJztcbmltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCBzYWZhcmkxNFdvcmthcm91bmQgZnJvbSAnc2FmYXJpLTE0LWlkYi1maXgnO1xuaW1wb3J0IHsgdHlwZSBPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50cyc7XG5pbXBvcnQgeyBSYW5nZVNldCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcmFuZ2VzZXQnO1xuaW1wb3J0IHsgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGdsb2JhbEV2ZW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQgeyBzaWduYWxTdWJzY3JpYmVyc05vdyB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvY2FjaGUvc2lnbmFsU3Vic2NyaWJlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGV4aWVPcGVuIChkYjogRGV4aWUpIHtcbiAgY29uc3Qgc3RhdGUgPSBkYi5fc3RhdGU7XG4gIGNvbnN0IHtpbmRleGVkREJ9ID0gZGIuX2RlcHM7XG4gIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuICAgICAgcmV0dXJuIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW48RGV4aWU+KCgpID0+IHN0YXRlLmRiT3BlbkVycm9yID9cbiAgICAgICAgcmVqZWN0aW9uIChzdGF0ZS5kYk9wZW5FcnJvcikgOlxuICAgICAgICBkYik7XG4gIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG4gIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICBjb25zdCBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcbiAgbGV0IG5hdGl2ZVZlclRvT3BlbiA9IE1hdGgucm91bmQoZGIudmVybm8gKiAxMCk7XG4gIGxldCBzY2hlbWFQYXRjaE1vZGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuICAgIC8vIElmIHN0YXRlLm9wZW5DYW5jZWxsZXIgb2JqZWN0IHJlZmVyZW5jZSBpcyByZXBsYWNlZCwgaXQgbWVhbnMgZGIuY2xvc2UoKSBoYXMgYmVlbiBjYWxsZWQsXG4gICAgLy8gbWVhbmluZyB0aGlzIG9wZW4gZmxvdyBzaG91bGQgYmUgY2FuY2VsbGVkLlxuICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcbiAgfVxuICBcbiAgLy8gRnVuY3Rpb24gcG9pbnRlcnMgdG8gY2FsbCB3aGVuIHRoZSBjb3JlIG9wZW5pbmcgcHJvY2VzcyBjb21wbGV0ZXMuXG4gIGxldCByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgICAgLy8gdXBncmFkZVRyYW5zYWN0aW9uIHRvIGFib3J0IG9uIGZhaWx1cmUuXG4gICAgICB1cGdyYWRlVHJhbnNhY3Rpb246IChJREJUcmFuc2FjdGlvbiB8IG51bGwpID0gbnVsbCxcbiAgICAgIHdhc0NyZWF0ZWQgPSBmYWxzZTtcblxuICBjb25zdCB0cnlPcGVuREIgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgIC8vIElmIG5vIEFQSSwgdGhyb3chXG4gICAgaWYgKCFpbmRleGVkREIpIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICBjb25zdCBkYk5hbWUgPSBkYi5uYW1lO1xuICAgIFxuICAgIGNvbnN0IHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgfHwgIW5hdGl2ZVZlclRvT3BlbiA/XG4gICAgICBpbmRleGVkREIub3BlbihkYk5hbWUpIDpcbiAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSwgbmF0aXZlVmVyVG9PcGVuKTtcbiAgICBpZiAoIXJlcSkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpOyAvLyBNYXkgaGFwcGVuIGluIFNhZmFyaSBwcml2YXRlIG1vZGUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlci9EZXhpZS5qcy9pc3N1ZXMvMTM0XG4gICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICByZXEub25ibG9ja2VkID0gd3JhcChkYi5fZmlyZU9uQmxvY2tlZCk7XG4gICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAgKGUgPT4ge1xuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHsgLy8gVW5sZXNzIGFuIGFkZG9uIGhhcyBzcGVjaWZpZWQgZGIuX2FsbG93RW1wdHlEQiwgbGV0cyBtYWtlIHRoZSBjYWxsIGZhaWwuXG4gICAgICAgICAgICAvLyBDYWxsZXIgZGlkIG5vdCBzcGVjaWZ5IGEgdmVyc2lvbiBvciBzY2hlbWEuIERvaW5nIHRoYXQgaXMgb25seSBhY2NlcHRhYmxlIGZvciBvcGVuaW5nIGFscmVhZCBleGlzdGluZyBkYXRhYmFzZXMuXG4gICAgICAgICAgICAvLyBJZiBvbnVwZ3JhZGVuZWVkZWQgaXMgY2FsbGVkIGl0IG1lYW5zIGRhdGFiYXNlIGRpZCBub3QgZXhpc3QuIFJlamVjdCB0aGUgb3BlbigpIHByb21pc2UgYW5kIG1ha2Ugc3VyZSB0aGF0IHdlXG4gICAgICAgICAgICAvLyBkbyBub3QgY3JlYXRlIGEgbmV3IGRhdGFiYXNlIGJ5IGFjY2lkZW50IGhlcmUuXG4gICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0OyAvLyBQcm9oaWJpdCBvbmFib3J0IGVycm9yIGZyb20gZmlyaW5nIGJlZm9yZSB3ZSdyZSBkb25lIVxuICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7IC8vIEFib3J0IHRyYW5zYWN0aW9uICh3b3VsZCBob3BlIHRoYXQgdGhpcyB3b3VsZCBtYWtlIERCIGRpc2FwcGVhciBidXQgaXQgZG9lc250LilcbiAgICAgICAgICAgIC8vIENsb3NlIGRhdGFiYXNlIGFuZCBkZWxldGUgaXQuXG4gICAgICAgICAgICByZXEucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTsgLy8gVGhlIHVwZ3JhZGUgdHJhbnNhY3Rpb24gaXMgYXRvbWljLCBhbmQgamF2YXNjcmlwdCBpcyBzaW5nbGUgdGhyZWFkZWQgLSBtZWFuaW5nIHRoYXQgdGhlcmUgaXMgbm8gcmlzayB0aGF0IHdlIGRlbGV0ZSBzb21lb25lIGVsc2VzIGRhdGFiYXNlIGhlcmUhXG4gICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QgKG5ldyBleGNlcHRpb25zLk5vU3VjaERhdGFiYXNlKGBEYXRhYmFzZSAke2RiTmFtZX0gZG9lc250IGV4aXN0YCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24ub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmVyID0gZS5vbGRWZXJzaW9uID4gTWF0aC5wb3coMiwgNjIpID8gMCA6IGUub2xkVmVyc2lvbjsgLy8gU2FmYXJpIDggZml4LlxuICAgICAgICAgICAgd2FzQ3JlYXRlZCA9IG9sZFZlciA8IDE7XG4gICAgICAgICAgICBkYi5pZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1hUGF0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgIHBhdGNoQ3VycmVudFZlcnNpb24oZGIsIHVwZ3JhZGVUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5VcGdyYWRlcnMoZGIsIG9sZFZlciAvIDEwLCB1cGdyYWRlVHJhbnNhY3Rpb24sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9LCByZWplY3QpO1xuICAgIFxuICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwICgoKSA9PiB7XG4gICAgICAgIC8vIENvcmUgb3BlbmluZyBwcm9jZWR1cmUgY29tcGxldGUuIE5vdyBsZXQncyBqdXN0IHJlY29yZCBzb21lIHN0dWZmLlxuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBpZGJkYiA9IGRiLmlkYmRiID0gcmVxLnJlc3VsdDtcblxuICAgICAgICBjb25zdCBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgIGlmIChvYmplY3RTdG9yZU5hbWVzLmxlbmd0aCA+IDApIHRyeSB7XG4gICAgICAgICAgY29uc3QgdG1wVHJhbnMgPSBpZGJkYi50cmFuc2FjdGlvbihzYWZhcmlNdWx0aVN0b3JlRml4KG9iamVjdFN0b3JlTmFtZXMpLCAncmVhZG9ubHknKTtcbiAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSkgcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIGRiLl9kYlNjaGVtYSwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICBpZiAoIXZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpICYmICFzY2hlbWFQYXRjaE1vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERleGllIFNjaGVtYURpZmY6IFNjaGVtYSB3YXMgZXh0ZW5kZWQgd2l0aG91dCBpbmNyZWFzaW5nIHRoZSBudW1iZXIgcGFzc2VkIHRvIGRiLnZlcnNpb24oKS4gRGV4aWUgd2lsbCBhZGQgbWlzc2luZyBwYXJ0cyBhbmQgaW5jcmVtZW50IG5hdGl2ZSB2ZXJzaW9uIG51bWJlciB0byB3b3JrYXJvdW5kIHRoaXMuYCk7XG4gICAgICAgICAgICAgICAgaWRiZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSBpZGJkYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlICh0cnlPcGVuREIoKSk7IC8vIFRyeSBhZ2FpbiB3aXRoIG5ldyB2ZXJzaW9uIChuYXRpdmVWZXJUb09wZW5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNhZmFyaSA4IG1heSBiYWlsIG91dCBpZiA+IDEgc3RvcmUgbmFtZXMuIEhvd2V2ZXIsIHRoaXMgc2hvdWxkbnQgYmUgYSBzaG93c3RvcHBlci4gSXNzdWUgIzEyMC5cbiAgICAgICAgICAvLyBCVUdCVUc6IEl0IHdpbGwgYmFpbCBvdXQgYW55d2F5IGFzIG9mIERleGllIDMuXG4gICAgICAgICAgLy8gU2hvdWxkIHdlIHN1cHBvcnQgU2FmYXJpIDggYW55bW9yZT8gQmVsaWV2ZSBhbGxcbiAgICAgICAgICAvLyBEZXhpZSB1c2VycyB1c2UgdGhlIHNoaW0gZm9yIHRoYXQgcGxhdGZvcm0gYW55d2F5PyFcbiAgICAgICAgICAvLyBJZiByZW1vdmluZyBTYWZhcmkgOCBzdXBwb3J0LCBnbyBhaGVhZCBhbmQgcmVtb3ZlIHRoZSBzYWZhcmlNdWx0aVN0b3JlRml4KCkgZnVuY3Rpb25cbiAgICAgICAgICAvLyBhcyB3ZWxsIGFzIGFic3VyZCB1cGdyYWRlIHZlcnNpb24gcXVpcmsgZm9yIFNhZmFyaS5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7IC8vIFVzZWQgZm9yIGVtdWxhdGluZyB2ZXJzaW9uY2hhbmdlIGV2ZW50IG9uIElFL0VkZ2UvU2FmYXJpLlxuICAgICAgICBcbiAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBzdGF0ZS52Y0ZpcmVkID0gdHJ1ZTsgLy8gZGV0ZWN0IGltcGxlbWVudGF0aW9ucyB0aGF0IG5vdCBzdXBwb3J0IHZlcnNpb25jaGFuZ2UgKElFL0VkZ2UvU2FmYXJpKVxuICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlkYmRiLm9uY2xvc2UgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3YXNDcmVhdGVkKSBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgfSwgcmVqZWN0KTtcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICBzd2l0Y2ggKGVycj8ubmFtZSkge1xuICAgICAgY2FzZSBcIlVua25vd25FcnJvclwiOlxuICAgICAgICBpZiAoc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgLy8gQnVnIGluIENocm9tZSBhZnRlciBjbGVhcmluZyBzaXRlIGRhdGFcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGV4aWUvRGV4aWUuanMvaXNzdWVzLzU0MyNpc3N1ZWNvbW1lbnQtMTc5NTczNjY5NVxuICAgICAgICAgIHN0YXRlLlBSMTM5OF9tYXhMb29wLS07XG4gICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogV29ya2Fyb3VuZCBmb3IgQ2hyb21lIFVua25vd25FcnJvciBvbiBvcGVuKCknKTtcbiAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVmVyc2lvbkVycm9yXCI6XG4gICAgICAgIGlmIChuYXRpdmVWZXJUb09wZW4gPiAwKSB7XG4gICAgICAgICAgbmF0aXZlVmVyVG9PcGVuID0gMDtcbiAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICB9KTtcbiAgXG4gIC8vIHNhZmFyaTE0V29ya2Fyb3VuZCA9IFdvcmthcm91bmQgYnkgamFrZWFyY2hpYmFsZCBmb3IgbmV3IG5hc3R5IGJ1ZyBpbiBzYWZhcmkgMTQuXG4gIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgIG9wZW5DYW5jZWxsZXIsXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBzYWZhcmkxNFdvcmthcm91bmQoKSkudGhlbih0cnlPcGVuREIpXG4gIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gQmVmb3JlIGZpbmFsbHkgcmVzb2x2aW5nIHRoZSBkYlJlYWR5UHJvbWlzZSBhbmQgdGhpcyBwcm9taXNlLFxuICAgICAgLy8gY2FsbCBhbmQgYXdhaXQgYWxsIG9uKCdyZWFkeScpIHN1YnNjcmliZXJzOlxuICAgICAgLy8gRGV4aWUudmlwKCkgbWFrZXMgc3Vic2NyaWJlcnMgYWJsZSB0byB1c2UgdGhlIGRhdGFiYXNlIHdoaWxlIGJlaW5nIG9wZW5lZC5cbiAgICAgIC8vIFRoaXMgaXMgYSBtdXN0IHNpbmNlIHRoZXNlIHN1YnNjcmliZXJzIHRha2UgcGFydCBvZiB0aGUgb3BlbmluZyBwcm9jZWR1cmUuXG4gICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG4gICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2aXAoKCk9PmRiLm9uLnJlYWR5LmZpcmUoZGIudmlwKSkpLnRoZW4oZnVuY3Rpb24gZmlyZVJlbWFpbmRlcnMoKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gSW4gY2FzZSBhZGRpdGlvbmFsIHN1YnNjcmliZXJzIHRvIGRiLm9uKCdyZWFkeScpIHdlcmUgYWRkZWQgZHVyaW5nIHRoZSB0aW1lIGRiLm9uLnJlYWR5LmZpcmUgd2FzIGV4ZWN1dGVkLlxuICAgICAgICAgICAgICBsZXQgcmVtYWluZGVycyA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG4gICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmlwKCgpPT5yZW1haW5kZXJzKGRiLnZpcCkpKS50aGVuKGZpcmVSZW1haW5kZXJzKVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9KS5maW5hbGx5KCgpPT57XG4gICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciA9PT0gb3BlbkNhbmNlbGxlcikge1xuICAgICAgICAvLyBPbmx5IG1vZGlmeSBzdGF0ZSBpZiBub3QgY2FuY2VsbGVkIGluIHRoZSBtZWFuIHRpbWUuXG4gICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcbiAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICAgICAgfVxuICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBlcnI7IC8vIFJlY29yZCB0aGUgZXJyb3IuIEl0IHdpbGwgYmUgdXNlZCB0byByZWplY3QgZnVydGhlciBwcm9taXNlcyBvZiBkYiBvcGVyYXRpb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRGlkIHdlIGZhaWwgd2l0aGluIG9udXBncmFkZW5lZWRlZD8gTWFrZSBzdXJlIHRvIGFib3J0IHRoZSB1cGdyYWRlIHRyYW5zYWN0aW9uIHNvIGl0IGRvZXNudCBjb21taXQuXG4gICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiAmJiB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgIH0gY2F0Y2ggeyB9XG4gICAgICBpZiAob3BlbkNhbmNlbGxlciA9PT0gc3RhdGUub3BlbkNhbmNlbGxlcikge1xuICAgICAgICAvLyBTdGlsbCBpbiB0aGUgc2FtZSBvcGVuIGZsb3cgLSBUaGUgZXJyb3IgcmVhc29uIHdhcyBub3QgZHVlIHRvIGV4dGVybmFsIGNhbGwgdG8gZGIuY2xvc2UoKS5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGNhbGwgZGIuY2xvc2UoKSB0byBmaW5hbGl6ZSByZXNvdXJjZXMuXG4gICAgICAgIGRiLl9jbG9zZSgpOyAvLyBDbG9zZXMgYW5kIHJlc2V0cyBpZGJkYiwgcmVtb3ZlcyBjb25uZWN0aW9ucywgcmVzZXRzIGRiUmVhZHlQcm9taXNlIGFuZCBvcGVuQ2FuY2VsbGVyIHNvIHRoYXQgYSBsYXRlciBkYi5vcGVuKCkgaXMgZnJlc2guXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVqZWN0aW9uIChlcnIpO1xuICB9KS5maW5hbGx5KCgpPT57XG4gICAgc3RhdGUub3BlbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICByZXNvbHZlRGJSZWFkeSgpOyAvLyBkYlJlYWR5UHJvbWlzZSBpcyByZXNvbHZlZCBubyBtYXR0ZXIgaWYgb3BlbigpIHJlamVjdHMgb3IgcmVzb2x2ZWQuIEl0J3MganVzdCB0byB3YWtlIHVwIHdhaXRlcnMuXG4gIH0pLnRoZW4oKCk9PntcbiAgICBpZiAod2FzQ3JlYXRlZCkge1xuICAgICAgLy8gUHJvcGFnYXRlIGZ1bGwgcmFuZ2Ugb24gcHJpbWFyeSBrZXlzIGFuZCBpbmRleGVzIG9uIGFsbCB0YWJsZXMgbm93IHRoYXQgdGhlIERCIGlzIHJlYWR5IGFuZCBvcGVuZWQsXG4gICAgICAvLyBhbmQgYWxsIHVwZ3JhZGVycyBhbmQgb24oJ3JlYWR5Jykgc3Vic2NyaWJlcnMgaGF2ZSBydW4uXG4gICAgICBjb25zdCBldmVyeXRoaW5nOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgICBkYi50YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgIHRhYmxlLnNjaGVtYS5pbmRleGVzLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICBpZiAoaWR4Lm5hbWUpIGV2ZXJ5dGhpbmdbYGlkYjovLyR7ZGIubmFtZX0vJHt0YWJsZS5uYW1lfS8ke2lkeC5uYW1lfWBdID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZXJ5dGhpbmdbYGlkYjovLyR7ZGIubmFtZX0vJHt0YWJsZS5uYW1lfS9gXSA9IGV2ZXJ5dGhpbmdbYGlkYjovLyR7ZGIubmFtZX0vJHt0YWJsZS5uYW1lfS86ZGVsc2BdID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcbiAgICAgIH0pO1xuICAgICAgLy8gRGF0YWJhc2Ugd2FzIGNyZWF0ZWQuIElmIGFub3RoZXIgdGFiIGhhZCBpdCBvcGVuIHdoZW4gaXQgd2FzIGRlbGV0ZWQgYW5kIHJlb3BlbmVkLCB0aGF0IHRhYiBtdXN0IGJlIHVwZGF0ZWQgbm93LlxuICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKS5maXJlKGV2ZXJ5dGhpbmcpO1xuICAgICAgLy8gV2lwZSB0aGUgY2FjaGUgYW5kIHRyaWdnZXIgb3B0aW1pc3RpYyBxdWVyaWVzOlxuICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3coZXZlcnl0aGluZywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIFJlc29sdmUgdGhlIGRiLm9wZW4oKSB3aXRoIHRoZSBkYiBpbnN0YW5jZS5cbiAgICByZXR1cm4gZGI7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRJdGVyYXRvciAoaXRlcmF0b3I6IEl0ZXJhdG9yPGFueT4pIHtcbiAgdmFyIGNhbGxOZXh0ID0gcmVzdWx0ID0+IGl0ZXJhdG9yLm5leHQocmVzdWx0KSxcbiAgICAgIGRvVGhyb3cgPSBlcnJvciA9PiBpdGVyYXRvci50aHJvdyhlcnJvciksXG4gICAgICBvblN1Y2Nlc3MgPSBzdGVwKGNhbGxOZXh0KSxcbiAgICAgIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dDogKGFueSk9PmFueSkge1xuICAgICAgcmV0dXJuICh2YWw/KSA9PiB7XG4gICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksXG4gICAgICAgICAgICAgIHZhbHVlID0gbmV4dC52YWx1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG4gICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgPyBQcm9taXNlLmFsbCh2YWx1ZSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpIDogb25TdWNjZXNzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xufVxuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uTW9kZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbi1tb2RlJztcbmltcG9ydCB7IGVycm5hbWVzLCBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGZsYXR0ZW4sIGlzQXN5bmNGdW5jdGlvbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vZGV4aWUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBhd2FpdEl0ZXJhdG9yIH0gZnJvbSAnLi4vLi4vaGVscGVycy95aWVsZC1zdXBwb3J0JztcbmltcG9ydCBQcm9taXNlLCB7XG4gIFBTRCxcbiAgTmF0aXZlUHJvbWlzZSxcbiAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gIHJlamVjdGlvbixcbiAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHNcbn0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZTogVHJhbnNhY3Rpb25Nb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG4gIC8vIExldCB0YWJsZSBhcmd1bWVudHMgYmUgYWxsIGFyZ3VtZW50cyBiZXR3ZWVuIG1vZGUgYW5kIGxhc3QgYXJndW1lbnQuXG4gIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGkgPCAyKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJUb28gZmV3IGFyZ3VtZW50c1wiKTtcbiAgLy8gUHJldmVudCBvcHRpbXphdGlvbiBraWxsZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzMi1sZWFraW5nLWFyZ3VtZW50cylcbiAgLy8gYW5kIGNsb25lIGFyZ3VtZW50cyBleGNlcHQgdGhlIGZpcnN0IG9uZSBpbnRvIGxvY2FsIHZhciAnYXJncycuXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgd2hpbGUgKC0taSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIC8vIExldCBzY29wZUZ1bmMgYmUgdGhlIGxhc3QgYXJndW1lbnQgYW5kIHBvcCBpdCBzbyB0aGF0IGFyZ3Mgbm93IG9ubHkgY29udGFpbiB0aGUgdGFibGUgYXJndW1lbnRzLlxuICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTsgLy8gU3VwcG9ydCB1c2luZyBhcnJheSBhcyBtaWRkbGUgYXJndW1lbnQsIG9yIGEgbWl4IG9mIGFycmF5cyBhbmQgbm9uLWFycmF5cy5cbiAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoXG4gIGRiOiBEZXhpZSxcbiAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgcGFyZW50VHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkLFxuICBzY29wZUZ1bmM6ICgpPT5Qcm9taXNlTGlrZTxhbnk+IHwgYW55XG4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIGxhc3Qgbm9uLXRyYW5zYWN0aW9uYWwgUFNEIHRvIHVzZSBpZiBzb21lb25lIGNhbGxzIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkuXG4gICAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgLy8gT3VyIHRyYW5zYWN0aW9uLlxuICAgIC8vcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICB0cmFucy5leHBsaWNpdCA9IHRydWU7XG4gICAgLy8gTGV0IHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSBiZSBwYXJ0IG9mIGEgUHJvbWlzZS1zcGVjaWZpYyBkYXRhIChQU0QpIHZhbHVlLlxuICAgIGNvbnN0IHpvbmVQcm9wcyA9IHtcbiAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG4gICAgfTtcblxuICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgLy8gRW11bGF0ZSB0cmFuc2FjdGlvbiBjb21taXQgYXdhcmVuZXNzIGZvciBpbm5lciB0cmFuc2FjdGlvbiAobXVzdCAnY29tbWl0JyB3aGVuIHRoZSBpbm5lciB0cmFuc2FjdGlvbiBoYXMgbm8gbW9yZSBvcGVyYXRpb25zIG9uZ29pbmcpXG4gICAgICB0cmFucy5pZGJ0cmFucyA9IHBhcmVudFRyYW5zYWN0aW9uLmlkYnRyYW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0cmFucy5jcmVhdGUoKTsgLy8gQ3JlYXRlIHRoZSBuYXRpdmUgdHJhbnNhY3Rpb24gc28gdGhhdCBjb21wbGV0ZSgpIG9yIGVycm9yKCkgd2lsbCB0cmlnZ2VyIGV2ZW4gaWYgbm8gb3BlcmF0aW9uIGlzIG1hZGUgdXBvbiBpdC5cbiAgICAgICAgLy8gQHRzLWlnbm9yZSBNYXJrIHRoZSBpZGJ0cmFucyBvYmplY3Qgd2l0aCBcIl9leHBsaWNpdFwiLiBEQkNvcmUgbWlkZGxld2FyZSB3b24ndCBoYXZlIGFjY2VzcyB0byBEZXhpZSB0cmFucyBidXQgd2lsbCBuZWVkIHRvIGhhdmUgdGhpcyBpbmZvLlxuICAgICAgICB0cmFucy5pZGJ0cmFucy5fZXhwbGljaXQgPSB0cnVlO1xuICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgIGRiLmNsb3NlKHtkaXNhYmxlQXV0b09wZW46IGZhbHNlfSk7XG4gICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKCgpID0+IGVudGVyVHJhbnNhY3Rpb25TY29wZShcbiAgICAgICAgICAgIGRiLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHN0b3JlTmFtZXMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc2NvcGVGdW5jXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBmb3IgbmF0aXZlIGFzeW5jIGF3YWl0LlxuICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcbiAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICB9XG5cbiAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgY29uc3QgcHJvbWlzZUZvbGxvd2VkID0gUHJvbWlzZS5mb2xsb3coKCkgPT4ge1xuICAgICAgLy8gRmluYWxseSwgY2FsbCB0aGUgc2NvcGUgZnVuY3Rpb24gd2l0aCBvdXIgdGFibGUgYW5kIHRyYW5zYWN0aW9uIGFyZ3VtZW50cy5cbiAgICAgIHJldHVyblZhbHVlID0gc2NvcGVGdW5jLmNhbGwodHJhbnMsIHRyYW5zKTtcbiAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgIC8vIHNjb3BlRnVuYyBpcyBhIG5hdGl2ZSBhc3luYyBmdW5jdGlvbiAtIHdlIGtub3cgZm9yIHN1cmUgcmV0dXJuVmFsdWUgaXMgbmF0aXZlIHByb21pc2UuXG4gICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJldHVyblZhbHVlLm5leHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gc2NvcGVGdW5jIHJldHVybmVkIGFuIGl0ZXJhdG9yIHdpdGggdGhyb3ctc3VwcG9ydC4gSGFuZGxlIHlpZWxkIGFzIGF3YWl0LlxuICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXRJdGVyYXRvcihyZXR1cm5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB6b25lUHJvcHMpO1xuICAgIHJldHVybiAocmV0dXJuVmFsdWUgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuICAgICAgLy8gUHJvbWlzZSByZXR1cm5lZC4gVXNlciB1c2VzIHByb21pc2Utc3R5bGUgdHJhbnNhY3Rpb25zLlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS50aGVuKHggPT4gdHJhbnMuYWN0aXZlID9cbiAgICAgICAgeCAvLyBUcmFuc2FjdGlvbiBzdGlsbCBhY3RpdmUuIENvbnRpbnVlLlxuICAgICAgICA6IHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5QcmVtYXR1cmVDb21taXQoXG4gICAgICAgICAgXCJUcmFuc2FjdGlvbiBjb21taXR0ZWQgdG9vIGVhcmx5LiBTZWUgaHR0cDovL2JpdC5seS8ya2Rja01uXCIpKSlcbiAgICAgIC8vIE5vIHByb21pc2UgcmV0dXJuZWQuIFdhaXQgZm9yIGFsbCBvdXRzdGFuZGluZyBwcm9taXNlcyBiZWZvcmUgY29udGludWluZy4gXG4gICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpID0+IHJldHVyblZhbHVlKVxuICAgICkudGhlbih4ID0+IHtcbiAgICAgIC8vIHN1YiB0cmFuc2FjdGlvbnMgZG9uJ3QgcmVhY3QgdG8gaWRidHJhbnMub25jb21wbGV0ZS4gV2UgbXVzdCB0cmlnZ2VyIGEgY29tcGxldGlvbjpcbiAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgIC8vIHdhaXQgZm9yIHRyYW5zLl9jb21wbGV0aW9uXG4gICAgICAvLyAoaWYgcm9vdCB0cmFuc2FjdGlvbiwgdGhpcyBtZWFucyAnY29tcGxldGUnIGV2ZW50LiBJZiBzdWItdHJhbnNhY3Rpb24sIHdlJ3ZlIGp1c3QgZmlyZWQgaXQgb3Vyc2VsdmVzKVxuICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4geCk7XG4gICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICB0cmFucy5fcmVqZWN0KGUpOyAvLyBZZXMsIGFib3ZlIHRoZW4taGFuZGxlciB3ZXJlIG1heWJlIG5vdCBjYWxsZWQgYmVjYXVzZSBvZiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGluIHNjb3BlRnVuYyFcbiAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7XG4gIERCQ29yZSxcbiAgREJDb3JlSW5kZXgsXG4gIERCQ29yZUtleVJhbmdlLFxuICBEQkNvcmVRdWVyeVJlcXVlc3QsXG4gIERCQ29yZVJhbmdlVHlwZSxcbiAgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QsXG4gIERCQ29yZUNvdW50UmVxdWVzdCxcbiAgREJDb3JlQ3Vyc29yLFxuICBEQkNvcmVUYWJsZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0S2V5RXh0cmFjdG9yIH0gZnJvbSAnLi9nZXQta2V5LWV4dHJhY3Rvcic7XG5pbXBvcnQgeyBnZXRLZXlQYXRoQWxpYXMgfSBmcm9tICcuL2RiY29yZS1pbmRleGVkZGInO1xuaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlJztcblxuaW50ZXJmYWNlIFZpcnR1YWxJbmRleCBleHRlbmRzIERCQ29yZUluZGV4IHtcbiAgLyoqIFRydWUgaWYgdGhpcyBpbmRleCBpcyB2aXJ0dWFsLCBpLmUuIHJlcHJlc2VudHMgYSBjb21wb3VuZCBpbmRleCBpbnRlcm5hbGx5LFxuICAgKiBidXQgbWFrZXMgaXQgYWN0IGFzIGFzIGhhdmluZyBhIHN1YnNldCBvZiBpdHMga2V5UGF0aHMuXG4gICAqL1xuICBpc1ZpcnR1YWw6IGJvb2xlYW47XG5cbiAgLyoqIE51bWJlciBvZiBrZXlwYXRocyB0aGF0IHRoaXMgaW5kZXggY29tcHJpc2VzLiBDYW4gYmUgMC4uTi5cbiAgICogTm90ZTogVGhpcyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSAqdmlydHVhbCBpbmRleCosIG5vdCB0aGUgcmVhbCBpbmRleC5cbiAgICovXG4gIGtleUxlbmd0aDogbnVtYmVyO1xuXG4gIC8qKiBOdW1iZXIgb2YgcG9wcGVkIGtleXBhdGhzIGZyb20gdGhlIHJlYWwgaW5kZXguXG4gICAqL1xuICBrZXlUYWlsOiBudW1iZXI7XG5cbiAgLyoqIExvd0xldmVsSW5kZXggcmVwcmVzZW50cyB0aGUgYWN0dWFsIEluZGV4ZWREQiBpbmRleCBiZWhpbmQgaXQgKi9cbiAgbG93TGV2ZWxJbmRleDogREJDb3JlSW5kZXg7XG59XG5cbi8vIE1vdmUgaW50byBzb21lIHV0aWw6XG5leHBvcnQgZnVuY3Rpb24gcGFkIChhOiBhbnkgfCBhbnlbXSwgdmFsdWU6IGFueSwgY291bnQ6IG51bWJlcikge1xuICBjb25zdCByZXN1bHQgPSBpc0FycmF5KGEpID8gYS5zbGljZSgpIDogW2FdO1xuICBmb3IgKGxldCBpPTA7IGk8Y291bnQ7ICsraSkgcmVzdWx0LnB1c2godmFsdWUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlIChkb3duOiBEQkNvcmUpIDogREJDb3JlIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kb3duLFxuICAgIHRhYmxlKHRhYmxlTmFtZTogc3RyaW5nKSB7XG4gICAgICBjb25zdCB0YWJsZSA9IGRvd24udGFibGUodGFibGVOYW1lKTtcbiAgICAgIGNvbnN0IHtzY2hlbWF9ID0gdGFibGU7XG4gICAgICBjb25zdCBpbmRleExvb2t1cDoge1tpbmRleEFsaWFzOiBzdHJpbmddOiBWaXJ0dWFsSW5kZXhbXX0gPSB7fTtcbiAgICAgIGNvbnN0IGFsbFZpcnR1YWxJbmRleGVzOiBWaXJ0dWFsSW5kZXhbXSA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBhZGRWaXJ0dWFsSW5kZXhlcyAoa2V5UGF0aDogbnVsbCB8IHN0cmluZyB8IHN0cmluZ1tdLCBrZXlUYWlsOiBudW1iZXIsIGxvd0xldmVsSW5kZXg6IERCQ29yZUluZGV4KTogVmlydHVhbEluZGV4IHtcbiAgICAgICAgY29uc3Qga2V5UGF0aEFsaWFzID0gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpO1xuICAgICAgICBjb25zdCBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlQYXRoID09IG51bGwgPyAwOiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyAxIDoga2V5UGF0aC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuICAgICAgICBjb25zdCB2aXJ0dWFsSW5kZXggPSB7XG4gICAgICAgICAgLi4ubG93TGV2ZWxJbmRleCxcbiAgICAgICAgICBuYW1lOiBpc1ZpcnR1YWxcbiAgICAgICAgICAgID8gYCR7a2V5UGF0aEFsaWFzfSh2aXJ0dWFsLWZyb206JHtsb3dMZXZlbEluZGV4Lm5hbWV9KWBcbiAgICAgICAgICAgIDogbG93TGV2ZWxJbmRleC5uYW1lLFxuICAgICAgICAgIGxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgaXNWaXJ0dWFsLFxuICAgICAgICAgIGtleVRhaWwsXG4gICAgICAgICAga2V5TGVuZ3RoLFxuICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSxcbiAgICAgICAgICB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWVcbiAgICAgICAgfTtcbiAgICAgICAgaW5kZXhMaXN0LnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgYWxsVmlydHVhbEluZGV4ZXMucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3QgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuICAgICAgICAgICAga2V5UGF0aFswXSA6IC8vIFRoaXMgaXMgYSBjb21wb3VuZCBbYSwgYl0uIEFkZCBhIHZpcnR1YWwgbm9ybWFsIGluZGV4IGEuXG4gICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpOyAvLyBUaGlzIGlzIGNvbXBvdW5kIFthLGIsY10uIEFkZCB2aXJ0dWFsIGNvbXBvdW5kIFthLGJdLlxuICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKHZpcnR1YWxLZXlQYXRoLCBrZXlUYWlsICsgMSwgbG93TGV2ZWxJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhMaXN0LnNvcnQoKGEsYikgPT4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsKTsgLy8gU2hvcnRlc3Qga2V5VGFpbCBpcyB0aGUgYmVzdCBvbmUgKHJlcHJlc2VudHMgcmVhbCBpbmRleClcbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2NoZW1hLmluZGV4ZXMpIHtcbiAgICAgICAgYWRkVmlydHVhbEluZGV4ZXMoaW5kZXgua2V5UGF0aCwgMCwgaW5kZXgpO1xuICAgICAgfVxuICAgIFxuICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pOiBWaXJ0dWFsSW5kZXgge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJhbmdlIChyYW5nZTogREJDb3JlS2V5UmFuZ2UsIGtleVRhaWw6IG51bWJlcik6IERCQ29yZUtleVJhbmdlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuRXF1YWwgP1xuICAgICAgICAgICAgREJDb3JlUmFuZ2VUeXBlLlJhbmdlIDpcbiAgICAgICAgICAgIHJhbmdlLnR5cGUsXG4gICAgICAgICAgbG93ZXI6IHBhZChyYW5nZS5sb3dlciwgcmFuZ2UubG93ZXJPcGVuID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICBsb3dlck9wZW46IHRydWUsIC8vIGRvZXNuJ3QgbWF0dGVyIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZSAvLyBkb2Vzbid0IG1hdHRlciB0cnVlIG9yIGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgXG4gICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0IChyZXE6IERCQ29yZVF1ZXJ5UmVxdWVzdCk6IERCQ29yZVF1ZXJ5UmVxdWVzdDtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QgKHJlcTogREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpOiBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdDtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QgKHJlcTogREJDb3JlQ291bnRSZXF1ZXN0KTogREJDb3JlQ291bnRSZXF1ZXN0IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXEucXVlcnkuaW5kZXggYXMgVmlydHVhbEluZGV4O1xuICAgICAgICByZXR1cm4gaW5kZXguaXNWaXJ0dWFsID8ge1xuICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4Lmxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSA6IHJlcTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IHJlc3VsdDogREJDb3JlVGFibGUgPSB7XG4gICAgICAgIC4uLnRhYmxlLFxuICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAuLi5zY2hlbWEsXG4gICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcyxcbiAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogZmluZEJlc3RJbmRleFxuICAgICAgICB9LFxuXG4gICAgICAgIGNvdW50KHJlcSkge1xuICAgICAgICAgIHJldHVybiB0YWJsZS5jb3VudCh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICB9LCAgICBcbiAgICBcbiAgICAgICAgcXVlcnkocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIHRhYmxlLnF1ZXJ5KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG9wZW5DdXJzb3IocmVxKSB7XG4gICAgICAgICAgY29uc3Qge2tleVRhaWwsIGlzVmlydHVhbCwga2V5TGVuZ3RofSA9IChyZXEucXVlcnkuaW5kZXggYXMgVmlydHVhbEluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzVmlydHVhbCkgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcbiAgICBcbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcjogREJDb3JlQ3Vyc29yKSA6IERCQ29yZUN1cnNvciB7XG4gICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUgKGtleT86IGFueSkge1xuICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpXG4gICAgICAgICAgICAgICAgICApIDpcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsQ3Vyc29yID0gT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgY29udGludWU6IHt2YWx1ZTogX2NvbnRpbnVlfSxcbiAgICAgICAgICAgICAgY29udGludWVQcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWUoa2V5OiBhbnksIHByaW1hcnlLZXk6IGFueSkge1xuICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleShwYWQoa2V5LCBkb3duLk1BWF9LRVksIGtleVRhaWwpLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5IGFzIGFueVtdOyAvLyBBIHZpcnR1YWwgY3Vyc29yIGFsd2F5cyBvcGVyYXRlcyBvbiBjb21wb3VuZCBrZXlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOiAvLyBDdXJzb3Iua2V5IHNob3VsZCBub3QgYmUgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpOyAvLyBDdXJzb3Iua2V5IHNob3VsZCBiZSBmaXJzdCBwYXJ0IG9mIGFycmF5LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmlydHVhbEN1cnNvcjtcbiAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuICAgICAgICAgICAgLnRoZW4oY3Vyc29yID0+IGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcbiAgbGV2ZWw6IDEsXG4gIGNyZWF0ZTogY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZVxufTtcblxuIiwgImltcG9ydCB7IGtleXMsIGhhc093biwgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdERpZmYoYTogYW55LCBiOiBhbnksIHJ2PzogYW55LCBwcmZ4Pzogc3RyaW5nKSB7XG4gIC8vIENvbXBhcmVzIG9iamVjdHMgYSBhbmQgYiBhbmQgcHJvZHVjZXMgYSBkaWZmIG9iamVjdC5cbiAgcnYgPSBydiB8fCB7fTtcbiAgcHJmeCA9IHByZnggfHwgJyc7XG4gIGtleXMoYSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICghaGFzT3duKGIsIHByb3ApKSB7XG4gICAgICAvLyBQcm9wZXJ0eSByZW1vdmVkXG4gICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcCA9IGFbcHJvcF0sXG4gICAgICAgIGJwID0gYltwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgYXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBicCA9PT0gJ29iamVjdCcgJiYgYXAgJiYgYnApIHtcbiAgICAgICAgY29uc3QgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgY29uc3QgYnBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGJwKTtcblxuICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGNoYW5nZWQgdG8gb3RoZXIgdHlwZVxuICAgICAgICB9IGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgLy8gUG9qbyBvYmplY3RzIChub3QgRGF0ZSwgQXJyYXlCdWZmZXIsIEFycmF5IGV0YykuIEdvIGRlZXAuXG4gICAgICAgICAgZ2V0T2JqZWN0RGlmZihhcCwgYnAsIHJ2LCBwcmZ4ICsgcHJvcCArICcuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXAgIT09IGJwKSB7XG4gICAgICAgICAgLy8gVmFsdWVzIGRpZmZlci5cbiAgICAgICAgICAvLyBDb3VsZCBoYXZlIGNoZWNrZWQgaWYgRGF0ZSwgYXJyYXlzIG9yIGJpbmFyeSB0eXBlcyBoYXZlIHNhbWVcbiAgICAgICAgICAvLyBjb250ZW50IGhlcmUgYnV0IEkgdGhpbmsgdGhhdCB3b3VsZCBiZSBhIHN1Ym9wdGltYXRpb24uXG4gICAgICAgICAgLy8gUHJlZmVyIHNpbXBsaWNpdHkuXG4gICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcCAhPT0gYnApIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByaW1pdGl2ZSB2YWx1ZSBjaGFuZ2VkXG4gICAgfVxuICB9KTtcbiAga2V5cyhiKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGFkZGVkXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJ2O1xufVxuIiwgImltcG9ydCB7XG4gIERCQ29yZUFkZFJlcXVlc3QsXG4gIERCQ29yZVB1dFJlcXVlc3QsXG4gIERCQ29yZURlbGV0ZVJlcXVlc3QsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVUYWJsZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMgKFxuICBwcmltYXJ5S2V5OiBEQkNvcmVJbmRleCxcbiAgcmVxOiAoUGljazxEQkNvcmVBZGRSZXF1ZXN0IHwgREJDb3JlUHV0UmVxdWVzdCwgXCJ0eXBlXCIgfCBcInZhbHVlc1wiPiAmIHtrZXlzPzogYW55W119KSB8IFBpY2s8REJDb3JlRGVsZXRlUmVxdWVzdCwgXCJrZXlzXCIgfCBcInR5cGVcIj4pXG57XG4gIC8vY29uc3Qge291dGJvdW5kfSA9IHByaW1hcnlLZXk7XG4gIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHJldHVybiByZXEua2V5cztcbiAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSlcbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbiAgREJDb3JlRGVsZXRlUmFuZ2VSZXF1ZXN0LFxuICBEQkNvcmVBZGRSZXF1ZXN0LFxuICBEQkNvcmVQdXRSZXF1ZXN0LFxuICBEQkNvcmVEZWxldGVSZXF1ZXN0LFxuICBEQkNvcmVUcmFuc2FjdGlvbixcbiAgREJDb3JlS2V5UmFuZ2Vcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgaGFzT3duLCBzZXRCeUtleVBhdGggfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0T2JqZWN0RGlmZiB9IGZyb20gXCIuLi9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmXCI7XG5pbXBvcnQgeyBQU0QgfSBmcm9tICcuLi9oZWxwZXJzL3Byb21pc2UnO1xuLy9pbXBvcnQgeyBMb2NrYWJsZVRhYmxlTWlkZGxld2FyZSB9IGZyb20gJy4uL2RiY29yZS9sb2NrYWJsZS10YWJsZS1taWRkbGV3YXJlJztcbmltcG9ydCB7IGdldEVmZmVjdGl2ZUtleXMgfSBmcm9tICcuLi9kYmNvcmUvZ2V0LWVmZmVjdGl2ZS1rZXlzJztcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvdHJhbnNhY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaG9va3NNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gID0ge1xuICBzdGFjazogXCJkYmNvcmVcIixcbiAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcbiAgbGV2ZWw6IDIsXG4gIGNyZWF0ZTogKGRvd25Db3JlOiBEQkNvcmUpID0+ICh7XG4gICAgLi4uZG93bkNvcmUsXG4gICAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IGRvd25UYWJsZSA9IGRvd25Db3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBjb25zdCB7cHJpbWFyeUtleX0gPSBkb3duVGFibGUuc2NoZW1hO1xuICBcbiAgICAgIGNvbnN0IHRhYmxlTWlkZGxld2FyZTogREJDb3JlVGFibGUgPSB7XG4gICAgICAgIC4uLmRvd25UYWJsZSxcbiAgICAgICAgbXV0YXRlKHJlcSk6UHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnMgYXMgVHJhbnNhY3Rpb247XG4gICAgICAgICAgLy8gSG9va3MgY2FuIGJlIHRyYW5zYWN0aW9uLWJvdW5kLiBOZWVkIHRvIGdyYWIgdGhlbSBmcm9tIHRyYW5zYWN0aW9uLnRhYmxlIGFuZCBub3RcbiAgICAgICAgICAvLyBkYi50YWJsZSFcbiAgICAgICAgICBjb25zdCB7ZGVsZXRpbmcsIGNyZWF0aW5nLCB1cGRhdGluZ30gPSBkeFRyYW5zLnRhYmxlKHRhYmxlTmFtZSkuaG9vaztcbiAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApIGJyZWFrO1xuICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCk9PmFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5kZWxldGVSYW5nZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQW55IG9mIHRoZSBicmVha3MgYWJvdmUgaGFwcGVuZWQgKG5vIGhvb2tzKSAtIGRvIHRoZSBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcTogREJDb3JlQWRkUmVxdWVzdCB8IERCQ29yZVB1dFJlcXVlc3QgfCBEQkNvcmVEZWxldGVSZXF1ZXN0KTogUHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgICAgY29uc3QgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG4gICAgICAgICAgICBpZiAoIWtleXMpIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIC8vIENsb25lIFJlcXVlc3QgYW5kIHNldCBrZXlzIGFyZ1xuICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/XG4gICAgICAgICAgICAgIHsuLi5yZXEsIGtleXN9IDpcbiAgICAgICAgICAgICAgey4uLnJlcX07XG4gICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKSByZXEudmFsdWVzID0gWy4uLnJlcS52YWx1ZXNdO1xuICAgICAgICAgICAgaWYgKHJlcS5rZXlzKSByZXEua2V5cyA9IFsuLi5yZXEua2V5c107XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuIChleGlzdGluZ1ZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRzID0ga2V5cy5tYXAoKGtleSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBleGlzdGluZ1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgIGRlbGV0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYWRkKCkgb3IgcHV0KCkgcmVzdWx0ZWQgaW4gYSBjcmVhdGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByaW1hcnlLZXkgPSBjcmVhdGluZy5maXJlLmNhbGwoY3R4LCBrZXksIHJlcS52YWx1ZXNbaV0sIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgcHV0KCkgb3BlcmF0aW9uIHJlc3VsdGVkIGluIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYoZXhpc3RpbmdWYWx1ZSwgcmVxLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2hhbmdlcyA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVmFsdWUgPSByZXEudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlcykuZm9yRWFjaChrZXlQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5UGF0aCBpcyBhbHJlYWR5IHByZXNlbnQgYXMgYSBsaXRlcmFsIHByb3BlcnR5IG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZhbHVlW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleVBhdGggcmVwcmVzZW50cyBhIG5ldyBvciBleGlzdGluZyBwYXRoIGludG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbigoe2ZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdH0pID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8a2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID8gLy8gdGhlIHB1dCByZXN1bHRlZCBpbiBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOiAvLyB1cGRhdGUgaG9va3MgZXhwZWN0cyBleGlzdGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleSAvLyBjcmVhdGUgaG9va3MgZXhwZWN0cyBwcmltYXJ5IGtleVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge2ZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdH07XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGN0eCA9PiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXE6IERCQ29yZURlbGV0ZVJhbmdlUmVxdWVzdCk6IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsocmVxLnRyYW5zLCByZXEucmFuZ2UsIDEwMDAwKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFuczogREJDb3JlVHJhbnNhY3Rpb24sIHJhbmdlOiBEQkNvcmVLZXlSYW5nZSwgbGltaXQ6IG51bWJlcikge1xuICAgICAgICAgICAgLy8gUXVlcnkgd2hhdCBrZXlzIGluIHRoZSBEQiB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHt0cmFucywgdmFsdWVzOiBmYWxzZSwgcXVlcnk6IHtpbmRleDogcHJpbWFyeUtleSwgcmFuZ2V9LCBsaW1pdH0pXG4gICAgICAgICAgICAudGhlbigoe3Jlc3VsdH0pID0+IHtcbiAgICAgICAgICAgICAgLy8gR2l2ZW4gYSBzZXQgb2Yga2V5cywgYnVsayBkZWxldGUgdGhvc2UgdXNpbmcgdGhlIHNhbWUgcHJvY2VkdXJlIGFzIGluIGFkZFB1dE9yRGVsZXRlKCkuXG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdCBkZWxldGluZyBob29rIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHt0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuc30pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMCkgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9IGFzIERCQ29yZU11dGF0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHRyYW5zLCB7Li4ucmFuZ2UsIGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWV9LCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy9jb25zdCB7bG9jaywgbG9ja2FibGVNaWRkbGV3YXJlfSA9IExvY2thYmxlVGFibGVNaWRkbGV3YXJlKHRhYmxlTWlkZGxld2FyZSk7XG5cbiAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG4gICAgfSxcbiAgfSkgYXMgREJDb3JlXG59O1xuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyhcbiAgdGFibGU6IERCQ29yZVRhYmxlLFxuICByZXE6IERCQ29yZUFkZFJlcXVlc3QgfCBEQkNvcmVQdXRSZXF1ZXN0IHwgREJDb3JlRGVsZXRlUmVxdWVzdCxcbiAgZWZmZWN0aXZlS2V5czogYW55W11cbikge1xuICByZXR1cm4gcmVxLnR5cGUgPT09IFwiYWRkXCJcbiAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBEQkNvcmUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiY29yZVwiO1xuaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZVwiO1xuaW1wb3J0IFByb21pc2UgZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgY21wIH0gZnJvbSAnLi4vZnVuY3Rpb25zL2NtcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShcbiAga2V5czogcmVhZG9ubHkgYW55W10sXG4gIGNhY2hlOiB7IGtleXM6IGFueVtdOyB2YWx1ZXM6IGFueVtdIH0gfCB1bmRlZmluZWQgfCBudWxsLFxuICBjbG9uZT86IGJvb2xlYW5cbikge1xuICB0cnkge1xuICAgIGlmICghY2FjaGUpIHJldHVybiBudWxsO1xuICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgLy8gQ29tcGFyZSBpZiB0aGUgZXhhY3Qgc2FtZSBvcmRlciBvZiBrZXlzIHdhcyByZXRyaWV2ZWQgaW4gc2FtZSB0cmFuc2FjdGlvbjpcbiAgICAvLyBBbGxvdyBzb21lIGNhY2hlZCBrZXlzIHRvIGJlIG9taXR0ZWQgZnJvbSBwcm92aWRlZCBzZXQgb2Yga2V5c1xuICAgIC8vIFVzZSBjYXNlOiAxLiBnZXRNYW55KGtleXMpIDIuIHVwZGF0ZSBhIHN1YnNldCBvZiB0aG9zZSAzLiBjYWxsIHB1dCB3aXRoIHRoZSB1cGRhdGVkIG9uZXMgPT0+IG1pZGRsZXdhcmVzIHNob3VsZCBiZSBhYmxlIHRvIGZpbmQgb2xkIHZhbHVlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKSBjb250aW51ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGNsb25lID8gZGVlcENsb25lKGNhY2hlLnZhbHVlc1tpXSkgOiBjYWNoZS52YWx1ZXNbaV0pO1xuICAgICAgKytqO1xuICAgIH1cbiAgICAvLyBJZiBnb3QgYWxsIGtleXMgY2FsbGVyIHdhcyBsb29raW5nIGZvciwgcmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmU6IE1pZGRsZXdhcmU8REJDb3JlPiA9IHtcbiAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gIGxldmVsOiAtMSxcbiAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoXG4gICAgICAgICAgICAgIHJlcS5rZXlzLFxuICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0sXG4gICAgICAgICAgICAgIHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSB7XG4gICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgb24gYW55IG11dGF0ZSBleGNlcHQgXCJhZGRcIiB3aGljaCBjYW4ndCBjaGFuZ2UgZXhpc3RpbmcgdmFsdWVzOlxuICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSBcImFkZFwiKSByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuIiwgImltcG9ydCB7IERCQ29yZSwgREJDb3JlVGFibGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IExpdmVRdWVyeUNvbnRleHQgfSBmcm9tICcuLi9saXZlLXF1ZXJ5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FjaGFibGVDb250ZXh0KGN0eDogTGl2ZVF1ZXJ5Q29udGV4dCwgdGFibGU6IERCQ29yZVRhYmxlKSB7XG4gIHJldHVybiAoXG4gICAgY3R4LnRyYW5zLm1vZGUgPT09ICdyZWFkb25seScgJiZcbiAgICAhIWN0eC5zdWJzY3IgJiZcbiAgICAhY3R4LnRyYW5zLmV4cGxpY2l0ICYmXG4gICAgY3R4LnRyYW5zLmRiLl9vcHRpb25zLmNhY2hlICE9PSAnZGlzYWJsZWQnICYmXG4gICAgIXRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5Lm91dGJvdW5kXG4gICk7XG59XG5cbiIsICJpbXBvcnQgeyBEQkNvcmVDb3VudFJlcXVlc3QsIERCQ29yZUdldE1hbnlSZXF1ZXN0LCBEQkNvcmVHZXRSZXF1ZXN0LCBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCwgREJDb3JlUXVlcnlSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FjaGFibGVSZXF1ZXN0KHR5cGU6IHN0cmluZywgcmVxOiBQYXJ0aWFsPERCQ29yZVF1ZXJ5UmVxdWVzdCAmIERCQ29yZUNvdW50UmVxdWVzdCAmIERCQ29yZUdldE1hbnlSZXF1ZXN0ICYgREJDb3JlR2V0UmVxdWVzdCAmIERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0Pikge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICByZXR1cm4gcmVxLnZhbHVlcyAmJiAhcmVxLnVuaXF1ZTtcbiAgICBjYXNlICdnZXQnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJ2dldE1hbnknOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlICdvcGVuQ3Vyc29yJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IExpdmVRdWVyeUNvbnRleHQgfSBmcm9tIFwiLlwiO1xuaW1wb3J0IHsgZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUgfSBmcm9tIFwiLi4vZGJjb3JlL2NhY2hlLWV4aXN0aW5nLXZhbHVlcy1taWRkbGV3YXJlXCI7XG5pbXBvcnQgeyBnZXRFZmZlY3RpdmVLZXlzIH0gZnJvbSBcIi4uL2RiY29yZS9nZXQtZWZmZWN0aXZlLWtleXNcIjtcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBjbXAgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL2NtcFwiO1xuaW1wb3J0IHsgaXNBcnJheSwga2V5cyB9IGZyb20gXCIuLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IFBTRCB9IGZyb20gXCIuLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IFJhbmdlU2V0IH0gZnJvbSBcIi4uL2hlbHBlcnMvcmFuZ2VzZXRcIjtcbmltcG9ydCB7IE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50c1wiO1xuaW1wb3J0IHtcbiAgREJDb3JlLFxuICBEQkNvcmVDb3VudFJlcXVlc3QsXG4gIERCQ29yZUN1cnNvcixcbiAgREJDb3JlR2V0TWFueVJlcXVlc3QsXG4gIERCQ29yZUdldFJlcXVlc3QsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCxcbiAgREJDb3JlUXVlcnlSZXF1ZXN0LFxuICBEQkNvcmVRdWVyeVJlc3BvbnNlLFxuICBEQkNvcmVUYWJsZSxcbiAgREJDb3JlVGFibGVTY2hlbWEsXG4gIERCQ29yZVRyYW5zYWN0aW9uLFxufSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiY29yZVwiO1xuaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZVwiO1xuaW1wb3J0IHsgaXNDYWNoYWJsZUNvbnRleHQgfSBmcm9tIFwiLi9jYWNoZS9pcy1jYWNoYWJsZS1jb250ZXh0XCI7XG5pbXBvcnQgeyBpc0NhY2hhYmxlUmVxdWVzdCB9IGZyb20gXCIuL2NhY2hlL2lzLWNhY2hhYmxlLXJlcXVlc3RcIjtcbmltcG9ydCB7IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tIFwiLi9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXRcIjtcblxuZXhwb3J0IGNvbnN0IG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBsZXZlbDogMCxcbiAgbmFtZTogXCJPYnNlcnZhYmlsaXR5XCIsXG4gIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICBjb25zdCBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgIGNvbnN0IEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvcmUsXG4gICAgICB0cmFuc2FjdGlvbjogKHN0b3JlcywgbW9kZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoUFNELnN1YnNjciAmJiBtb2RlICE9PSAncmVhZG9ubHknKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoYFJlYWR3cml0ZSB0cmFuc2FjdGlvbiBpbiBsaXZlUXVlcnkgY29udGV4dC4gUXVlcmllciBzb3VyY2U6ICR7KFBTRCBhcyBMaXZlUXVlcnlDb250ZXh0KS5xdWVyaWVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3JlLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSB0YWJsZTtcbiAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5LCBpbmRleGVzIH0gPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHsgZXh0cmFjdEtleSwgb3V0Ym91bmQgfSA9IHByaW1hcnlLZXk7XG4gICAgICAgIGNvbnN0IGluZGV4ZXNXaXRoQXV0b0luY1BLID0gcHJpbWFyeUtleS5hdXRvSW5jcmVtZW50ICYmIGluZGV4ZXMuZmlsdGVyKFxuICAgICAgICAgIChpbmRleCkgPT4gaW5kZXguY29tcG91bmQgJiYgKGluZGV4LmtleVBhdGggYXMgc3RyaW5nW10pLmluY2x1ZGVzKHByaW1hcnlLZXkua2V5UGF0aCBhcyBzdHJpbmcpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRhYmxlQ2xvbmU6IERCQ29yZVRhYmxlID0ge1xuICAgICAgICAgIC4uLnRhYmxlLFxuICAgICAgICAgIG11dGF0ZTogKHJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnMgPSByZXEudHJhbnMgYXMgREJDb3JlVHJhbnNhY3Rpb24gJiB7XG4gICAgICAgICAgICAgIG11dGF0ZWRQYXJ0cz86IE9ic2VydmFiaWxpdHlTZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbXV0YXRlZFBhcnRzID0gcmVxLm11dGF0ZWRQYXJ0cyB8fCAocmVxLm11dGF0ZWRQYXJ0cyA9IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gKG11dGF0ZWRQYXJ0c1twYXJ0XSB8fFxuICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpIGFzIFJhbmdlU2V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcmVxO1xuICAgICAgICAgICAgbGV0IFtrZXlzLCBuZXdPYmpzXSA9XG4gICAgICAgICAgICAgIHJlcS50eXBlID09PSBcImRlbGV0ZVJhbmdlXCJcbiAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdIC8vIGtleXMgd2lsbCBiZSBhbiBEQkNvcmVLZXlSYW5nZSBvYmplY3QgLSB0cmFuc2Zvcm1lZCBsYXRlciBvbiB0byBhIFtmcm9tLHRvXS1zdHlsZSByYW5nZS5cbiAgICAgICAgICAgICAgICA6IHJlcS50eXBlID09PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgPyBbcmVxLmtleXNdIC8vIGtleXMga25vd24gYWxyZWFkeSBoZXJlLiBuZXdPYmpzIHdpbGwgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuICAgICAgICAgICAgICAgID8gW2dldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKS5maWx0ZXIoaWQgPT4gaWQpLCByZXEudmFsdWVzXSAvLyBrZXlzIGV4Y2VwdCBhdXRvSW5jcmVtZW50ZWQgLSB0aGV5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgb24uXG4gICAgICAgICAgICAgICAgOiBbXTsgLy8ga2V5cyBhbmQgbmV3T2JqcyB3aWxsIGJvdGggYmUgdW5kZWZpbmVkIC0gY2hhbmdlU3BlYyB3aWxsIGJlY29tZSB0cnVlIChjaGFuZ2VkIGZvciBlbnRpcmUgdGFibGUpXG5cbiAgICAgICAgICAgIGNvbnN0IG9sZENhY2hlID0gcmVxLnRyYW5zW1wiX2NhY2hlXCJdO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG11dGF0ZWQgdGFibGUgYW5kIG9wdGlvbmFsbHkga2V5cyB0byB0aGUgbXV0YXRlZFRhYmxlcyBzZXQgb24gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgLy8gVXNlZCBieSBzdWJzY3JpYmVycyB0byB0eGNvbW1pdCBldmVudCBhbmQgZm9yIENvbGxlY3Rpb24ucHJvdG90eXBlLnN1YnNjcmliZSgpLlxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgLy8ga2V5cyBpcyBhbiBhcnJheSAtIGRlbGV0ZSwgYWRkIG9yIHB1dCBvZiBsZXNzIHRoYW4gNTAgcm93cy5cbiAgICAgICAgICAgICAgLy8gSW5kaXZpZHVhbCBrZXlzIChhZGQgcHV0IG9yIGRlbGV0ZSlcbiAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAvLyBPbmx5IGdldCBvbGRPYmpzIGlmIHRoZXkgaGF2ZSBiZWVuIGNhY2hlZCByZWNlbnRseVxuICAgICAgICAgICAgICAvLyAoVGhpcyBhcHBsaWVzIHRvIENvbGxlY3Rpb24ubW9kaWZ5KCkgb25seSwgYnV0IGFsc28gaWYgdXBkYXRpbmcvZGVsZXRpbmcgaG9va3MgaGF2ZSBzdWJzY3JpYmVycylcbiAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqcyA9IHR5cGUgPT09ICdkZWxldGUnIHx8IGtleXMubGVuZ3RoID09PSBuZXdPYmpzLmxlbmd0aCA/IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgLy8gU3VwcGx5IGRldGFpbGVkIHZhbHVlcyBwZXIgaW5kZXggZm9yIGJvdGggb2xkIGFuZCBuZXcgb2JqZWN0czpcbiAgICAgICAgICAgICAgaWYgKCFvbGRPYmpzKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkLCBkZWxldGUgb3IgcHV0IGFuZCB3ZSBkb24ndCBrbm93IG9sZCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgdGhpcyBpbiB0aGUgXCI6ZGVsc1wiIHBhcnQsIGZvciB0aGUgc2FrZSBvZiBjb3VudCgpIGFuZCBwcmltYXJ5S2V5cygpIHF1ZXJpZXMgb25seSFcbiAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob2xkT2JqcyB8fCBuZXdPYmpzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbWF0dGVyIGlmIGtub3duaW5nIG9sZE9ianMgb3Igbm90LCB0cmFjayB0aGUgaW5kaWNlcyBpZiBpdCdzIGEgcHV0LCBhZGQgb3IgZGVsZXRlLlxuICAgICAgICAgICAgICAgIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgLy8ga2V5cyBpcyBhIERCQ29yZUtleVJhbmdlIG9iamVjdC4gVHJhbnNmb3JtIGl0IHRvIFtmcm9tLHRvXS1zdHlsZSByYW5nZS5cbiAgICAgICAgICAgICAgLy8gQXMgd2UgY2FuJ3Qga25vdyBkZWxldGVkIGluZGV4IHJhbmdlcywgbWFyayBpbmRleC1iYXNlZCBzdWJzY3JpcHRpb25zIG11c3QgdHJpZ2dlci5cbiAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb206IGtleXMubG93ZXIsIHRvOiBrZXlzLnVwcGVyIH07XG4gICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAvLyBkZWxldGVSYW5nZS4ga2V5cyBpcyBhIERCQ29yZUtleVJhbmdlIG9iamVjdHMuIFRyYW5zZm9ybSBpdCB0byBbZnJvbSx0b10tc3R5bGUgcmFuZ2UuXG4gICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRvbyBtYW55IHJlcXVlc3RzIHRvIHJlY29yZCB0aGUgZGV0YWlscyB3aXRob3V0IHNsb3dpbmcgZG93biB3cml0ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCByZWNvcmQgYSBnZW5lcmljIGxhcmdlIHJhbmdlIG9uIHByaW1hcnkga2V5LCB0aGUgdmlydHVhbCA6ZGVscyBpbmRleCBhbmRcbiAgICAgICAgICAgICAgLy8gYWxsIHNlY29uZGFyeSBpbmRpY2VzOlxuICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChpZHggPT4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIG11dGF0ZWQgcGFydHMgZnJvbSB0aGUgcmVxdWVzdCBpbnRvIHRoZSB0cmFuc2FjdGlvbidzIG11dGF0ZWRQYXJ0c1xuICAgICAgICAgICAgICAvLyBub3cgd2hlbiB0aGUgcmVxdWVzdCB3ZW50IGZpbmUuXG4gICAgICAgICAgICAgIGlmIChrZXlzICYmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnKSkge1xuICAgICAgICAgICAgICAgIC8vIExlc3MgdGhhbiA1MCByZXF1ZXN0cyAoa2V5cyB0cnV0aHkpIChvdGhlcndpc2Ugd2UndmUgYWRkZWQgZnVsbCByYW5nZSBhbnl3YXkpXG4gICAgICAgICAgICAgICAgLy8gYXV0b2luY3JlbWVudCBtZWFucyB3ZSBtaWdodCBub3QgaGF2ZSBnb3QgYWxsIGtleXMgdW50aWwgbm93XG4gICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlcy5yZXN1bHRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhlc1dpdGhBdXRvSW5jUEspIHtcbiAgICAgICAgICAgICAgICAgIC8vIERleGllIElzc3VlIDE5NDY6XG4gICAgICAgICAgICAgICAgICAvLyBJZiBhbiBhdXRvLWluY3JlbWVudGVkIHByaW1hcnkga2V5IGlzIHBhcnQgb2YgYSBjb21wb3VuZCBpbmRleCxcbiAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcmVzdWx0aW5nIHZhbHVlIG9mIHRoYXQgaW5kZXggYWZ0ZXIgaW5zZXJ0aW5nXG4gICAgICAgICAgICAgICAgICAvLyB0aGUgcm93cy5cbiAgICAgICAgICAgICAgICAgIGluZGV4ZXNXaXRoQXV0b0luY1BLLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB2YWx1ZXMgb2YgdGhpcyBjb21wb3VuZCBpbmRleCB3aGVyZSBwcmltYXJ5IGtleSBpcyBub3QgeWV0IHNldDpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4VmFscyA9IHJlcS52YWx1ZXMubWFwKHYgPT4gaWR4LmV4dHJhY3RLZXkodikpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgcHJpbWFyeSBrZXkgaW4gdGhlIGluZGV4OlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwa1BvcyA9IChpZHgua2V5UGF0aCBhcyBzdHJpbmdbXSkuZmluZEluZGV4KHByb3AgPT4gcHJvcCA9PT0gcHJpbWFyeUtleS5rZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGlkeFZhbHMgd2l0aCB0aGUgcmVzdWx0aW5nIHByaW1hcnkga2V5cyB0byBjb21wbGV0ZSB0aGUgaW5kZXggdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yZXN1bHRzIS5mb3JFYWNoKHBrID0+IGlkeFZhbHNbcGtQb3NdID0gcGspO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHVwZGF0ZWQgaW5kZXggdG8gdGhlIHJhbmdlc2V0OlxuICAgICAgICAgICAgICAgICAgICBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkS2V5cyhpZHhWYWxzKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmFucy5tdXRhdGVkUGFydHMgPSBleHRlbmRPYnNlcnZhYmlsaXR5U2V0IChcbiAgICAgICAgICAgICAgICB0cmFucy5tdXRhdGVkUGFydHMgfHwge30sXG4gICAgICAgICAgICAgICAgbXV0YXRlZFBhcnRzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGdldFJhbmdlOiAocmVxOiBhbnkpID0+IFtEQkNvcmVJbmRleCwgUmFuZ2VTZXRdID0gKHtcbiAgICAgICAgICBxdWVyeTogeyBpbmRleCwgcmFuZ2UgfSxcbiAgICAgICAgfTpcbiAgICAgICAgICB8IERCQ29yZVF1ZXJ5UmVxdWVzdFxuICAgICAgICAgIHwgREJDb3JlQ291bnRSZXF1ZXN0XG4gICAgICAgICAgfCBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCkgPT4gW1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIG5ldyBSYW5nZVNldChyYW5nZS5sb3dlciA/PyBjb3JlLk1JTl9LRVksIHJhbmdlLnVwcGVyID8/IGNvcmUuTUFYX0tFWSksXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgcmVhZFN1YnNjcmliZXJzOiB7W21ldGhvZCBpblxuICAgICAgICAgIEV4Y2x1ZGU8a2V5b2YgREJDb3JlVGFibGUsIFwibmFtZVwiIHwgXCJzY2hlbWFcIiB8IFwibXV0YXRlXCI+XTogXG4gICAgICAgICAgKHJlcTogYW55KSA9PiBbREJDb3JlSW5kZXgsIFJhbmdlU2V0XVxuICAgICAgICB9ID0ge1xuICAgICAgICAgIGdldDogKHJlcSkgPT4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldChyZXEua2V5KV0sXG4gICAgICAgICAgZ2V0TWFueTogKHJlcSkgPT4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldCgpLmFkZEtleXMocmVxLmtleXMpXSxcbiAgICAgICAgICBjb3VudDogZ2V0UmFuZ2UsXG4gICAgICAgICAgcXVlcnk6IGdldFJhbmdlLFxuICAgICAgICAgIG9wZW5DdXJzb3I6IGdldFJhbmdlLFxuICAgICAgICB9XG5cbiAgICAgICAga2V5cyhyZWFkU3Vic2NyaWJlcnMpLmZvckVhY2goKG1ldGhvZDogJ2dldCcgfCAnZ2V0TWFueScgfCAnY291bnQnIHwgJ3F1ZXJ5JyB8ICdvcGVuQ3Vyc29yJykgPT4ge1xuICAgICAgICAgIHRhYmxlQ2xvbmVbbWV0aG9kXSA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHJlcTpcbiAgICAgICAgICAgICAgfCBEQkNvcmVHZXRSZXF1ZXN0XG4gICAgICAgICAgICAgIHwgREJDb3JlR2V0TWFueVJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVRdWVyeVJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVDb3VudFJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3IgfSA9IFBTRCBhcyBMaXZlUXVlcnlDb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgaXNMaXZlUXVlcnkgPSAhIXN1YnNjcjtcbiAgICAgICAgICAgIGxldCBjYWNoYWJsZSA9IGlzQ2FjaGFibGVDb250ZXh0KFBTRCBhcyBMaXZlUXVlcnlDb250ZXh0LCB0YWJsZSkgJiYgaXNDYWNoYWJsZVJlcXVlc3QobWV0aG9kLCByZXEpO1xuICAgICAgICAgICAgY29uc3Qgb2JzU2V0ID0gY2FjaGFibGVcbiAgICAgICAgICAgICAgPyByZXEub2JzU2V0ID0ge30gLy8gSW1wbGljaXQgcmVhZCB0cmFuc2FjdGlvbiAtIHRyYWNrIGNoYW5nZXMgZm9yIHRoaXMgcXVlcnkgb25seSBmb3IgdGhlIHJlcXVlc3QncyBkdXJhdGlvblxuICAgICAgICAgICAgICA6IHN1YnNjcjsgLy8gRXhwbGljaXQgcmVhZCB0cmFuc2FjdGlvbiAtIHRyYWNrIGNoYW5nZXMgYWNyb3NzIGVudGlyZSBsaXZlIHF1ZXJ5XG5cbiAgICAgICAgICAgIGlmIChpc0xpdmVRdWVyeSkge1xuICAgICAgICAgICAgICAvLyBDdXJyZW50IHpvbmUgd2FudCdzIHRvIHRyYWNrIGFsbCBxdWVyaWVzIHNvIHRoZXkgY2FuIGJlIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAgICAgIC8vIChUaGUgcXVlcnkgaXMgZXhlY3V0ZWQgd2l0aGluIGEgXCJsaXZlUXVlcnlcIiB6b25lKVxuICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBxdWVyeSBhcHBsaWVzIHRvIGEgY2VydGFpbiBzZXQgb2YgcmFuZ2VzOlxuICAgICAgICAgICAgICAvLyBUcmFjayB3aGF0IHdlIHNob3VsZCBiZSBvYnNlcnZpbmc6XG4gICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYnNTZXRbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgIChvYnNTZXRbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpIGFzIFJhbmdlU2V0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgIGNvbnN0IFtxdWVyaWVkSW5kZXgsIHF1ZXJpZWRSYW5nZXNdID0gcmVhZFN1YnNjcmliZXJzW21ldGhvZF0ocmVxKTtcbiAgICAgICAgICAgICAgLy8gQSBnZW5lcmljIHJ1bGUgaGVyZTogcXVlcmllZCByYW5nZXMgc2hvdWxkIGFsd2F5cyBiZSBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAncXVlcnknICYmIHF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkgJiYgIShyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHB1cmUgcHJpbWF5LWtleSBiYXNlZCBDb2xsZWN0aW9uIHdoZXJlIG9ubHkgLnByaW1hcnlLZXlzKCkgaXMgcmVxdWVzdGVkLiBEb24ndCB3YWtldXAgb24gb3RoZXIgY2hhbmdlcyB0aGFuIGFkZGVkIG9yIGRlbGV0ZWQgcHJpbWFyeSBrZXlzIHdpdGhpbiBxdWVyaWVkIHJhbmdlLlxuICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocXVlcmllZFJhbmdlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQocXVlcmllZEluZGV4Lm5hbWUgfHwgXCJcIikuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY291bnQoKSwgcXVlcnkoKSBhbmQgb3BlbkN1cnNvcigpIG9wZXJhdGVzIG9uIHNlY29uZGFyeSBpbmRpY2VzLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHB1dCgpLCBkZWxldGUoKSBhbmQgZGVsZXRlUmFuZ2UoKSBtdXRhdGlvbnMgbWF5IGhhcHBlbiB3aXRob3V0IGtub3dpbmcgb2xkT2JqcyxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbXV0YXRlKCkgbWV0aG9kIHdpbGwgYmUgbWlzc2luZyB3aGF0IHNlY29uZGFyeSBpbmRpY2VzIHRoYXQgYXJlIGJlaW5nIGRlbGV0ZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJzY3JpYmVkIHJhbmdlLiBXZSBhcmUgd29ya2luZyBhcm91bmQgdGhpcyBpc3N1ZSBieSByZWNvcmRpbmcgYWxsIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGtleXMgZnJvbSB0aGUgcXVlcmllcy4gVGhpcyBvbmx5IHdvcmtzIGZvciB0aG9zZSBraW5kcyBvZiBxdWVyaWVzIHdoZXJlIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgcHJpbWFyeSBrZXkgZnJvbSB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgYmxvY2sgd2UgYXJlIGFjY29tcGxpc2hpbmcgdGhpcyB1c2luZyB2YXJpb3VzIHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHF1ZXJ5IHJlc3VsdC5cblxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZ290IGEgcHJvYmxlbSEgRGVsZXRlIGFuZCBwdXQgbXV0YXRpb25zIGhhcHBlbiB3aXRob3V0IGtub3duIHRoZSBvbGRPYmpzLlxuICAgICAgICAgICAgICAgICAgLy8gVGhvc2UgbXV0YXRpb24gY291bGQgY2hhbmdlIHRoZSBjb3VudC5cbiAgICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uOiBEZWRpY2F0ZWQgXCI6ZGVsc1wiIHVybCByZXByZXNlbmRzIGEgc3Vic2NyaXB0aW9uIHRvIGFsbCBtdXRhdGlvbnMgd2l0aG91dCBvbGRPYmpzXG4gICAgICAgICAgICAgICAgICAvLyAoc3BlY2lhbGx5IHRyaWdnZXJlZCBpbiB0aGUgbXV0YXRvcnMgcHV0KCksIGRlbGV0ZSgpIGFuZCBkZWxldGVSYW5nZSgpIHdoZW4gdGhleSBkb24ndCBrbm93IG9sZE9iamVjdClcbiAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9wZW5DdXJzb3IoKSBvciBxdWVyeSgpXG5cbiAgICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgYSBrZXlzUHJvbWlzZSBpbiBjYXNlIHRoZSB3ZSdyZSBkb2luZyBhbiBJREJJbmRleC5nZXRBbGwoKSBvbiBhIHN0b3JlIHdpdGggb3V0Ym91bmQga2V5cy5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXNQcm9taXNlID1cbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID09PSBcInF1ZXJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICB0YWJsZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYga2V5cyBhcmUgb3V0Ym91bmQsIHdlIGNhbid0IHVzZSBleHRyYWN0S2V5IHRvIG1hcCB3aGF0IGtleXMgdG8gb2JzZXJ2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIHF1ZXJpZWQgYW4gaW5kZXggKGxpa2UgJ2RhdGVUaW1lJykgb24gYW4gb3V0Ym91bmQgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXRyaWV2ZSBhIGxpc3Qgb2Ygb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB3aG8gd2UgY2Fubm90IGtub3cgdGhlaXIgcHJpbWFyeSBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJMdWNraWx5XCIgdGhvdWdoLCB3ZSd2ZSBwcmVwYXJlZCB0aGUga2V5c1Byb21pc2UgdG8gYXNzaXN0IHVzIGluIGV4YWN0IHRoaXMgY29uZGl0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh7IHJlc3VsdDogcmVzdWx0aW5nS2V5cyB9OiBEQkNvcmVRdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5KCkgaW5ib3VuZCB2YWx1ZXMsIGtleXMgb3Igb3V0Ym91bmQga2V5cy4gU2Vjb25kYXJ5IGluZGV4ZXMgb25seSBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwcmltYXJ5IGtleXMgd2Ugd291bGQgb25seSBhZGQgcmVzdWx0cyB3aXRoaW4gdGhlIGFscmVhZHkgcmVnaXN0ZXJlZCByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwS2V5cyA9IChyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHJlcyBhcyBEQkNvcmVRdWVyeVJlc3BvbnNlKS5yZXN1bHQubWFwKGV4dHJhY3RLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChyZXMgYXMgREJDb3JlUXVlcnlSZXNwb25zZSkucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVxIGFzIERCQ29yZVF1ZXJ5UmVxdWVzdCkudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYW55IG11dGF0aW9uIG1hZGUgb24gdGhlIHJldHVybmVkIGtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHdlIGRldGVjdCBib3RoIGRlbGV0aW9ucyBhbmQgdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIG9ubHkgdG8gbXV0YXRpb25zIG9uIHRoZSByZXR1cm5lZCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBtdXRhdG9yIHdhcyB1bmFibGUgdG8ga25vdyBvbGRPYmpzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaGFzIG9sZE9iaiwgdGhlIG11dGF0b3Igd29uJ3QgcHV0IGFueXRoaW5nIGluIFwiOmRlbHNcIiBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBjYW4gbW9yZSBmaW5lLWdyYWluZWQgcHV0IHRoZSBleGFjdCByZW1vdmVkIGFuZCBhZGRlZCBpbmRleCB2YWx1ZSBpbiB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggcmFuZ2UgdGhhdCB3ZSBzdWJzY3JpYmUgdG8gaW4gdGhlIHF1ZXJpZWQgcmFuZ2Ugc2V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGxvYWQgdmFsdWVzIHNvIGEgY2hhbmdlIG9uIGEgcHJvcGVydHkgb3V0c2lkZSBvdXIgaW5kZXggd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUgdXMgdG8gcmUtZXhlY3V0ZSB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZXIgcmVxdWVzdHMgYSBjdXJzb3IuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBzYW1lIHJlYXNvbiBhcyB3aGVuIG1ldGhvZD09PVwicXVlcnlcIiwgd2Ugb25seSBuZWVkIHRvIG9ic2VydmVcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aG9zZSBrZXlzIHdob3NlIHZhbHVlcyBhcmUgcG9zc2libHkgdXNlZCBvciByZW5kZXJlZCAtIHdoaWNoIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBoYXBwZW4gb24ga2V5cyB3aGVyZSB0aGV5IGdldCB0aGUgY3Vyc29yJ3Mga2V5LCBwcmltYXJ5S2V5IG9yIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvcjogREJDb3JlQ3Vyc29yIHwgbnVsbCA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YW50VmFsdWVzID0gKHJlcSBhcyBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCkudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkocGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbnRWYWx1ZXMgJiYgcGtSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YWJsZUNsb25lO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhY2tBZmZlY3RlZEluZGV4ZXMoXG4gIGdldFJhbmdlU2V0OiAoaW5kZXg6IHN0cmluZykgPT4gUmFuZ2VTZXQsXG4gIHNjaGVtYTogREJDb3JlVGFibGVTY2hlbWEsXG4gIG9sZE9ianM6IHJlYWRvbmx5IGFueVtdIHwgdW5kZWZpbmVkLFxuICBuZXdPYmpzOiByZWFkb25seSBhbnlbXSB8IHVuZGVmaW5lZFxuKSB7XG4gIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXg6IERCQ29yZUluZGV4KSB7XG4gICAgY29uc3QgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqOiBhbnkpIHtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFkZEtleU9yS2V5cyA9IChrZXk6IGFueSkgPT4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgIC8vIG11bHRpRW50cnkgYW5kIHRoZSBvbGQgcHJvcGVydHkgd2FzIGFuIGFycmF5IC0gYWRkIGVhY2ggYXJyYXkgZW50cnkgdG8gdGhlIHJhbmdlU2V0OlxuICAgICAgPyBrZXkuZm9yRWFjaChrZXkgPT4gcmFuZ2VTZXQuYWRkS2V5KGtleSkpXG4gICAgICAvLyBOb3QgbXVsdGlFbnRyeSBvciB0aGUgb2xkIHByb3BlcnR5IHdhcyBub3QgYW4gYXJyYXkgLSBhZGQgZWFjaCBhcnJheSBlbnRyeSB0byB0aGUgcmFuZ2VTZXQ6XG4gICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpO1xuXG4gICAgKG9sZE9ianMgfHwgbmV3T2JqcykuZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgY29uc3Qgb2xkS2V5ID0gb2xkT2JqcyAmJiBleHRyYWN0S2V5KG9sZE9ianNbaV0pO1xuICAgICAgY29uc3QgbmV3S2V5ID0gbmV3T2JqcyAmJiBleHRyYWN0S2V5KG5ld09ianNbaV0pO1xuICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcbiAgICAgICAgLy8gVGhlIGluZGV4IGhhcyBjaGFuZ2VkLiBBZGQgYm90aCBvbGQgYW5kIG5ldyB2YWx1ZSBvZiB0aGUgaW5kZXguXG4gICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbCkgYWRkS2V5T3JLZXlzKG9sZEtleSk7IC8vIElmIG9sZEtleSBpcyBpbnZhbGlkIGtleSwgYWRkS2V5KCkgd2lsbCBiZSBhIG5vb3AuXG4gICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbCkgYWRkS2V5T3JLZXlzKG5ld0tleSk7IC8vIElmIG5ld0tleSBpcyBpbnZhbGlkIGtleSwgYWRkS2V5KCkgd2lsbCBiZSBhIG5vb3AuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcbn1cbiIsICJpbXBvcnQgeyBkZWxBcnJheUl0ZW0sIGlzQXJyYXkgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgVGJsUXVlcnlDYWNoZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9jYWNoZSc7XG5pbXBvcnQge1xuICBEQkNvcmVNdXRhdGVSZXF1ZXN0LFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbn0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKFxuICB0YmxDYWNoZTogVGJsUXVlcnlDYWNoZSxcbiAgcmVxOiBEQkNvcmVNdXRhdGVSZXF1ZXN0LFxuICByZXM6IERCQ29yZU11dGF0ZVJlc3BvbnNlXG4pOiBEQkNvcmVNdXRhdGVSZXF1ZXN0IHtcbiAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gMCkgcmV0dXJuIHJlcTtcbiAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG4gICAgLy8gbnVtRmFpbHVyZXMgPiAwIG1lYW5zIHRoZSBkZWxldGVSYW5nZSBvcGVyYXRpb24gZmFpbGVkIGluIGl0cyB3aG9sZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG51bUJ1bGtPcHMgPSByZXEua2V5c1xuICAgID8gcmVxLmtleXMubGVuZ3RoXG4gICAgOiAndmFsdWVzJyBpbiByZXEgJiYgcmVxLnZhbHVlc1xuICAgID8gcmVxLnZhbHVlcy5sZW5ndGhcbiAgICA6IDE7XG4gIGlmIChyZXMubnVtRmFpbHVyZXMgPT09IG51bUJ1bGtPcHMpIHtcbiAgICAvLyBTYW1lIG51bWJlciBvZiBmYWlsdXJlcyBhcyB0aGUgbnVtYmVyIG9mIG9wcy4gVGhpcyBtZWFucyB0aGF0IGFsbCBvcHMgZmFpbGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgY2xvbmU6IERCQ29yZU11dGF0ZVJlcXVlc3QgPSB7IC4uLnJlcSB9O1xuXG4gIGlmIChpc0FycmF5KGNsb25lLmtleXMpKSB7XG4gICAgY2xvbmUua2V5cyA9IGNsb25lLmtleXMuZmlsdGVyKChfLCBpKSA9PiAhKGkgaW4gcmVzLmZhaWx1cmVzKSk7XG4gIH1cbiAgaWYgKCd2YWx1ZXMnIGluIGNsb25lICYmIGlzQXJyYXkoY2xvbmUudmFsdWVzKSkge1xuICAgIGNsb25lLnZhbHVlcyA9IGNsb25lLnZhbHVlcy5maWx0ZXIoKF8sIGkpID0+ICEoaSBpbiByZXMuZmFpbHVyZXMpKTtcbiAgfVxuICByZXR1cm4gY2xvbmU7XG59XG4iLCAiaW1wb3J0IHsgY21wIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NtcCc7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vLi4vcHVibGljJztcbmltcG9ydCB7IERCQ29yZUtleVJhbmdlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fib3ZlTG93ZXIoa2V5OiBJbmRleGFibGVUeXBlLCByYW5nZTogREJDb3JlS2V5UmFuZ2UpIHtcbiAgcmV0dXJuIHJhbmdlLmxvd2VyID09PSB1bmRlZmluZWRcbiAgICA/IHRydWUgLy8gbG93ZXIgaXMgbGVzcyB0aGFuIGFueXRoaW5nIGJlY2F1c2UgaXQgaXMgdW5kZWZpbmVkXG4gICAgOiByYW5nZS5sb3dlck9wZW5cbiAgICA/IGNtcChrZXksIHJhbmdlLmxvd2VyKSA+IDAgLy8gbG93ZXJPcGVuOiBFeGNsdWRlIGxvd2VyIGJvdW5kXG4gICAgOiBjbXAoa2V5LCByYW5nZS5sb3dlcikgPj0gMDsgLy8gIWxvd2VyT3BlbjogSW5jbHVkZSBsb3dlciBib3VuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCZWxvd1VwcGVyKGtleTogSW5kZXhhYmxlVHlwZSwgcmFuZ2U6IERCQ29yZUtleVJhbmdlKSB7XG4gIHJldHVybiByYW5nZS51cHBlciA9PT0gdW5kZWZpbmVkXG4gICAgPyB0cnVlIC8vIHVwcGVyIGlzIGdyZWF0ZXIgdGhhbiBhbnl0aGluZyBiZWNhdXNlIGl0IGlzIHVuZGVmaW5lZFxuICAgIDogcmFuZ2UudXBwZXJPcGVuXG4gICAgPyBjbXAoa2V5LCByYW5nZS51cHBlcikgPCAwIC8vIHVwcGVyT3BlbjogRXhjbHVkZSB1cHBlciBib3VuZFxuICAgIDogY21wKGtleSwgcmFuZ2UudXBwZXIpIDw9IDA7IC8vICF1cHBlck9wZW46IEluY2x1ZGUgdXBwZXIgYm91bmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2l0aGluUmFuZ2Uoa2V5OiBJbmRleGFibGVUeXBlLCByYW5nZTogREJDb3JlS2V5UmFuZ2UpIHtcbiAgcmV0dXJuIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSAmJiBpc0JlbG93VXBwZXIoa2V5LCByYW5nZSk7XG59XG4iLCAiaW1wb3J0IHsgY21wIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NtcCc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IFJhbmdlU2V0IH0gZnJvbSAnLi4vLi4vaGVscGVycy9yYW5nZXNldCc7XG5pbXBvcnQgeyBDYWNoZUVudHJ5IH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2NhY2hlJztcbmltcG9ydCB7XG4gIERCQ29yZU11dGF0ZVJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlVGFibGUsXG59IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgaXNXaXRoaW5SYW5nZSB9IGZyb20gJy4vaXMtd2l0aGluLXJhbmdlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY09wcyhcbiAgcmVzdWx0OiBhbnlbXSxcbiAgcmVxOiBEQkNvcmVRdWVyeVJlcXVlc3QsXG4gIG9wczogREJDb3JlTXV0YXRlUmVxdWVzdFtdIHwgdW5kZWZpbmVkLFxuICB0YWJsZTogREJDb3JlVGFibGUsXG4gIGNhY2hlRW50cnk6IENhY2hlRW50cnksXG4gIGltbXV0YWJsZTogYm9vbGVhblxuKTogYW55W10ge1xuICBpZiAoIW9wcyB8fCBvcHMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBjb25zdCBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcbiAgY29uc3QgeyBtdWx0aUVudHJ5IH0gPSBpbmRleDtcbiAgY29uc3QgcXVlcnlSYW5nZSA9IHJlcS5xdWVyeS5yYW5nZTtcbiAgY29uc3QgcHJpbWFyeUtleSA9IHRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICBjb25zdCBleHRyYWN0UHJpbUtleSA9IHByaW1hcnlLZXkuZXh0cmFjdEtleSE7XG4gIGNvbnN0IGV4dHJhY3RJbmRleCA9IGluZGV4LmV4dHJhY3RLZXkhO1xuICBjb25zdCBleHRyYWN0TG93TGV2ZWxJbmRleCA9IChpbmRleC5sb3dMZXZlbEluZGV4IHx8IGluZGV4KS5leHRyYWN0S2V5ITtcblxuICBsZXQgZmluYWxSZXN1bHQgPSBvcHMucmVkdWNlKChyZXN1bHQsIG9wKSA9PiB7XG4gICAgbGV0IG1vZGlmZWRSZXN1bHQgPSByZXN1bHQ7XG4gICAgY29uc3QgaW5jbHVkZWRWYWx1ZXM6IGFueVtdID0gW107XG4gICAgaWYgKG9wLnR5cGUgPT09ICdhZGQnIHx8IG9wLnR5cGUgPT09ICdwdXQnKSB7XG4gICAgICBjb25zdCBpbmNsdWRlZFBLcyA9IG5ldyBSYW5nZVNldCgpOyAvLyBGb3IgaWdub3JpbmcgZHVwbGljYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IG9wLnZhbHVlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAvLyBiYWNrd2FyZHMgdG8gcHJpb3JpdGl6ZSBsYXN0IHZhbHVlIG9mIHNhbWUgUEtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvcC52YWx1ZXNbaV07XG4gICAgICAgIGNvbnN0IHBrID0gZXh0cmFjdFByaW1LZXkodmFsdWUpO1xuICAgICAgICBpZiAoaW5jbHVkZWRQS3MuaGFzS2V5KHBrKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGV4dHJhY3RJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgPyBrZXkuc29tZSgoaykgPT4gaXNXaXRoaW5SYW5nZShrLCBxdWVyeVJhbmdlKSlcbiAgICAgICAgICAgIDogaXNXaXRoaW5SYW5nZShrZXksIHF1ZXJ5UmFuZ2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGluY2x1ZGVkUEtzLmFkZEtleShwayk7XG4gICAgICAgICAgaW5jbHVkZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdhZGQnOlxuICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmNvbmNhdChcbiAgICAgICAgICByZXEudmFsdWVzXG4gICAgICAgICAgICA/IGluY2x1ZGVkVmFsdWVzXG4gICAgICAgICAgICA6IGluY2x1ZGVkVmFsdWVzLm1hcCgodikgPT4gZXh0cmFjdFByaW1LZXkodikpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHV0JzpcbiAgICAgICAgY29uc3Qga2V5U2V0ID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhcbiAgICAgICAgICBvcC52YWx1ZXMubWFwKCh2KSA9PiBleHRyYWN0UHJpbUtleSh2KSlcbiAgICAgICAgKTtcbiAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGl0ZW1zIHRoYXQgYXJlIGJlaW5nIHJlcGxhY2VkXG4gICAgICAgICAgICAoaXRlbSkgPT4gIWtleVNldC5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSlcbiAgICAgICAgICApXG4gICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgIC8vIEFkZCBhbGwgaXRlbXMgdGhhdCBhcmUgYmVpbmcgcHV0IChzb3J0aW5nIHdpbGwgYmUgZG9uZSBsYXRlcilcbiAgICAgICAgICAgIHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgPyBpbmNsdWRlZFZhbHVlc1xuICAgICAgICAgICAgICA6IGluY2x1ZGVkVmFsdWVzLm1hcCgodikgPT4gZXh0cmFjdFByaW1LZXkodikpXG4gICAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICBjb25zdCBrZXlzVG9EZWxldGUgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLmtleXMpO1xuICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmZpbHRlcihcbiAgICAgICAgICAoaXRlbSkgPT4gIWtleXNUb0RlbGV0ZS5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSlcbiAgICAgICAgKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBvcC5yYW5nZTtcbiAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoKGl0ZW0pID0+ICFpc1dpdGhpblJhbmdlKGV4dHJhY3RQcmltS2V5KGl0ZW0pLCByYW5nZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG1vZGlmZWRSZXN1bHQ7XG4gIH0sIHJlc3VsdCk7XG5cbiAgLy8gSWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUsIHdlIGNhbiByZXR1cm4gdGhlIG9yaWdpbmFsIHJlc3VsdC5cbiAgaWYgKGZpbmFsUmVzdWx0ID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cbiAgLy8gU29ydCB0aGUgcmVzdWx0IG9uIHNvcnRJbmRleDpcbiAgZmluYWxSZXN1bHQuc29ydCgoYSwgYikgPT5cbiAgICBjbXAoZXh0cmFjdExvd0xldmVsSW5kZXgoYSksIGV4dHJhY3RMb3dMZXZlbEluZGV4KGIpKSB8fFxuICAgIGNtcChleHRyYWN0UHJpbUtleShhKSwgZXh0cmFjdFByaW1LZXkoYikpXG4gICk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxpbWl0IHdlIG5lZWQgdG8gcmVzcGVjdCBpdDpcbiAgaWYgKHJlcS5saW1pdCAmJiByZXEubGltaXQgPCBJbmZpbml0eSkge1xuICAgIGlmIChmaW5hbFJlc3VsdC5sZW5ndGggPiByZXEubGltaXQpIHtcbiAgICAgIGZpbmFsUmVzdWx0Lmxlbmd0aCA9IHJlcS5saW1pdDsgLy8gQ3V0IG9mIGFueSBleHRyYXMgYWZ0ZXIgc29ydGluZyBjb3JyZWN0bHkuXG4gICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSByZXEubGltaXQgJiYgZmluYWxSZXN1bHQubGVuZ3RoIDwgcmVxLmxpbWl0KSB7XG4gICAgICAvLyBXZSdyZSBtaXNzaW5nIHNvbWUgaXRlbXMgYmVjYXVzZSBvZiB0aGUgbGltaXQuIFdlIG5lZWQgdG8gYWRkIHRoZW0gYmFjay5cbiAgICAgIC8vIFRoZSBlYXNpZXN0IHdheSBpcyB0byBtYXJrIHRoZSBjYWNoZSBlbnRyeSBhcyBkaXJ0eSwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgLy8gaXQgdG8gYmUgcmVxdWVyaWVkIGFmdGVyIHRoZSB3cml0ZS10cmFuc2FjdGlvbiBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICAgICAgY2FjaGVFbnRyeS5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbW11dGFibGUgPyBPYmplY3QuZnJlZXplKGZpbmFsUmVzdWx0KSBhcyBhbnlbXSA6IGZpbmFsUmVzdWx0O1xufVxuIiwgImltcG9ydCB7IGNtcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jbXAnO1xuaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFyZVJhbmdlc0VxdWFsKHIxOiBEQkNvcmVLZXlSYW5nZSwgcjI6IERCQ29yZUtleVJhbmdlKSB7XG4gIHJldHVybiAoXG4gICAgY21wKHIxLmxvd2VyLCByMi5sb3dlcikgPT09IDAgJiZcbiAgICBjbXAocjEudXBwZXIsIHIyLnVwcGVyKSA9PT0gMCAmJlxuICAgICEhcjEubG93ZXJPcGVuID09PSAhIXIyLmxvd2VyT3BlbiAmJlxuICAgICEhcjEudXBwZXJPcGVuID09PSAhIXIyLnVwcGVyT3BlblxuICApO1xufVxuIiwgImltcG9ydCB7IGNtcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jbXAnO1xuaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVMb3dlcnMobG93ZXIxOiBhbnksIGxvd2VyMjogYW55LCBsb3dlck9wZW4xOiBib29sZWFuLCBsb3dlck9wZW4yOiBib29sZWFuKSB7XG4gIGlmIChsb3dlcjEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGxvd2VyMiAhPT0gdW5kZWZpbmVkID8gLTEgOiAwO1xuICBpZiAobG93ZXIyID09PSB1bmRlZmluZWQpIHJldHVybiAxOyAvLyBzaW5jZSBsb3dlcjEgIT09IHVuZGVmaW5lZFxuICBjb25zdCBjID0gY21wKGxvd2VyMSwgbG93ZXIyKTtcbiAgaWYgKGMgPT09IDApIHtcbiAgICBpZiAobG93ZXJPcGVuMSAmJiBsb3dlck9wZW4yKSByZXR1cm4gMDtcbiAgICBpZiAobG93ZXJPcGVuMSkgcmV0dXJuIDFcbiAgICBpZiAobG93ZXJPcGVuMikgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVVwcGVycyh1cHBlcjE6IGFueSwgdXBwZXIyOiBhbnksIHVwcGVyT3BlbjE6IGJvb2xlYW4sIHVwcGVyT3BlbjI6IGJvb2xlYW4pIHtcbiAgaWYgKHVwcGVyMSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdXBwZXIyICE9PSB1bmRlZmluZWQgPyAxIDogMDtcbiAgaWYgKHVwcGVyMiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7IC8vIHNpbmNlIHVwcGVyMSAhPT0gdW5kZWZpbmVkXG4gIGNvbnN0IGMgPSBjbXAodXBwZXIxLCB1cHBlcjIpO1xuICBpZiAoYyA9PT0gMCkge1xuICAgIGlmICh1cHBlck9wZW4xICYmIHVwcGVyT3BlbjIpIHJldHVybiAwO1xuICAgIGlmICh1cHBlck9wZW4xKSByZXR1cm4gLTFcbiAgICBpZiAodXBwZXJPcGVuMikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cGVyUmFuZ2UocjE6IERCQ29yZUtleVJhbmdlLCByMjogREJDb3JlS2V5UmFuZ2UpIHtcbiAgcmV0dXJuIChcbiAgICBjb21wYXJlTG93ZXJzKHIxLmxvd2VyLCByMi5sb3dlciwgcjEubG93ZXJPcGVuLCByMi5sb3dlck9wZW4pIDw9IDAgJiZcbiAgICBjb21wYXJlVXBwZXJzKHIxLnVwcGVyLCByMi51cHBlciwgcjEudXBwZXJPcGVuLCByMi51cHBlck9wZW4pID49IDBcbiAgKTtcbn0iLCAiaW1wb3J0IHsgQ2FjaGVFbnRyeSwgVGJsUXVlcnlDYWNoZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9jYWNoZSc7XG5pbXBvcnQge1xuICBEQkNvcmVDb3VudFJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbn0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBhcmVSYW5nZXNFcXVhbCB9IGZyb20gJy4vYXJlLXJhbmdlcy1lcXVhbCc7XG5pbXBvcnQgeyBjYWNoZSB9IGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgaXNTdXBlclJhbmdlIH0gZnJvbSAnLi9pcy1zdXBlci1yYW5nZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ29tcGF0aWJsZVF1ZXJ5KFxuICBkYk5hbWU6IHN0cmluZyxcbiAgdGFibGVOYW1lOiBzdHJpbmcsXG4gIHR5cGU6ICdxdWVyeScsXG4gIHJlcTogREJDb3JlUXVlcnlSZXF1ZXN0XG4pOiBbXSB8IFtDYWNoZUVudHJ5LCBib29sZWFuLCBUYmxRdWVyeUNhY2hlLCBDYWNoZUVudHJ5W11dO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDb21wYXRpYmxlUXVlcnkoXG4gIGRiTmFtZTogc3RyaW5nLFxuICB0YWJsZU5hbWU6IHN0cmluZyxcbiAgdHlwZTogJ2NvdW50JyxcbiAgcmVxOiBEQkNvcmVDb3VudFJlcXVlc3Rcbik6IFtdIHwgW0NhY2hlRW50cnksIGJvb2xlYW4sIFRibFF1ZXJ5Q2FjaGUsIENhY2hlRW50cnlbXV07XG5leHBvcnQgZnVuY3Rpb24gZmluZENvbXBhdGlibGVRdWVyeShcbiAgZGJOYW1lOiBzdHJpbmcsXG4gIHRhYmxlTmFtZTogc3RyaW5nLFxuICB0eXBlOiAncXVlcnknIHwgJ2NvdW50JyxcbiAgcmVxOiBQYXJ0aWFsPERCQ29yZVF1ZXJ5UmVxdWVzdD4gJiBQYXJ0aWFsPERCQ29yZUNvdW50UmVxdWVzdD5cbik6IFtdIHwgW0NhY2hlRW50cnksIGJvb2xlYW4sIFRibFF1ZXJ5Q2FjaGUsIENhY2hlRW50cnlbXV0ge1xuICBjb25zdCB0YmxDYWNoZSA9IGNhY2hlW2BpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9YF07XG4gIGlmICghdGJsQ2FjaGUpIHJldHVybiBbXTtcbiAgY29uc3QgcXVlcmllcyA9IHRibENhY2hlLnF1ZXJpZXNbdHlwZV07XG4gIGlmICghcXVlcmllcykgcmV0dXJuIFtudWxsLCBmYWxzZSwgdGJsQ2FjaGUsIG51bGxdO1xuICBjb25zdCBpbmRleE5hbWUgPSByZXEucXVlcnkgPyByZXEucXVlcnkuaW5kZXgubmFtZSA6IG51bGw7XG4gIGNvbnN0IGVudHJpZXMgPSBxdWVyaWVzW2luZGV4TmFtZSB8fCAnJ107XG4gIGlmICghZW50cmllcykgcmV0dXJuIFtudWxsLCBmYWxzZSwgdGJsQ2FjaGUsIG51bGxdO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGNvbnN0IGVxdWFsRW50cnkgPSBlbnRyaWVzLmZpbmQoXG4gICAgICAgIChlbnRyeSkgPT5cbiAgICAgICAgICAoZW50cnkucmVxIGFzIERCQ29yZVF1ZXJ5UmVxdWVzdCkubGltaXQgPT09IHJlcS5saW1pdCAmJlxuICAgICAgICAgIChlbnRyeS5yZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXMgPT09IHJlcS52YWx1ZXMgJiZcbiAgICAgICAgICBhcmVSYW5nZXNFcXVhbChlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSlcbiAgICAgICk7XG4gICAgICBpZiAoZXF1YWxFbnRyeSlcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlcXVhbEVudHJ5LFxuICAgICAgICAgIHRydWUsIC8vIGV4YWN0IG1hdGNoXG4gICAgICAgICAgdGJsQ2FjaGUsXG4gICAgICAgICAgZW50cmllcyxcbiAgICAgICAgXTtcbiAgICAgIGNvbnN0IHN1cGVyRW50cnkgPSBlbnRyaWVzLmZpbmQoKGVudHJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gJ2xpbWl0JyBpbiBlbnRyeS5yZXEgPyBlbnRyeS5yZXEubGltaXQgOiBJbmZpbml0eTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBsaW1pdCA+PSByZXEubGltaXQgJiZcbiAgICAgICAgICAocmVxLnZhbHVlcyA/IChlbnRyeS5yZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXMgOiB0cnVlKSAmJlxuICAgICAgICAgIGlzU3VwZXJSYW5nZShlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtzdXBlckVudHJ5LCBmYWxzZSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgIGNvbnN0IGNvdW50UXVlcnkgPSBlbnRyaWVzLmZpbmQoKGVudHJ5KSA9PlxuICAgICAgICBhcmVSYW5nZXNFcXVhbChlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gW2NvdW50UXVlcnksICEhY291bnRRdWVyeSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZGVsQXJyYXlJdGVtIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgQ2FjaGVFbnRyeSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvY2FjaGVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZVRvQ2FjaGVFbnRyeShjYWNoZUVudHJ5OiBDYWNoZUVudHJ5LCBjb250YWluZXI6IENhY2hlRW50cnlbXSwgcmVxdWVyeTogKCk9PnZvaWQsIHNpZ25hbDogQWJvcnRTaWduYWwpIHtcbiAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5hZGQocmVxdWVyeSk7XG4gIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgIGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuZGVsZXRlKHJlcXVlcnkpO1xuICAgIGlmIChjYWNoZUVudHJ5LnN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeSwgY29udGFpbmVyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeTogQ2FjaGVFbnRyeSwgY29udGFpbmVyOiBDYWNoZUVudHJ5W10pIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkgeyAvLyBTdGlsbCBlbXB0eSAobm8gbmV3IHN1YnNjcmliZXJzIHJlYWRkZWQgYWZ0ZXIgZ3JhY2UgdGltZSlcbiAgICAgIGRlbEFycmF5SXRlbShjb250YWluZXIsIGNhY2hlRW50cnkpO1xuICAgIH1cbiAgfSwgMzAwMCk7XG59XG4iLCAiaW1wb3J0IHsgTGl2ZVF1ZXJ5Q29udGV4dCB9IGZyb20gJy4uJztcbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi8uLi9jbGFzc2VzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGdldEVmZmVjdGl2ZUtleXMgfSBmcm9tICcuLi8uLi9kYmNvcmUvZ2V0LWVmZmVjdGl2ZS1rZXlzJztcbmltcG9ydCB7IGRlZXBDbG9uZSwgZGVsQXJyYXlJdGVtLCBzZXRCeUtleVBhdGggfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IERleGllUHJvbWlzZSwgeyBQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHMnO1xuaW1wb3J0IHtcbiAgREJDb3JlLCBEQkNvcmVNdXRhdGVSZXF1ZXN0LCBEQkNvcmVNdXRhdGVSZXNwb25zZSwgREJDb3JlUXVlcnlSZXF1ZXN0LFxuICBEQkNvcmVRdWVyeVJlc3BvbnNlXG59IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IG9ic1NldHNPdmVybGFwIH0gZnJvbSAnLi4vb2JzLXNldHMtb3ZlcmxhcCc7XG5pbXBvcnQgeyBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzIH0gZnJvbSAnLi9hZGp1c3Qtb3B0aW1pc3RpYy1yZXF1ZXN0LWZyb20tZmFpbHVyZXMnO1xuaW1wb3J0IHsgYXBwbHlPcHRpbWlzdGljT3BzIH0gZnJvbSAnLi9hcHBseS1vcHRpbWlzdGljLW9wcyc7XG5pbXBvcnQgeyBjYWNoZSB9IGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgZmluZENvbXBhdGlibGVRdWVyeSB9IGZyb20gJy4vZmluZC1jb21wYXRpYmxlLXF1ZXJ5JztcbmltcG9ydCB7IGlzQ2FjaGFibGVDb250ZXh0IH0gZnJvbSAnLi9pcy1jYWNoYWJsZS1jb250ZXh0JztcbmltcG9ydCB7IGlzQ2FjaGFibGVSZXF1ZXN0IH0gZnJvbSAnLi9pcy1jYWNoYWJsZS1yZXF1ZXN0JztcbmltcG9ydCB7IHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5IH0gZnJvbSAnLi9zaWduYWxTdWJzY3JpYmVycyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb0NhY2hlRW50cnkgfSBmcm9tICcuL3N1YnNjcmliZS1jYWNoZW50cnknO1xuXG5leHBvcnQgY29uc3QgY2FjaGVNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiAnZGJjb3JlJyxcbiAgbGV2ZWw6IDAsXG4gIG5hbWU6ICdDYWNoZScsXG4gIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICBjb25zdCBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgIGNvbnN0IGNvcmVNVzogREJDb3JlID0ge1xuICAgICAgLi4uY29yZSxcbiAgICAgIHRyYW5zYWN0aW9uOiAoc3RvcmVzLCBtb2RlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkYnRyYW5zID0gY29yZS50cmFuc2FjdGlvbihcbiAgICAgICAgICBzdG9yZXMsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICkgYXMgSURCVHJhbnNhY3Rpb24gJiB7XG4gICAgICAgICAgbXV0YXRlZFBhcnRzPzogT2JzZXJ2YWJpbGl0eVNldDtcbiAgICAgICAgICBfZXhwbGljaXQ/OiBib29sZWFuO1xuICAgICAgICB9O1xuICAgICAgICAvLyBNYWludGFpbiBUYmxRdWVyeUNhY2hlLm9wcyBhcnJheSB3aGVuIHRyYW5zYWN0aW9ucyBjb21taXQgb3IgYWJvcnRcbiAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgY29uc3QgeyBzaWduYWwgfSA9IGFjO1xuICAgICAgICAgIGNvbnN0IGVuZFRyYW5zYWN0aW9uID0gKHdhc0NvbW1pdHRlZDogYm9vbGVhbikgPT4gKCkgPT4ge1xuICAgICAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJykge1xuICAgICAgICAgICAgICAvLyBDb2xsZWN0IHdoaWNoIHN1YnNjcmliZXJzIHRvIG5vdGlmeTpcbiAgICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRTdWJzY3JpYmVycyA9IG5ldyBTZXQ8KCk9PnZvaWQ+KCk7XG5cbiAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgdGFibGVzIGluIHRyYW5zYWN0aW9uIGFuZCBjaGVjayBpZiB0aGV5IGhhdmUgYW55IG9wdGltaXN0aWMgdXBkYXRlc1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0b3JlTmFtZSBvZiBzdG9yZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YmxDYWNoZSA9IGNhY2hlW2BpZGI6Ly8ke2RiTmFtZX0vJHtzdG9yZU5hbWV9YF07XG4gICAgICAgICAgICAgICAgaWYgKHRibENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgIC8vIFBpY2sgb3B0aW1pc3RpYyBvcHMgdGhhdCBhcmUgcGFydCBvZiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb25zdCBvcHMgPSB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKG9wKSA9PiBvcC50cmFucyA9PT0gaWRidHJhbnNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAvLyBUcmFuc2FjdGlvbiB3YXMgbWFya2VkIGFzIF9leHBsaWNpdCBpbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoKSwgdHJhbnNhY3Rpb24taGVscGVycy50cy5cbiAgICAgICAgICAgICAgICAgIGlmIChpZGJ0cmFucy5fZXhwbGljaXQgJiYgd2FzQ29tbWl0dGVkICYmIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBxdWVyaWVzIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSBtdXRhdGVkIHBhcnRzIGFuZCBzaWduYWwgdGhlaXIgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyaWVzIG9mIE9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzLnNsaWNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYnNTZXRzT3ZlcmxhcChlbnRyeS5vYnNTZXQsIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTsgLy8gUmVtb3ZlIHRoZSBlbnRyeSBmcm9tIHRoZSBjYWNoZSBzbyBpdCBjYW4gYmUgcmVmcmVzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goKHJlcXVlcnkpID0+IGFmZmVjdGVkU3Vic2NyaWJlcnMuYWRkKHJlcXVlcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZW0gZnJvbSB0aGUgb3B0aW1pc3RpY09wcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzID0gdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgKG9wKSA9PiBvcC50cmFucyAhPT0gaWRidHJhbnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWl0IG9yIGFib3J0IHRoZSBvcHRpbWlzdGljIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyaWVzIG9mIE9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzLnNsaWNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzICE9IG51bGwgJiYgLy8gaWYgZW50cnkucHJvbWlzZSBidXQgbm90IGVudHJ5LnJlcywgd2UncmUgZmluZS4gUXVlcnkgd2lsbCByZXN1bWUgbm93IGFuZCBnZXQgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMubXV0YXRlZFBhcnRzLyogJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzU2V0c092ZXJsYXAoZW50cnkub2JzU2V0LCBpZGJ0cmFucy5tdXRhdGVkUGFydHMpKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FzQ29tbWl0dGVkICYmICFlbnRyeS5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyZWV6ZVJlc3VsdHMgPSBPYmplY3QuaXNGcm96ZW4oZW50cnkucmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RSZXMgPSBhcHBseU9wdGltaXN0aWNPcHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXMgYXMgYW55W10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlZXplUmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBvdXQgYXQgdGhpcyBwb2ludCB0aGF0IHRoZSBlbnRyeSBpcyBkaXJ0eSAtIG5vdCB0byByZWx5IG9uIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goKHJlcXVlcnkpID0+IGFmZmVjdGVkU3Vic2NyaWJlcnMuYWRkKHJlcXVlcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFJlcyAhPT0gZW50cnkucmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXMgPSBtb2RSZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHtyZXN1bHQ6IG1vZFJlc30gc2F0aXNmaWVzIERCQ29yZVF1ZXJ5UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIG5vdGlmeSBzdWJzY3JpYmVycy4gVGhleSBhbHJlYWR5IGhhdmUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUganVzdCB1cGRhdGVkIHRoZSB2YWx1ZSBvZiB0aGUgY2FjaGUgd2l0aG91dCBoYXZpbmcgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlcnkgdGhlIGRhdGFiYXNlIC0gYmVjYXVzZSB3ZSBrbm93IHRoZSByZXN1bHQgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IGJhc2VkIG9uIGNvbXB1dGluZyB0aGUgb3BlcmF0aW9ucyBhbmQgYXBwbHlpbmcgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHByZXZpb3VzIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW50cnkgaXMgZGlydHkgd2UgbmVlZCB0byBnZXQgcmlkIG9mIGl0IHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgbmV3IGVudHJ5IHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBxdWVyeSBpcyBydW4gYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY29tbWl0dGluZywgd2UgbmVlZCB0byBub3RpZnkgc3Vic2NyaWJlcnMgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWlzdGljIHVwZGF0ZXMgYXJlIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKChyZXF1ZXJ5KSA9PiBhZmZlY3RlZFN1YnNjcmliZXJzLmFkZChyZXF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWZmZWN0ZWRTdWJzY3JpYmVycy5mb3JFYWNoKChyZXF1ZXJ5KSA9PiByZXF1ZXJ5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWRidHJhbnMuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlbmRUcmFuc2FjdGlvbihmYWxzZSksIHtcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgZW5kVHJhbnNhY3Rpb24odHJ1ZSksIHtcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRidHJhbnM7XG4gICAgICB9LFxuICAgICAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZG93blRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICBjb25zdCBwcmltS2V5ID0gZG93blRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgICBjb25zdCB0YWJsZU1XID0ge1xuICAgICAgICAgIC4uLmRvd25UYWJsZSxcbiAgICAgICAgICBtdXRhdGUocmVxOiBEQkNvcmVNdXRhdGVSZXF1ZXN0KTogUHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnMgPSBQU0QudHJhbnMgYXMgVHJhbnNhY3Rpb247XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByaW1LZXkub3V0Ym91bmQgfHwgLy8gTm9uLWluYm91bmQgdGFibGVzIGFyZSBoYXJkZWQgdG8gYXBwbHkgb3B0aW1pc3RpYyB1cGRhdGVzIG9uIGJlY2F1c2Ugd2UgY2FuJ3Qga25vdyBwcmltYXJ5IGtleSBvZiByZXN1bHRzXG4gICAgICAgICAgICAgIHRyYW5zLmRiLl9vcHRpb25zLmNhY2hlID09PSAnZGlzYWJsZWQnIHx8IC8vIFVzZXIgaGFzIG9wdGVkLW91dCBmcm9tIGNhY2hpbmdcbiAgICAgICAgICAgICAgdHJhbnMuZXhwbGljaXQgLy8gSXQncyBhbiBleHBsaWNpdCB3cml0ZSB0cmFuc2FjdGlvbiBiZWluZyBtYWRlLiBEb24ndCBhZmZlY3QgY2FjaGUgdW50aWwgdHJhbnNhY3Rpb24gY29tbWl0cy5cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBKdXN0IGZvcndhcmQgdGhlIHJlcXVlc3QgdG8gdGhlIGNvcmUuXG4gICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBUYmxRdWVyeUNhY2hlIGZvciB0aGlzIHRhYmxlOlxuICAgICAgICAgICAgY29uc3QgdGJsQ2FjaGUgPSBjYWNoZVtgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfWBdO1xuICAgICAgICAgICAgaWYgKCF0YmxDYWNoZSkgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgIGlmICgocmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JykgJiYgKHJlcS52YWx1ZXMubGVuZ3RoID49IDUwIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbUtleSwgcmVxKS5zb21lKGtleSA9PiBrZXkgPT0gbnVsbCkpKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBzb21lIGF1dG9JbmNyZW1lbnRlZCBrZXlzIG5vdCBzZXQgeWV0LiBOZWVkIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24gYmVmb3JlIHdlIGNhbiByZWxpYWJseSBlbnF1ZXVlIHRoZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgIC8vIChvciB0aGVyZSBhcmUgdG9vIG1hbnkgb2JqZWN0cyBzbyB3ZSBsYXp5IG91dCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrIGZvciBsYXJnZSBidWxrIGluc2VydHMpXG4gICAgICAgICAgICAgIHByb21pc2UudGhlbigocmVzKSA9PiB7IC8vIFdlIG5lZWQgdG8gZXh0cmFjdCByZXN1bHQga2V5cyBhbmQgZ2VuZXJhdGUgY2xvbmVkIHZhbHVlcyB3aXRoIHRoZSBrZXlzIHNldCAoc28gdGhhdCBhcHBseU9wdGltaXN0aWNPcHMgY2FuIHdvcmspXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGhhdmUgYSBwcm9ibGVtISBUaGUgcmVxLm11dGF0ZWRQYXJ0cyBpcyBzdGlsbCBub3QgY29tcGxldGUgc28gd2UgaGF2ZSB0byBhY3RpdmVseSBhZGQgdGhlIGtleXMgdG8gdGhlIHVuc2lnbmFsZWRQYXJ0cyBzZXQgbWFudWFsbHkuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxV2l0aFJlc29sdmVkS2V5cyA9IHtcbiAgICAgICAgICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVxLnZhbHVlcy5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlV2l0aEtleSA9IHByaW1LZXkua2V5UGF0aD8uaW5jbHVkZXMoJy4nKVxuICAgICAgICAgICAgICAgICAgICAgID8gZGVlcENsb25lKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHZhbHVlV2l0aEtleSwgcHJpbUtleS5rZXlQYXRoLCByZXMucmVzdWx0cyFbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVXaXRoS2V5O1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkUmVxID0gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxV2l0aFJlc29sdmVkS2V5cywgcmVzKTtcbiAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLnB1c2goYWRqdXN0ZWRSZXEpO1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hbCBzdWJzY3JpYmVycyBhZnRlciB0aGUgb2JzZXJ2YWJpbGl0eSBtaWRkbGV3YXJlIGhhcyBjb21wbGVtZW50ZWQgcmVxLm11dGF0ZWRQYXJ0cyB3aXRoIHRoZSBuZXcga2V5cy5cbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IHF1ZXVlIHRoZSB0YXNrIHNvIHRoYXQgd2UgZ2V0IHRoZSByZXEubXV0YXRlZFBhcnRzIHVwZGF0ZWQgYnkgb2JzZXJ2YWJpbGl0eSBtaWRkbGV3YXJlIGZpcnN0LlxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlZmFjdG9yIHRoZSBkZXBlbmRlbmN5IGJldHdlZW4gb2JzZXJ2YWJpbGl0eSBtaWRkbGV3YXJlIGFuZCB0aGlzIG1pZGRsZXdhcmUgd2UgbWlnaHQgbm90IG5lZWQgdG8gcXVldWUgdGhlIHRhc2suXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCk9PnJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cykpOyAvLyBSZWFzb24gZm9yIGRvdWJsZSBsYXppbmVzczogaW4gdXNlciBhd2FpdHMgcHV0IGFuZCB0aGVuIGRvZXMgYW5vdGhlciBwdXQsIHNpZ25hbCBvbmNlLlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEVucXVlIHRoZSBvcGVyYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgIC8vIFNpZ25hbCBzdWJzY3JpYmVycyB0aGF0IHRoZXJlIGFyZSBtdXRhdGVkIHBhcnRzXG4gICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG9wZXJhdGlvbiBmYWlsZWQsIHdlIG5lZWQgdG8gcmVtb3ZlIGl0IGZyb20gdGhlIG9wdGltaXN0aWNPcHMgYXJyYXkuXG4gICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkUmVxID0gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdGVkUmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChhZGp1c3RlZFJlcSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpOyAvLyBTaWduYWwgdGhlIHJvbGxpbmcgYmFjayBvZiB0aGUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goKCk9PiB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgb3BlcmF0aW9uIGZhaWxlZCwgd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgb3B0aW1pc3RpY09wcyBhcnJheS5cbiAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcbiAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpOyAvLyBTaWduYWwgdGhlIHJvbGxpbmcgYmFjayBvZiB0aGUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcXVlcnkocmVxOiBEQkNvcmVRdWVyeVJlcXVlc3QpOiBQcm9taXNlPERCQ29yZVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICAgICAgICAgIGlmICghaXNDYWNoYWJsZUNvbnRleHQoUFNELCBkb3duVGFibGUpIHx8ICFpc0NhY2hhYmxlUmVxdWVzdChcInF1ZXJ5XCIsIHJlcSkpIHJldHVybiBkb3duVGFibGUucXVlcnkocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGZyZWV6ZVJlc3VsdHMgPVxuICAgICAgICAgICAgICAoUFNEIGFzIExpdmVRdWVyeUNvbnRleHQpLnRyYW5zPy5kYi5fb3B0aW9ucy5jYWNoZSA9PT0gJ2ltbXV0YWJsZSc7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlcnksIHNpZ25hbCB9ID0gUFNEIGFzIExpdmVRdWVyeUNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgW2NhY2hlRW50cnksIGV4YWN0TWF0Y2gsIHRibENhY2hlLCBjb250YWluZXJdID1cbiAgICAgICAgICAgICAgZmluZENvbXBhdGlibGVRdWVyeShkYk5hbWUsIHRhYmxlTmFtZSwgJ3F1ZXJ5JywgcmVxKTtcbiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5ICYmIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgY2FjaGVFbnRyeS5vYnNTZXQgPSByZXEub2JzU2V0ITsgLy8gU28gdGhhdCBvcHRpbWlzdGljIHJlc3VsdCBpcyBtb25pdG9yZWQuXG4gICAgICAgICAgICAgIC8vIEhvdz8gLSBiZWNhdXNlIG9ic2VydmFiaWxpdHktbWlkZGxld2FyZSB3aWxsIHRyYWNrIHJlc3VsdCB3aGVyZSBvcHRpbWlzdGljXG4gICAgICAgICAgICAgIC8vIG11dGF0aW9ucyBhcmUgYXBwbGllZCBhbmQgcmVjb3JkIGl0IGluIHRoZSBjYWNoZUVudHJ5LlxuICAgICAgICAgICAgICAvLyBUT0RPOiBDSEFOR0UgVEhJUyEgVGhlIGRpZmZlcmVuY2UgaXMgcmVzdWx0S2V5cyBvbmx5LlxuICAgICAgICAgICAgICAvLyBXYW50ZWQgYmVoYXZpb3I6XG4gICAgICAgICAgICAgIC8vICAqIGNhY2hlRW50cnkgb2JzU2V0IHNob3VsZCByZXByZXNlbnQgdGhlIG9ic1NldCB3aXRob3V0IG9wdGltaXN0aWMgdXBkYXRlcyAoc28gaXQgY2FuIGJlIGNoZWNrZWQgd2hlbiBtZXJnaW5nIG9wcyBpbiB0eCBjb21taXQpXG4gICAgICAgICAgICAgIC8vICAqIGNhY2hlRW50cnkgb3B0aW1pc3RpY09ic1NldCBzaG91bGQgcmVwcmVzZW50IHRoZSBvYnNTZXQgd2l0aCBjdXJyZW50IG9wdGltaXN0aWMgdXBkYXRlcy4gSXQgc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBhZGRpbmcgYW4gb3BcbiAgICAgICAgICAgICAgLy8gICAgYnkgYWRkaW5nIHRoZSBwcmltYXJ5IGtleXMgb2YgdGhlIHB1dC9hZGQvZGVsZXRlIG9wZXJhdGlvbiB0byB0aGUgc2V0LlxuICAgICAgICAgICAgICAvLyAgKiBvYnNlcnZhYmlsaXR5LW1pZGRsZXdhcmUgc2hvdWxkIHN0b3AgcmVjb3JkaW5nIHJlcS5vYnNTZXQgd2hlbiBhIGNhY2hlIGVudHJ5IGV4YWN0IG1hdGNoIGlzIGZvdW5kIGJlY2F1c2UgaXQgd29uJ3QgYmUgdXNlZCBhbnl3YXkuXG4gICAgICAgICAgICAgIC8vIEknbSB0aGlua2luZyBvZiBtZXJnaW5nIG9ic2VydmFiaWxpdHktbWlkZGxld2FyZSB3aXRoIGNhY2hlLW1pZGRsZXdhcmUgaW50byBvbmUgc2luZ2xlIG1pZGRsZXdhcmUgYmVjYXVzZSB0aGUgZGVwZW5kZW5jaWVzIGFyZSB0b29cbiAgICAgICAgICAgICAgLy8gdGlnaHQgYmV0d2VlbiB0aGVtLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gLS0+IFRPRE8gaGVyZTogSWYgbm90IGV4YWN0IG1hdGNoLCBjaGVjayBpZiB3ZSBoYXZlIGEgc3VwZXJzZXQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgICAvLyB0aGUgZGF0YSBmcm9tLlxuXG4gICAgICAgICAgICAgIC8vIE5vIGNhY2hlZCByZXN1bHQgZm91bmQuIFdlIG5lZWQgdG8gcXVlcnkgdGhlIGRhdGFiYXNlIGFuZCBjYWNoZSB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZG93blRhYmxlLnF1ZXJ5KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRnJlZXplIG9yIGNsb25lIHJlc3VsdHNcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSBjYWNoZUVudHJ5LnJlcyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZnJlZXplUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgZG9uJ3QgZGVlcCBmcmVlemUuXG4gICAgICAgICAgICAgICAgICAvLyBPbmx5IGZyZWV6ZSB0aGUgdG9wLWxldmVsIGFycmF5IGFuZCBpdHMgaXRlbXMuXG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGdvb2QgZW5vdWdoIHRvIHRlYWNoIHVzZXJzIHRoYXQgdGhlIHJlc3VsdCBtdXN0IGJlIHRyZWF0ZWQgYXMgaW1tdXRhYmxlXG4gICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IGVuZm9yY2luZyBpdCByZWN1cnNpdmVseSBvbiB0aGUgZW50aXJlIHJlc3VsdCAod2hpY2ggaXMgbm90IGV2ZW4gcG9zc2libGVcbiAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGluZ3MgbGlrZSBEYXRlIG9iamVjdHMgYW5kIHR5cGVkIGFycmF5cylcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBmcm96ZW4sIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHJlc3VsdCB0byBhdm9pZCB1c2VyIG11dGF0aW5nIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBkbyB0aGlzLCB1c2VyJ3MgbXVzdCBmZWVsIGNvbmZvcm1hYmxlIHdpdGggdGhlIGZhY3QgdGhhdCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAvLyBjYW4gYmUgbXV0YXRlZCBkZWVwbHkgLSB1c2VyIGlzIG5vdCBleHBlY3RlZCB0byBoYXZlIGFueSByZXNwZWN0IGZvciBpbW11dGFiaWxpdHkuXG4gICAgICAgICAgICAgICAgICByZXMucmVzdWx0ID0gZGVlcENsb25lKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBxdWVyeSBvcGVyYXRpb24gZmFpbGVkLCB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgc3Vic2VxdWVudCBjYWxscyBkb2VzIG5vdCBnZXQgdGhlIHNhbWUgZXJyb3IgYnV0IHJlLWV2YWx1YXRlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgJiYgY2FjaGVFbnRyeSkgZGVsQXJyYXlJdGVtKGNvbnRhaW5lciwgY2FjaGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgb2JzU2V0OiByZXEub2JzU2V0ISxcbiAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdHlwZTogJ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgZGlydHk6IGZhbHNlLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnB1c2goY2FjaGVFbnRyeSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gW2NhY2hlRW50cnldO1xuICAgICAgICAgICAgICAgIGlmICghdGJsQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgIHRibENhY2hlID0gY2FjaGVbYGlkYjovLyR7ZGJOYW1lfS8ke3RhYmxlTmFtZX1gXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllczoge1xuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudDoge30sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9ianM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY09wczogW10sXG4gICAgICAgICAgICAgICAgICAgIHVuc2lnbmFsZWRQYXJ0czoge31cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRibENhY2hlLnF1ZXJpZXMucXVlcnlbcmVxLnF1ZXJ5LmluZGV4Lm5hbWUgfHwgJyddID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyISwgcmVxdWVyeSwgc2lnbmFsKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2UudGhlbigocmVzOiBEQkNvcmVRdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBhcHBseU9wdGltaXN0aWNPcHMoXG4gICAgICAgICAgICAgICAgICByZXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgdGJsQ2FjaGU/Lm9wdGltaXN0aWNPcHMsXG4gICAgICAgICAgICAgICAgICBkb3duVGFibGUsXG4gICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5ISxcbiAgICAgICAgICAgICAgICAgIGZyZWV6ZVJlc3VsdHNcbiAgICAgICAgICAgICAgICApIGFzIGFueVtdLCAvLyByZWFkb25seSBhbnlbXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRhYmxlTVc7XG4gICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGNvcmVNVztcbiAgfSxcbn07XG5cblxuIiwgImltcG9ydCB7IHR5cGUgRGV4aWUgfSBmcm9tIFwiLi4vY2xhc3Nlcy9kZXhpZVwiO1xuaW1wb3J0IHsgdHlwZSBUYWJsZSB9IGZyb20gXCIuLi9jbGFzc2VzL3RhYmxlXCI7XG5pbXBvcnQgeyB0eXBlIFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL2NsYXNzZXMvdHJhbnNhY3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHZpcGlmeTxUIGV4dGVuZHMgVGFibGUgfCBUcmFuc2FjdGlvbj4oXG4gIHRhcmdldDogVCxcbiAgdmlwRGI6IERleGllXG4pOiBUIHtcbiAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIC8vIFRoZSBcImRiXCIgcHJvcCBvZiB0aGUgdGFibGUgb3IgdHJhbnNhY3Rpb24gaXMgdGhlIG9ubHkgb25lIHdlIG5lZWQgdG9cbiAgICAgIC8vIG92ZXJyaWRlLiBUaGUgcmVzdCBvZiB0aGUgcHJvcHMgY2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIG9yaWdpbmFsXG4gICAgICAvLyBvYmplY3QuXG4gICAgICBpZiAocHJvcCA9PT0gJ2RiJykgcmV0dXJuIHZpcERiO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSk7XG59XG4iLCAiLy8gSW1wb3J0IHR5cGVzIGZyb20gdGhlIHB1YmxpYyBBUElcbmltcG9ydCB7IERleGllIGFzIElEZXhpZSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWVcIjtcbmltcG9ydCB7IERleGllT3B0aW9ucywgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtY29uc3RydWN0b3JcIjtcbmltcG9ydCB7IERiRXZlbnRzIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHNcIjtcbi8vaW1wb3J0IHsgUHJvbWlzZUV4dGVuZGVkLCBQcm9taXNlRXh0ZW5kZWRDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9wcm9taXNlLWV4dGVuZGVkJztcbmltcG9ydCB7IFRhYmxlIGFzIElUYWJsZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZSc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hXCI7XG5pbXBvcnQgeyBEYlNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYi1zY2hlbWEnO1xuXG4vLyBJbnRlcm5hbCBpbXBvcnRzXG5pbXBvcnQgeyBUYWJsZSwgVGFibGVDb25zdHJ1Y3RvciwgY3JlYXRlVGFibGVDb25zdHJ1Y3RvciB9IGZyb20gXCIuLi90YWJsZVwiO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiwgQ29sbGVjdGlvbkNvbnN0cnVjdG9yLCBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IgfSBmcm9tICcuLi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IFdoZXJlQ2xhdXNlIH0gZnJvbSAnLi4vd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBXaGVyZUNsYXVzZUNvbnN0cnVjdG9yLCBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQ29uc3RydWN0b3IsIGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IgfSBmcm9tICcuLi90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBWZXJzaW9uIH0gZnJvbSBcIi4uL3ZlcnNpb24vdmVyc2lvblwiO1xuaW1wb3J0IHsgVmVyc2lvbkNvbnN0cnVjdG9yLCBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IgfSBmcm9tICcuLi92ZXJzaW9uL3ZlcnNpb24tY29uc3RydWN0b3InO1xuXG4vLyBPdGhlciBpbXBvcnRzLi4uXG5pbXBvcnQgeyBEZXhpZUV2ZW50U2V0IH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RleGllLWV2ZW50LXNldCc7XG5pbXBvcnQgeyBEZXhpZUV4Y2VwdGlvbkNsYXNzZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZXJyb3JzJztcbmltcG9ydCB7IERleGllRE9NRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RleGllLWRvbS1kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgbm9wLCBwcm9taXNhYmxlQ2hhaW4gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCBQcm9taXNlLCB7IFBTRCwgZ2xvYmFsUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGV4dGVuZCwgb3ZlcnJpZGUsIGtleXMsIGhhc093biB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2hlbHBlcnMvRXZlbnRzJztcbmltcG9ydCB7IG1heFN0cmluZywgY29ubmVjdGlvbnMsIFJFQURPTkxZLCBSRUFEV1JJVEUgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRNYXhLZXkgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG93ZXJWZXJzaW9uRmlyc3QgfSBmcm9tICcuLi92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IGRleGllT3BlbiB9IGZyb20gJy4vZGV4aWUtb3Blbic7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IF9vbkRhdGFiYXNlRGVsZXRlZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvcic7XG5pbXBvcnQgeyBldmVudFJlamVjdEhhbmRsZXIgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IHsgZXh0cmFjdFRyYW5zYWN0aW9uQXJncywgZW50ZXJUcmFuc2FjdGlvblNjb3BlIH0gZnJvbSAnLi90cmFuc2FjdGlvbi1oZWxwZXJzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uTW9kZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbi1tb2RlJztcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyB1c2VQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBNaWRkbGV3YXJlLCBEZXhpZVN0YWNrcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgfSBmcm9tICcuLi8uLi9kYmNvcmUvdmlydHVhbC1pbmRleC1taWRkbGV3YXJlJztcbmltcG9ydCB7IGhvb2tzTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYyc7XG5pbXBvcnQgeyBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvb2JzZXJ2YWJpbGl0eS1taWRkbGV3YXJlJztcbmltcG9ydCB7IGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2NhY2hlLWV4aXN0aW5nLXZhbHVlcy1taWRkbGV3YXJlJztcbmltcG9ydCB7IGNhY2hlTWlkZGxld2FyZSB9IGZyb20gXCIuLi8uLi9saXZlLXF1ZXJ5L2NhY2hlL2NhY2hlLW1pZGRsZXdhcmVcIjtcbmltcG9ydCB7IHZpcGlmeSB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3ZpcGlmeVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIERiUmVhZHlTdGF0ZSB7XG4gIGRiT3BlbkVycm9yOiBhbnk7XG4gIGlzQmVpbmdPcGVuZWQ6IGJvb2xlYW47XG4gIG9uUmVhZHlCZWluZ0ZpcmVkOiB1bmRlZmluZWQgfCBGdW5jdGlvbltdO1xuICBvcGVuQ29tcGxldGU6IGJvb2xlYW47XG4gIGRiUmVhZHlSZXNvbHZlOiAoKSA9PiB2b2lkO1xuICBkYlJlYWR5UHJvbWlzZTogUHJvbWlzZTxhbnk+O1xuICBjYW5jZWxPcGVuOiAocmVhc29uPzogRXJyb3IpID0+IHZvaWQ7XG4gIG9wZW5DYW5jZWxsZXI6IFByb21pc2U8YW55PiAmIHsgX3N0YWNrSG9sZGVyPzogRXJyb3IgfTtcbiAgYXV0b1NjaGVtYTogYm9vbGVhbjtcbiAgdmNGaXJlZD86IGJvb2xlYW47XG4gIFBSMTM5OF9tYXhMb29wPzogbnVtYmVyO1xuICBhdXRvT3Blbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBEZXhpZSBpbXBsZW1lbnRzIElEZXhpZSB7XG4gIF9vcHRpb25zOiBEZXhpZU9wdGlvbnM7XG4gIF9zdGF0ZTogRGJSZWFkeVN0YXRlO1xuICBfdmVyc2lvbnM6IFZlcnNpb25bXTtcbiAgX3N0b3JlTmFtZXM6IHN0cmluZ1tdO1xuICBfZGVwczogRGV4aWVET01EZXBlbmRlbmNpZXM7XG4gIF9hbGxUYWJsZXM6IHsgW25hbWU6IHN0cmluZ106IFRhYmxlOyB9O1xuICBfY3JlYXRlVHJhbnNhY3Rpb246ICh0aGlzOiBEZXhpZSwgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLCBzdG9yZU5hbWVzOiBBcnJheUxpa2U8c3RyaW5nPiwgZGJzY2hlbWE6IHsgW3RhYmxlTmFtZTogc3RyaW5nXTogVGFibGVTY2hlbWE7IH0sIHBhcmVudFRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IFRyYW5zYWN0aW9uO1xuICBfZGJTY2hlbWE6IHsgW3RhYmxlTmFtZTogc3RyaW5nXTogVGFibGVTY2hlbWE7IH07XG4gIF9oYXNHZXRBbGw/OiBib29sZWFuO1xuICBfbWF4S2V5OiBJbmRleGFibGVUeXBlO1xuICBfZmlyZU9uQmxvY2tlZDogKGV2OiBFdmVudCkgPT4gdm9pZDtcbiAgX21pZGRsZXdhcmVzOiB7W1N0YWNrTmFtZSBpbiBrZXlvZiBEZXhpZVN0YWNrc10/OiBNaWRkbGV3YXJlPERleGllU3RhY2tzW1N0YWNrTmFtZV0+W119ID0ge307XG4gIF92aXA/OiBib29sZWFuO1xuICBfbm92aXA6IERleGllOy8vIGRiLl9ub3ZpcCBpcyB0byBlc2NhcGUgdG8gb3JpZyBkYiBmcm9tIGRiLnZpcC5cbiAgY29yZTogREJDb3JlO1xuXG4gIG5hbWU6IHN0cmluZztcbiAgdmVybm86IG51bWJlciA9IDA7XG4gIGlkYmRiOiBJREJEYXRhYmFzZSB8IG51bGw7XG4gIHZpcDogRGV4aWU7XG4gIG9uOiBEYkV2ZW50cztcblxuICBUYWJsZTogVGFibGVDb25zdHJ1Y3RvcjtcbiAgV2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlQ29uc3RydWN0b3I7XG4gIENvbGxlY3Rpb246IENvbGxlY3Rpb25Db25zdHJ1Y3RvcjtcbiAgVmVyc2lvbjogVmVyc2lvbkNvbnN0cnVjdG9yO1xuICBUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjtcbiAgc3RhdGljIGRpc2FibGVCZkNhY2hlPzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBEZXhpZU9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXBzID0gKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS5kZXBlbmRlbmNpZXM7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSB7XG4gICAgICAvLyBEZWZhdWx0IE9wdGlvbnNcbiAgICAgIGFkZG9uczogKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS5hZGRvbnMsIC8vIFBpY2sgc3RhdGljYWxseSByZWdpc3RlcmVkIGFkZG9ucyBieSBkZWZhdWx0XG4gICAgICBhdXRvT3BlbjogdHJ1ZSwgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlcXVpcmUgZGIub3BlbigpIGV4cGxpY2l0ZWx5LlxuICAgICAgLy8gRGVmYXVsdCBET00gZGVwZW5kZW5jeSBpbXBsZW1lbnRhdGlvbnMgZnJvbSBzdGF0aWMgcHJvcC5cbiAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsICAgICAgLy8gQmFja2VuZCBJbmRleGVkREIgYXBpLiBEZWZhdWx0IHRvIGJyb3dzZXIgZW52LlxuICAgICAgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsICAvLyBCYWNrZW5kIElEQktleVJhbmdlIGFwaS4gRGVmYXVsdCB0byBicm93c2VyIGVudi5cbiAgICAgIGNhY2hlOiAnY2xvbmVkJywgLy8gRGVmYXVsdCB0byBjbG9uZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIEZvciBiZXN0IHBlcmZvcm1hbmNlIGFuZCBsZWFzdCBtZW1vcnkgY29uc3VtcHRpb24gdXNlICdpbW11dGFibGUnLlxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07ICBcbiAgICB0aGlzLl9kZXBzID0ge1xuICAgICAgaW5kZXhlZERCOiBvcHRpb25zLmluZGV4ZWREQiBhcyBJREJGYWN0b3J5LFxuICAgICAgSURCS2V5UmFuZ2U6IG9wdGlvbnMuSURCS2V5UmFuZ2UgYXMgdHlwZW9mIElEQktleVJhbmdlXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBhZGRvbnMsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5fZGJTY2hlbWEgPSB7fTtcbiAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuICAgIHRoaXMuX3N0b3JlTmFtZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxUYWJsZXMgPSB7fTtcbiAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICB0aGlzLl9ub3ZpcCA9IHRoaXM7XG4gICAgY29uc3Qgc3RhdGU6IERiUmVhZHlTdGF0ZSA9IHtcbiAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuICAgICAgaXNCZWluZ09wZW5lZDogZmFsc2UsXG4gICAgICBvblJlYWR5QmVpbmdGaXJlZDogbnVsbCxcbiAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG4gICAgICBkYlJlYWR5UmVzb2x2ZTogbm9wLFxuICAgICAgZGJSZWFkeVByb21pc2U6IG51bGwgYXMgUHJvbWlzZSxcbiAgICAgIGNhbmNlbE9wZW46IG5vcCxcbiAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwgYXMgUHJvbWlzZSxcbiAgICAgIGF1dG9TY2hlbWE6IHRydWUsXG4gICAgICBQUjEzOThfbWF4TG9vcDogMyxcbiAgICAgIGF1dG9PcGVuOiBvcHRpb25zLmF1dG9PcGVuLFxuICAgIH07XG4gICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICB9KTtcbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcInBvcHVsYXRlXCIsIFwiYmxvY2tlZFwiLCBcInZlcnNpb25jaGFuZ2VcIiwgXCJjbG9zZVwiLCB7IHJlYWR5OiBbcHJvbWlzYWJsZUNoYWluLCBub3BdIH0pIGFzIERiRXZlbnRzO1xuICAgIHRoaXMub24ucmVhZHkuc3Vic2NyaWJlID0gb3ZlcnJpZGUodGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUsIHN1YnNjcmliZSA9PiB7XG4gICAgICByZXR1cm4gKHN1YnNjcmliZXIsIGJTdGlja3kpID0+IHtcbiAgICAgICAgKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS52aXAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gRGF0YWJhc2UgYWxyZWFkeSBvcGVuLiBDYWxsIHN1YnNjcmliZXIgYXNhcC5cbiAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAvLyBiU3RpY2t5OiBBbHNvIHN1YnNjcmliZSB0byBmdXR1cmUgb3BlbiBzdWNlc3NlcyAoYWZ0ZXIgY2xvc2UgLyByZW9wZW4pIFxuICAgICAgICAgICAgaWYgKGJTdGlja3kpIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkKSB7XG4gICAgICAgICAgICAvLyBkYi5vbigncmVhZHknKSBzdWJzY3JpYmVycyBhcmUgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIGFuZCBoYXZlIG5vdCB5ZXQgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBpZiAoYlN0aWNreSkgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEYXRhYmFzZSBub3QgeWV0IG9wZW4uIFN1YnNjcmliZSB0byBpdC5cbiAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIC8vIElmIGJTdGlja3kgaXMgZmFsc3ksIG1ha2Ugc3VyZSB0byB1bnN1YnNjcmliZSBzdWJzY3JpYmVyIHdoZW4gZmlyZWQgb25jZS5cbiAgICAgICAgICAgIGNvbnN0IGRiID0gdGhpcztcbiAgICAgICAgICAgIGlmICghYlN0aWNreSkgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgZGIub24ucmVhZHkudW5zdWJzY3JpYmUodW5zdWJzY3JpYmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBkZXJpdmVkIGNsYXNzZXMgYm91bmQgdG8gdGhpcyBpbnN0YW5jZSBvZiBEZXhpZTpcbiAgICB0aGlzLkNvbGxlY3Rpb24gPSBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5UYWJsZSA9IGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5WZXJzaW9uID0gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIHRoaXMuV2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKHRoaXMpO1xuXG4gICAgLy8gRGVmYXVsdCBzdWJzY3JpYmVycyB0byBcInZlcnNpb25jaGFuZ2VcIiBhbmQgXCJibG9ja2VkXCIuXG4gICAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgY3VzdG9tIGhhbmRsZXJzLiBJZiBjdXN0b20gaGFuZGxlcnMgcmV0dXJuIGZhbHNlLCB0aGVzZSBkZWZhdWx0XG4gICAgLy8gYmVoYXZpb3VycyB3aWxsIGJlIHByZXZlbnRlZC5cbiAgICB0aGlzLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBldiA9PiB7XG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGZvciB2ZXJzaW9uY2hhbmdlIGV2ZW50IGlzIHRvIGNsb3NlIGRhdGFiYXNlIGNvbm5lY3Rpb24uXG4gICAgICAvLyBDYWxsZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgZG9pbmcgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgICAvLyBMZXQncyBub3QgYmxvY2sgdGhlIG90aGVyIHdpbmRvdyBmcm9tIG1ha2luZyBpdCdzIGRlbGV0ZSgpIG9yIG9wZW4oKSBjYWxsLlxuICAgICAgLy8gTk9URSEgVGhpcyBldmVudCBpcyBuZXZlciBmaXJlZCBpbiBJRSxFZGdlIG9yIFNhZmFyaS5cbiAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcbiAgICAgICAgY29uc29sZS53YXJuKGBBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gdXBncmFkZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLmApO1xuICAgICAgZWxzZVxuICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byBkZWxldGUgZGF0YWJhc2UgJyR7dGhpcy5uYW1lfScuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuYCk7XG4gICAgICB0aGlzLmNsb3NlKHtkaXNhYmxlQXV0b09wZW46IGZhbHNlfSk7XG4gICAgICAvLyBJbiBtYW55IHdlYiBhcHBsaWNhdGlvbnMsIGl0IHdvdWxkIGJlIHJlY29tbWVuZGVkIHRvIGZvcmNlIHdpbmRvdy5yZWxvYWQoKVxuICAgICAgLy8gd2hlbiB0aGlzIGV2ZW50IG9jY3Vycy4gVG8gZG8gdGhhdCwgc3Vic2NyaWJlIHRvIHRoZSB2ZXJzaW9uY2hhbmdlIGV2ZW50XG4gICAgICAvLyBhbmQgY2FsbCB3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpIGlmIGV2Lm5ld1ZlcnNpb24gPiAwIChub3QgYSBkZWxldGlvbilcbiAgICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB5b3VyIGN1cnJlbnQgd2ViIGFwcCBvYnZpb3VzbHkgaGFzIG9sZCBzY2hlbWEgY29kZSB0aGF0IG5lZWRzXG4gICAgICAvLyB0byBiZSB1cGRhdGVkLiBBbm90aGVyIHdpbmRvdyBnb3QgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBhcHAgYW5kIG5lZWRzIHRvIHVwZ3JhZGUgREIgYnV0XG4gICAgICAvLyB5b3VyIHdpbmRvdyBpcyBibG9ja2luZyBpdCB1bmxlc3Mgd2UgY2xvc2UgaXQgaGVyZS5cbiAgICB9KTtcbiAgICB0aGlzLm9uKFwiYmxvY2tlZFwiLCBldiA9PiB7XG4gICAgICBpZiAoIWV2Lm5ld1ZlcnNpb24gfHwgZXYubmV3VmVyc2lvbiA8IGV2Lm9sZFZlcnNpb24pXG4gICAgICAgIGNvbnNvbGUud2FybihgRGV4aWUuZGVsZXRlKCcke3RoaXMubmFtZX0nKSB3YXMgYmxvY2tlZGApO1xuICAgICAgZWxzZVxuICAgICAgICBjb25zb2xlLndhcm4oYFVwZ3JhZGUgJyR7dGhpcy5uYW1lfScgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiAke2V2Lm9sZFZlcnNpb24gLyAxMH1gKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX21heEtleSA9IGdldE1heEtleShvcHRpb25zLklEQktleVJhbmdlIGFzIHR5cGVvZiBJREJLZXlSYW5nZSk7XG5cbiAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IChcbiAgICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICAgIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgZGJzY2hlbWE6IERiU2NoZW1hLFxuICAgICAgcGFyZW50VHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbikgPT4gbmV3IHRoaXMuVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHRoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7XG5cbiAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZXYgPT4ge1xuICAgICAgdGhpcy5vbihcImJsb2NrZWRcIikuZmlyZShldik7XG4gICAgICAvLyBXb3JrYXJvdW5kIChub3QgZnVsbHkqKSBmb3IgbWlzc2luZyBcInZlcnNpb25jaGFuZ2VcIiBldmVudCBpbiBJRSxFZGdlIGFuZCBTYWZhcmk6XG4gICAgICBjb25uZWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGMgPT4gYy5uYW1lID09PSB0aGlzLm5hbWUgJiYgYyAhPT0gdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZClcbiAgICAgICAgLm1hcChjID0+IGMub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IG1pZGRsZXdhcmVzOlxuICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcbiAgICB0aGlzLnVzZShjYWNoZU1pZGRsZXdhcmUpO1xuICAgIHRoaXMudXNlKG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlKTtcbiAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcbiAgICB0aGlzLnVzZShob29rc01pZGRsZXdhcmUpO1xuXG4gICAgY29uc3QgdmlwREIgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgZ2V0OiAoXywgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdfdmlwJykgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChwcm9wID09PSAndGFibGUnKSByZXR1cm4gKHRhYmxlTmFtZTogc3RyaW5nKSA9PiB2aXBpZnkodGhpcy50YWJsZSh0YWJsZU5hbWUpLCB2aXBEQik7XG4gICAgICAgIGNvbnN0IHJ2ID0gUmVmbGVjdC5nZXQoXywgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICBpZiAocnYgaW5zdGFuY2VvZiBUYWJsZSkgcmV0dXJuIHZpcGlmeShydiwgdmlwREIpO1xuICAgICAgICBpZiAocHJvcCA9PT0gJ3RhYmxlcycpIHJldHVybiAocnYgYXMgVGFibGVbXSkubWFwKHQgPT4gdmlwaWZ5KHQsIHZpcERCKSk7XG4gICAgICAgIGlmIChwcm9wID09PSAnX2NyZWF0ZVRyYW5zYWN0aW9uJykgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IHR4OiBUcmFuc2FjdGlvbiA9IChydiBhcyB0eXBlb2YgdGhpcy5fY3JlYXRlVHJhbnNhY3Rpb24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHZpcGlmeSh0eCwgdmlwREIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnZpcCA9IHZpcERCO1xuXG4gICAgLy8gQ2FsbCBlYWNoIGFkZG9uOlxuICAgIGFkZG9ucy5mb3JFYWNoKGFkZG9uID0+IGFkZG9uKHRoaXMpKTtcbiAgfVxuXG4gIHZlcnNpb24odmVyc2lvbk51bWJlcjogbnVtYmVyKTogVmVyc2lvbiB7XG4gICAgaWYgKGlzTmFOKHZlcnNpb25OdW1iZXIpIHx8IHZlcnNpb25OdW1iZXIgPCAwLjEpIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoYEdpdmVuIHZlcnNpb24gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyYCk7XG4gICAgdmVyc2lvbk51bWJlciA9IE1hdGgucm91bmQodmVyc2lvbk51bWJlciAqIDEwKSAvIDEwO1xuICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJDYW5ub3QgYWRkIHZlcnNpb24gd2hlbiBkYXRhYmFzZSBpcyBvcGVuXCIpO1xuICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICBjb25zdCB2ZXJzaW9ucyA9IHRoaXMuX3ZlcnNpb25zO1xuICAgIHZhciB2ZXJzaW9uSW5zdGFuY2UgPSB2ZXJzaW9ucy5maWx0ZXIoXG4gICAgICB2ID0+IHYuX2NmZy52ZXJzaW9uID09PSB2ZXJzaW9uTnVtYmVyKVswXTtcbiAgICBpZiAodmVyc2lvbkluc3RhbmNlKSByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgIHZlcnNpb25JbnN0YW5jZSA9IG5ldyB0aGlzLlZlcnNpb24odmVyc2lvbk51bWJlcik7XG4gICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uSW5zdGFuY2UpO1xuICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuICAgIHZlcnNpb25JbnN0YW5jZS5zdG9yZXMoe30pOyAvLyBEZXJpdmUgZWFybGllciBzY2hlbWFzIGJ5IGRlZmF1bHQuXG4gICAgLy8gRGlzYWJsZSBhdXRvc2NoZW1hIG1vZGUsIGFzIGF0IGxlYXN0IG9uZSB2ZXJzaW9uIGlzIHNwZWNpZmllZC5cbiAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcbiAgfVxuXG4gIF93aGVuUmVhZHk8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gKHRoaXMuaWRiZGIgJiYgKHRoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSB8fCBQU0QubGV0VGhyb3VnaCB8fCB0aGlzLl92aXApKSA/IGZuKCkgOiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgIC8vIGlkYmRiIGlzIGZhbHN5IGJ1dCBvcGVuQ29tcGxldGUgaXMgdHJ1ZS4gTXVzdCBoYXZlIGJlZW4gYW4gZXhjZXB0aW9uIGR1cmluIG9wZW4uXG4gICAgICAgIC8vIERvbid0IHdhaXQgZm9yIG9wZW5Db21wbGV0ZSBhcyBpdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3AuXG4gICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQodGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLmF1dG9PcGVuKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pLnRoZW4oZm4pO1xuICB9XG5cbiAgdXNlKHtzdGFjaywgY3JlYXRlLCBsZXZlbCwgbmFtZX06IE1pZGRsZXdhcmU8REJDb3JlPik6IHRoaXMge1xuICAgIGlmIChuYW1lKSB0aGlzLnVudXNlKHtzdGFjaywgbmFtZX0pOyAvLyBCZSBhYmxlIHRvIHJlcGxhY2UgZXhpc3RpbmcgbWlkZGxld2FyZS5cbiAgICBjb25zdCBtaWRkbGV3YXJlcyA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSB8fCAodGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gW10pO1xuICAgIG1pZGRsZXdhcmVzLnB1c2goe3N0YWNrLCBjcmVhdGUsIGxldmVsOiBsZXZlbCA9PSBudWxsID8gMTAgOiBsZXZlbCwgbmFtZX0pO1xuICAgIG1pZGRsZXdhcmVzLnNvcnQoKGEsIGIpID0+IGEubGV2ZWwgLSBiLmxldmVsKTtcbiAgICAvLyBUb2RvIHVwZGF0ZSBkYi5jb3JlIGFuZCBkYi50YWJsZXMuLi5jb3JlID8gT3Igc2hvdWxkIGJlIGV4cGVjdCB0aGlzIHRvIGhhdmUgZWZmZWN0XG4gICAgLy8gb25seSBhZnRlciBuZXh0IG9wZW4oKT9cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVudXNlKHtzdGFjaywgY3JlYXRlfTogTWlkZGxld2FyZTx7c3RhY2s6IGtleW9mIERleGllU3RhY2tzfT4pOiB0aGlzO1xuICB1bnVzZSh7c3RhY2ssIG5hbWV9OiB7c3RhY2s6IGtleW9mIERleGllU3RhY2tzLCBuYW1lOiBzdHJpbmd9KTogdGhpcztcbiAgdW51c2Uoe3N0YWNrLCBuYW1lLCBjcmVhdGV9OiB7c3RhY2s6IGtleW9mIERleGllU3RhY2tzLCBuYW1lPzogc3RyaW5nLCBjcmVhdGU/OiBGdW5jdGlvbn0pIHtcbiAgICBpZiAoc3RhY2sgJiYgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdKSB7XG4gICAgICB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10uZmlsdGVyKG13ID0+XG4gICAgICAgIGNyZWF0ZSA/IG13LmNyZWF0ZSAhPT0gY3JlYXRlIDogLy8gR2l2ZW4gbWlkZGxld2FyZSBoYXMgYSBjcmVhdGUgbWV0aG9kLiBNYXRjaCB0aGF0IGV4YWN0bHkuXG4gICAgICAgIG5hbWUgPyBtdy5uYW1lICE9PSBuYW1lIDogLy8gR2l2ZW4gbWlkZGxld2FyZSBzcGVjIFxuICAgICAgICBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICByZXR1cm4gdXNlUFNEKFxuICAgICAgZ2xvYmFsUFNELCAvLyBFbmZvcmNlIGdsb2JhbCBzY29wZSBoZXJlIHNpbmNlIGRiLm9wZW4oKSBjYW4gYmUgcGFydCBvZiBhIGxpdmUgcXVlcnkgb3IgdHJhbnNhY3Rpb24gc2NvcGVcbiAgICAgICgpID0+IGRleGllT3Blbih0aGlzKVxuICAgICk7XG4gIH1cblxuICBfY2xvc2UoKTogdm9pZCB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgIGlmIChpZHggPj0gMCkgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgaWYgKHRoaXMuaWRiZGIpIHtcbiAgICAgIHRyeSB7IHRoaXMuaWRiZGIuY2xvc2UoKTsgfSBjYXRjaCAoZSkgeyB9XG4gICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICB9ICAgIFxuICAgIC8vIFJlc2V0IGRiUmVhZHlQcm9taXNlIHByb21pc2U6XG4gICAgaWYgKCFzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAvLyBPbmx5IGlmIG5vdCBiZWluZyBvcGVuZWQsIHJlc2V0IHRoZXNlIHByb21pc2VzLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBrZWVwIHRoZW0gc28gZXhpc3RpbmcgcHJvbWlzZSBjb25zdW1lcnMgd2lsbCByZXNvbHZlIHdoZW4gZGJcbiAgICAgIC8vIGRiIGlzIHJlb3BlbmVkIGxhdGVyIG9uLCBpbiBjYXNlIGNsb3NpbmcgZm9yIHB1cnBvc2UgcmVvcGVuaW5nLCB1c2luZyB7ZGlzYWJsZUF1dG9PcGVuOiBmYWxzZX0uXG4gICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjbG9zZSh7ZGlzYWJsZUF1dG9PcGVufSA9IHtkaXNhYmxlQXV0b09wZW46IHRydWV9KTogdm9pZCB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBpZiAoZGlzYWJsZUF1dG9PcGVuKSB7XG4gICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAvLyBjYW5jZWwgYmVmb3JlIHRoZSBjYWxsIHRvIHRoaXMuX2Nsb3NlKCkgYmVjYXVzZSB0aGlzLl9jbG9zZSgpIHdpbGwgcmVjcmVhdGUgZGJSZWFkeVByb21pc2UgYW5kIG9wZW5DYW5jZWxsZXIuXG4gICAgICAgIHN0YXRlLmNhbmNlbE9wZW4obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgc3RhdGUuYXV0b09wZW4gPSBmYWxzZTtcbiAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICAgIHN0YXRlLmF1dG9PcGVuID0gdGhpcy5fb3B0aW9ucy5hdXRvT3BlbiB8fFxuICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkOyAvLyBJZiBhbiBvcGVuIGNhbGwgaXMgb25nb2luZywgdGhhdCBzYW1lIHByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gZGIgaXMgcmVvcGVuZC5cbiAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZShjbG9zZU9wdGlvbnMgPSB7ZGlzYWJsZUF1dG9PcGVuOiB0cnVlfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFByZXZlbnQgYWNjaWRlbnRpYWxseSBkb2luZyBkYi5kZWxldGUoMSkgd2hlbiBpbnRlbnRpb24gd2FzIHRvIGRvIGRiLlt0YWJsZV0uZGVsZXRlKDEpLlxuICAgIGNvbnN0IGhhc0ludmFsaWRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JzsgXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZG9EZWxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoY2xvc2VPcHRpb25zKTtcbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKHRoaXMubmFtZSk7XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQodGhpcy5fZGVwcywgdGhpcy5uYW1lKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25ibG9ja2VkID0gdGhpcy5fZmlyZU9uQmxvY2tlZDtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgYWNjaWRlbnRpYWxseSBkb2luZyBkYi5kZWxldGUoMSkgd2hlbiBpbnRlbnRpb24gd2FzIHRvIGRvIGRiLlt0YWJsZV0uZGVsZXRlKDEpLlxuICAgICAgaWYgKGhhc0ludmFsaWRBcmd1bWVudHMpIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgY2xvc2VPcHRpb25zIGFyZ3VtZW50IHRvIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihkb0RlbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb0RlbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYmFja2VuZERCKCkge1xuICAgIHJldHVybiB0aGlzLmlkYmRiO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICB9XG5cbiAgaGFzQmVlbkNsb3NlZCgpIHtcbiAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG4gIH1cblxuICBoYXNGYWlsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICB9XG5cbiAgZHluYW1pY2FsbHlPcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG4gIH1cblxuICBnZXQgdGFibGVzICgpIHtcbiAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChuYW1lID0+IHRoaXMuX2FsbFRhYmxlc1tuYW1lXSk7XG4gIH1cblxuICB0cmFuc2FjdGlvbigpOiBQcm9taXNlIHtcbiAgICBjb25zdCBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIF90cmFuc2FjdGlvbihtb2RlOiBUcmFuc2FjdGlvbk1vZGUsIHRhYmxlczogQXJyYXk8SVRhYmxlIHwgc3RyaW5nPiwgc2NvcGVGdW5jOiBGdW5jdGlvbikge1xuICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucyBhcyBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZDtcbiAgICAvLyBDaGVjayBpZiBwYXJlbnQgdHJhbnNhY3Rpb25zIGlzIGJvdW5kIHRvIHRoaXMgZGIgaW5zdGFuY2UsIGFuZCBpZiBjYWxsZXIgd2FudHMgdG8gcmV1c2UgaXRcbiAgICBpZiAoIXBhcmVudFRyYW5zYWN0aW9uIHx8IHBhcmVudFRyYW5zYWN0aW9uLmRiICE9PSB0aGlzIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSkgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgIGNvbnN0IG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpIGFzIFRyYW5zYWN0aW9uTW9kZTsgLy8gT2suIFdpbGwgY2hhbmdlIGFyZ3VtZW50c1swXSBhcyB3ZWxsIGJ1dCB3ZSB3b250IHRvdWNoIGFyZ3VtZW50cyBoZW5jZWZvcnRoLlxuICAgIGxldCBpZGJNb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgICAgIHN0b3JlTmFtZXM7XG5cbiAgICB0cnkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHZXQgc3RvcmVOYW1lcyBmcm9tIGFyZ3VtZW50cy4gRWl0aGVyIHRocm91Z2ggZ2l2ZW4gdGFibGUgaW5zdGFuY2VzLCBvciB0aHJvdWdoIGdpdmVuIHRhYmxlIG5hbWVzLlxuICAgICAgICAvL1xuICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcCh0YWJsZSA9PiB7XG4gICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gdGFibGUgaW5zdGFuY2VvZiB0aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc29sdmUgbW9kZS4gQWxsb3cgc2hvcnRjdXRzIFwiclwiIGFuZCBcInJ3XCIuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInJ3XCIgfHwgbW9kZSA9PSBSRUFEV1JJVEUpXG4gICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuXG4gICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gQmFzaWMgY2hlY2tzXG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bhd24gbmV3IHRyYW5zYWN0aW9uIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG5vdCBpbmNsdWRlZCBpbiBwYXJlbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSAmJiBwYXJlbnRUcmFuc2FjdGlvbiAmJiAhcGFyZW50VHJhbnNhY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgLy8gJz8nIG1vZGUgc2hvdWxkIG5vdCBrZWVwIHVzaW5nIGFuIGluYWN0aXZlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIChfLCByZWplY3QpID0+IHtyZWplY3QoZSk7fSkgOlxuICAgICAgICAgICAgcmVqZWN0aW9uIChlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyBhIHN1Yi10cmFuc2FjdGlvbiwgbG9jayB0aGUgcGFyZW50IGFuZCB0aGVuIGxhdW5jaCB0aGUgc3ViLXRyYW5zYWN0aW9uLlxuICAgIGNvbnN0IGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcbiAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgUFNELnRyYW5zID9cbiAgICAgICAgICAgIC8vIG5vIHBhcmVudCB0cmFuc2FjdGlvbiBkZXNwaXRlIFBTRC50cmFucyBleGlzdHMuIE1ha2Ugc3VyZSBhbHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSB6b25lIHdlIGNyZWF0ZSBpcyBub3QgYSBzdWItem9uZSBvZiBjdXJyZW50LCBiZWNhdXNlXG4gICAgICAgICAgICAvLyBQcm9taXNlLmZvbGxvdygpIHNob3VsZCBub3Qgd2FpdCBmb3IgaXQgaWYgc28uXG4gICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgKCk9PnRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSkgOlxuICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5IChlbnRlclRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZyk6IFRhYmxlO1xuICB0YWJsZTxULCBUS2V5IGV4dGVuZHMgSW5kZXhhYmxlVHlwZT1JbmRleGFibGVUeXBlPih0YWJsZU5hbWU6IHN0cmluZyk6IElUYWJsZTxULCBUS2V5PjtcbiAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpOiBUYWJsZSB7XG4gICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoYFRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGApOyB9XG4gICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgT2JzZXJ2YWJsZSBhcyBJT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2ZXIsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9vYnNlcnZhYmxlXCI7XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGU6IHR5cGVvZiBTeW1ib2wub2JzZXJ2YWJsZSA9XG4gIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG4gICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuICAgIDogXCJAQG9ic2VydmFibGVcIiBhcyBhbnk7XG5cbmV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlPFQ+IGltcGxlbWVudHMgSU9ic2VydmFibGU8VD4ge1xuICBwcml2YXRlIF9zdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IFN1YnNjcmlwdGlvbjtcbiAgaGFzVmFsdWU/OiAoKT0+Ym9vbGVhbjtcbiAgZ2V0VmFsdWU/OiAoKT0+VDtcblxuICBjb25zdHJ1Y3RvcihzdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IFN1YnNjcmlwdGlvbikge1xuICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgfVxuXG4gIHN1YnNjcmliZShcbiAgICBvbk5leHQ/OiAoKHZhbHVlOiBUKSA9PiB2b2lkKSB8wqBudWxsLFxuICAgIG9uRXJyb3I/OiAoKGVycm9yOiBhbnkpID0+IHZvaWQpIHwgbnVsbCxcbiAgICBvbkNvbXBsZXRlPzogKCgpID0+IHZvaWQpIHwgbnVsbFxuICApOiBTdWJzY3JpcHRpb247XG4gIHN1YnNjcmliZShvYnNlcnZlcj86IE9ic2VydmVyPFQ+IHwgbnVsbCk6IFN1YnNjcmlwdGlvbjtcbiAgc3Vic2NyaWJlKHg/OiBhbnksIGVycm9yPzogYW55LCBjb21wbGV0ZT86IGFueSk6IFN1YnNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShcbiAgICAgICF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yLCBjb21wbGV0ZSB9IDogeFxuICAgICk7XG4gIH1cblxuICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwnO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5cbmV4cG9ydCBsZXQgZG9tRGVwczogRGV4aWVET01EZXBlbmRlbmNpZXNcblxudHJ5IHtcbiAgZG9tRGVwcyA9IHtcbiAgICAvLyBSZXF1aXJlZDpcbiAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICB9O1xufSBjYXRjaCAoZSkge1xuICBkb21EZXBzID0geyBpbmRleGVkREI6IG51bGwsIElEQktleVJhbmdlOiBudWxsIH07XG59XG4iLCAiaW1wb3J0IHsgX2dsb2JhbCwgaXNBc3luY0Z1bmN0aW9uLCBrZXlzLCBvYmplY3RJc0VtcHR5IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7XG4gIGdsb2JhbEV2ZW50cyxcbiAgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsXG59IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQge1xuICBiZWdpbk1pY3JvVGlja1Njb3BlLFxuICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyxcbiAgZW5kTWljcm9UaWNrU2NvcGUsXG4gIGV4ZWNJbkdsb2JhbENvbnRleHQsXG4gIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzLFxuICBOYXRpdmVQcm9taXNlLFxuICBuZXdTY29wZSxcbiAgUFNELFxuICB1c2VQU0QsXG59IGZyb20gJy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50cyc7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlIGFzIElPYnNlcnZhYmxlLFxuICBTdWJzY3JpcHRpb24sXG59IGZyb20gJy4uL3B1YmxpYy90eXBlcy9vYnNlcnZhYmxlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9jbGFzc2VzL29ic2VydmFibGUvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBleHRlbmRPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSAnLi9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXQnO1xuaW1wb3J0IHsgcmFuZ2VzT3ZlcmxhcCB9IGZyb20gJy4uL2hlbHBlcnMvcmFuZ2VzZXQnO1xuaW1wb3J0IHsgZG9tRGVwcyB9IGZyb20gJy4uL2NsYXNzZXMvZGV4aWUvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgb2JzU2V0c092ZXJsYXAgfSBmcm9tICcuL29icy1zZXRzLW92ZXJsYXAnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpdmVRdWVyeUNvbnRleHQge1xuICBzdWJzY3I6IE9ic2VydmFiaWxpdHlTZXQ7XG4gIHNpZ25hbDogQWJvcnRTaWduYWw7XG4gIHJlcXVlcnk6ICgpID0+IHZvaWQ7XG4gIHRyYW5zOiBudWxsIHwgVHJhbnNhY3Rpb247XG4gIHF1ZXJpZXI6IEZ1bmN0aW9uOyAvLyBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIGFuZCBFcnJvciBtZXNzYWdlc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGl2ZVF1ZXJ5PFQ+KHF1ZXJpZXI6ICgpID0+IFQgfCBQcm9taXNlPFQ+KTogSU9ic2VydmFibGU8VD4ge1xuICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgbGV0IGN1cnJlbnRWYWx1ZTogVDtcbiAgY29uc3Qgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPFQ+KChvYnNlcnZlcikgPT4ge1xuICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG4gICAgZnVuY3Rpb24gZXhlY3V0ZShjdHg6IExpdmVRdWVyeUNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpOyAvLyBQZXJmb3JtYW5jZTogQXZvaWQgc3RhcnRpbmcgYSBuZXcgbWljcm90aWNrIHNjb3BlIHdpdGhpbiB0aGUgYXN5bmMgY29udGV4dC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnYgPSBuZXdTY29wZShxdWVyaWVyLCBjdHgpO1xuICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgcnYgPSBydi5maW5hbGx5IGluIG9yZGVyIHRvIHdhaXQgdG8gYWZ0ZXIgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgLy8gVGhpcyBmaXhlcyB6b25lIGxlYWtpbmcgaXNzdWUgdGhhdCB0aGUgbGl2ZVF1ZXJ5IHpvbmUgY2FuIGxlYWsgdG8gb2JzZXJ2ZXIncyBuZXh0IG1pY3JvdGFzay5cbiAgICAgICAgICBydiA9IChydiBhcyBQcm9taXNlPGFueT4pLmZpbmFsbHkoZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc1Jvb3RFeGVjICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7IC8vIEdpdmVuIHRoYXQgd2UgY3JlYXRlZCB0aGUgbWljcm90aWNrIHNjb3BlLCB3ZSBtdXN0IGFsc28gZW5kIGl0LlxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG5cbiAgICBsZXQgYWNjdW1NdXRzOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgbGV0IGN1cnJlbnRPYnM6IE9ic2VydmFiaWxpdHlTZXQgPSB7fTtcblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0ge1xuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH0sXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBpZiAoc3RhcnRlZExpc3RlbmluZykgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLnVuc3Vic2NyaWJlKG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgb2JzZXJ2ZXIuc3RhcnQgJiYgb2JzZXJ2ZXIuc3RhcnQoc3Vic2NyaXB0aW9uKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuXG4gICAgbGV0IHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcblxuICAgIGNvbnN0IGRvUXVlcnkgPSAoKSA9PiBleGVjSW5HbG9iYWxDb250ZXh0KF9kb1F1ZXJ5KTtcblxuICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcbiAgICAgIHJldHVybiBvYnNTZXRzT3ZlcmxhcChjdXJyZW50T2JzLCBhY2N1bU11dHMpO1xuICAgIH1cblxuICAgIGNvbnN0IG11dGF0aW9uTGlzdGVuZXIgPSAocGFydHM6IE9ic2VydmFiaWxpdHlTZXQpID0+IHtcbiAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG4gICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBfZG9RdWVyeSA9ICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgY2xvc2VkIHx8IC8vIGNsb3NlZCAtIGRvbid0IHJ1biFcbiAgICAgICAgIWRvbURlcHMuaW5kZXhlZERCKSAvLyBTU1IgaW4gc3ZlbHRla2l0LCBuZXh0anMgZXRjXG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgY29uc3Qgc3Vic2NyOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgICAvLyBBYm9ydCBzaWduYWwgZmlsbCB0aHJlZSBwdXJwb3NlczpcbiAgICAgIC8vIDEuIEFib3J0IHRoZSBxdWVyeSBpZiB0aGUgb2JzZXJ2YWJsZSBpcyB1bnN1YnNjcmliZWQuXG4gICAgICAvLyAyLiBBYm9ydCB0aGUgcXVlcnkgaWYgYSBuZXcgcXVlcnkgaXMgbWFkZSBiZWZvcmUgdGhlIHByZXZpb3VzIG9uZSBoYXMgY29tcGxldGVkLlxuICAgICAgLy8gMy4gRm9yIGNhY2hlZCBxdWVyaWVzIHRvIGtub3cgaWYgdGhleSBzaG91bGQgcmVtYWluIGluIG1lbW9yeSBvciBjb3VsZCBiZSBlbnF1ZWQgZm9yIGJlaW5nIGZyZWVkIHVwLlxuICAgICAgLy8gICAgKHRoZXkgd2lsbCByZW1haW4gaW4gbWVtb3J5IGZvciBhIHNob3J0IHRpbWUgYW5kIGlmIG5vb25lIG5lZWRzIHRoZW0gYWdhaW4sIHRoZXkgd2lsbCBldmVudHVhbGx5IGJlIGZyZWVkIHVwKVxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlcikgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7IC8vIENhbmNlbCBwcmV2aW91cyBxdWVyeS4gTGFzdCBxdWVyeSB3aWxsIGJlIGNhbmNlbGxlZCBvbiB1bnN1YnNjcmliZSgpLlxuICAgICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgXG4gICAgICBjb25zdCBjdHg6IExpdmVRdWVyeUNvbnRleHQgPSB7XG4gICAgICAgIHN1YnNjcixcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICByZXF1ZXJ5OiBkb1F1ZXJ5LFxuICAgICAgICBxdWVyaWVyLFxuICAgICAgICB0cmFuczogbnVsbCAvLyBNYWtlIHRoZSBzY29wZSB0cmFuc2FjdGlvbmxlc3MgKGRvbid0IHJldXNlIHRyYW5zYWN0aW9uIGZyb20gb3V0ZXIgc2NvcGUgb2YgdGhlIGNhbGxlciBvZiBzdWJzY3JpYmUoKSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldCA9IGV4ZWN1dGUoY3R4KTtcbiAgICAgIFByb21pc2UucmVzb2x2ZShyZXQpLnRoZW4oXG4gICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgY3VycmVudFZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIGlmIChjbG9zZWQgfHwgY3R4LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAvLyBjbG9zZWQgLSBubyBzdWJzY3JpYmVyIGFueW1vcmUuXG4gICAgICAgICAgICAvLyBzaWduYWwuYWJvcnRlZCAtIG5ldyBxdWVyeSB3YXMgbWFkZSBiZWZvcmUgdGhpcyBvbmUgY29tcGxldGVkIGFuZFxuICAgICAgICAgICAgLy8gdGhlIHF1ZXJpZXIgbWlnaHQgaGF2ZSBjYXRjaGVkIEFib3J0RXJyb3IgYW5kIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdC5cbiAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBzaG91bGQgbm90IHJlbHkgaW4gdGhhdCByZXN1bHQgYmVjYXVzZSB3ZSBrbm93IHdlIGhhdmUgYWJvcnRlZFxuICAgICAgICAgICAgLy8gdGhpcyBydW4sIHdoaWNoIG1lYW5zIHRoZXJlJ3MgYW5vdGhlciBydW4gZ29pbmcgb24gdGhhdCB3aWxsIGhhbmRsZSBhY2N1bU11dHNcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBtdXN0IG5vdCBiYXNlIGN1cnJlbnRPYnMgb24gdGhlIGhhbGYtYmFrZWQgc3Vic2NyLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAvLyBVcGRhdGUgd2hhdCB3ZSBhcmUgc3Vic2NyaWJpbmcgZm9yIGJhc2VkIG9uIHRoaXMgbGFzdCBydW46XG4gICAgICAgICAgY3VycmVudE9icyA9IHN1YnNjcjtcbiAgICAgICAgICBpZiAoIW9iamVjdElzRW1wdHkoY3VycmVudE9icykgJiYgIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgbXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICBzdGFydGVkTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlY0luR2xvYmFsQ29udGV4dCgoKT0+IWNsb3NlZCAmJiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQocmVzdWx0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmICghWydEYXRhYmFzZUNsb3NlZEVycm9yJywgJ0Fib3J0RXJyb3InXS5pbmNsdWRlcyhlcnI/Lm5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkgZXhlY0luR2xvYmFsQ29udGV4dCgoKT0+e1xuICAgICAgICAgICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIFVzZSBzZXRUaW1lb3QgaGVyZSB0byBndWFyYW50ZWUgZXhlY3V0aW9uIGluIGEgcHJpdmF0ZSBtYWNybyB0YXNrIGJlZm9yZSBhbmRcbiAgICAvLyBhZnRlci4gVGhlIGhlbHBlciBleGVjdXRlSW5HbG9iYWxDb250ZXh0KF9kb1F1ZXJ5KSBpcyBub3QgZW5vdWdoIGhlcmUgYmVjYXVzZVxuICAgIC8vIGNhbGxlciBvZiBgc3Vic2NyaWJlKClgIGNvdWxkIGJlIGFueXRoaW5nLCBzdWNoIGFzIGEgZnJvbnRlbmQgZnJhbWV3b3JrIHRoYXQgd2lsbFxuICAgIC8vIGNvbnRpbnVlIGluIHRoZSBzYW1lIHRpY2sgYWZ0ZXIgc3Vic2NyaWJlKCkgaXMgY2FsbGVkIGFuZCBjYWxsIG90aGVyXG4gICAgLy8gZWZ0ZWN0cywgdGhhdCBjb3VsZCBpbnZvbHZlIGRleGllIG9wZXJhdGlvbnMgc3VjaCBhcyB3cml0aW5nIHRvIHRoZSBEQi5cbiAgICAvLyBJZiB0aGF0IGhhcHBlbnMsIHRoZSBwcml2YXRlIHpvbmUgZWNob2VzIGZyb20gYSBsaXZlIHF1ZXJ5IHRhc3Qgc3RhcnRlZCBoZXJlXG4gICAgLy8gY291bGQgc3RpbGwgYmUgb25nb2luZyB3aGVuIHRoZSBvdGhlciBvcGVyYXRpb25zIHN0YXJ0IGFuZCBtYWtlIHRoZW0gaW5oZXJpdFxuICAgIC8vIHRoZSBhc3luYyBjb250ZXh0IGZyb20gYSBsaXZlIHF1ZXJ5LlxuICAgIHNldFRpbWVvdXQoZG9RdWVyeSwgMCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfSk7XG4gIG9ic2VydmFibGUuaGFzVmFsdWUgPSAoKSA9PiBoYXNWYWx1ZTtcbiAgb2JzZXJ2YWJsZS5nZXRWYWx1ZSA9ICgpID0+IGN1cnJlbnRWYWx1ZTtcbiAgcmV0dXJuIG9ic2VydmFibGU7XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgYXMgX0RleGllIH0gZnJvbSAnLi9kZXhpZSc7XG5pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwnO1xuaW1wb3J0IHsgcHJvcHMsIGRlcml2ZSwgZXh0ZW5kLCBvdmVycmlkZSwgZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGgsIGRlbEJ5S2V5UGF0aCwgc2hhbGxvd0Nsb25lLCBkZWVwQ2xvbmUsIGFzYXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0T2JqZWN0RGlmZiB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmXCI7XG5pbXBvcnQgeyBmdWxsTmFtZUV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBnZXREYXRhYmFzZU5hbWVzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9kYXRhYmFzZS1lbnVtZXJhdG9yJztcbmltcG9ydCB7IFBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyB1c2VQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgbmV3U2NvcGUgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGF3YWl0SXRlcmF0b3IgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3lpZWxkLXN1cHBvcnQnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCAqIGFzIERlYnVnIGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgZGV4aWVTdGFja0ZyYW1lRmlsdGVyLCBtaW5LZXksIGNvbm5lY3Rpb25zLCBERVhJRV9WRVJTSU9OIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9oZWxwZXJzL0V2ZW50cyc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGVycm5hbWVzIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1heEtleSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgdmlwIH0gZnJvbSAnLi92aXAnO1xuaW1wb3J0IHsgZ2xvYmFsRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcbmltcG9ydCB7IGxpdmVRdWVyeSB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeSc7XG5pbXBvcnQgeyBleHRlbmRPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSAnLi4vLi4vbGl2ZS1xdWVyeS9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXQnO1xuaW1wb3J0IHsgZG9tRGVwcyB9IGZyb20gJy4vZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY21wJztcbmltcG9ydCB7IGNhY2hlIH0gZnJvbSAnLi4vLi4vbGl2ZS1xdWVyeS9jYWNoZS9jYWNoZSc7XG5cbi8qIChEZXhpZSkgaXMgYW4gaW5zdGFuY2Ugb2YgRGV4aWVDb25zdHJ1Y3RvciwgYXMgZGVmaW5lZCBpbiBwdWJsaWMvdHlwZXMvZGV4aWUtY29uc3RydWN0b3IuZC50c1xuKiAgKG5ldyBEZXhpZSgpKSBpcyBhbiBpbnN0YW5jZSBvZiBEZXhpZSwgYXMgZGVmaW5lZCBpbiBwdWJsaWMvdHlwZXMvZGV4aWUuZC50c1xuKiBcbiogV2h5IHdlJ3JlIGRvaW5nIHRoaXM/XG5cbiogQmVjYXVzZSB3ZSd2ZSBjaG9vc2VuIHRvIGRlZmluZSB0aGUgcHVibGljIERleGllIEFQSSB1c2luZyBhIERleGllQ29uc3RydWN0b3IgaW50ZXJmYWNlXG4qIHJhdGhlciB0aGFuIGRlY2xhcmluZyBhIGNsYXNzLiBPbiB0aGF0IGludGVyZmFjZSwgYWxsIHN0YXRpYyBwcm9wcyBhcmUgZGVmaW5lZC5cbiogSW4gcHJhY3RpY2UsIGNsYXNzIERleGllJ3MgY29uc3RydWN0b3IgaW1wbGVtZW50cyBEZXhpZUNvbnN0cnVjdG9yIGFuZCBhbGwgbWVtYmVyIHByb3BzXG4qIGFyZSBkZWZpbmVkIGluIGludGVyZmFjZSBEZXhpZS4gV2UgY291bGQgc2F5LCBpdCdzIGEgdHlwZXNjcmlwdCBsaW1pdGF0aW9uIG9mIG5vdCBiZWluZ1xuKiBhYmxlIHRvIGRlZmluZSBhIHN0YXRpYyBpbnRlcmZhY2UgdGhhdCBmb3JjZXMgdXMgdG8gZG8gdGhlIGNhc3QgYmVsb3cuXG4qL1xuY29uc3QgRGV4aWUgPSBfRGV4aWUgYXMgYW55IGFzIERleGllQ29uc3RydWN0b3I7XG5cbi8vXG4vLyBTZXQgYWxsIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIG9udG8gRGV4aWU6XG4vLyBcbnByb3BzKERleGllLCB7XG5cbiAgLy8gRGV4aWUuQnVsa0Vycm9yID0gY2xhc3MgQnVsa0Vycm9yIHsuLi59O1xuICAvLyBEZXhpZS5YWFhFcnJvciA9IGNsYXNzIFhYWEVycm9yIHsuLi59O1xuICAuLi5mdWxsTmFtZUV4Y2VwdGlvbnMsXG5cbiAgLy9cbiAgLy8gU3RhdGljIGRlbGV0ZSgpIG1ldGhvZC5cbiAgLy9cbiAgZGVsZXRlKGRhdGFiYXNlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgZGIgPSBuZXcgRGV4aWUoZGF0YWJhc2VOYW1lLCB7YWRkb25zOiBbXX0pO1xuICAgIHJldHVybiBkYi5kZWxldGUoKTtcbiAgfSxcblxuICAvL1xuICAvLyBTdGF0aWMgZXhpc3RzKCkgbWV0aG9kLlxuICAvL1xuICBleGlzdHMobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZGIgPT4ge1xuICAgICAgZGIuY2xvc2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhdGNoKCdOb1N1Y2hEYXRhYmFzZUVycm9yJywgKCkgPT4gZmFsc2UpO1xuICB9LFxuXG4gIC8vXG4gIC8vIFN0YXRpYyBtZXRob2QgZm9yIHJldHJpZXZpbmcgYSBsaXN0IG9mIGFsbCBleGlzdGluZyBkYXRhYmFzZXMgYXQgY3VycmVudCBob3N0LlxuICAvL1xuICBnZXREYXRhYmFzZU5hbWVzKGNiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzKERleGllLmRlcGVuZGVuY2llcykudGhlbihjYik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBkZWZpbmVDbGFzcygpIHtcbiAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBDbGFzcztcbiAgfSxcblxuICBpZ25vcmVUcmFuc2FjdGlvbihzY29wZUZ1bmMpIHtcbiAgICAvLyBJbiBjYXNlIGNhbGxlciBpcyB3aXRoaW4gYSB0cmFuc2FjdGlvbiBidXQgbmVlZHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4gICAgLy8gRXhhbXBsZSBvZiB1c2FnZTpcbiAgICAvL1xuICAgIC8vIExldCdzIHNheSB3ZSBoYXZlIGEgbG9nZ2VyIGZ1bmN0aW9uIGluIG91ciBhcHAuIE90aGVyIGFwcGxpY2F0aW9uLWxvZ2ljIHNob3VsZCBiZSB1bmF3YXJlIG9mIHRoZVxuICAgIC8vIGxvZ2dlciBmdW5jdGlvbiBhbmQgbm90IG5lZWQgdG8gaW5jbHVkZSB0aGUgJ2xvZ2VudHJpZXMnIHRhYmxlIGluIGFsbCB0cmFuc2FjdGlvbiBpdCBwZXJmb3Jtcy5cbiAgICAvLyBUaGUgbG9nZ2luZyBzaG91bGQgYWx3YXlzIGJlIGRvbmUgaW4gYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbiBhbmQgbm90IGJlIGRlcGVuZGFudCBvbiB0aGUgY3VycmVudFxuICAgIC8vIHJ1bm5pbmcgdHJhbnNhY3Rpb24gY29udGV4dC4gVGhlbiB5b3UgY291bGQgdXNlIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkgdG8gcnVuIGNvZGUgdGhhdCBzdGFydHMgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAgLy9cbiAgICAvLyAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgICAgICBkYi5sb2dlbnRyaWVzLmFkZChuZXdMb2dFbnRyeSk7XG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgLy8gVW5sZXNzIHVzaW5nIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCksIHRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIHRyeSB0byByZXVzZSB0aGUgY3VycmVudCB0cmFuc2FjdGlvblxuICAgIC8vIGluIGN1cnJlbnQgUHJvbWlzZS1zY29wZS5cbiAgICAvL1xuICAgIC8vIEFuIGFsdGVybmF0aXZlIHRvIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkgd291bGQgYmUgc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLiBUaGUgcmVhc29uIHdlIHN0aWxsIHByb3ZpZGUgYW5cbiAgICAvLyBBUEkgZm9yIHRoaXMgYmVjYXVzZVxuICAgIC8vICAxKSBUaGUgaW50ZW50aW9uIG9mIHdyaXRpbmcgdGhlIHN0YXRlbWVudCBjb3VsZCBiZSB1bmNsZWFyIGlmIHVzaW5nIHNldEltbWVkaWF0ZSgpIG9yIHNldFRpbWVvdXQoKS5cbiAgICAvLyAgMikgc2V0VGltZW91dCgpIHdvdWxkIHdhaXQgdW5uZXNjZXNzYXJ5IHVudGlsIGZpcmluZy4gVGhpcyBpcyBob3dldmVyIG5vdCB0aGUgY2FzZSB3aXRoIHNldEltbWVkaWF0ZSgpLlxuICAgIC8vICAzKSBzZXRJbW1lZGlhdGUoKSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBFUyBzdGFuZGFyZC5cbiAgICAvLyAgNCkgWW91IG1pZ2h0IHdhbnQgdG8ga2VlcCBvdGhlciBQU0Qgc3RhdGUgdGhhdCB3YXMgc2V0IGluIGEgcGFyZW50IFBTRCwgc3VjaCBhcyBQU0QubGV0VGhyb3VnaC5cbiAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDogLy8gVXNlIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IHdhcyBub24tdHJhbnNhY3Rpb25hbC5cbiAgICAgIHNjb3BlRnVuYygpOyAvLyBObyBuZWVkIHRvIGNoYW5nZSBzY29wZSBiZWNhdXNlIHRoZXJlIGlzIG5vIG9uZ29pbmcgdHJhbnNhY3Rpb24uXG4gIH0sXG5cbiAgdmlwLFxuXG4gIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm46IEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGl6LCBhcmdzIHx8IFtdKSk7XG4gICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgIHJldHVybiBydjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgIH1cbiAgfSxcblxuICAvLyBEZXhpZS5jdXJyZW50VHJhbnNhY3Rpb24gcHJvcGVydHlcbiAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG4gICAgZ2V0OiAoKSA9PiBQU0QudHJhbnMgfHwgbnVsbFxuICB9LFxuXG4gIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlT3JGdW5jdGlvbiwgb3B0aW9uYWxUaW1lb3V0KSB7XG4gICAgLy8gSWYgYSBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaW52b2tlIGl0IGFuZCBwYXNzIHRoZSByZXR1cm5pbmcgdmFsdWUgdG8gVHJhbnNhY3Rpb24ud2FpdEZvcigpXG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShcbiAgICAgIHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKHByb21pc2VPckZ1bmN0aW9uKSA6XG4gICAgICAgIHByb21pc2VPckZ1bmN0aW9uKVxuICAgICAgLnRpbWVvdXQob3B0aW9uYWxUaW1lb3V0IHx8IDYwMDAwKTsgLy8gRGVmYXVsdCB0aGUgdGltZW91dCB0byBvbmUgbWludXRlLiBDYWxsZXIgbWF5IHNwZWNpZnkgSW5maW5pdHkgaWYgcmVxdWlyZWQuICAgICAgIFxuXG4gICAgLy8gUnVuIGdpdmVuIHByb21pc2Ugb24gY3VycmVudCB0cmFuc2FjdGlvbi4gSWYgbm8gY3VycmVudCB0cmFuc2FjdGlvbiwganVzdCByZXR1cm4gYSBEZXhpZSBwcm9taXNlIGJhc2VkXG4gICAgLy8gb24gZ2l2ZW4gdmFsdWUuXG4gICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICBQU0QudHJhbnMud2FpdEZvcihwcm9taXNlKSA6XG4gICAgICBwcm9taXNlO1xuICB9LFxuXG4gIC8vIEV4cG9ydCBvdXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBzaW5jZSBpdCBjYW4gYmUgaGFuZHkgYXMgYSBzdGFuZGFsb25lIFByb21pc2UgaW1wbGVtZW50YXRpb25cbiAgUHJvbWlzZTogUHJvbWlzZSxcblxuICAvLyBEZXhpZS5kZWJ1ZyBwcm9wdGVyeTpcbiAgLy8gRGV4aWUuZGVidWcgPSBmYWxzZVxuICAvLyBEZXhpZS5kZWJ1ZyA9IHRydWVcbiAgLy8gRGV4aWUuZGVidWcgPSBcImRleGllXCIgLSBkb24ndCBoaWRlIGRleGllJ3Mgc3RhY2sgZnJhbWVzLlxuICBkZWJ1Zzoge1xuICAgIGdldDogKCkgPT4gRGVidWcuZGVidWcsXG4gICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICBEZWJ1Zy5zZXREZWJ1Zyh2YWx1ZSwgdmFsdWUgPT09ICdkZXhpZScgPyAoKSA9PiB0cnVlIDogZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gRXhwb3J0IG91ciBkZXJpdmUvZXh0ZW5kL292ZXJyaWRlIG1ldGhvZG9sb2d5XG4gIGRlcml2ZTogZGVyaXZlLCAvLyBEZXByZWNhdGU/XG4gIGV4dGVuZDogZXh0ZW5kLCAvLyBEZXByZWNhdGU/XG4gIHByb3BzOiBwcm9wcyxcbiAgb3ZlcnJpZGU6IG92ZXJyaWRlLCAvLyBEZXByZWNhdGU/XG4gIC8vIEV4cG9ydCBvdXIgRXZlbnRzKCkgZnVuY3Rpb24gLSBjYW4gYmUgaGFuZHkgYXMgYSB0b29sa2l0XG4gIEV2ZW50czogRXZlbnRzLFxuICBvbjogZ2xvYmFsRXZlbnRzLFxuICBsaXZlUXVlcnksXG4gIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQsXG4gIC8vIFV0aWxpdGllc1xuICBnZXRCeUtleVBhdGg6IGdldEJ5S2V5UGF0aCxcbiAgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsXG4gIGRlbEJ5S2V5UGF0aDogZGVsQnlLZXlQYXRoLFxuICBzaGFsbG93Q2xvbmU6IHNoYWxsb3dDbG9uZSxcbiAgZGVlcENsb25lOiBkZWVwQ2xvbmUsXG4gIGdldE9iamVjdERpZmY6IGdldE9iamVjdERpZmYsXG4gIGNtcCxcbiAgYXNhcDogYXNhcCxcbiAgLy9tYXhLZXk6IG5ldyBEZXhpZSgnJyx7YWRkb25zOltdfSkuX21heEtleSxcbiAgbWluS2V5OiBtaW5LZXksXG4gIC8vIEFkZG9uIHJlZ2lzdHJ5XG4gIGFkZG9uczogW10sXG4gIC8vIEdsb2JhbCBEQiBjb25uZWN0aW9uIGxpc3RcbiAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuXG4gIC8vTXVsdGlNb2RpZnlFcnJvcjogZXhjZXB0aW9ucy5Nb2RpZnksIC8vIE9ic29sZXRlIVxuICBlcnJuYW1lczogZXJybmFtZXMsXG5cbiAgLy8gRXhwb3J0IG90aGVyIHN0YXRpYyBjbGFzc2VzXG4gIC8vSW5kZXhTcGVjOiBJbmRleFNwZWMsIE9ic29sZXRlIVxuICAvL1RhYmxlU2NoZW1hOiBUYWJsZVNjaGVtYSwgT2Jzb2xldGUhXG5cbiAgLy9cbiAgLy8gRGVwZW5kZW5jaWVzXG4gIC8vXG4gIC8vIFRoZXNlIHdpbGwgYXV0b21hdGljYWxseSB3b3JrIGluIGJyb3dzZXJzIHdpdGggaW5kZXhlZERCIHN1cHBvcnQsIG9yIHdoZXJlIGFuIGluZGV4ZWREQiBwb2x5ZmlsbCBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgLy9cbiAgLy8gSW4gbm9kZS5qcywgaG93ZXZlciwgdGhlc2UgcHJvcGVydGllcyBtdXN0IGJlIHNldCBcIm1hbnVhbGx5XCIgYmVmb3JlIGluc3RhbnNpYXRpbmcgYSBuZXcgRGV4aWUoKS5cbiAgLy8gRm9yIG5vZGUuanMsIHlvdSBuZWVkIHRvIHJlcXVpcmUgaW5kZXhlZGRiLWpzIG9yIHNpbWlsYXIgYW5kIHRoZW4gc2V0IHRoZXNlIGRlcHMuXG4gIC8vXG4gIGRlcGVuZGVuY2llczogZG9tRGVwcyxcbiAgY2FjaGUsXG5cbiAgLy8gQVBJIFZlcnNpb24gTnVtYmVyOiBUeXBlIE51bWJlciwgbWFrZSBzdXJlIHRvIGFsd2F5cyBzZXQgYSB2ZXJzaW9uIG51bWJlciB0aGF0IGNhbiBiZSBjb21wYXJhYmxlIGNvcnJlY3RseS4gRXhhbXBsZTogMC45LCAwLjkxLCAwLjkyLCAxLjAsIDEuMDEsIDEuMSwgMS4yLCAxLjIxLCBldGMuXG4gIHNlbVZlcjogREVYSUVfVkVSU0lPTixcbiAgdmVyc2lvbjogREVYSUVfVkVSU0lPTi5zcGxpdCgnLicpXG4gICAgLm1hcChuID0+IHBhcnNlSW50KG4pKVxuICAgIC5yZWR1Y2UoKHAsIGMsIGkpID0+IHAgKyAoYyAvIE1hdGgucG93KDEwLCBpICogMikpKSxcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlci9EZXhpZS5qcy9pc3N1ZXMvMTg2XG4gIC8vIHR5cGVzY3JpcHQgY29tcGlsZXIgdHNjIGluIG1vZGUgdHMtLT5lczUgJiBjb21tb25KUywgd2lsbCBleHBlY3QgcmVxdWlyZSgpIHRvIHJldHVyblxuICAvLyB4LmRlZmF1bHQuIFdvcmthcm91bmQ6IFNldCBEZXhpZS5kZWZhdWx0ID0gRGV4aWUuXG4gIC8vIGRlZmF1bHQ6IERleGllLCAvLyBDb21tZW50ZWQgYmVjYXVzZSBzb2x2ZWQgaW4gaW5kZXgtdW1kLnRzIGluc3RlYWQuXG4gIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gaW1wb3J0IHtEZXhpZX0gKG5vbi1kZWZhdWx0IGltcG9ydClcbiAgLy8gUmVhc29uIDE6IE1heSBzd2l0Y2ggdG8gdGhhdCBpbiBmdXR1cmUuXG4gIC8vIFJlYXNvbiAyOiBXZSBkZWNsYXJlIGl0IGJvdGggZGVmYXVsdCBhbmQgbmFtZWQgZXhwb3J0ZWQgaW4gZC50cyB0byBtYWtlIGl0IHBvc3NpYmxlXG4gIC8vIHRvIGxldCBhZGRvbnMgZXh0ZW5kIHRoZSBEZXhpZSBpbnRlcmZhY2Ugd2l0aCBUeXBlc2NyaXB0IDIuMSAod29ya3Mgb25seSB3aGVuIGV4cGxpY2l0ZWx5XG4gIC8vIGV4cG9ydGluZyB0aGUgc3ltYm9sLCBub3QganVzdCBkZWZhdWx0IGV4cG9ydGluZylcbiAgLy8gRGV4aWU6IERleGllIC8vIENvbW1lbnRlZCBiZWNhdXNlIHNvbHZlZCBpbiBpbmRleC11bWQudHMgaW5zdGVhZC5cbn0pO1xuXG5EZXhpZS5tYXhLZXkgPSBnZXRNYXhLZXkoRGV4aWUuZGVwZW5kZW5jaWVzLklEQktleVJhbmdlKTtcbiIsICJpbXBvcnQgeyBnbG9iYWxFdmVudHMsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgfSBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbC1ldmVudHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5pbXBvcnQgeyBzaWduYWxTdWJzY3JpYmVyc05vdyB9IGZyb20gJy4vY2FjaGUvc2lnbmFsU3Vic2NyaWJlcnMnO1xuXG5pZiAodHlwZW9mIGRpc3BhdGNoRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIHVwZGF0ZWRQYXJ0cyA9PiB7XG4gICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgIGxldCBldmVudDogQ3VzdG9tRXZlbnQ8T2JzZXJ2YWJpbGl0eVNldD47XG4gICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcbiAgICAgICAgZGV0YWlsOiB1cGRhdGVkUGFydHNcbiAgICAgIH0pO1xuICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgYWRkRXZlbnRMaXN0ZW5lcihTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsICh7ZGV0YWlsfTogQ3VzdG9tRXZlbnQ8T2JzZXJ2YWJpbGl0eVNldD4pID0+IHtcbiAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgcHJvcGFnYXRlTG9jYWxseShkZXRhaWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKiBDYWxsZWQgZnJvbSBsaXN0ZW5lcnMgdG8gQnJvYWRjYXN0Q2hhbm5lbCBhbmQgRE9NIGV2ZW50IHRvXG4gKiBwcm9wYWdhdGUgdGhlIGV2ZW50IGxvY2FsbHkgaW50byBkZXhpZSdzIHN0b3JhZ2VtdXRhdGVkIGV2ZW50XG4gKiBhbmQgaW52YWxpZGF0ZSBjYWNoZWQgcXVlcmllcy5cbiAqIFxuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBub3Qgb3JpZ2luYXRpbmdcbiAqIGZyb20gdGhpcyBzYW1lIERleGllIG1vZHVsZSAtIGVpdGhlciBmcm9tIGFub3RoZXIgcmVkdW5kYW50IGRleGllIGltcG9ydFxuICogb3IgZnJvbSBhIGZvcmVpZ24gdGFiIG9yIHdvcmtlci4gVGhhdCdzIHdoeSB3ZSBuZWVkIHRvIGludmFsaWRhdGVcbiAqIHRoZSBjYWNoZSB3aGVuIHRoaXMgaGFwcGVucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BhZ2F0ZUxvY2FsbHkodXBkYXRlUGFydHM6IE9ic2VydmFiaWxpdHlTZXQpIHtcbiAgbGV0IHdhc01lID0gcHJvcGFnYXRpbmdMb2NhbGx5O1xuICB0cnkge1xuICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgLy8gRmlyZSB0aGUgXCJzdG9yYWdlbXV0YXRlZFwiIGV2ZW50LlxuICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgICAvLyBJbnZhbGlkYXRlIGNhY2hlZCBxdWVyaWVzIGFuZCBzaWduYWwgc3Vic2NyaWJlcnMgdG8gcmVxdWVyeS5cbiAgICBzaWduYWxTdWJzY3JpYmVyc05vdyh1cGRhdGVQYXJ0cywgdHJ1ZSk7XG4gIH0gZmluYWxseSB7XG4gICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gd2FzTWU7XG4gIH1cbn1cblxuZXhwb3J0IGxldCBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcbiIsICJpbXBvcnQge1xuICBnbG9iYWxFdmVudHMsXG4gIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSxcbiAgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsXG59IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQgeyBwcm9wYWdhdGVMb2NhbGx5LCBwcm9wYWdhdGluZ0xvY2FsbHkgfSBmcm9tICcuL3Byb3BhZ2F0ZS1sb2NhbGx5JztcblxuZXhwb3J0IGxldCBiYzogQnJvYWRjYXN0Q2hhbm5lbDtcblxuZXhwb3J0IGxldCBjcmVhdGVCQyA9ICgpPT57fTtcblxuaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICBjcmVhdGVCQyA9ICgpID0+IHtcbiAgICBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSk7XG4gICAgYmMub25tZXNzYWdlID0gZXYgPT4gZXYuZGF0YSAmJiBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpO1xuICB9XG4gIGNyZWF0ZUJDKCk7XG5cbiAgLyoqXG4gICAqIFRoZSBOb2RlLmpzIEJyb2FkY2FzdENoYW5uZWwgd2lsbCBwcmV2ZW50IHRoZSBub2RlIHByb2Nlc3MgZnJvbSBleGl0aW5nXG4gICAqIGlmIHRoZSBCcm9hZGNhc3RDaGFubmVsIGlzIG5vdCBjbG9zZWQuXG4gICAqIFRoZXJlZm9yZSB3ZSBoYXZlIHRvIGNhbGwgdW5yZWYoKSB3aGljaCBhbGxvd3MgdGhlIHByb2Nlc3MgdG8gZmluaXNoXG4gICAqIHByb3Blcmx5IGV2ZW4gd2hlbiB0aGUgQnJvYWRjYXN0Q2hhbm5lbCBpcyBuZXZlciBjbG9zZWQuXG4gICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvd29ya2VyX3RocmVhZHMuaHRtbCNicm9hZGNhc3RjaGFubmVsdW5yZWZcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2RleGllL0RleGllLmpzL3B1bGwvMTU3NlxuICAgKi9cbiAgaWYgKHR5cGVvZiAoYmMgYXMgYW55KS51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIChiYyBhcyBhbnkpLnVucmVmKCk7XG4gIH1cbiAgXG4gIC8vXG4gIC8vIFByb3BhZ2F0ZSBsb2NhbCBjaGFuZ2VzIHRvIHJlbW90ZSB0YWJzLCB3aW5kb3dzIGFuZCB3b3JrZXJzIHZpYSBCcm9hZGNhc3RDaGFubmVsXG4gIC8vXG4gIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tIFwiLi9jbGFzc2VzL2RleGllXCI7XG5pbXBvcnQgeyBjb25uZWN0aW9ucyB9IGZyb20gXCIuL2dsb2JhbHMvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gXCIuL2hlbHBlcnMvZGVidWdcIjtcbmltcG9ydCB7IFJhbmdlU2V0IH0gZnJvbSBcIi4vaGVscGVycy9yYW5nZXNldFwiO1xuaW1wb3J0IHsgYmMsIGNyZWF0ZUJDIH0gZnJvbSBcIi4vbGl2ZS1xdWVyeS9lbmFibGUtYnJvYWRjYXN0XCI7XG5pbXBvcnQgeyBwcm9wYWdhdGVMb2NhbGx5IH0gZnJvbSBcIi4vbGl2ZS1xdWVyeS9wcm9wYWdhdGUtbG9jYWxseVwiO1xuXG5cbmlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoIURleGllLmRpc2FibGVCZkNhY2hlICYmIGV2ZW50LnBlcnNpc3RlZCkge1xuICAgICAgaWYgKGRlYnVnKSBjb25zb2xlLmRlYnVnKCdEZXhpZTogaGFuZGxpbmcgcGVyc2lzdGVkIHBhZ2VoaWRlJyk7XG4gICAgICBiYz8uY2xvc2UoKTtcbiAgICAgIGZvciAoY29uc3QgZGIgb2YgY29ubmVjdGlvbnMpIHtcbiAgICAgICAgZGIuY2xvc2Uoe2Rpc2FibGVBdXRvT3BlbjogZmFsc2V9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBhZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIChldmVudCkgPT4ge1xuICAgIGlmICghRGV4aWUuZGlzYWJsZUJmQ2FjaGUgJiYgZXZlbnQucGVyc2lzdGVkKSB7XG4gICAgICBpZiAoZGVidWcpIGNvbnNvbGUuZGVidWcoJ0RleGllOiBoYW5kbGluZyBwZXJzaXN0ZWQgcGFnZXNob3cnKTtcbiAgICAgIGNyZWF0ZUJDKCk7XG4gICAgICBwcm9wYWdhdGVMb2NhbGx5KHthbGw6IG5ldyBSYW5nZVNldCgtSW5maW5pdHksIFtbXV0pfSk7IC8vIFRyaWdnZXIgYWxsIHF1ZXJpZXMgdG8gcmVxdWVyeVxuICAgIH1cbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgUHJvcE1vZGlmaWNhdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb3AtbW9kaWZpY2F0aW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQodmFsdWU6IG51bWJlciB8IGJpZ2ludCB8IEFycmF5PHN0cmluZyB8IG51bWJlcj4pIHtcbiAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHthZGQ6IHZhbHVlfSk7XG59XG4iLCAiaW1wb3J0IHsgUHJvcE1vZGlmaWNhdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb3AtbW9kaWZpY2F0aW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUodmFsdWU6IG51bWJlciB8IGJpZ2ludCB8IEFycmF5PHN0cmluZyB8IG51bWJlcj4pIHtcbiAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHtyZW1vdmU6IHZhbHVlfSk7XG59XG4iLCAiaW1wb3J0IHsgUHJvcE1vZGlmaWNhdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb3AtbW9kaWZpY2F0aW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlUHJlZml4KGE6IHN0cmluZywgYjpzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHtyZXBsYWNlUHJlZml4OiBbYSwgYl19KTtcbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vY2xhc3Nlcy9kZXhpZSc7XG5pbXBvcnQgeyBEZXhpZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi9wdWJsaWMvdHlwZXMvZGV4aWUtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgRGV4aWVQcm9taXNlIH0gZnJvbSAnLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgbWFwRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgKiBhcyBEZWJ1ZyBmcm9tICcuL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgZGV4aWVTdGFja0ZyYW1lRmlsdGVyIH0gZnJvbSAnLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5cbi8vIEdlbmVyYXRlIGFsbCBzdGF0aWMgcHJvcGVydGllcyBzdWNoIGFzIERleGllLm1heEtleSBldGNcbi8vIChpbXBsZW1lbnQgaW50ZXJmYWNlIERleGllQ29uc3RydWN0b3IpOlxuaW1wb3J0ICcuL2NsYXNzZXMvZGV4aWUvZGV4aWUtc3RhdGljLXByb3BzJztcbmltcG9ydCAnLi9saXZlLXF1ZXJ5L2VuYWJsZS1icm9hZGNhc3QnO1xuaW1wb3J0ICcuL3N1cHBvcnQtYmZjYWNoZSc7XG5pbXBvcnQgeyBsaXZlUXVlcnkgfSBmcm9tICcuL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICcuL2NsYXNzZXMvZW50aXR5L0VudGl0eSc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tICcuL2Z1bmN0aW9ucy9jbXAnO1xuaW1wb3J0IHsgUHJvcE1vZGlmaWNhdGlvbiwgUHJvcE1vZFN5bWJvbCB9IGZyb20gJy4vaGVscGVycy9wcm9wLW1vZGlmaWNhdGlvbic7XG5pbXBvcnQgeyByZXBsYWNlUHJlZml4LCBhZGQsIHJlbW92ZSB9IGZyb20gJy4vZnVuY3Rpb25zL3Byb3Btb2RzJztcblxuXG4vLyBTZXQgcmVqZWN0aW9uTWFwcGVyIG9mIERleGllUHJvbWlzZSBzbyB0aGF0IGl0IGdlbmVyYWxseSB0cmllcyB0byBtYXBcbi8vIERPTUVycm9ycyBhbmQgRE9NRXhjZXB0aW9ucyB0byBhIERleGllRXJyb3IgaW5zdGFuY2Ugd2l0aCBzYW1lIG5hbWUgYnV0IHdpdGhcbi8vIGFzeW5jIHN0YWNrIHN1cHBvcnQgYW5kIHdpdGggYSBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGZyb20gRGV4aWVFcnJvciBhbmQgRXJyb3IuXG4vLyBvZiBNYXAgRE9NRXJyb3JzIGFuZCBET01FeGNlcHRpb25zIHRvIGNvcnJlc3BvbmRpbmcgRGV4aWUgZXJyb3JzLlxuRGV4aWVQcm9taXNlLnJlamVjdGlvbk1hcHBlciA9IG1hcEVycm9yO1xuXG4vLyBMZXQgdGhlIGFzeW5jIHN0YWNrIGZpbHRlciBmb2N1cyBvbiBhcHAgY29kZSBhbmQgZmlsdGVyIGF3YXkgZnJhbWVzIGZyb20gZGV4aWUubWluLmpzOlxuRGVidWcuc2V0RGVidWcoRGVidWcuZGVidWcsIGRleGllU3RhY2tGcmFtZUZpbHRlcik7XG5cbmV4cG9ydCB7IFJhbmdlU2V0LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCB9IGZyb20gXCIuL2hlbHBlcnMvcmFuZ2VzZXRcIjtcbmV4cG9ydCB7IERleGllLCBsaXZlUXVlcnkgfTsgLy8gQ29tcGx5IHdpdGggcHVibGljL2luZGV4LmQudHMuXG5leHBvcnQgeyBFbnRpdHkgfTtcbmV4cG9ydCB7IGNtcCB9O1xuZXhwb3J0IHsgUHJvcE1vZFN5bWJvbCwgUHJvcE1vZGlmaWNhdGlvbiwgcmVwbGFjZVByZWZpeCwgYWRkLCByZW1vdmUgfTtcbmV4cG9ydCBkZWZhdWx0IERleGllO1xuIiwgIi8vIElzc3VlICMxMTI3LiBOZWVkIGFub3RoZXIgaW5kZXgudHMgZm9yIHRoZSBVTUQgbW9kdWxlIHdpdGggb25seSBhIGRlZmF1bHQgZXhwb3J0XG4vLyBsaWtlIGl0IHdhcyBiZWZvcmUuXG4vLyBJbiBwcmFjdGljZSB0aG91Z2gsIHRoZSBVTUQgZXhwb3J0IHdpbGwgYWxzbyBleHBvcnQgdGhlIG5hbWVkIGV4cG9ydCBpbiBcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyL0RleGllLmpzL2Jsb2IvYzkxODdhZTYwYzBkN2E0MjRmODViYWIzYWYxNzlmYmJjOTkwMWM4ZS9zcmMvY2xhc3Nlcy9kZXhpZS9kZXhpZS1zdGF0aWMtcHJvcHMudHMjTDIyMy1MMjI4XG5pbXBvcnQgRGV4aWUgZnJvbSBcIi4vaW5kZXhcIjtcbmltcG9ydCAqIGFzIG5hbWVkRXhwb3J0cyBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5fX2Fzc2lnbihEZXhpZSwgbmFtZWRFeHBvcnRzLCB7ZGVmYXVsdDogRGV4aWV9KTtcbmV4cG9ydCBkZWZhdWx0IERleGllO1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEV2ZW50U291cmNlLFxuICBNZXNzYWdlLFxuICBNZXNzYWdlVHlwZSxcbiAgUG9zdE1lc3NhZ2VXaXRoT3JpZ2luLFxuICBXaXJlVmFsdWUsXG4gIFdpcmVWYWx1ZVR5cGUsXG59IGZyb20gXCIuL3Byb3RvY29sXCI7XG5leHBvcnQgdHlwZSB7IEVuZHBvaW50IH07XG5cbmV4cG9ydCBjb25zdCBwcm94eU1hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIik7XG5leHBvcnQgY29uc3QgY3JlYXRlRW5kcG9pbnQgPSBTeW1ib2woXCJDb21saW5rLmVuZHBvaW50XCIpO1xuZXhwb3J0IGNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbChcIkNvbWxpbmsucmVsZWFzZVByb3h5XCIpO1xuZXhwb3J0IGNvbnN0IGZpbmFsaXplciA9IFN5bWJvbChcIkNvbWxpbmsuZmluYWxpemVyXCIpO1xuXG5jb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsudGhyb3duXCIpO1xuXG4vKipcbiAqIEludGVyZmFjZSBvZiB2YWx1ZXMgdGhhdCB3ZXJlIG1hcmtlZCB0byBiZSBwcm94aWVkIHdpdGggYGNvbWxpbmsucHJveHkoKWAuXG4gKiBDYW4gYWxzbyBiZSBpbXBsZW1lbnRlZCBieSBjbGFzc2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5TWFya2VkIHtcbiAgW3Byb3h5TWFya2VyXTogdHJ1ZTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHR5cGUgYW5kIHdyYXBzIGl0IGluIGEgUHJvbWlzZSwgaWYgaXQgbm90IGFscmVhZHkgaXMgb25lLlxuICogVGhpcyBpcyB0byBhdm9pZCBgUHJvbWlzZTxQcm9taXNlPFQ+PmAuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgVW5wcm9taXNpZnk8VD5gLlxuICovXG50eXBlIFByb21pc2lmeTxUPiA9IFQgZXh0ZW5kcyBQcm9taXNlPHVua25vd24+ID8gVCA6IFByb21pc2U8VD47XG4vKipcbiAqIFRha2VzIGEgdHlwZSB0aGF0IG1heSBiZSBQcm9taXNlIGFuZCB1bndyYXBzIHRoZSBQcm9taXNlIHR5cGUuXG4gKiBJZiBgUGAgaXMgbm90IGEgUHJvbWlzZSwgaXQgcmV0dXJucyBgUGAuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgUHJvbWlzaWZ5PFQ+YC5cbiAqL1xudHlwZSBVbnByb21pc2lmeTxQPiA9IFAgZXh0ZW5kcyBQcm9taXNlPGluZmVyIFQ+ID8gVCA6IFA7XG5cbi8qKlxuICogVGFrZXMgdGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIHByb3BlcnR5IGFuZCByZXR1cm5zIHRoZSB0eXBlIHRoYXQgaXMgdmlzaWJsZSB0byB0aGUgbG9jYWwgdGhyZWFkIG9uIHRoZSBwcm94eS5cbiAqXG4gKiBOb3RlOiBUaGlzIG5lZWRzIHRvIGJlIGl0cyBvd24gdHlwZSBhbGlhcywgb3RoZXJ3aXNlIGl0IHdpbGwgbm90IGRpc3RyaWJ1dGUgb3ZlciB1bmlvbnMuXG4gKiBTZWUgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svYWR2YW5jZWQtdHlwZXMuaHRtbCNkaXN0cmlidXRpdmUtY29uZGl0aW9uYWwtdHlwZXNcbiAqL1xudHlwZSBSZW1vdGVQcm9wZXJ0eTxUPiA9XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhIG1ldGhvZCwgY29tbGluayB3aWxsIHByb3h5IGl0IGF1dG9tYXRpY2FsbHkuXG4gIC8vIE9iamVjdHMgYXJlIG9ubHkgcHJveGllZCBpZiB0aGV5IGFyZSBtYXJrZWQgdG8gYmUgcHJveGllZC5cbiAgLy8gT3RoZXJ3aXNlLCB0aGUgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSBjbG9uZWQgdmFsdWUuXG4gIFQgZXh0ZW5kcyBGdW5jdGlvbiB8IFByb3h5TWFya2VkID8gUmVtb3RlPFQ+IDogUHJvbWlzaWZ5PFQ+O1xuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHByb3BlcnR5IGFzIGEgcmVtb3RlIHRocmVhZCB3b3VsZCBzZWUgaXQgdGhyb3VnaCBhIHByb3h5IChlLmcuIHdoZW4gcGFzc2VkIGluIGFzIGEgZnVuY3Rpb25cbiAqIGFyZ3VtZW50KSBhbmQgcmV0dXJucyB0aGUgdHlwZSB0aGF0IHRoZSBsb2NhbCB0aHJlYWQgaGFzIHRvIHN1cHBseS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGBSZW1vdGVQcm9wZXJ0eTxUPmAuXG4gKlxuICogTm90ZTogVGhpcyBuZWVkcyB0byBiZSBpdHMgb3duIHR5cGUgYWxpYXMsIG90aGVyd2lzZSBpdCB3aWxsIG5vdCBkaXN0cmlidXRlIG92ZXIgdW5pb25zLiBTZWVcbiAqIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2FkdmFuY2VkLXR5cGVzLmh0bWwjZGlzdHJpYnV0aXZlLWNvbmRpdGlvbmFsLXR5cGVzXG4gKi9cbnR5cGUgTG9jYWxQcm9wZXJ0eTxUPiA9IFQgZXh0ZW5kcyBGdW5jdGlvbiB8IFByb3h5TWFya2VkXG4gID8gTG9jYWw8VD5cbiAgOiBVbnByb21pc2lmeTxUPjtcblxuLyoqXG4gKiBQcm94aWVzIGBUYCBpZiBpdCBpcyBhIGBQcm94eU1hcmtlZGAsIGNsb25lcyBpdCBvdGhlcndpc2UgKGFzIGhhbmRsZWQgYnkgc3RydWN0dXJlZCBjbG9uaW5nIGFuZCB0cmFuc2ZlciBoYW5kbGVycykuXG4gKi9cbmV4cG9ydCB0eXBlIFByb3h5T3JDbG9uZTxUPiA9IFQgZXh0ZW5kcyBQcm94eU1hcmtlZCA/IFJlbW90ZTxUPiA6IFQ7XG4vKipcbiAqIEludmVyc2Ugb2YgYFByb3h5T3JDbG9uZTxUPmAuXG4gKi9cbmV4cG9ydCB0eXBlIFVucHJveHlPckNsb25lPFQ+ID0gVCBleHRlbmRzIFJlbW90ZU9iamVjdDxQcm94eU1hcmtlZD5cbiAgPyBMb2NhbDxUPlxuICA6IFQ7XG5cbi8qKlxuICogVGFrZXMgdGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIG9iamVjdCBpbiB0aGUgb3RoZXIgdGhyZWFkIGFuZCByZXR1cm5zIHRoZSB0eXBlIGFzIGl0IGlzIHZpc2libGUgdG8gdGhlIGxvY2FsIHRocmVhZFxuICogd2hlbiBwcm94aWVkIHdpdGggYENvbWxpbmsucHJveHkoKWAuXG4gKlxuICogVGhpcyBkb2VzIG5vdCBoYW5kbGUgY2FsbCBzaWduYXR1cmVzLCB3aGljaCBpcyBoYW5kbGVkIGJ5IHRoZSBtb3JlIGdlbmVyYWwgYFJlbW90ZTxUPmAgdHlwZS5cbiAqXG4gKiBAdGVtcGxhdGUgVCBUaGUgcmF3IHR5cGUgb2YgYSByZW1vdGUgb2JqZWN0IGFzIHNlZW4gaW4gdGhlIG90aGVyIHRocmVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVtb3RlT2JqZWN0PFQ+ID0geyBbUCBpbiBrZXlvZiBUXTogUmVtb3RlUHJvcGVydHk8VFtQXT4gfTtcbi8qKlxuICogVGFrZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0IGFzIGEgcmVtb3RlIHRocmVhZCB3b3VsZCBzZWUgaXQgdGhyb3VnaCBhIHByb3h5IChlLmcuIHdoZW4gcGFzc2VkIGluIGFzIGEgZnVuY3Rpb25cbiAqIGFyZ3VtZW50KSBhbmQgcmV0dXJucyB0aGUgdHlwZSB0aGF0IHRoZSBsb2NhbCB0aHJlYWQgaGFzIHRvIHN1cHBseS5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IGhhbmRsZSBjYWxsIHNpZ25hdHVyZXMsIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhlIG1vcmUgZ2VuZXJhbCBgTG9jYWw8VD5gIHR5cGUuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgUmVtb3RlT2JqZWN0PFQ+YC5cbiAqXG4gKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBhIHByb3hpZWQgb2JqZWN0LlxuICovXG5leHBvcnQgdHlwZSBMb2NhbE9iamVjdDxUPiA9IHsgW1AgaW4ga2V5b2YgVF06IExvY2FsUHJvcGVydHk8VFtQXT4gfTtcblxuLyoqXG4gKiBBZGRpdGlvbmFsIHNwZWNpYWwgY29tbGluayBtZXRob2RzIGF2YWlsYWJsZSBvbiBlYWNoIHByb3h5IHJldHVybmVkIGJ5IGBDb21saW5rLndyYXAoKWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJveHlNZXRob2RzIHtcbiAgW2NyZWF0ZUVuZHBvaW50XTogKCkgPT4gUHJvbWlzZTxNZXNzYWdlUG9ydD47XG4gIFtyZWxlYXNlUHJveHldOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHJlbW90ZSBvYmplY3QsIGZ1bmN0aW9uIG9yIGNsYXNzIGluIHRoZSBvdGhlciB0aHJlYWQgYW5kIHJldHVybnMgdGhlIHR5cGUgYXMgaXQgaXMgdmlzaWJsZSB0b1xuICogdGhlIGxvY2FsIHRocmVhZCBmcm9tIHRoZSBwcm94eSByZXR1cm4gdmFsdWUgb2YgYENvbWxpbmsud3JhcCgpYCBvciBgQ29tbGluay5wcm94eSgpYC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVtb3RlPFQ+ID1cbiAgLy8gSGFuZGxlIHByb3BlcnRpZXNcbiAgUmVtb3RlT2JqZWN0PFQ+ICZcbiAgICAvLyBIYW5kbGUgY2FsbCBzaWduYXR1cmUgKGlmIHByZXNlbnQpXG4gICAgKFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgVEFyZ3VtZW50cykgPT4gaW5mZXIgVFJldHVyblxuICAgICAgPyAoXG4gICAgICAgICAgLi4uYXJnczogeyBbSSBpbiBrZXlvZiBUQXJndW1lbnRzXTogVW5wcm94eU9yQ2xvbmU8VEFyZ3VtZW50c1tJXT4gfVxuICAgICAgICApID0+IFByb21pc2lmeTxQcm94eU9yQ2xvbmU8VW5wcm9taXNpZnk8VFJldHVybj4+PlxuICAgICAgOiB1bmtub3duKSAmXG4gICAgLy8gSGFuZGxlIGNvbnN0cnVjdCBzaWduYXR1cmUgKGlmIHByZXNlbnQpXG4gICAgLy8gVGhlIHJldHVybiBvZiBjb25zdHJ1Y3Qgc2lnbmF0dXJlcyBpcyBhbHdheXMgcHJveGllZCAod2hldGhlciBtYXJrZWQgb3Igbm90KVxuICAgIChUIGV4dGVuZHMgeyBuZXcgKC4uLmFyZ3M6IGluZmVyIFRBcmd1bWVudHMpOiBpbmZlciBUSW5zdGFuY2UgfVxuICAgICAgPyB7XG4gICAgICAgICAgbmV3IChcbiAgICAgICAgICAgIC4uLmFyZ3M6IHtcbiAgICAgICAgICAgICAgW0kgaW4ga2V5b2YgVEFyZ3VtZW50c106IFVucHJveHlPckNsb25lPFRBcmd1bWVudHNbSV0+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk6IFByb21pc2lmeTxSZW1vdGU8VEluc3RhbmNlPj47XG4gICAgICAgIH1cbiAgICAgIDogdW5rbm93bikgJlxuICAgIC8vIEluY2x1ZGUgYWRkaXRpb25hbCBzcGVjaWFsIGNvbWxpbmsgbWV0aG9kcyBhdmFpbGFibGUgb24gdGhlIHByb3h5LlxuICAgIFByb3h5TWV0aG9kcztcblxuLyoqXG4gKiBFeHByZXNzZXMgdGhhdCBhIHR5cGUgY2FuIGJlIGVpdGhlciBhIHN5bmMgb3IgYXN5bmMuXG4gKi9cbnR5cGUgTWF5YmVQcm9taXNlPFQ+ID0gUHJvbWlzZTxUPiB8IFQ7XG5cbi8qKlxuICogVGFrZXMgdGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIG9iamVjdCwgZnVuY3Rpb24gb3IgY2xhc3MgYXMgYSByZW1vdGUgdGhyZWFkIHdvdWxkIHNlZSBpdCB0aHJvdWdoIGEgcHJveHkgKGUuZy4gd2hlblxuICogcGFzc2VkIGluIGFzIGEgZnVuY3Rpb24gYXJndW1lbnQpIGFuZCByZXR1cm5zIHRoZSB0eXBlIHRoZSBsb2NhbCB0aHJlYWQgaGFzIHRvIHN1cHBseS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGBSZW1vdGU8VD5gLiBJdCB0YWtlcyBhIGBSZW1vdGU8VD5gIGFuZCByZXR1cm5zIGl0cyBvcmlnaW5hbCBpbnB1dCBgVGAuXG4gKi9cbmV4cG9ydCB0eXBlIExvY2FsPFQ+ID1cbiAgLy8gT21pdCB0aGUgc3BlY2lhbCBwcm94eSBtZXRob2RzICh0aGV5IGRvbid0IG5lZWQgdG8gYmUgc3VwcGxpZWQsIGNvbWxpbmsgYWRkcyB0aGVtKVxuICBPbWl0PExvY2FsT2JqZWN0PFQ+LCBrZXlvZiBQcm94eU1ldGhvZHM+ICZcbiAgICAvLyBIYW5kbGUgY2FsbCBzaWduYXR1cmVzIChpZiBwcmVzZW50KVxuICAgIChUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFRBcmd1bWVudHMpID0+IGluZmVyIFRSZXR1cm5cbiAgICAgID8gKFxuICAgICAgICAgIC4uLmFyZ3M6IHsgW0kgaW4ga2V5b2YgVEFyZ3VtZW50c106IFByb3h5T3JDbG9uZTxUQXJndW1lbnRzW0ldPiB9XG4gICAgICAgICkgPT4gLy8gVGhlIHJhdyBmdW5jdGlvbiBjb3VsZCBlaXRoZXIgYmUgc3luYyBvciBhc3luYywgYnV0IGlzIGFsd2F5cyBwcm94aWVkIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgTWF5YmVQcm9taXNlPFVucHJveHlPckNsb25lPFVucHJvbWlzaWZ5PFRSZXR1cm4+Pj5cbiAgICAgIDogdW5rbm93bikgJlxuICAgIC8vIEhhbmRsZSBjb25zdHJ1Y3Qgc2lnbmF0dXJlIChpZiBwcmVzZW50KVxuICAgIC8vIFRoZSByZXR1cm4gb2YgY29uc3RydWN0IHNpZ25hdHVyZXMgaXMgYWx3YXlzIHByb3hpZWQgKHdoZXRoZXIgbWFya2VkIG9yIG5vdClcbiAgICAoVCBleHRlbmRzIHsgbmV3ICguLi5hcmdzOiBpbmZlciBUQXJndW1lbnRzKTogaW5mZXIgVEluc3RhbmNlIH1cbiAgICAgID8ge1xuICAgICAgICAgIG5ldyAoXG4gICAgICAgICAgICAuLi5hcmdzOiB7XG4gICAgICAgICAgICAgIFtJIGluIGtleW9mIFRBcmd1bWVudHNdOiBQcm94eU9yQ2xvbmU8VEFyZ3VtZW50c1tJXT47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTogLy8gVGhlIHJhdyBjb25zdHJ1Y3RvciBjb3VsZCBlaXRoZXIgYmUgc3luYyBvciBhc3luYywgYnV0IGlzIGFsd2F5cyBwcm94aWVkIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICBNYXliZVByb21pc2U8TG9jYWw8VW5wcm9taXNpZnk8VEluc3RhbmNlPj4+O1xuICAgICAgICB9XG4gICAgICA6IHVua25vd24pO1xuXG5jb25zdCBpc09iamVjdCA9ICh2YWw6IHVua25vd24pOiB2YWwgaXMgb2JqZWN0ID0+XG4gICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vKipcbiAqIEN1c3RvbWl6ZXMgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMgYXMgZGV0ZXJtaW5lZCBieSBgY2FuSGFuZGxlKClgLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIFRoZSBpbnB1dCB0eXBlIGJlaW5nIGhhbmRsZWQgYnkgdGhpcyB0cmFuc2ZlciBoYW5kbGVyLlxuICogQHRlbXBsYXRlIFMgVGhlIHNlcmlhbGl6ZWQgdHlwZSBzZW50IG92ZXIgdGhlIHdpcmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJIYW5kbGVyPFQsIFM+IHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGZvciBldmVyeSB2YWx1ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHRyYW5zZmVyIGhhbmRsZXJcbiAgICogc2hvdWxkIHNlcmlhbGl6ZSB0aGUgdmFsdWUsIHdoaWNoIGluY2x1ZGVzIGNoZWNraW5nIHRoYXQgaXQgaXMgb2YgdGhlIHJpZ2h0XG4gICAqIHR5cGUgKGJ1dCBjYW4gcGVyZm9ybSBjaGVja3MgYmV5b25kIHRoYXQgYXMgd2VsbCkuXG4gICAqL1xuICBjYW5IYW5kbGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUO1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBpZiBgY2FuSGFuZGxlKClgIHJldHVybmVkIGB0cnVlYCB0byBwcm9kdWNlIGFcbiAgICogdmFsdWUgdGhhdCBjYW4gYmUgc2VudCBpbiBhIG1lc3NhZ2UsIGNvbnNpc3Rpbmcgb2Ygc3RydWN0dXJlZC1jbG9uZWFibGVcbiAgICogdmFsdWVzIGFuZC9vciB0cmFuc2ZlcnJhYmxlIG9iamVjdHMuXG4gICAqL1xuICBzZXJpYWxpemUodmFsdWU6IFQpOiBbUywgVHJhbnNmZXJhYmxlW11dO1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB0byBkZXNlcmlhbGl6ZSBhbiBpbmNvbWluZyB2YWx1ZSB0aGF0IHdhcyBzZXJpYWxpemVkIGluIHRoZVxuICAgKiBvdGhlciB0aHJlYWQgd2l0aCB0aGlzIHRyYW5zZmVyIGhhbmRsZXIgKGtub3duIHRocm91Z2ggdGhlIG5hbWUgaXQgd2FzXG4gICAqIHJlZ2lzdGVyZWQgdW5kZXIpLlxuICAgKi9cbiAgZGVzZXJpYWxpemUodmFsdWU6IFMpOiBUO1xufVxuXG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZSB0byBoYW5kbGUgb2JqZWN0cyBtYXJrZWQgdG8gcHJveHkuXG4gKi9cbmNvbnN0IHByb3h5VHJhbnNmZXJIYW5kbGVyOiBUcmFuc2ZlckhhbmRsZXI8b2JqZWN0LCBNZXNzYWdlUG9ydD4gPSB7XG4gIGNhbkhhbmRsZTogKHZhbCk6IHZhbCBpcyBQcm94eU1hcmtlZCA9PlxuICAgIGlzT2JqZWN0KHZhbCkgJiYgKHZhbCBhcyBQcm94eU1hcmtlZClbcHJveHlNYXJrZXJdLFxuICBzZXJpYWxpemUob2JqKSB7XG4gICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGV4cG9zZShvYmosIHBvcnQxKTtcbiAgICByZXR1cm4gW3BvcnQyLCBbcG9ydDJdXTtcbiAgfSxcbiAgZGVzZXJpYWxpemUocG9ydCkge1xuICAgIHBvcnQuc3RhcnQoKTtcbiAgICByZXR1cm4gd3JhcChwb3J0KTtcbiAgfSxcbn07XG5cbmludGVyZmFjZSBUaHJvd25WYWx1ZSB7XG4gIFt0aHJvd01hcmtlcl06IHVua25vd247IC8vIGp1c3QgbmVlZHMgdG8gYmUgcHJlc2VudFxuICB2YWx1ZTogdW5rbm93bjtcbn1cbnR5cGUgU2VyaWFsaXplZFRocm93blZhbHVlID1cbiAgfCB7IGlzRXJyb3I6IHRydWU7IHZhbHVlOiBFcnJvciB9XG4gIHwgeyBpc0Vycm9yOiBmYWxzZTsgdmFsdWU6IHVua25vd24gfTtcblxuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGVyIHRvIGhhbmRsZSB0aHJvd24gZXhjZXB0aW9ucy5cbiAqL1xuY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXI6IFRyYW5zZmVySGFuZGxlcjxcbiAgVGhyb3duVmFsdWUsXG4gIFNlcmlhbGl6ZWRUaHJvd25WYWx1ZVxuPiA9IHtcbiAgY2FuSGFuZGxlOiAodmFsdWUpOiB2YWx1ZSBpcyBUaHJvd25WYWx1ZSA9PlxuICAgIGlzT2JqZWN0KHZhbHVlKSAmJiB0aHJvd01hcmtlciBpbiB2YWx1ZSxcbiAgc2VyaWFsaXplKHsgdmFsdWUgfSkge1xuICAgIGxldCBzZXJpYWxpemVkOiBTZXJpYWxpemVkVGhyb3duVmFsdWU7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbWVzc2FnZTogdmFsdWUubWVzc2FnZSxcbiAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjayxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSB7IGlzRXJyb3I6IGZhbHNlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTtcbiAgfSxcbiAgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBFcnJvcihzZXJpYWxpemVkLnZhbHVlLm1lc3NhZ2UpLFxuICAgICAgICBzZXJpYWxpemVkLnZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlO1xuICB9LFxufTtcblxuLyoqXG4gKiBBbGxvd3MgY3VzdG9taXppbmcgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlckhhbmRsZXJzID0gbmV3IE1hcDxcbiAgc3RyaW5nLFxuICBUcmFuc2ZlckhhbmRsZXI8dW5rbm93biwgdW5rbm93bj5cbj4oW1xuICBbXCJwcm94eVwiLCBwcm94eVRyYW5zZmVySGFuZGxlcl0sXG4gIFtcInRocm93XCIsIHRocm93VHJhbnNmZXJIYW5kbGVyXSxcbl0pO1xuXG5mdW5jdGlvbiBpc0FsbG93ZWRPcmlnaW4oXG4gIGFsbG93ZWRPcmlnaW5zOiAoc3RyaW5nIHwgUmVnRXhwKVtdLFxuICBvcmlnaW46IHN0cmluZ1xuKTogYm9vbGVhbiB7XG4gIGZvciAoY29uc3QgYWxsb3dlZE9yaWdpbiBvZiBhbGxvd2VkT3JpZ2lucykge1xuICAgIGlmIChvcmlnaW4gPT09IGFsbG93ZWRPcmlnaW4gfHwgYWxsb3dlZE9yaWdpbiA9PT0gXCIqXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dlZE9yaWdpbiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9zZShcbiAgb2JqOiBhbnksXG4gIGVwOiBFbmRwb2ludCA9IGdsb2JhbFRoaXMgYXMgYW55LFxuICBhbGxvd2VkT3JpZ2luczogKHN0cmluZyB8IFJlZ0V4cClbXSA9IFtcIipcIl1cbikge1xuICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBjYWxsYmFjayhldjogTWVzc2FnZUV2ZW50KSB7XG4gICAgaWYgKCFldiB8fCAhZXYuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgZXYub3JpZ2luKSkge1xuICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIG9yaWdpbiAnJHtldi5vcmlnaW59JyBmb3IgY29tbGluayBwcm94eWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCB0eXBlLCBwYXRoIH0gPSB7XG4gICAgICBwYXRoOiBbXSBhcyBzdHJpbmdbXSxcbiAgICAgIC4uLihldi5kYXRhIGFzIE1lc3NhZ2UpLFxuICAgIH07XG4gICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgY29uc3QgcmF3VmFsdWUgPSBwYXRoLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5HRVQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhcmVudFtwYXRoLnNsaWNlKC0xKVswXV0gPSBmcm9tV2lyZVZhbHVlKGV2LmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5BUFBMWTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ09OU1RSVUNUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb3h5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRU5EUE9JTlQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDIpO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlJFTEVBU0U6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoICh2YWx1ZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgfVxuICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSlcbiAgICAgIC5jYXRjaCgodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgIH0pXG4gICAgICAudGhlbigocmV0dXJuVmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgIGVwLnBvc3RNZXNzYWdlKHsgLi4ud2lyZVZhbHVlLCBpZCB9LCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IE1lc3NhZ2VUeXBlLlJFTEVBU0UpIHtcbiAgICAgICAgICAvLyBkZXRhY2ggYW5kIGRlYWN0aXZlIGFmdGVyIHNlbmRpbmcgcmVsZWFzZSByZXNwb25zZSBhYm92ZS5cbiAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjYWxsYmFjayBhcyBhbnkpO1xuICAgICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZXIgaW4gb2JqICYmIHR5cGVvZiBvYmpbZmluYWxpemVyXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvYmpbZmluYWxpemVyXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgLy8gU2VuZCBTZXJpYWxpemF0aW9uIEVycm9yIFRvIENhbGxlclxuICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHtcbiAgICAgICAgICB2YWx1ZTogbmV3IFR5cGVFcnJvcihcIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZVwiKSxcbiAgICAgICAgICBbdGhyb3dNYXJrZXJdOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZXAucG9zdE1lc3NhZ2UoeyAuLi53aXJlVmFsdWUsIGlkIH0sIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgfSk7XG4gIH0gYXMgYW55KTtcbiAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgZXAuc3RhcnQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGVuZHBvaW50OiBFbmRwb2ludCk6IGVuZHBvaW50IGlzIE1lc3NhZ2VQb3J0IHtcbiAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTWVzc2FnZVBvcnRcIjtcbn1cblxuZnVuY3Rpb24gY2xvc2VFbmRQb2ludChlbmRwb2ludDogRW5kcG9pbnQpIHtcbiAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKSBlbmRwb2ludC5jbG9zZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcDxUPihlcDogRW5kcG9pbnQsIHRhcmdldD86IGFueSk6IFJlbW90ZTxUPiB7XG4gIHJldHVybiBjcmVhdGVQcm94eTxUPihlcCwgW10sIHRhcmdldCkgYXMgYW55O1xufVxuXG5mdW5jdGlvbiB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1JlbGVhc2VkOiBib29sZWFuKSB7XG4gIGlmIChpc1JlbGVhc2VkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgaGFzIGJlZW4gcmVsZWFzZWQgYW5kIGlzIG5vdCB1c2VhYmxlXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VFbmRwb2ludChlcDogRW5kcG9pbnQpIHtcbiAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHtcbiAgICB0eXBlOiBNZXNzYWdlVHlwZS5SRUxFQVNFLFxuICB9KS50aGVuKCgpID0+IHtcbiAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgfSk7XG59XG5cbmludGVyZmFjZSBGaW5hbGl6YXRpb25SZWdpc3RyeTxUPiB7XG4gIG5ldyAoY2I6IChoZWxkVmFsdWU6IFQpID0+IHZvaWQpOiBGaW5hbGl6YXRpb25SZWdpc3RyeTxUPjtcbiAgcmVnaXN0ZXIoXG4gICAgd2Vha0l0ZW06IG9iamVjdCxcbiAgICBoZWxkVmFsdWU6IFQsXG4gICAgdW5yZWdpc3RlclRva2VuPzogb2JqZWN0IHwgdW5kZWZpbmVkXG4gICk6IHZvaWQ7XG4gIHVucmVnaXN0ZXIodW5yZWdpc3RlclRva2VuOiBvYmplY3QpOiB2b2lkO1xufVxuZGVjbGFyZSB2YXIgRmluYWxpemF0aW9uUmVnaXN0cnk6IEZpbmFsaXphdGlvblJlZ2lzdHJ5PEVuZHBvaW50PjtcblxuY29uc3QgcHJveHlDb3VudGVyID0gbmV3IFdlYWtNYXA8RW5kcG9pbnQsIG51bWJlcj4oKTtcbmNvbnN0IHByb3h5RmluYWxpemVycyA9XG4gIFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIiBpbiBnbG9iYWxUaGlzICYmXG4gIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXA6IEVuZHBvaW50KSA9PiB7XG4gICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgLSAxO1xuICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICBpZiAobmV3Q291bnQgPT09IDApIHtcbiAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgfVxuICB9KTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJQcm94eShwcm94eTogb2JqZWN0LCBlcDogRW5kcG9pbnQpIHtcbiAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgKyAxO1xuICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICBwcm94eUZpbmFsaXplcnMucmVnaXN0ZXIocHJveHksIGVwLCBwcm94eSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5yZWdpc3RlclByb3h5KHByb3h5OiBvYmplY3QpIHtcbiAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgIHByb3h5RmluYWxpemVycy51bnJlZ2lzdGVyKHByb3h5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eTxUPihcbiAgZXA6IEVuZHBvaW50LFxuICBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKVtdID0gW10sXG4gIHRhcmdldDogb2JqZWN0ID0gZnVuY3Rpb24gKCkge31cbik6IFJlbW90ZTxUPiB7XG4gIGxldCBpc1Byb3h5UmVsZWFzZWQgPSBmYWxzZTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgZ2V0KF90YXJnZXQsIHByb3ApIHtcbiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICBpZiAocHJvcCA9PT0gcmVsZWFzZVByb3h5KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgdW5yZWdpc3RlclByb3h5KHByb3h5KTtcbiAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICAgIGlzUHJveHlSZWxlYXNlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwge1xuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkdFVCxcbiAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHIudGhlbi5iaW5kKHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBbLi4ucGF0aCwgcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7XG4gICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgXHUwMEFGXFxfKFx1MzBDNClfL1x1MDBBRlxuICAgICAgY29uc3QgW3ZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKFxuICAgICAgICBlcCxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFVCxcbiAgICAgICAgICBwYXRoOiBbLi4ucGF0aCwgcHJvcF0ubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICApLnRoZW4oZnJvbVdpcmVWYWx1ZSkgYXMgYW55O1xuICAgIH0sXG4gICAgYXBwbHkoX3RhcmdldCwgX3RoaXNBcmcsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoKGxhc3QgYXMgYW55KSA9PT0gY3JlYXRlRW5kcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHtcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5FTkRQT0lOVCxcbiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGp1c3QgcHJldGVuZCB0aGF0IGBiaW5kKClgIGRpZG5cdTIwMTl0IGhhcHBlbi5cbiAgICAgIGlmIChsYXN0ID09PSBcImJpbmRcIikge1xuICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpO1xuICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoXG4gICAgICAgIGVwLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQVBQTFksXG4gICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICApLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgfSxcbiAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShcbiAgICAgICAgZXAsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QsXG4gICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzXG4gICAgICApLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgfSxcbiAgfSk7XG4gIHJlZ2lzdGVyUHJveHkocHJveHksIGVwKTtcbiAgcmV0dXJuIHByb3h5IGFzIGFueTtcbn1cblxuZnVuY3Rpb24gbXlGbGF0PFQ+KGFycjogKFQgfCBUW10pW10pOiBUW10ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3Q6IGFueVtdKTogW1dpcmVWYWx1ZVtdLCBUcmFuc2ZlcmFibGVbXV0ge1xuICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTtcbiAgcmV0dXJuIFtwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzBdKSwgbXlGbGF0KHByb2Nlc3NlZC5tYXAoKHYpID0+IHZbMV0pKV07XG59XG5cbmNvbnN0IHRyYW5zZmVyQ2FjaGUgPSBuZXcgV2Vha01hcDxhbnksIFRyYW5zZmVyYWJsZVtdPigpO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZmVyPFQ+KG9iajogVCwgdHJhbnNmZXJzOiBUcmFuc2ZlcmFibGVbXSk6IFQge1xuICB0cmFuc2ZlckNhY2hlLnNldChvYmosIHRyYW5zZmVycyk7XG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm94eTxUIGV4dGVuZHMge30+KG9iajogVCk6IFQgJiBQcm94eU1hcmtlZCB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgeyBbcHJveHlNYXJrZXJdOiB0cnVlIH0pIGFzIGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpbmRvd0VuZHBvaW50KFxuICB3OiBQb3N0TWVzc2FnZVdpdGhPcmlnaW4sXG4gIGNvbnRleHQ6IEV2ZW50U291cmNlID0gZ2xvYmFsVGhpcyxcbiAgdGFyZ2V0T3JpZ2luID0gXCIqXCJcbik6IEVuZHBvaW50IHtcbiAgcmV0dXJuIHtcbiAgICBwb3N0TWVzc2FnZTogKG1zZzogYW55LCB0cmFuc2ZlcmFibGVzOiBUcmFuc2ZlcmFibGVbXSkgPT5cbiAgICAgIHcucG9zdE1lc3NhZ2UobXNnLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b1dpcmVWYWx1ZSh2YWx1ZTogYW55KTogW1dpcmVWYWx1ZSwgVHJhbnNmZXJhYmxlW11dIHtcbiAgZm9yIChjb25zdCBbbmFtZSwgaGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgIGlmIChoYW5kbGVyLmNhbkhhbmRsZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFdpcmVWYWx1ZVR5cGUuSEFORExFUixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZXMsXG4gICAgICBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFdpcmVWYWx1ZVR5cGUuUkFXLFxuICAgICAgdmFsdWUsXG4gICAgfSxcbiAgICB0cmFuc2ZlckNhY2hlLmdldCh2YWx1ZSkgfHwgW10sXG4gIF07XG59XG5cbmZ1bmN0aW9uIGZyb21XaXJlVmFsdWUodmFsdWU6IFdpcmVWYWx1ZSk6IGFueSB7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgV2lyZVZhbHVlVHlwZS5IQU5ETEVSOlxuICAgICAgcmV0dXJuIHRyYW5zZmVySGFuZGxlcnMuZ2V0KHZhbHVlLm5hbWUpIS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7XG4gICAgY2FzZSBXaXJlVmFsdWVUeXBlLlJBVzpcbiAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKFxuICBlcDogRW5kcG9pbnQsXG4gIG1zZzogTWVzc2FnZSxcbiAgdHJhbnNmZXJzPzogVHJhbnNmZXJhYmxlW11cbik6IFByb21pc2U8V2lyZVZhbHVlPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gbChldjogTWVzc2FnZUV2ZW50KSB7XG4gICAgICBpZiAoIWV2LmRhdGEgfHwgIWV2LmRhdGEuaWQgfHwgZXYuZGF0YS5pZCAhPT0gaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbCBhcyBhbnkpO1xuICAgICAgcmVzb2x2ZShldi5kYXRhKTtcbiAgICB9IGFzIGFueSk7XG4gICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICBlcC5zdGFydCgpO1xuICAgIH1cbiAgICBlcC5wb3N0TWVzc2FnZSh7IGlkLCAuLi5tc2cgfSwgdHJhbnNmZXJzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IEFycmF5KDQpXG4gICAgLmZpbGwoMClcbiAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpXG4gICAgLmpvaW4oXCItXCIpO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBjb25zdGFudHNcbiAqIEBzdW1tYXJ5IFVzZWZ1bCBjb25zdGFudHNcbiAqIEBkZXNjcmlwdGlvblxuICogQ29sbGVjdGlvbiBvZiB1c2VmdWwgZGF0ZSBjb25zdGFudHMuXG4gKlxuICogVGhlIGNvbnN0YW50cyBjb3VsZCBiZSBpbXBvcnRlZCBmcm9tIGBkYXRlLWZucy9jb25zdGFudHNgOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBtYXhUaW1lLCBtaW5UaW1lIH0gZnJvbSBcIi4vY29uc3RhbnRzL2RhdGUtZm5zL2NvbnN0YW50c1wiO1xuICpcbiAqIGZ1bmN0aW9uIGlzQWxsb3dlZFRpbWUodGltZSkge1xuICogICByZXR1cm4gdGltZSA8PSBtYXhUaW1lICYmIHRpbWUgPj0gbWluVGltZTtcbiAqIH1cbiAqIGBgYFxuICovXG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBkYXlzSW5XZWVrXG4gKiBAc3VtbWFyeSBEYXlzIGluIDEgd2Vlay5cbiAqL1xuZXhwb3J0IGNvbnN0IGRheXNJbldlZWsgPSA3O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgZGF5c0luWWVhclxuICogQHN1bW1hcnkgRGF5cyBpbiAxIHllYXIuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBIb3cgbWFueSBkYXlzIGluIGEgeWVhci5cbiAqXG4gKiBPbmUgeWVhcnMgZXF1YWxzIDM2NS4yNDI1IGRheXMgYWNjb3JkaW5nIHRvIHRoZSBmb3JtdWxhOlxuICpcbiAqID4gTGVhcCB5ZWFyIG9jY3VycyBldmVyeSA0IHllYXJzLCBleGNlcHQgZm9yIHllYXJzIHRoYXQgYXJlIGRpdmlzaWJsZSBieSAxMDAgYW5kIG5vdCBkaXZpc2libGUgYnkgNDAwLlxuICogPiAxIG1lYW4geWVhciA9ICgzNjUrMS80LTEvMTAwKzEvNDAwKSBkYXlzID0gMzY1LjI0MjUgZGF5c1xuICovXG5leHBvcnQgY29uc3QgZGF5c0luWWVhciA9IDM2NS4yNDI1O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWF4VGltZVxuICogQHN1bW1hcnkgTWF4aW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IG1heFRpbWUgfSBmcm9tIFwiLi9jb25zdGFudHMvZGF0ZS1mbnMvY29uc3RhbnRzXCI7XG4gKlxuICogY29uc3QgaXNWYWxpZCA9IDg2NDAwMDAwMDAwMDAwMDEgPD0gbWF4VGltZTtcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBuZXcgRGF0ZSg4NjQwMDAwMDAwMDAwMDAxKTtcbiAqIC8vPT4gSW52YWxpZCBEYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBtYXhUaW1lID0gTWF0aC5wb3coMTAsIDgpICogMjQgKiA2MCAqIDYwICogMTAwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pblRpbWVcbiAqIEBzdW1tYXJ5IE1pbmltdW0gYWxsb3dlZCB0aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBtaW5UaW1lIH0gZnJvbSBcIi4vY29uc3RhbnRzL2RhdGUtZm5zL2NvbnN0YW50c1wiO1xuICpcbiAqIGNvbnN0IGlzVmFsaWQgPSAtODY0MDAwMDAwMDAwMDAwMSA+PSBtaW5UaW1lO1xuICogLy89PiBmYWxzZVxuICpcbiAqIG5ldyBEYXRlKC04NjQwMDAwMDAwMDAwMDAxKVxuICogLy89PiBJbnZhbGlkIERhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG1pblRpbWUgPSAtbWF4VGltZTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luV2Vla1xuICogQHN1bW1hcnkgTWlsbGlzZWNvbmRzIGluIDEgd2Vlay5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbGxpc2Vjb25kc0luV2VlayA9IDYwNDgwMDAwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luRGF5XG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSBkYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBtaWxsaXNlY29uZHNJbkRheSA9IDg2NDAwMDAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5NaW51dGVcbiAqIEBzdW1tYXJ5IE1pbGxpc2Vjb25kcyBpbiAxIG1pbnV0ZVxuICovXG5leHBvcnQgY29uc3QgbWlsbGlzZWNvbmRzSW5NaW51dGUgPSA2MDAwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luSG91clxuICogQHN1bW1hcnkgTWlsbGlzZWNvbmRzIGluIDEgaG91clxuICovXG5leHBvcnQgY29uc3QgbWlsbGlzZWNvbmRzSW5Ib3VyID0gMzYwMDAwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luU2Vjb25kXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSBzZWNvbmRcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbGxpc2Vjb25kc0luU2Vjb25kID0gMTAwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbnV0ZXNJblllYXJcbiAqIEBzdW1tYXJ5IE1pbnV0ZXMgaW4gMSB5ZWFyLlxuICovXG5leHBvcnQgY29uc3QgbWludXRlc0luWWVhciA9IDUyNTYwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbnV0ZXNJbk1vbnRoXG4gKiBAc3VtbWFyeSBNaW51dGVzIGluIDEgbW9udGguXG4gKi9cbmV4cG9ydCBjb25zdCBtaW51dGVzSW5Nb250aCA9IDQzMjAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWludXRlc0luRGF5XG4gKiBAc3VtbWFyeSBNaW51dGVzIGluIDEgZGF5LlxuICovXG5leHBvcnQgY29uc3QgbWludXRlc0luRGF5ID0gMTQ0MDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbnV0ZXNJbkhvdXJcbiAqIEBzdW1tYXJ5IE1pbnV0ZXMgaW4gMSBob3VyLlxuICovXG5leHBvcnQgY29uc3QgbWludXRlc0luSG91ciA9IDYwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbW9udGhzSW5RdWFydGVyXG4gKiBAc3VtbWFyeSBNb250aHMgaW4gMSBxdWFydGVyLlxuICovXG5leHBvcnQgY29uc3QgbW9udGhzSW5RdWFydGVyID0gMztcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1vbnRoc0luWWVhclxuICogQHN1bW1hcnkgTW9udGhzIGluIDEgeWVhci5cbiAqL1xuZXhwb3J0IGNvbnN0IG1vbnRoc0luWWVhciA9IDEyO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgcXVhcnRlcnNJblllYXJcbiAqIEBzdW1tYXJ5IFF1YXJ0ZXJzIGluIDEgeWVhclxuICovXG5leHBvcnQgY29uc3QgcXVhcnRlcnNJblllYXIgPSA0O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luSG91clxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIGhvdXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5Ib3VyID0gMzYwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbk1pbnV0ZVxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIG1pbnV0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJbk1pbnV0ZSA9IDYwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luRGF5XG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgZGF5LlxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luRGF5ID0gc2Vjb25kc0luSG91ciAqIDI0O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luV2Vla1xuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIHdlZWsuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5XZWVrID0gc2Vjb25kc0luRGF5ICogNztcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJblllYXJcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSB5ZWFyLlxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luWWVhciA9IHNlY29uZHNJbkRheSAqIGRheXNJblllYXI7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5Nb250aFxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIG1vbnRoXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5Nb250aCA9IHNlY29uZHNJblllYXIgLyAxMjtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJblF1YXJ0ZXJcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSBxdWFydGVyLlxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luUXVhcnRlciA9IHNlY29uZHNJbk1vbnRoICogMztcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIGNvbnN0cnVjdEZyb21TeW1ib2xcbiAqIEBzdW1tYXJ5IFN5bWJvbCBlbmFibGluZyBEYXRlIGV4dGVuc2lvbnMgdG8gaW5oZXJpdCBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlZmVyZW5jZSBkYXRlLlxuICpcbiAqIFRoZSBzeW1ib2wgaXMgdXNlZCB0byBlbmFibGUgdGhlIGBjb25zdHJ1Y3RGcm9tYCBmdW5jdGlvbiB0byBjb25zdHJ1Y3QgYSBkYXRlXG4gKiB1c2luZyBhIHJlZmVyZW5jZSBkYXRlIGFuZCBhIHZhbHVlLiBJdCBhbGxvd3MgdG8gdHJhbnNmZXIgZXh0cmEgcHJvcGVydGllc1xuICogZnJvbSB0aGUgcmVmZXJlbmNlIGRhdGUgdG8gdGhlIG5ldyBkYXRlLiBJdCdzIHVzZWZ1bCBmb3IgZXh0ZW5zaW9ucyBsaWtlXG4gKiBbYFRaRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy90eikgdGhhdCBhY2NlcHQgYSB0aW1lIHpvbmUgYXNcbiAqIGEgY29uc3RydWN0b3IgYXJndW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3RGcm9tU3ltYm9sID0gU3ltYm9sLmZvcihcImNvbnN0cnVjdERhdGVGcm9tXCIpO1xuIiwgImltcG9ydCB7IGNvbnN0cnVjdEZyb21TeW1ib2wgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcblxuLyoqXG4gKiBAbmFtZSBjb25zdHJ1Y3RGcm9tXG4gKiBAY2F0ZWdvcnkgR2VuZXJpYyBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb25zdHJ1Y3RzIGEgZGF0ZSB1c2luZyB0aGUgcmVmZXJlbmNlIGRhdGUgYW5kIHRoZSB2YWx1ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGZ1bmN0aW9uIGNvbnN0cnVjdHMgYSBuZXcgZGF0ZSB1c2luZyB0aGUgY29uc3RydWN0b3IgZnJvbSB0aGUgcmVmZXJlbmNlXG4gKiBkYXRlIGFuZCB0aGUgZ2l2ZW4gdmFsdWUuIEl0IGhlbHBzIHRvIGJ1aWxkIGdlbmVyaWMgZnVuY3Rpb25zIHRoYXQgYWNjZXB0XG4gKiBkYXRlIGV4dGVuc2lvbnMuXG4gKlxuICogSXQgZGVmYXVsdHMgdG8gYERhdGVgIGlmIHRoZSBwYXNzZWQgcmVmZXJlbmNlIGRhdGUgaXMgYSBudW1iZXIgb3IgYSBzdHJpbmcuXG4gKlxuICogU3RhcnRpbmcgZnJvbSB2My43LjAsIGl0IGFsbG93cyB0byBjb25zdHJ1Y3QgYSBkYXRlIHVzaW5nIGBbU3ltYm9sLmZvcihcImNvbnN0cnVjdERhdGVGcm9tXCIpXWBcbiAqIGVuYWJsaW5nIHRvIHRyYW5zZmVyIGV4dHJhIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVmZXJlbmNlIGRhdGUgdG8gdGhlIG5ldyBkYXRlLlxuICogSXQncyB1c2VmdWwgZm9yIGV4dGVuc2lvbnMgbGlrZSBbYFRaRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy90eilcbiAqIHRoYXQgYWNjZXB0IGEgdGltZSB6b25lIGFzIGEgY29uc3RydWN0b3IgYXJndW1lbnQuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgcmVmZXJlbmNlIGRhdGUgdG8gdGFrZSBjb25zdHJ1Y3RvciBmcm9tXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBkYXRlXG4gKlxuICogQHJldHVybnMgRGF0ZSBpbml0aWFsaXplZCB1c2luZyB0aGUgZ2l2ZW4gZGF0ZSBhbmQgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20vZGF0ZS1mbnNcIjtcbiAqXG4gKiAvLyBBIGZ1bmN0aW9uIHRoYXQgY2xvbmVzIGEgZGF0ZSBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCB0eXBlXG4gKiBmdW5jdGlvbiBjbG9uZURhdGU8RGF0ZVR5cGUgZXh0ZW5kcyBEYXRlPihkYXRlOiBEYXRlVHlwZSk6IERhdGVUeXBlIHtcbiAqICAgcmV0dXJuIGNvbnN0cnVjdEZyb20oXG4gKiAgICAgZGF0ZSwgLy8gVXNlIGNvbnN0cnVjdG9yIGZyb20gdGhlIGdpdmVuIGRhdGVcbiAqICAgICBkYXRlLmdldFRpbWUoKSAvLyBVc2UgdGhlIGRhdGUgdmFsdWUgdG8gY3JlYXRlIGEgbmV3IGRhdGVcbiAqICAgKTtcbiAqIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEZyb20oZGF0ZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBkYXRlKHZhbHVlKTtcblxuICBpZiAoZGF0ZSAmJiB0eXBlb2YgZGF0ZSA9PT0gXCJvYmplY3RcIiAmJiBjb25zdHJ1Y3RGcm9tU3ltYm9sIGluIGRhdGUpXG4gICAgcmV0dXJuIGRhdGVbY29uc3RydWN0RnJvbVN5bWJvbF0odmFsdWUpO1xuXG4gIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIG5ldyBkYXRlLmNvbnN0cnVjdG9yKHZhbHVlKTtcblxuICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGNvbnN0cnVjdEZyb207XG4iLCAiaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20uanNcIjtcblxuLyoqXG4gKiBAbmFtZSB0b0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogU3RhcnRpbmcgZnJvbSB2My43LjAsIGl0IGNsb25lcyBhIGRhdGUgdXNpbmcgYFtTeW1ib2wuZm9yKFwiY29uc3RydWN0RGF0ZUZyb21cIildYFxuICogZW5hYmxpbmcgdG8gdHJhbnNmZXIgZXh0cmEgcHJvcGVydGllcyBmcm9tIHRoZSByZWZlcmVuY2UgZGF0ZSB0byB0aGUgbmV3IGRhdGUuXG4gKiBJdCdzIHVzZWZ1bCBmb3IgZXh0ZW5zaW9ucyBsaWtlIFtgVFpEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3R6KVxuICogdGhhdCBhY2NlcHQgYSB0aW1lIHpvbmUgYXMgYSBjb25zdHJ1Y3RvciBhcmd1bWVudC5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqIEB0eXBlUGFyYW0gUmVzdWx0RGF0ZSAtIFRoZSByZXN1bHQgYERhdGVgIHR5cGUsIGl0IGlzIHRoZSB0eXBlIHJldHVybmVkIGZyb20gdGhlIGNvbnRleHQgZnVuY3Rpb24gaWYgaXQgaXMgcGFzc2VkLCBvciBpbmZlcnJlZCBmcm9tIHRoZSBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIGFyZ3VtZW50IC0gVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCwgY29udGV4dCkge1xuICAvLyBbVE9ET10gR2V0IHJpZCBvZiBgdG9EYXRlYCBvciBgY29uc3RydWN0RnJvbWA/XG4gIHJldHVybiBjb25zdHJ1Y3RGcm9tKGNvbnRleHQgfHwgYXJndW1lbnQsIGFyZ3VtZW50KTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCB0b0RhdGU7XG4iLCAiaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20uanNcIjtcbmltcG9ydCB7IHRvRGF0ZSB9IGZyb20gXCIuL3RvRGF0ZS5qc1wiO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgYWRkRGF5c30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGFkZERheXNcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGF5cyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqIEB0eXBlUGFyYW0gUmVzdWx0RGF0ZSAtIFRoZSByZXN1bHQgYERhdGVgIHR5cGUsIGl0IGlzIHRoZSB0eXBlIHJldHVybmVkIGZyb20gdGhlIGNvbnRleHQgZnVuY3Rpb24gaWYgaXQgaXMgcGFzc2VkLCBvciBpbmZlcnJlZCBmcm9tIHRoZSBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBkYXlzIHRvIGJlIGFkZGVkLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIGRheXMgYWRkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDEwIGRheXMgdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZERheXMobmV3IERhdGUoMjAxNCwgOCwgMSksIDEwKVxuICogLy89PiBUaHUgU2VwIDExIDIwMTQgMDA6MDA6MDBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgYW1vdW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUsIG9wdGlvbnM/LmluKTtcbiAgaWYgKGlzTmFOKGFtb3VudCkpIHJldHVybiBjb25zdHJ1Y3RGcm9tKG9wdGlvbnM/LmluIHx8IGRhdGUsIE5hTik7XG5cbiAgLy8gSWYgMCBkYXlzLCBuby1vcCB0byBhdm9pZCBjaGFuZ2luZyB0aW1lcyBpbiB0aGUgaG91ciBiZWZvcmUgZW5kIG9mIERTVFxuICBpZiAoIWFtb3VudCkgcmV0dXJuIF9kYXRlO1xuXG4gIF9kYXRlLnNldERhdGUoX2RhdGUuZ2V0RGF0ZSgpICsgYW1vdW50KTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGFkZERheXM7XG4iLCAiaW1wb3J0IHsgdG9EYXRlIH0gZnJvbSBcIi4vdG9EYXRlLmpzXCI7XG5cbi8qKlxuICogQG5hbWUgaXNBZnRlclxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBmaXJzdCBkYXRlIGFmdGVyIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYWZ0ZXIgdGhlIG90aGVyIG9uZSB0byByZXR1cm4gdHJ1ZVxuICogQHBhcmFtIGRhdGVUb0NvbXBhcmUgLSBUaGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAqXG4gKiBAcmV0dXJucyBUaGUgZmlyc3QgZGF0ZSBpcyBhZnRlciB0aGUgc2Vjb25kIGRhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMTAgSnVseSAxOTg5IGFmdGVyIDExIEZlYnJ1YXJ5IDE5ODc/XG4gKiBjb25zdCByZXN1bHQgPSBpc0FmdGVyKG5ldyBEYXRlKDE5ODksIDYsIDEwKSwgbmV3IERhdGUoMTk4NywgMSwgMTEpKVxuICogLy89PiB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FmdGVyKGRhdGUsIGRhdGVUb0NvbXBhcmUpIHtcbiAgcmV0dXJuICt0b0RhdGUoZGF0ZSkgPiArdG9EYXRlKGRhdGVUb0NvbXBhcmUpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGlzQWZ0ZXI7XG4iLCAiLy8gTWFraW5nIHRoZSBtb2R1bGUgdmVyc2lvbiBjb25zdW1hYmxlIHZpYSByZXF1aXJlIC0gdG8gcHJvaGliaXRcbi8vIG11bHRpcGxlIG9jY3VycmFuY2llcyBvZiB0aGUgc2FtZSBtb2R1bGUgaW4gdGhlIHNhbWUgYXBwXG4vLyAoZHVhbCBwYWNrYWdlIGhhemFyZCwgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI2R1YWwtcGFja2FnZS1oYXphcmQpXG5pbXBvcnQgX0RleGllIGZyb20gXCIuL2Rpc3QvZGV4aWUuanNcIjtcbmNvbnN0IERleGllU3ltYm9sID0gU3ltYm9sLmZvcihcIkRleGllXCIpO1xuY29uc3QgRGV4aWUgPSBnbG9iYWxUaGlzW0RleGllU3ltYm9sXSB8fCAoZ2xvYmFsVGhpc1tEZXhpZVN5bWJvbF0gPSBfRGV4aWUpO1xuaWYgKF9EZXhpZS5zZW1WZXIgIT09IERleGllLnNlbVZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHdvIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBEZXhpZSBsb2FkZWQgaW4gdGhlIHNhbWUgYXBwOiAke19EZXhpZS5zZW1WZXJ9IGFuZCAke0RleGllLnNlbVZlcn1gKTtcbn1cbmNvbnN0IHsgbGl2ZVF1ZXJ5LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCwgUmFuZ2VTZXQsIGNtcCwgRW50aXR5LFxuICAgIFByb3BNb2RTeW1ib2wsIFByb3BNb2RpZmljYXRpb24sIHJlcGxhY2VQcmVmaXgsIGFkZCwgcmVtb3ZlIH0gPSBEZXhpZTtcbmV4cG9ydCB7IGxpdmVRdWVyeSwgbWVyZ2VSYW5nZXMsIHJhbmdlc092ZXJsYXAsIFJhbmdlU2V0LCBjbXAsIERleGllLCBFbnRpdHksXG4gICAgUHJvcE1vZFN5bWJvbCwgUHJvcE1vZGlmaWNhdGlvbiwgcmVwbGFjZVByZWZpeCwgYWRkLCByZW1vdmUgfTtcbmV4cG9ydCBkZWZhdWx0IERleGllO1xuIiwgImltcG9ydCBEZXhpZSwgeyB0eXBlIFRhYmxlIH0gZnJvbSAnZGV4aWUnXG5cbi8qKlxuICogSW5kZXhlZERCLWJhc2VkIGNhY2hlIGltcGxlbWVudGF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRGF0YWJhc2VTdG9yYWdlIGV4dGVuZHMgRGV4aWUge1xuICBrZXlWYWx1ZSE6IFRhYmxlPENhY2hlRW50cnksIHN0cmluZz5cbiAgcGFja2FnZUluZGV4ITogVGFibGU8UGFja2FnZUluZGV4SXRlbSwgc3RyaW5nPlxuICBzeW1ib2xJbmRleCE6IFRhYmxlPFN5bWJvbEluZGV4SXRlbSwgc3RyaW5nPlxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdDYWNoZVN0b3JlJylcblxuICAgIHRoaXMudmVyc2lvbigyKS5zdG9yZXMoe1xuICAgICAga2V5VmFsdWU6ICdrZXknLFxuICAgICAgcGFja2FnZUluZGV4OiAnaW1wb3J0UGF0aCwgcHJlZml4LCBuYW1lJyxcbiAgICAgIHN5bWJvbEluZGV4OiBgXG4gICAgICAgIGtleSxcbiAgICAgICAgcGFja2FnZVBhdGgsXG4gICAgICAgIFtwYWNrYWdlTmFtZStwcmVmaXhdLFxuICAgICAgICBbcGFja2FnZU5hbWUrbGFiZWxdLFxuICAgICAgICBbcGFja2FnZVBhdGgrcHJlZml4XWAsXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRW50cnk8VCA9IGFueT4ge1xuICBrZXk6IHN0cmluZ1xuICB2YWx1ZTogVFxuICBleHBpcmVBdD86IERhdGVcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjYWNoZSBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaXRlbSBieSBrZXkuXG4gICAqXG4gICAqIFJldHVybnMgbm90aGluZyBpZiBUVEwgaXMgZXhwaXJlZC5cbiAgICovXG4gIGdldEl0ZW06IDxUPihrZXk6IHN0cmluZykgPT4gUHJvbWlzZTxUIHwgdW5kZWZpbmVkPlxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBieSBrZXkuXG4gICAqXG4gICAqIFJldHVybnMgd2hldGhlciBkZWxldGlvbiBhZmZlY3RlZCBhbnkgcmVjb3JkLlxuICAgKi9cbiAgZGVsZXRlSXRlbTogKGtleTogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XG5cbiAgLyoqXG4gICAqIFN0b3JlIGFuIGl0ZW1cbiAgICogQHBhcmFtIGtleSBJdGVtIGtleVxuICAgKiBAcGFyYW0gdmFsdWUgVmFsdWVcbiAgICogQHBhcmFtIGV4cGlyZUF0IEtleSBleHBpcmF0aW9uIGRhdGUuXG4gICAqL1xuICBzZXRJdGVtOiA8VD4oa2V5OiBzdHJpbmcsIHZhbHVlOiBULCBleHBpcmVBdD86IERhdGUpID0+IFByb21pc2U8dm9pZD5cblxuICAvKipcbiAgICogVHJ1bmNhdGUgc3RvcmFnZS5cbiAgICovXG4gIGZsdXNoOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbmltcG9ydCB0eXBlICogYXMgbW9uYWNvIGZyb20gJ21vbmFjby1lZGl0b3InXG5cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25JdGVtID0gbW9uYWNvLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbVxuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkl0ZW1zID0gbW9uYWNvLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbVtdXG5cbi8qKlxuICogTm9ybWFsaXplZCB2ZXJzaW9uIG9mIENvbXBsZXRpb25JdGVtIHRoYXQgY29udGFpbnMgZml4ZWQgdHlwZXMgaW5zdGVhZCBvZiB1bmlvbiAoZS5nLiBGb28gfCBCYXIpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm9ybWFsaXplZENvbXBsZXRpb25JdGVtIGV4dGVuZHMgT21pdDxtb25hY28ubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtLCAnbGFiZWwnIHwgJ3JhbmdlJz4ge1xuICBsYWJlbDogc3RyaW5nXG4gIGRvY3VtZW50YXRpb24/OiBtb25hY28uSU1hcmtkb3duU3RyaW5nXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyByZWNvcmQgZnJvbSBwYWNrYWdlIGluZGV4LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhY2thZ2VJbmRleEl0ZW0ge1xuICAvKipcbiAgICogRnVsbCBpbXBvcnQgcGF0aC5cbiAgICovXG4gIGltcG9ydFBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBQYWNrYWdlIG5hbWUuXG4gICAqL1xuICBuYW1lOiBzdHJpbmdcblxuICAvKipcbiAgICogUHJlZml4IGZvciBzZWFyY2ggYnkgZmlyc3QgbGV0dGVyIHN1cHBsaWVkIGJ5IE1vbmFjby5cbiAgICovXG4gIHByZWZpeDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIEluaGVyaXRlZCBmcm9tIENvbXBsZXRpb25JdGVtLlxuICAgKi9cbiAgZG9jdW1lbnRhdGlvbj86IG1vbmFjby5JTWFya2Rvd25TdHJpbmdcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHJlY29yZCBmcm9tIHN5bWJvbCBpbmRleC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW1ib2xJbmRleEl0ZW0gZXh0ZW5kcyBOb3JtYWxpemVkQ29tcGxldGlvbkl0ZW0ge1xuICAvKipcbiAgICogS2V5IGlzIGNvbXBvdW5kIHBhaXIgb2YgcGFja2FnZSBuYW1lIGFuZCBzeW1ib2wgbmFtZS5cbiAgICpcbiAgICogRS5nLiBgc3lzY2FsbC9qcy5WYWx1ZWBcbiAgICovXG4gIGtleTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFByZWZpeCBmb3Igc2VhcmNoIGJ5IGZpcnN0IGxldHRlciBzdXBwbGllZCBieSBNb25hY28uXG4gICAqL1xuICBwcmVmaXg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBGdWxsIHBhY2thZ2UgcGF0aCB0byB3aGljaCB0aGlzIHN5bWJvbCBiZWxvbmdzLlxuICAgKi9cbiAgcGFja2FnZVBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBQYWNrYWdlIG5hbWUgcGFydCBvZiBwYWNrYWdlIHBhdGhcbiAgICovXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmdcblxuICAvKipcbiAgICogU2lnbmF0dXJlIHJlcHJlc2VudHMgZnVsbCBzeW1ib2wgc2lnbmF0dXJlIHRvIHNob3cgb24gaG92ZXIuXG4gICAqL1xuICBzaWduYXR1cmU6IHN0cmluZ1xufVxuXG5pbXBvcnQgeyBpc0FmdGVyIH0gZnJvbSAnZGF0ZS1mbnMnXG5cbnR5cGUgUmVjb3JkVmFsaWRhdG9yPFQ+ID0gKGVudHJ5OiBDYWNoZUVudHJ5PFQ+KSA9PiBib29sZWFuXG5cbmV4cG9ydCBjbGFzcyBLZXlWYWx1ZVN0b3JlIGltcGxlbWVudHMgQ2FjaGVTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBkYjogRGF0YWJhc2VTdG9yYWdlKSB7fVxuXG4gIGFzeW5jIGdldEl0ZW08VD4oa2V5OiBzdHJpbmcsIHZhbGlkYXRlPzogUmVjb3JkVmFsaWRhdG9yPFQ+KTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLmRiLmtleVZhbHVlLmdldChrZXkpXG4gICAgaWYgKGVudHJ5Py5leHBpcmVBdCAmJiBpc0FmdGVyKG5ldyBEYXRlKCksIGVudHJ5LmV4cGlyZUF0KSkge1xuICAgICAgdm9pZCB0aGlzLmRlbGV0ZUl0ZW0oa2V5KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChlbnRyeSAmJiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGUoZW50cnkpKSB7XG4gICAgICB2b2lkIHRoaXMuZGVsZXRlSXRlbShrZXkpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5Py52YWx1ZSBhcyBUIHwgdW5kZWZpbmVkXG4gIH1cblxuICBhc3luYyBkZWxldGVJdGVtKGtleTogc3RyaW5nKSB7XG4gICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuZGIua2V5VmFsdWUud2hlcmUoeyBrZXkgfSkuZGVsZXRlKClcbiAgICByZXR1cm4gbiA+IDBcbiAgfVxuXG4gIGFzeW5jIHNldEl0ZW08VD4oa2V5OiBzdHJpbmcsIHZhbHVlOiBULCBleHBpcmVBdD86IERhdGUpIHtcbiAgICBhd2FpdCB0aGlzLmRlbGV0ZUl0ZW0oa2V5KVxuICAgIGF3YWl0IHRoaXMuZGIua2V5VmFsdWUucHV0KHsga2V5LCB2YWx1ZSwgZXhwaXJlQXQgfSlcbiAgfVxuXG4gIGFzeW5jIGZsdXNoKCkge1xuICAgIGF3YWl0IHRoaXMuZGIua2V5VmFsdWUuY2xlYXIoKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkYiA9IG5ldyBEYXRhYmFzZVN0b3JhZ2UoKVxuZXhwb3J0IGNvbnN0IGtleVZhbHVlID0gbmV3IEtleVZhbHVlU3RvcmUoZGIpXG4iLCAiaW1wb3J0IHR5cGUgKiBhcyBtb25hY28gZnJvbSAnbW9uYWNvLWVkaXRvcidcbmltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSAnY29tbGluaydcbmltcG9ydCB7IGFkZERheXMgfSBmcm9tICdkYXRlLWZucydcbmltcG9ydCB7ZGIsIGtleVZhbHVlLCBQYWNrYWdlSW5kZXhJdGVtLCBTeW1ib2xJbmRleEl0ZW19IGZyb20gJy4uL2RiJ1xuXG5jb25zdCBjb21wbGV0aW9uVmVyc2lvbktleSA9ICdjb21wbGV0aW9uSXRlbXMudmVyc2lvbidcblxuY29uc3QgVFRMX0RBWVMgPSA3XG5cbmNvbnN0IGdldEV4cGlyZVRpbWUgPSAoKSA9PiBhZGREYXlzKG5ldyBEYXRlKCksIFRUTF9EQVlTKVxuXG5jb25zdCBpc1BhY2thZ2VRdWVyeSA9IChxOiBTdWdnZXN0aW9uUXVlcnkpOiBxIGlzIFBhY2thZ2VTeW1ib2xRdWVyeSA9PiAncGFja2FnZU5hbWUnIGluIHFcblxuXG5leHBvcnQgY2xhc3MgV29ya2VySGFuZGxlciB7XG4gIHByaXZhdGUgY2FjaGVQb3B1bGF0ZWQgPSBmYWxzZVxuICBwcml2YXRlIHBvcHVsYXRlUHJvbWlzZT86IFByb21pc2U8dm9pZD5cblxuICAvKipcbiAgICogU3RvcmUga2VlcHMgY29tcGxldGlvbnMgaW4gY2FjaGUuXG4gICAqXG4gICAqIFVzaW5nIGluLW1lbW9yeSBjYWNoZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgYXMgTW9uYWNvIG11dGF0ZXMgY29tcGxldGlvbnMgYWZ0ZXIgc3VibWl0LlxuICAgKiBDb21wbGV0aW9ucyB3aXRoIG11dGF0ZWQgcG9zaXRpb24gYXJlIG5vIGxvbmdlciB2YWxpZGF0ZWQsIHNvIGVpdGhlciBlYWNoIG5ldyBjb3B5IHNob3VsZCBiZSBkb25lXG4gICAqIG9yIGl0J3MgbXVjaCBlYXNpZXIgdG8ganVzdCBxdWVyeSB0aGUgREIuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRiID0gZGJcbiAgcHJpdmF0ZSByZWFkb25seSBrZXlWYWx1ZSA9IGtleVZhbHVlXG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBjYWNoZSB3YXMgcHJldmlvdXNseSBwb3B1bGF0ZWQuXG4gICAqL1xuICBpc1dhcm1VcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVBvcHVsYXRlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBwcmVkZWZpbmVkIGJ1aWx0aW5zLlxuICAgKlxuICAgKiBVc2VkIHRvIHNwZWVkLXVwIGhvdmVyIG9wZXJhdGlvbnMuXG4gICAqL1xuICBhc3luYyBnZXRCdWlsdGluTmFtZXMoKSB7XG4gICAgYXdhaXQgdGhpcy5jaGVja0NhY2hlUmVhZHkoKVxuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5kYi5zeW1ib2xJbmRleC53aGVyZSh7IHBhY2thZ2VOYW1lOiAnYnVpbHRpbicgfSkudG9BcnJheSgpXG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoeyBsYWJlbCB9KSA9PiBsYWJlbClcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRIb3ZlckZpbHRlcihxdWVyeTogSG92ZXJRdWVyeSk6IFBhcnRpYWw8U3ltYm9sSW5kZXhJdGVtPiB7XG4gICAgY29uc3QgaXNQYWNrYWdlTWVtYmVyID0gJ3BhY2thZ2VOYW1lJyBpbiBxdWVyeVxuICAgIGlmICghaXNQYWNrYWdlTWVtYmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGBidWlsdGluLiR7cXVlcnkudmFsdWV9YCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwa2dQYXRoID0gZmluZFBhY2thZ2VQYXRoRnJvbUNvbnRleHQocXVlcnkuY29udGV4dCwgcXVlcnkucGFja2FnZU5hbWUpXG4gICAgaWYgKHBrZ1BhdGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogYCR7cGtnUGF0aH0uJHtxdWVyeS52YWx1ZX1gLFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYWNrYWdlTmFtZTogcXVlcnkucGFja2FnZU5hbWUsXG4gICAgICBsYWJlbDogcXVlcnkudmFsdWUsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaG92ZXIgZG9jdW1lbnRhdGlvbiBmb3IgYSBzeW1ib2wuXG4gICAqL1xuICBhc3luYyBnZXRIb3ZlclZhbHVlKHF1ZXJ5OiBIb3ZlclF1ZXJ5KTogUHJvbWlzZTxtb25hY28ubGFuZ3VhZ2VzLkhvdmVyIHwgbnVsbD4ge1xuICAgIGF3YWl0IHRoaXMuY2hlY2tDYWNoZVJlYWR5KClcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmJ1aWxkSG92ZXJGaWx0ZXIocXVlcnkpXG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLmRiLnN5bWJvbEluZGV4LndoZXJlKGZpbHRlcikuZmlyc3QoKVxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRzOiBzeW1ib2xIb3ZlckRvYyhlbnRyeSksXG4gICAgICByYW5nZTogcXVlcnkuY29udGV4dC5yYW5nZSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGtub3duIGltcG9ydGFibGUgR28gcGFja2FnZXMuXG4gICAqXG4gICAqIFJldHVybnMgdmFsdWUgZnJvbSBjYWNoZSBpZiBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRJbXBvcnRTdWdnZXN0aW9ucygpIHtcbiAgICAvLyBUT0RPOiBwcm92aWRlIHRoaXJkLXBhcnR5IHBhY2thZ2VzIHVzaW5nIGdvIHByb3h5IGluZGV4LlxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFN0YW5kYXJkUGFja2FnZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3ltYm9sIG9yIGxpdGVyYWwgc3VnZ2VzdGlvbnMgYnkgcHJlZml4IGFuZCBwYWNrYWdlIG5hbWUuXG4gICAqL1xuICBhc3luYyBnZXRTeW1ib2xTdWdnZXN0aW9ucyhxdWVyeTogU3VnZ2VzdGlvblF1ZXJ5KSB7XG4gICAgY29uc29sZS5sb2cocXVlcnkpXG4gICAgYXdhaXQgdGhpcy5jaGVja0NhY2hlUmVhZHkoKVxuXG4gICAgaWYgKGlzUGFja2FnZVF1ZXJ5KHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TWVtYmVyU3VnZ2VzdGlvbihxdWVyeSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMaXRlcmFsU3VnZ2VzdGlvbihxdWVyeSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0TWVtYmVyU3VnZ2VzdGlvbih7IHZhbHVlLCBwYWNrYWdlTmFtZSwgY29udGV4dCB9OiBQYWNrYWdlU3ltYm9sUXVlcnkpIHtcbiAgICAvLyBJZiBwYWNrYWdlIHdpdGggc3BlY2lmaWVkIG5hbWUgaXMgaW1wb3J0ZWQgLSBmaWx0ZXIgc3ltYm9sc1xuICAgIC8vIHRvIGF2b2lkIG92ZXJsYXAgd2l0aCBwYWNrYWdlcyB3aXRoIGVwb255bW91cyBuYW1lLlxuICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gZmluZFBhY2thZ2VQYXRoRnJvbUNvbnRleHQoY29udGV4dCwgcGFja2FnZU5hbWUpXG5cbiAgICBjb25zdCBmaWx0ZXI6IFBhcnRpYWw8U3ltYm9sSW5kZXhJdGVtPiA9IHBhY2thZ2VQYXRoXG4gICAgICA/IHtcbiAgICAgICAgICBwYWNrYWdlUGF0aCxcbiAgICAgICAgfVxuICAgICAgOiB7IHBhY2thZ2VOYW1lIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZmlsdGVyLnByZWZpeCA9IHZhbHVlLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpXG4gICAgfVxuXG4gICAgY29uc3Qgc3ltYm9scyA9IGF3YWl0IHRoaXMuZGIuc3ltYm9sSW5kZXgud2hlcmUoZmlsdGVyKS50b0FycmF5KClcbiAgICByZXR1cm4gc3ltYm9scy5tYXAoKHN5bWJvbCkgPT4gY29tcGxldGlvbkZyb21TeW1ib2woc3ltYm9sLCBjb250ZXh0LCAhIXBhY2thZ2VQYXRoKSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0TGl0ZXJhbFN1Z2dlc3Rpb24oeyB2YWx1ZSwgY29udGV4dCB9OiBMaXRlcmFsUXVlcnkpIHtcbiAgICBjb25zdCBwYWNrYWdlcyA9IGF3YWl0IHRoaXMuZGIucGFja2FnZUluZGV4LndoZXJlKCdwcmVmaXgnKS5lcXVhbHModmFsdWUpLnRvQXJyYXkoKVxuICAgIGNvbnN0IGJ1aWx0aW5zID0gYXdhaXQgdGhpcy5kYi5zeW1ib2xJbmRleC53aGVyZSgncGFja2FnZVBhdGgnKS5lcXVhbHMoJ2J1aWx0aW4nKS50b0FycmF5KClcblxuICAgIGNvbnN0IHBhY2thZ2VDb21wbGV0aW9ucyA9IHBhY2thZ2VzLm1hcCgoaXRlbSkgPT4gY29tcGxldGlvbkZyb21QYWNrYWdlKGl0ZW0sIGNvbnRleHQpKVxuICAgIGNvbnN0IHN5bWJvbHNDb21wbGV0aW9ucyA9IGJ1aWx0aW5zLm1hcCgoaXRlbSkgPT4gY29tcGxldGlvbkZyb21TeW1ib2woaXRlbSwgY29udGV4dCwgZmFsc2UpKVxuXG4gICAgcmV0dXJuIHBhY2thZ2VDb21wbGV0aW9ucy5jb25jYXQoc3ltYm9sc0NvbXBsZXRpb25zKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRTdGFuZGFyZFBhY2thZ2VzKCkge1xuICAgIGF3YWl0IHRoaXMuY2hlY2tDYWNoZVJlYWR5KClcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmRiLnBhY2thZ2VJbmRleC50b0FycmF5KClcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoaW1wb3J0Q29tcGxldGlvbkZyb21QYWNrYWdlKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0NhY2hlUmVhZHkoKSB7XG4gICAgaWYgKHRoaXMuY2FjaGVQb3B1bGF0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIGludmFsaWRhdGlvbiBieSBHbyB2ZXJzaW9uXG4gICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMua2V5VmFsdWUuZ2V0SXRlbTxzdHJpbmc+KGNvbXBsZXRpb25WZXJzaW9uS2V5LCAoZW50cnkpID0+IHtcbiAgICAgIC8vIHYyLjIuMCBkaWRuJ3Qgd3JpdGUgVFRMIGJ5IG1pc3Rha2VcbiAgICAgIHJldHVybiB0eXBlb2YgZW50cnkuZXhwaXJlQXQgIT09ICd1bmRlZmluZWQnXG4gICAgfSlcblxuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgYXdhaXQgdGhpcy5wb3B1bGF0ZUNhY2hlKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgY291bnQgPSBhd2FpdCB0aGlzLmRiLnBhY2thZ2VJbmRleC5jb3VudCgpXG4gICAgdGhpcy5jYWNoZVBvcHVsYXRlZCA9IGNvdW50ID4gMFxuICAgIGlmICghdGhpcy5jYWNoZVBvcHVsYXRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5wb3B1bGF0ZUNhY2hlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVQb3B1bGF0ZWRcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcG9wdWxhdGVDYWNoZSgpIHtcbiAgICBpZiAoIXRoaXMucG9wdWxhdGVQcm9taXNlKSB7XG4gICAgICAvLyBDYWNoZSBwb3B1bGF0aW9uIG1pZ2h0IGJlIHRyaWdnZXJlZCBieSBtdWx0aXBsZSBhY3RvcnMgb3V0c2lkZS5cbiAgICAgIHRoaXMucG9wdWxhdGVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcnNwID0gYXdhaXQgZmV0Y2goJy9zdGF0aWMvZ28taW5kZXguanNvbicpXG4gICAgICAgIGlmICghcnNwLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3JzcC5zdGF0dXN9ICR7cnNwLnN0YXR1c1RleHR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGE6IEdvSW5kZXhGaWxlID0gYXdhaXQgcnNwLmpzb24oKVxuICAgICAgICBpZiAoZGF0YS52ZXJzaW9uID4gMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgdW5zdXBwb3J0ZWQgc3ltYm9sIGluZGV4IHZlcnNpb246ICR7ZGF0YS52ZXJzaW9ufSwgc2tpcCB1cGRhdGUuYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIGNvbnN0IHBhY2thZ2VzID0gY29uc3RydWN0UGFja2FnZXMoZGF0YS5wYWNrYWdlcylcbiAgICAgICAgY29uc3Qgc3ltYm9scyA9IGNvbnN0cnVjdFN5bWJvbHMoZGF0YS5zeW1ib2xzKVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICB0aGlzLmRiLnBhY2thZ2VJbmRleC5jbGVhcigpLFxuICAgICAgICAgIHRoaXMuZGIuc3ltYm9sSW5kZXguY2xlYXIoKSxcbiAgICAgICAgICB0aGlzLmRiLnBhY2thZ2VJbmRleC5idWxrQWRkKHBhY2thZ2VzKSxcbiAgICAgICAgICB0aGlzLmRiLnN5bWJvbEluZGV4LmJ1bGtBZGQoc3ltYm9scyksXG4gICAgICAgICAgdGhpcy5rZXlWYWx1ZS5zZXRJdGVtKGNvbXBsZXRpb25WZXJzaW9uS2V5LCBkYXRhLmdvLCBnZXRFeHBpcmVUaW1lKCkpLFxuICAgICAgICBdKVxuXG4gICAgICAgIHRoaXMuY2FjaGVQb3B1bGF0ZWQgPSB0cnVlXG4gICAgICB9KSgpXG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wb3B1bGF0ZVByb21pc2VcbiAgfVxufVxuXG5Db21saW5rLmV4cG9zZShuZXcgV29ya2VySGFuZGxlcigpKVxuXG5leHBvcnQgZW51bSBTeW1ib2xTb3VyY2VLZXkge1xuICBOYW1lID0gMCxcbiAgUGF0aCA9IDEsXG59XG5cbnR5cGUgU3ltYm9sU291cmNlID0gW25hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nXVxuXG4vKipcbiAqIEBzZWUgaW50ZXJuYWwvcGtnaW5kZXgvaW5kZXgvdHlwZXMuZ29cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW1ib2xzIHtcbiAgbmFtZXM6IHN0cmluZ1tdXG4gIGRvY3M6IHN0cmluZ1tdXG4gIGRldGFpbHM6IHN0cmluZ1tdXG4gIHNpZ25hdHVyZXM6IHN0cmluZ1tdXG4gIGluc2VydFRleHRzOiBzdHJpbmdbXVxuICBpbnNlcnRUZXh0UnVsZXM6IG1vbmFjby5sYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtdXG4gIGtpbmRzOiBtb25hY28ubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtS2luZFtdXG4gIHBhY2thZ2VzOiBTeW1ib2xTb3VyY2VbXVxufVxuXG4vKipcbiAqIEBzZWUgaW50ZXJuYWwvcGtnaW5kZXgvaW5kZXgvdHlwZXMuZ29cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlcyB7XG4gIG5hbWVzOiBzdHJpbmdbXVxuICBwYXRoczogc3RyaW5nW11cbiAgZG9jczogc3RyaW5nW11cbn1cblxuLyoqXG4gKiBHbyBpbmRleCBmaWxlIHJlc3BvbnNlIHR5cGUuXG4gKlxuICogQHNlZSBpbnRlcm5hbC9wa2dpbmRleC9pbmRleC90eXBlcy5nb1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEdvSW5kZXhGaWxlIHtcbiAgLyoqXG4gICAqIEZpbGUgZm9ybWF0IHZlcnNpb24uXG4gICAqL1xuICB2ZXJzaW9uOiBudW1iZXJcblxuICAvKipcbiAgICogR28gdmVyc2lvbiB1c2VkIHRvIGdlbmVyYXRlIGluZGV4LlxuICAgKi9cbiAgZ286IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHN0YW5kYXJkIHBhY2thZ2VzLlxuICAgKi9cbiAgcGFja2FnZXM6IFBhY2thZ2VzXG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygc3ltYm9scyBvZiBlYWNoIHBhY2thZ2UuXG4gICAqL1xuICBzeW1ib2xzOiBTeW1ib2xzXG59XG5cbmV4cG9ydCBlbnVtIEltcG9ydENsYXVzZVR5cGUge1xuICAvKipcbiAgICogVGhlcmUgaXMgbm8gYW55IGltcG9ydCBibG9jay5cbiAgICovXG4gIE5vbmUsXG5cbiAgLyoqXG4gICAqIFNpbmdsZSBsaW5lIGltcG9ydC5cbiAgICovXG4gIFNpbmdsZSxcblxuICAvKipcbiAgICogTXVsdGktbGluZSBpbXBvcnQgYmxvY2sgd2l0aCBicmFjZXMuXG4gICAqL1xuICBCbG9jayxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRzQ29udGV4dCB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIGFueSBlcnJvciB3YXMgZGV0ZWN0ZWQgZHVyaW5nIGNvbnRleHQgYnVpbGQuXG4gICAqL1xuICBoYXNFcnJvcj86IGJvb2xlYW5cblxuICAvKipcbiAgICogTGlzdCBvZiBpbXBvcnQgcGF0aHMgZnJvbSBhbGwgaW1wb3J0IGJsb2Nrcy5cbiAgICovXG4gIGFsbFBhdGhzPzogU2V0PHN0cmluZz5cblxuICAvKipcbiAgICogU3RhcnQgYW5kIGVuZCBsaW5lIG9mIGFyZWEgY29udGFpbmluZyBhbGwgaW1wb3J0cy5cbiAgICpcbiAgICogVGhpcyBhcmVhIHdpbGwgYmUgbW9uaXRvcmVkIGZvciBjaGFuZ2VzIHRvIHVwZGF0ZSBkb2N1bWVudCBpbXBvcnRzIGNhY2hlLlxuICAgKi9cbiAgdG90YWxSYW5nZT86IFBpY2s8bW9uYWNvLklSYW5nZSwgJ3N0YXJ0TGluZU51bWJlcicgfCAnZW5kTGluZU51bWJlcic+XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgaW4gYSBsYXN0IGJsb2NrIHJlbGF0ZWQgdG8gYHJhbmdlYC5cbiAgICovXG4gIGJsb2NrUGF0aHM/OiBzdHJpbmdbXVxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIG5lYXJlc3QgaW1wb3J0IGJsb2NrLlxuICAgKi9cbiAgYmxvY2tUeXBlOiBJbXBvcnRDbGF1c2VUeXBlXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9mIG5lYXJlc3QgaW1wb3J0IGJsb2NrIHRvIGluc2VydCBuZXcgaW1wb3J0cy5cbiAgICpcbiAgICogSWYgYGJsb2NrVHlwZWAgaXMgYEltcG9ydENsYXVzZVR5cGUuTm9uZWAgLSBwb2ludHMgdG8gcG9zaXRpb25cbiAgICogb2YgbmVhcmVzdCBlbXB0eSBsaW5lIGFmdGVyIGBwYWNrYWdlYCBjbGF1c2UuXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIG5vIGVtcHR5IGxpbmUgYWZ0ZXIgYHBhY2thZ2VgIGNsYXVzZSAtIHNob3VsZCBwb2ludFxuICAgKiB0byB0aGUgZW5kIG9mIGNsYXVzZSBzdGF0ZW1lbnQgKyAxIGV4dHJhIGNvbHVtbi5cbiAgICpcbiAgICogT3RoZXJ3aXNlIC0gc2hvdWxkIHBvaW50IHRvIGEgZnVsbCByYW5nZSBvZiBsYXN0IGBpbXBvcnRgIGJsb2NrLlxuICAgKlxuICAgKiBAc2VlIHByZXBlbmROZXdMaW5lXG4gICAqL1xuICByYW5nZT86IG1vbmFjby5JUmFuZ2VcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZXh0cmEgbmV3IGxpbmUgc2hvdWxkIGJlIGFwcGVuZGVkIGJlZm9yZSBgaW1wb3J0YCBjbGF1c2UuXG4gICAqXG4gICAqIEVmZmVjdGl2ZSBvbmx5IHdoZW4gYHJhbmdlYCBpcyBgSW1wb3J0Q2xhdXNlVHlwZS5Ob25lYC5cbiAgICovXG4gIHByZXBlbmROZXdMaW5lPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1Z2dlc3Rpb25Db250ZXh0IHtcbiAgLyoqXG4gICAqIEN1cnJlbnQgZWRpdCByYW5nZVxuICAgKi9cbiAgcmFuZ2U6IG1vbmFjby5JUmFuZ2VcblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IGF1dG8gaW1wb3J0IHN1Z2dlc3Rpb25zIHdpbGwgYmUgYWRkZWQuXG4gICAqL1xuICBpbXBvcnRzOiBJbXBvcnRzQ29udGV4dFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpdGVyYWxRdWVyeSB7XG4gIHZhbHVlOiBzdHJpbmdcbiAgY29udGV4dDogU3VnZ2VzdGlvbkNvbnRleHRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlU3ltYm9sUXVlcnkge1xuICBwYWNrYWdlTmFtZTogc3RyaW5nXG4gIHZhbHVlPzogc3RyaW5nXG4gIGNvbnRleHQ6IFN1Z2dlc3Rpb25Db250ZXh0XG59XG5cbmV4cG9ydCB0eXBlIFN1Z2dlc3Rpb25RdWVyeSA9IExpdGVyYWxRdWVyeSB8IFBhY2thZ2VTeW1ib2xRdWVyeVxuXG5leHBvcnQgdHlwZSBIb3ZlclF1ZXJ5ID0gTGl0ZXJhbFF1ZXJ5IHwgUmVxdWlyZWQ8UGFja2FnZVN5bWJvbFF1ZXJ5PlxuXG5cbnR5cGUgQ29tcGxldGlvbkl0ZW0gPSBtb25hY28ubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtXG5cbmNvbnN0IGdldFByZWZpeCA9IChzdHI6IHN0cmluZykgPT4gc3RyWzBdPy50b0xvd2VyQ2FzZSgpID8/ICcnXG5cbi8vIEFsdGhvdWdoIG1vbmFjbyBkb2Vzbid0IHJlcXVpcmUgYWN0dWFsIHJhbmdlLCBpdCdzIGRlZmluZWQgYXMgcmVxdWlyZWQgaW4gVFMgdHlwZXMuXG4vLyBUaGlzIGlzIGEgc3R1YiB2YWx1ZSB0byBzYXRpc2Z5IHR5cGUgY2hlY2tzLlxuY29uc3Qgc3R1YlJhbmdlID0gdW5kZWZpbmVkIGFzIGFueSBhcyBtb25hY28uSVJhbmdlXG5cbmNvbnN0IHBhY2thZ2VDb21wbGV0aW9uS2luZCA9IDhcblxuY29uc3QgZGlzY2FyZElmRW1wdHkgPSAoc3RyOiBzdHJpbmcsIGRlZmF1bHRzPzogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiAoc3RyLmxlbmd0aCA/IHN0ciA6IGRlZmF1bHRzKVxuXG5jb25zdCBzdHJpbmdUb01hcmtkb3duID0gKHZhbHVlOiBzdHJpbmcpOiBtb25hY28uSU1hcmtkb3duU3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlLFxuICAgIGlzVHJ1c3RlZDogdHJ1ZSxcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29uc3RydWN0UGFja2FnZXMgPSAoeyBuYW1lcywgcGF0aHMsIGRvY3MgfTogUGFja2FnZXMpOiBQYWNrYWdlSW5kZXhJdGVtW10gPT5cbiAgICBuYW1lcy5tYXAoKG5hbWUsIGkpID0+ICh7XG4gICAgICBuYW1lLFxuICAgICAgaW1wb3J0UGF0aDogcGF0aHNbaV0sXG4gICAgICBwcmVmaXg6IGdldFByZWZpeChuYW1lc1tpXSksXG4gICAgICBkb2N1bWVudGF0aW9uOiBzdHJpbmdUb01hcmtkb3duKGRvY3NbaV0pLFxuICAgIH0pKVxuXG5leHBvcnQgY29uc3QgY29uc3RydWN0U3ltYm9scyA9ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dFJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OiBTeW1ib2xzKTogU3ltYm9sSW5kZXhJdGVtW10gPT5cbiAgICBuYW1lcy5tYXAoKG5hbWUsIGkpID0+ICh7XG4gICAgICBrZXk6IGAke3BhY2thZ2VzW2ldW1N5bWJvbFNvdXJjZUtleS5QYXRoXX0uJHtuYW1lfWAsXG4gICAgICBsYWJlbDogbmFtZSxcbiAgICAgIGRldGFpbDogZGlzY2FyZElmRW1wdHkoZGV0YWlsc1tpXSwgbmFtZSksXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZXNbaV0sXG4gICAgICBraW5kOiBraW5kc1tpXSxcbiAgICAgIGluc2VydFRleHQ6IGluc2VydFRleHRzW2ldLFxuICAgICAgaW5zZXJ0VGV4dFJ1bGVzOiBpbnNlcnRUZXh0UnVsZXNbaV0sXG4gICAgICBwcmVmaXg6IGdldFByZWZpeChuYW1lKSxcbiAgICAgIHBhY2thZ2VOYW1lOiBwYWNrYWdlc1tpXVtTeW1ib2xTb3VyY2VLZXkuTmFtZV0sXG4gICAgICBwYWNrYWdlUGF0aDogcGFja2FnZXNbaV1bU3ltYm9sU291cmNlS2V5LlBhdGhdLFxuICAgICAgZG9jdW1lbnRhdGlvbjogc3RyaW5nVG9NYXJrZG93bihkb2NzW2ldKSxcbiAgICB9KSlcblxuZXhwb3J0IGNvbnN0IGltcG9ydENvbXBsZXRpb25Gcm9tUGFja2FnZSA9ICh7IGltcG9ydFBhdGgsIG5hbWUsIGRvY3VtZW50YXRpb24gfTogUGFja2FnZUluZGV4SXRlbSk6IENvbXBsZXRpb25JdGVtID0+ICh7XG4gIGxhYmVsOiBpbXBvcnRQYXRoLFxuICBkb2N1bWVudGF0aW9uLFxuICBkZXRhaWw6IG5hbWUsXG4gIGluc2VydFRleHQ6IGltcG9ydFBhdGgsXG4gIGtpbmQ6IHBhY2thZ2VDb21wbGV0aW9uS2luZCxcbiAgcmFuZ2U6IHN0dWJSYW5nZSxcbn0pXG5cbnR5cGUgSVNpbmdsZUVkaXRPcGVyYXRpb24gPSBtb25hY28uZWRpdG9yLklTaW5nbGVFZGl0T3BlcmF0aW9uXG5cbmNvbnN0IGltcG9ydFBhY2thZ2VUZXh0RWRpdCA9IChcbiAgICBpbXBvcnRQYXRoOiBzdHJpbmcsXG4gICAgeyBpbXBvcnRzIH06IFN1Z2dlc3Rpb25Db250ZXh0LFxuKTogSVNpbmdsZUVkaXRPcGVyYXRpb25bXSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICghaW1wb3J0cy5yYW5nZSB8fCBpbXBvcnRzLmFsbFBhdGhzPy5oYXMoaW1wb3J0UGF0aCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBzd2l0Y2ggKGltcG9ydHMuYmxvY2tUeXBlKSB7XG4gICAgY2FzZSBJbXBvcnRDbGF1c2VUeXBlLk5vbmU6IHtcbiAgICAgIGNvbnN0IHRleHQgPSBgaW1wb3J0IFwiJHtpbXBvcnRQYXRofVwiXFxuYFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHRleHQ6IGltcG9ydHMucHJlcGVuZE5ld0xpbmUgPyBgXFxuJHt0ZXh0fWAgOiB0ZXh0LFxuICAgICAgICAgIHJhbmdlOiBpbXBvcnRzLnJhbmdlLFxuICAgICAgICAgIGZvcmNlTW92ZU1hcmtlcnM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICBdXG4gICAgfVxuICAgIGNhc2UgSW1wb3J0Q2xhdXNlVHlwZS5TaW5nbGU6XG4gICAgY2FzZSBJbXBvcnRDbGF1c2VUeXBlLkJsb2NrOiB7XG4gICAgICBjb25zdCBpbXBvcnRMaW5lcyA9IChpbXBvcnRzLmJsb2NrUGF0aHMgPz8gW10pXG4gICAgICAgICAgLmNvbmNhdChpbXBvcnRQYXRoKVxuICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAubWFwKCh2KSA9PiBgXFx0XCIke3Z9XCJgKVxuICAgICAgICAgIC5qb2luKCdcXG4nKVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdGV4dDogYGltcG9ydCAoXFxuJHtpbXBvcnRMaW5lc31cXG4pYCxcbiAgICAgICAgICByYW5nZTogaW1wb3J0cy5yYW5nZSxcbiAgICAgICAgICBmb3JjZU1vdmVNYXJrZXJzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgXVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29tcGxldGlvbkZyb21QYWNrYWdlID0gKFxuICAgIHsgaW1wb3J0UGF0aCwgbmFtZSwgZG9jdW1lbnRhdGlvbiB9OiBQYWNrYWdlSW5kZXhJdGVtLFxuICAgIGN0eDogU3VnZ2VzdGlvbkNvbnRleHQsXG4pOiBDb21wbGV0aW9uSXRlbSA9PiAoe1xuICBsYWJlbDogbmFtZSxcbiAgZG9jdW1lbnRhdGlvbixcbiAgZGV0YWlsOiBpbXBvcnRQYXRoLFxuICBpbnNlcnRUZXh0OiBuYW1lLFxuICBraW5kOiBwYWNrYWdlQ29tcGxldGlvbktpbmQsXG4gIHJhbmdlOiBjdHgucmFuZ2UsXG4gIGFkZGl0aW9uYWxUZXh0RWRpdHM6IGltcG9ydFBhY2thZ2VUZXh0RWRpdChpbXBvcnRQYXRoLCBjdHgpLFxufSlcblxuZXhwb3J0IGNvbnN0IGNvbXBsZXRpb25Gcm9tU3ltYm9sID0gKFxuICAgIHsgcGFja2FnZVBhdGgsIC4uLmNvbXBsZXRpb25JdGVtIH06IFN5bWJvbEluZGV4SXRlbSxcbiAgICBjdHg6IFN1Z2dlc3Rpb25Db250ZXh0LFxuICAgIHRleHRFZGl0czogYm9vbGVhbixcbik6IENvbXBsZXRpb25JdGVtID0+ICh7XG4gIC4uLmNvbXBsZXRpb25JdGVtLFxuICByYW5nZTogY3R4LnJhbmdlLFxuICBhZGRpdGlvbmFsVGV4dEVkaXRzOiB0ZXh0RWRpdHMgPyBpbXBvcnRQYWNrYWdlVGV4dEVkaXQocGFja2FnZVBhdGgsIGN0eCkgOiB1bmRlZmluZWQsXG59KVxuXG5jb25zdCBwa2dOYW1lRnJvbVBhdGggPSAoaW1wb3J0UGF0aDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHNsYXNoUG9zID0gaW1wb3J0UGF0aC5sYXN0SW5kZXhPZignLycpXG4gIHJldHVybiBzbGFzaFBvcyA9PT0gLTEgPyBpbXBvcnRQYXRoIDogaW1wb3J0UGF0aC5zbGljZShzbGFzaFBvcyArIDEpXG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZmluZCBmaXJzdCBpbXBvcnQgcGF0aCB0aGF0IG1hdGNoZXMgcGFja2FnZSBuYW1lLlxuICovXG5leHBvcnQgY29uc3QgZmluZFBhY2thZ2VQYXRoRnJvbUNvbnRleHQgPSAoeyBpbXBvcnRzIH06IFN1Z2dlc3Rpb25Db250ZXh0LCBwa2dOYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAoIWltcG9ydHMuYWxsUGF0aHMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoaW1wb3J0cy5hbGxQYXRocy5oYXMocGtnTmFtZSkpIHtcbiAgICByZXR1cm4gcGtnTmFtZVxuICB9XG5cbiAgZm9yIChjb25zdCBpbXBvcnRQYXRoIG9mIGltcG9ydHMuYWxsUGF0aHMua2V5cygpKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBuYW1lZCBpbXBvcnRzXG4gICAgaWYgKHBrZ05hbWUgPT09IHBrZ05hbWVGcm9tUGF0aChpbXBvcnRQYXRoKSkge1xuICAgICAgcmV0dXJuIGltcG9ydFBhdGhcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZ29Eb2NEb21haW4gPSAncGtnLmdvLmRldidcbmV4cG9ydCBjb25zdCBzeW1ib2xIb3ZlckRvYyA9ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2thZ2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH06IFN5bWJvbEluZGV4SXRlbSk6IG1vbmFjby5JTWFya2Rvd25TdHJpbmdbXSA9PiB7XG4gIGNvbnN0IGRvYzogbW9uYWNvLklNYXJrZG93blN0cmluZ1tdID0gW11cblxuICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgZG9jLnB1c2goe1xuICAgICAgdmFsdWU6ICdgYGBnb1xcbicgKyBzaWduYXR1cmUgKyAnXFxuYGBgJyxcbiAgICB9KVxuICB9XG5cbiAgaWYgKGRvY3VtZW50YXRpb24pIHtcbiAgICBkb2MucHVzaChkb2N1bWVudGF0aW9uKVxuICB9XG5cbiAgY29uc3QgZG9jTGFiZWwgPSBwYWNrYWdlUGF0aCA9PT0gJ2J1aWx0aW4nID8gbGFiZWwgOiBgJHtwYWNrYWdlTmFtZX0uJHtsYWJlbH1gXG4gIGNvbnN0IGxpbmtMYWJlbCA9IGBcXGAke2RvY0xhYmVsfVxcYCBvbiAke2dvRG9jRG9tYWlufWBcbiAgZG9jLnB1c2goe1xuICAgIHZhbHVlOiBgWyR7bGlua0xhYmVsfV0oaHR0cHM6Ly8ke2dvRG9jRG9tYWlufS8ke3BhY2thZ2VQYXRofSMke2xhYmVsfSlgLFxuICAgIGlzVHJ1c3RlZDogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gZG9jXG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsVUFBSSxnQkFBZ0IsU0FBUyxHQUFHLEdBQUc7QUFDL0Isd0JBQWdCLE9BQU8sa0JBQ2xCLEVBQUUsV0FBVyxDQUFBLEVBQUUsYUFBYyxTQUFTLFNBQVVBLElBQUdDLElBQUc7QUFBRSxVQUFBRCxHQUFFLFlBQVlDO1FBQUUsS0FDekUsU0FBVUQsSUFBR0MsSUFBRztBQUFFLG1CQUFTLEtBQUtBLEdBQUcsS0FBSSxPQUFPLFVBQVUsZUFBZSxLQUFLQSxJQUFHLENBQUMsRUFBRyxDQUFBRCxHQUFFLENBQUMsSUFBSUMsR0FBRSxDQUFDO1FBQUU7QUFDbkcsZUFBTyxjQUFjLEdBQUcsQ0FBQztNQUM3QjtBQUVPLGVBQVMsVUFBVSxHQUFHLEdBQUc7QUFDNUIsWUFBSSxPQUFPLE1BQU0sY0FBYyxNQUFNO0FBQ2pDLGdCQUFNLElBQUksVUFBVSx5QkFBeUIsT0FBTyxDQUFDLElBQUksK0JBQStCO0FBQzVGLHNCQUFjLEdBQUcsQ0FBQztBQUNsQixpQkFBUyxLQUFLO0FBQUUsZUFBSyxjQUFjO1FBQUU7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O0FBRUEsTUFBSSxRQUFRLFNBQVMsSUFBSSxPQUFPLEdBQUc7QUFDakMsV0FBTztBQUFBLEVBQ1Q7QUFFQSxhQUFXLGNBQWMsUUFBUSxTQUFTLEtBQUssR0FBRztBQUVoRCxRQUFJLFlBQVksZ0JBQWdCLFVBQVUsR0FBRztBQUMzQyxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDRjtBQUVBLElBQU0sY0FBYztBQUNiLElBQU0saUJBQWlCLENBQUM7QUFBQSxFQUNFO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGLE1BQWlEO0FBQzlFLFFBQU0sTUFBZ0MsQ0FBQztBQUV2QyxNQUFJLFdBQVc7QUFDYixRQUFJLEtBQUs7QUFBQSxNQUNQLE9BQU8sWUFBWSxZQUFZO0FBQUEsSUFDakMsQ0FBQztBQUFBLEVBQ0g7QUFFQSxNQUFJLGVBQWU7QUFDakIsUUFBSSxLQUFLLGFBQWE7QUFBQSxFQUN4QjtBQUVBLFFBQU0sV0FBVyxnQkFBZ0IsWUFBWSxRQUFRLEdBQUcsV0FBVyxJQUFJLEtBQUs7QUFDNUUsUUFBTSxZQUFZLEtBQUssUUFBUSxTQUFTLFdBQVc7QUFDbkQsTUFBSSxLQUFLO0FBQUEsSUFDUCxPQUFPLElBQUksU0FBUyxhQUFhLFdBQVcsSUFBSSxXQUFXLElBQUksS0FBSztBQUFBLElBQ3BFLFdBQVc7QUFBQSxFQUNiLENBQUM7QUFFRCxTQUFPO0FBQ1Q7IiwKICAibmFtZXMiOiBbImQiLCAiYiIsICJfX2Fzc2lnbiIsICJhc2FwIiwgIkRleGllRXJyb3IiLCAiX2EiLCAidHlwZSIsICJyZXNvbHZlIiwgInJlamVjdCIsICJmaW5hbGl6ZXIiLCAid3JhcCIsICJwcm9wcyIsICJkYiIsICJFbnRpdHkiLCAiY21wIiwgIlRhYmxlIiwgInRhc2siLCAidHJhbnMiLCAiUHJvbWlzZSIsICJrZXlzIiwgImkiLCAiYWRkIiwgImFyZ3MiLCAiUHJvcE1vZFN5bWJvbCIsICJQcm9wTW9kaWZpY2F0aW9uIiwgIkNvbGxlY3Rpb24iLCAiY291bnQiLCAiZGlyZWN0aW9uIiwgIldoZXJlQ2xhdXNlIiwgImFkZFJhbmdlIiwgInJhbmdlcyIsICJUcmFuc2FjdGlvbiIsICJwIiwgInRhYmxlcyIsICJrZXlQYXRoIiwgImNvbXBvdW5kIiwgInJlc3VsdCIsICJyZXEiLCAib3BlbkN1cnNvciIsICJxdWVyeSIsICJldiIsICJoYXNHZXRBbGwiLCAib2xkVmVyc2lvbiIsICJ0YWJsZUNoYW5nZSIsICJWZXJzaW9uIiwgImluZGV4ZWREQiIsICJEZXhpZSIsICJSYW5nZVNldCIsICJtZXJnZVJhbmdlcyIsICJ0YXJnZXQiLCAicmFuZ2VzT3ZlcmxhcCIsICJzYWZhcmkxNFdvcmthcm91bmQiLCAiaW5kZXgiLCAicHJpbWFyeUtleSIsICJkeFRyYW5zIiwgImNhY2hlIiwgImtleSIsICJzdGF0ZSIsICJPYnNlcnZhYmxlIiwgImxpdmVRdWVyeSIsICJfRGV4aWUiLCAiRGVidWcuZGVidWciLCAiRGVidWcuc2V0RGVidWciLCAicmVtb3ZlIiwgInJlcGxhY2VQcmVmaXgiLCAib2JqIiwgInJldHVyblZhbHVlIiwgInByb3h5IiwgIl9EZXhpZSIsICJkYiIsICJTeW1ib2xTb3VyY2VLZXkiLCAiSW1wb3J0Q2xhdXNlVHlwZSJdCn0K
