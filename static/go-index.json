{"version":1,"go":"1.23.1","packages":{"names":["bufio","bytes","cmp","context","crypto","embed","encoding","errors","expvar","flag","fmt","hash","html","image","io","iter","log","maps","math","mime","net","os","path","plugin","reflect","regexp","runtime","slices","sort","strconv","strings","structs","sync","syscall","testing","time","unicode","unique","unsafe","tar","zip","bzip2","flate","gzip","lzw","zlib","heap","list","ring","aes","cipher","des","dsa","ecdh","ecdsa","ed25519","elliptic","hmac","md5","rand","rc4","rsa","sha1","sha256","sha512","subtle","tls","x509","sql","buildinfo","dwarf","elf","gosym","macho","pe","plan9obj","ascii85","asn1","base32","base64","binary","csv","gob","hex","json","pem","xml","ast","build","constant","doc","format","importer","parser","printer","scanner","token","types","version","adler32","crc32","crc64","fnv","maphash","template","color","draw","gif","jpeg","png","suffixarray","fs","ioutil","slog","syslog","big","bits","cmplx","rand","multipart","quotedprintable","http","mail","netip","rpc","smtp","textproto","url","exec","signal","user","filepath","syntax","cgo","coverage","debug","metrics","pprof","trace","atomic","js","fstest","iotest","quick","slogtest","scanner","tabwriter","template","utf16","utf8","pkix","driver","constraint","comment","palette","rand","cgi","cookiejar","fcgi","httptest","httptrace","httputil","pprof","jsonrpc","parse","chacha20","chacha20poly1305","cryptobyte","hkdf","sha3","idna","nettest","cpu","transform","asn1","dnsmessage","httpguts","httpproxy","hpack","bidirule","bidi","norm"],"paths":["bufio","bytes","cmp","context","crypto","embed","encoding","errors","expvar","flag","fmt","hash","html","image","io","iter","log","maps","math","mime","net","os","path","plugin","reflect","regexp","runtime","slices","sort","strconv","strings","structs","sync","syscall","testing","time","unicode","unique","unsafe","archive/tar","archive/zip","compress/bzip2","compress/flate","compress/gzip","compress/lzw","compress/zlib","container/heap","container/list","container/ring","crypto/aes","crypto/cipher","crypto/des","crypto/dsa","crypto/ecdh","crypto/ecdsa","crypto/ed25519","crypto/elliptic","crypto/hmac","crypto/md5","crypto/rand","crypto/rc4","crypto/rsa","crypto/sha1","crypto/sha256","crypto/sha512","crypto/subtle","crypto/tls","crypto/x509","database/sql","debug/buildinfo","debug/dwarf","debug/elf","debug/gosym","debug/macho","debug/pe","debug/plan9obj","encoding/ascii85","encoding/asn1","encoding/base32","encoding/base64","encoding/binary","encoding/csv","encoding/gob","encoding/hex","encoding/json","encoding/pem","encoding/xml","go/ast","go/build","go/constant","go/doc","go/format","go/importer","go/parser","go/printer","go/scanner","go/token","go/types","go/version","hash/adler32","hash/crc32","hash/crc64","hash/fnv","hash/maphash","html/template","image/color","image/draw","image/gif","image/jpeg","image/png","index/suffixarray","io/fs","io/ioutil","log/slog","log/syslog","math/big","math/bits","math/cmplx","math/rand","mime/multipart","mime/quotedprintable","net/http","net/mail","net/netip","net/rpc","net/smtp","net/textproto","net/url","os/exec","os/signal","os/user","path/filepath","regexp/syntax","runtime/cgo","runtime/coverage","runtime/debug","runtime/metrics","runtime/pprof","runtime/trace","sync/atomic","syscall/js","testing/fstest","testing/iotest","testing/quick","testing/slogtest","text/scanner","text/tabwriter","text/template","unicode/utf16","unicode/utf8","crypto/x509/pkix","database/sql/driver","go/build/constraint","go/doc/comment","image/color/palette","math/rand/v2","net/http/cgi","net/http/cookiejar","net/http/fcgi","net/http/httptest","net/http/httptrace","net/http/httputil","net/http/pprof","net/rpc/jsonrpc","text/template/parse","golang.org/x/crypto/chacha20","golang.org/x/crypto/chacha20poly1305","golang.org/x/crypto/cryptobyte","golang.org/x/crypto/hkdf","golang.org/x/crypto/sha3","golang.org/x/net/idna","golang.org/x/net/nettest","golang.org/x/sys/cpu","golang.org/x/text/transform","golang.org/x/crypto/cryptobyte/asn1","golang.org/x/net/dns/dnsmessage","golang.org/x/net/http/httpguts","golang.org/x/net/http/httpproxy","golang.org/x/net/http2/hpack","golang.org/x/text/secure/bidirule","golang.org/x/text/unicode/bidi","golang.org/x/text/unicode/norm"],"docs":["Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.\n\n[`bufio` on pkg.go.dev](https://pkg.go.dev/bufio)","Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the [strings](https://pkg.go.dev/strings/) package.\n\n[`bytes` on pkg.go.dev](https://pkg.go.dev/bytes)","Package cmp provides types and functions related to comparing ordered values.\n\n[`cmp` on pkg.go.dev](https://pkg.go.dev/cmp)","Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n\nIncoming requests to a server should create a \\[Context], and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using \\[WithCancel], \\[WithDeadline], \\[WithTimeout], or \\[WithValue]. When a Context is canceled, all Contexts derived from it are also canceled.\n\nThe \\[WithCancel], \\[WithDeadline], and \\[WithTimeout] functions take a Context (the parent) and return a derived Context (the child) and a \\[CancelFunc]. Calling the CancelFunc cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.\n\nThe \\[WithCancelCause] function returns a \\[CancelCauseFunc], which takes an error and records it as the cancellation cause. Calling \\[Cause] on the canceled context or any of its children retrieves the cause. If no cause is specified, Cause(ctx) returns the same value as ctx.Err().\n\nPrograms that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:\n\nDo not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:\n\n\tfunc DoSomething(ctx context.Context, arg Arg) error {\n\t\t// ... use ctx ...\n\t}\n\nDo not pass a nil \\[Context], even if a function permits it. Pass [context.TODO](https://pkg.go.dev/context/#TODO) if you are unsure about which Context to use.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.\n\nSee [https://blog.golang.org/context](https://blog.golang.org/context) for example code for a server that uses Contexts.\n\n[`context` on pkg.go.dev](https://pkg.go.dev/context)","Package crypto collects common cryptographic constants.\n\n[`crypto` on pkg.go.dev](https://pkg.go.dev/crypto)","Package embed provides access to files embedded in the running Go program.\n\nGo source files that import \"embed\" can use the //go:embed directive to initialize a variable of type string, \\[]byte, or \\[FS] with the contents of files read from the package directory or subdirectories at compile time.\n\nFor example, here are three ways to embed a file named hello.txt and then print its contents at run time.\n\nEmbedding one file into a string:\n\n\timport _ \"embed\"\n\n\t//go:embed hello.txt\n\tvar s string\n\tprint(s)\n\nEmbedding one file into a slice of bytes:\n\n\timport _ \"embed\"\n\n\t//go:embed hello.txt\n\tvar b []byte\n\tprint(string(b))\n\nEmbedded one or more files into a file system:\n\n\timport \"embed\"\n\n\t//go:embed hello.txt\n\tvar f embed.FS\n\tdata, _ := f.ReadFile(\"hello.txt\")\n\tprint(string(data))\n\n### Directives {#hdr-Directives}\n\nA //go:embed directive above a variable declaration specifies which files to embed, using one or more path.Match patterns.\n\nThe directive must immediately precede a line containing the declaration of a single variable. Only blank lines and ‘//’ line comments are permitted between the directive and the declaration.\n\nThe type of the variable must be a string type, or a slice of a byte type, or \\[FS] (or an alias of \\[FS]).\n\nFor example:\n\n\tpackage server\n\n\timport \"embed\"\n\n\t// content holds our static web server content.\n\t//go:embed image/* template/*\n\t//go:embed html/index.html\n\tvar content embed.FS\n\nThe Go build system will recognize the directives and arrange for the declared variable (in the example above, content) to be populated with the matching files from the file system.\n\nThe //go:embed directive accepts multiple space-separated patterns for brevity, but it can also be repeated, to avoid very long lines when there are many patterns. The patterns are interpreted relative to the package directory containing the source file. The path separator is a forward slash, even on Windows systems. Patterns may not contain ‘.’ or ‘..’ or empty path elements, nor may they begin or end with a slash. To match everything in the current directory, use ‘\\*’ instead of ‘.’. To allow for naming files with spaces in their names, patterns can be written as Go double-quoted or back-quoted string literals.\n\nIf a pattern names a directory, all files in the subtree rooted at that directory are embedded (recursively), except that files with names beginning with ‘.’ or ‘\\_’ are excluded. So the variable in the above example is almost equivalent to:\n\n\t// content is our static web server content.\n\t//go:embed image template html/index.html\n\tvar content embed.FS\n\nThe difference is that ‘image/\\*’ embeds ‘image/.tempfile’ while ‘image’ does not. Neither embeds ‘image/dir/.tempfile’.\n\nIf a pattern begins with the prefix ‘all:’, then the rule for walking directories is changed to include those files beginning with ‘.’ or ‘\\_’. For example, ‘all:image’ embeds both ‘image/.tempfile’ and ‘image/dir/.tempfile’.\n\nThe //go:embed directive can be used with both exported and unexported variables, depending on whether the package wants to make the data available to other packages. It can only be used with variables at package scope, not with local variables.\n\nPatterns must not match files outside the package's module, such as ‘.git/\\*’ or symbolic links. Patterns must not match files whose names include the special punctuation characters  \" \\* \\\u003c \u003e ? \\` ' | / \\\\ and :. Matches for empty directories are ignored. After that, each pattern in a //go:embed line must match at least one file or non-empty directory.\n\nIf any patterns are invalid or have invalid matches, the build will fail.\n\n### Strings and Bytes {#hdr-Strings_and_Bytes}\n\nThe //go:embed line for a variable of type string or \\[]byte can have only a single pattern, and that pattern can match only a single file. The string or \\[]byte is initialized with the contents of that file.\n\nThe //go:embed directive requires importing \"embed\", even when using a string or \\[]byte. In source files that don't refer to [embed.FS](https://pkg.go.dev/embed/#FS), use a blank import (import \\_ \"embed\").\n\n### File Systems {#hdr-File_Systems}\n\nFor embedding a single file, a variable of type string or \\[]byte is often best. The \\[FS] type enables embedding a tree of files, such as a directory of static web server content, as in the example above.\n\nFS implements the [io/fs](https://pkg.go.dev/io/fs/) package's \\[FS] interface, so it can be used with any package that understands file systems, including [net/http](https://pkg.go.dev/net/http/), [text/template](https://pkg.go.dev/text/template/), and [html/template](https://pkg.go.dev/html/template/).\n\nFor example, given the content variable in the example above, we can write:\n\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(content))))\n\n\ttemplate.ParseFS(content, \"*.tmpl\")\n\n### Tools {#hdr-Tools}\n\nTo support tools that analyze Go packages, the patterns found in //go:embed lines are available in “go list” output. See the EmbedPatterns, TestEmbedPatterns, and XTestEmbedPatterns fields in the “go help list” output.\n\n[`embed` on pkg.go.dev](https://pkg.go.dev/embed)","Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.\n\nAdding encoding/decoding methods to existing types may constitute a breaking change, as they can be used for serialization in communicating with programs written with different library versions. The policy for packages maintained by the Go project is to only allow the addition of marshaling functions if no existing, reasonable marshaling exists.\n\n[`encoding` on pkg.go.dev](https://pkg.go.dev/encoding)","Package errors implements functions to manipulate errors.\n\nThe \\[New] function creates errors whose only content is a text message.\n\nAn error e wraps another error if e's type has one of the methods\n\n\tUnwrap() error\n\tUnwrap() []error\n\nIf e.Unwrap() returns a non-nil error w or a slice containing w, then we say that e wraps w. A nil error returned from e.Unwrap() indicates that e does not wrap any error. It is invalid for an Unwrap method to return an \\[]error containing a nil error value.\n\nAn easy way to create wrapped errors is to call [fmt.Errorf](https://pkg.go.dev/fmt/#Errorf) and apply the %w verb to the error argument:\n\n\twrapsErr := fmt.Errorf(\"... %w ...\", ..., err, ...)\n\nSuccessive unwrapping of an error creates a tree. The \\[Is] and \\[As] functions inspect an error's tree by examining first the error itself followed by the tree of each of its children in turn (pre-order, depth-first traversal).\n\n\\[Is] examines the tree of its first argument looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:\n\n\tif errors.Is(err, fs.ErrExist)\n\nis preferable to\n\n\tif err == fs.ErrExist\n\nbecause the former will succeed if err wraps [io/fs.ErrExist](https://pkg.go.dev/io/fs/#ErrExist).\n\n\\[As] examines the tree of its first argument looking for an error that can be assigned to its second argument, which must be a pointer. If it succeeds, it performs the assignment and returns true. Otherwise, it returns false. The form\n\n\tvar perr *fs.PathError\n\tif errors.As(err, \u0026perr) {\n\t\tfmt.Println(perr.Path)\n\t}\n\nis preferable to\n\n\tif perr, ok := err.(*fs.PathError); ok {\n\t\tfmt.Println(perr.Path)\n\t}\n\nbecause the former will succeed if err wraps an [\\*io/fs.PathError](https://pkg.go.dev/io/fs/#PathError).\n\n[`errors` on pkg.go.dev](https://pkg.go.dev/errors)","Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format. As of Go 1.22, the /debug/vars request must use GET.\n\nOperations to set or modify these public variables are atomic.\n\nIn addition to adding the HTTP handler, this package registers the following variables:\n\n\tcmdline   os.Args\n\tmemstats  runtime.Memstats\n\nThe package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:\n\n\timport _ \"expvar\"\n\n[`expvar` on pkg.go.dev](https://pkg.go.dev/expvar)","Package flag implements command-line flag parsing.\n\n### Usage {#hdr-Usage}\n\nDefine flags using [flag.String](https://pkg.go.dev/flag/#String), \\[Bool], \\[Int], etc.\n\nThis declares an integer flag, -n, stored in the pointer nFlag, with type \\*int:\n\n\timport \"flag\"\n\tvar nFlag = flag.Int(\"n\", 1234, \"help message for flag n\")\n\nIf you like, you can bind the flag to a variable using the Var() functions.\n\n\tvar flagvar int\n\tfunc init() {\n\t\tflag.IntVar(\u0026flagvar, \"flagname\", 1234, \"help message for flagname\")\n\t}\n\nOr you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by\n\n\tflag.Var(\u0026flagVal, \"name\", \"help message for flagname\")\n\nFor such flags, the default value is just the initial value of the variable.\n\nAfter all flags are defined, call\n\n\tflag.Parse()\n\nto parse the command line into the defined flags.\n\nFlags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.\n\n\tfmt.Println(\"ip has value \", *ip)\n\tfmt.Println(\"flagvar has value \", flagvar)\n\nAfter parsing, the arguments following the flags are available as the slice [flag.Args](https://pkg.go.dev/flag/#Args) or individually as [flag.Arg](https://pkg.go.dev/flag/#Arg)(i). The arguments are indexed from 0 through [flag.NArg](https://pkg.go.dev/flag/#NArg)-1.\n\n### Command line flag syntax {#hdr-Command_line_flag_syntax}\n\nThe following forms are permitted:\n\n\t-flag\n\t--flag   // double dashes are also permitted\n\t-flag=x\n\t-flag x  // non-boolean flags only\n\nOne or two dashes may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command\n\n\tcmd -x *\n\nwhere \\* is a Unix shell wildcard, will change if there is a file called 0, false, etc. You must use the -flag=false form to turn off a boolean flag.\n\nFlag parsing stops just before the first non-flag argument (\"-\" is a non-flag argument) or after the terminator \"--\".\n\nInteger flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:\n\n\t1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\n\nDuration flags accept any input valid for time.ParseDuration.\n\nThe default set of command-line flags is controlled by top-level functions.  The \\[FlagSet] type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of \\[FlagSet] are analogous to the top-level functions for the command-line flag set.\n\n[`flag` on pkg.go.dev](https://pkg.go.dev/flag)","Package fmt implements formatted I/O with functions analogous to C's printf and scanf.  The format 'verbs' are derived from C's but are simpler.\n\n### Printing {#hdr-Printing}\n\nThe verbs:\n\nGeneral:\n\n\t%v\tthe value in a default format\n\t\twhen printing structs, the plus flag (%+v) adds field names\n\t%#v\ta Go-syntax representation of the value\n\t\t(floating-point infinities and NaNs print as ±Inf and NaN)\n\t%T\ta Go-syntax representation of the type of the value\n\t%%\ta literal percent sign; consumes no value\n\nBoolean:\n\n\t%t\tthe word true or false\n\nInteger:\n\n\t%b\tbase 2\n\t%c\tthe character represented by the corresponding Unicode code point\n\t%d\tbase 10\n\t%o\tbase 8\n\t%O\tbase 8 with 0o prefix\n\t%q\ta single-quoted character literal safely escaped with Go syntax.\n\t%x\tbase 16, with lower-case letters for a-f\n\t%X\tbase 16, with upper-case letters for A-F\n\t%U\tUnicode format: U+1234; same as \"U+%04X\"\n\nFloating-point and complex constituents:\n\n\t%b\tdecimalless scientific notation with exponent a power of two,\n\t\tin the manner of strconv.FormatFloat with the 'b' format,\n\t\te.g. -123456p-78\n\t%e\tscientific notation, e.g. -1.234456e+78\n\t%E\tscientific notation, e.g. -1.234456E+78\n\t%f\tdecimal point but no exponent, e.g. 123.456\n\t%F\tsynonym for %f\n\t%g\t%e for large exponents, %f otherwise. Precision is discussed below.\n\t%G\t%E for large exponents, %F otherwise\n\t%x\thexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20\n\t%X\tupper-case hexadecimal notation, e.g. -0X1.23ABCP+20\n\nString and slice of bytes (treated equivalently with these verbs):\n\n\t%s\tthe uninterpreted bytes of the string or slice\n\t%q\ta double-quoted string safely escaped with Go syntax\n\t%x\tbase 16, lower-case, two characters per byte\n\t%X\tbase 16, upper-case, two characters per byte\n\nSlice:\n\n\t%p\taddress of 0th element in base 16 notation, with leading 0x\n\nPointer:\n\n\t%p\tbase 16 notation, with leading 0x\n\tThe %b, %d, %o, %x and %X verbs also work with pointers,\n\tformatting the value exactly as if it were an integer.\n\nThe default format for %v is:\n\n\tbool:                    %t\n\tint, int8 etc.:          %d\n\tuint, uint8 etc.:        %d, %#x if printed with %#v\n\tfloat32, complex64, etc: %g\n\tstring:                  %s\n\tchan:                    %p\n\tpointer:                 %p\n\nFor compound objects, the elements are printed using these rules, recursively, laid out like this:\n\n\tstruct:             {field0 field1 ...}\n\tarray, slice:       [elem0 elem1 ...]\n\tmaps:               map[key1:value1 key2:value2 ...]\n\tpointer to above:   \u0026{}, \u0026[], \u0026map[]\n\nWidth is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:\n\n\t%f     default width, default precision\n\t%9f    width 9, default precision\n\t%.2f   default width, precision 2\n\t%9.2f  width 9, precision 2\n\t%9.f   width 9, precision 0\n\nWidth and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '\\*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.\n\nFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.\n\nFor complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type \\[]rune) with %q, invalid Unicode code points are changed to the Unicode replacement character, U+FFFD, as in [strconv.QuoteRune](https://pkg.go.dev/strconv/#QuoteRune).\n\nOther flags:\n\n\t'+'\talways print a sign for numeric values;\n\t\tguarantee ASCII-only output for %q (%+q)\n\t'-'\tpad with spaces on the right rather than the left (left-justify the field)\n\t'#'\talternate format: add leading 0b for binary (%#b), 0 for octal (%#o),\n\t\t0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);\n\t\tfor %q, print a raw (backquoted) string if [strconv.CanBackquote]\n\t\treturns true;\n\t\talways print a decimal point for %e, %E, %f, %F, %g and %G;\n\t\tdo not remove trailing zeros for %g and %G;\n\t\twrite e.g. U+0078 'x' if the character is printable for %U (%#U)\n\t' '\t(space) leave a space for elided sign in numbers (% d);\n\t\tput spaces between bytes printing strings or slices in hex (% x, % X)\n\t'0'\tpad with leading zeros rather than spaces;\n\t\tfor numbers, this moves the padding after the sign\n\nFlags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.\n\nFor each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand.  Another variant Println inserts blanks between operands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:\n\n\tvar i interface{} = 23\n\tfmt.Printf(\"%v\\n\", i)\n\nwill print 23.\n\nExcept when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:\n\n1\\. If the operand is a [reflect.Value](https://pkg.go.dev/reflect/#Value), the operand is replaced by the concrete value that it holds, and printing continues with the next rule.\n\n2\\. If an operand implements the \\[Formatter] interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation.\n\n3\\. If the %v verb is used with the # flag (%#v) and the operand implements the \\[GoStringer] interface, that will be invoked.\n\nIf the format (which is implicitly %v for \\[Println] etc.) is valid for a string (%s %q %x %X), or is %v but not %#v, the following two rules apply:\n\n4\\. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\n5\\. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\n\ttype X string\n\tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", x) }\n\nconvert the value before recurring:\n\n\tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", string(x)) }\n\nInfinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.\n\n### Explicit argument indexes {#hdr-Explicit_argument_indexes}\n\nIn \\[Printf], \\[Sprintf], and \\[Fprintf], the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation \\[n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '\\*' for a width or precision selects the argument index holding the value. After processing a bracketed expression \\[n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.\n\nFor example,\n\n\tfmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\n\nwill yield \"22 11\", while\n\n\tfmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\n\nequivalent to\n\n\tfmt.Sprintf(\"%6.2f\", 12.0)\n\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated:\n\n\tfmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\n\nwill yield \"16 17 0x10 0x11\".\n\n### Format errors {#hdr-Format_errors}\n\nIf an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:\n\n\tWrong type or unknown verb: %!verb(type=value)\n\t\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\n\tToo many arguments: %!(EXTRA type=value)\n\t\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\n\tToo few arguments: %!verb(MISSING)\n\t\tPrintf(\"hi%d\"):            hi%!d(MISSING)\n\tNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\t\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\t\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\n\tInvalid or invalid use of argument index: %!(BADINDEX)\n\t\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\t\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\n\nAll errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description.\n\nIf an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package.  For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like\n\n\t%!s(PANIC=bad)\n\nThe %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, \"\\\u003cnil\u003e\".\n\n### Scanning {#hdr-Scanning}\n\nAn analogous set of functions scans formatted text to yield values.  \\[Scan], \\[Scanf] and \\[Scanln] read from [os.Stdin](https://pkg.go.dev/os/#Stdin); \\[Fscan], \\[Fscanf] and \\[Fscanln] read from a specified [io.Reader](https://pkg.go.dev/io/#Reader); \\[Sscan], \\[Sscanf] and \\[Sscanln] read from an argument string.\n\n\\[Scan], \\[Fscan], \\[Sscan] treat newlines in the input as spaces.\n\n\\[Scanln], \\[Fscanln] and \\[Sscanln] stop scanning at a newline and require that the items be followed by a newline or EOF.\n\n\\[Scanf], \\[Fscanf], and \\[Sscanf] parse the arguments according to a format string, analogous to that of \\[Printf]. In the text that follows, 'space' means any Unicode whitespace character except newline.\n\nIn the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of \\[Printf]. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The \\[Printf] verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159\\_26535\\_89793\").\n\nInput processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.\n\nWidth is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,\n\n\tSscanf(\" 1234567 \", \"%5s%d\", \u0026s, \u0026i)\n\nwill set s to \"12345\" and i to 67 while\n\n\tSscanf(\" 12 34 567 \", \"%5s%d\", \u0026s, \u0026i)\n\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\\\r\\\\n means the same as \\\\n).\n\nIn all the scanning functions, if an operand implements method \\[Scan] (that is, it implements the \\[Scanner] interface) that method will be used to scan the text for that operand.  Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic types or implementations of the \\[Scanner] interface.\n\nLike \\[Scanf] and \\[Fscanf], \\[Sscanf] need not consume its entire input. There is no way to recover how much of the input string \\[Sscanf] used.\n\nNote: \\[Fscan] etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input.  This is usually a problem only when there is no space between input values.  If the reader provided to \\[Fscan] implements ReadRune, that method will be used to read characters.  If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data.  To attach ReadRune and UnreadRune methods to a reader without that capability, use [bufio.NewReader](https://pkg.go.dev/bufio/#NewReader).\n\n[`fmt` on pkg.go.dev](https://pkg.go.dev/fmt)","Package hash provides interfaces for hash functions.\n\n[`hash` on pkg.go.dev](https://pkg.go.dev/hash)","Package html provides functions for escaping and unescaping HTML text.\n\n[`html` on pkg.go.dev](https://pkg.go.dev/html)","Package image implements a basic 2-D image library.\n\nThe fundamental interface is called \\[Image]. An \\[Image] contains colors, which are described in the image/color package.\n\nValues of the \\[Image] interface are created either by calling functions such as \\[NewRGBA] and \\[NewPaletted], or by calling \\[Decode] on an [io.Reader](https://pkg.go.dev/io/#Reader) containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have\n\n\timport _ \"image/png\"\n\nin a program's main package. The \\_ means to import a package purely for its initialization side effects.\n\nSee \"The Go image package\" for more details: [https://golang.org/doc/articles/image\\_package.html](https://golang.org/doc/articles/image_package.html)\n\n### Security Considerations {#hdr-Security_Considerations}\n\nThe image package can be used to parse arbitrarily large images, which can cause resource exhaustion on machines which do not have enough memory to store them. When operating on arbitrary images, \\[DecodeConfig] should be called before \\[Decode], so that the program can decide whether the image, as defined in the returned header, can be safely decoded with the available resources. A call to \\[Decode] which produces an extremely large image, as defined in the header returned by \\[DecodeConfig], is not considered a security issue, regardless of whether the image is itself malformed or not. A call to \\[DecodeConfig] which returns a header which does not match the image returned by \\[Decode] may be considered a security issue, and should be reported per the \\[Go Security Policy]([https://go.dev/security/policy](https://go.dev/security/policy)).\n\n[`image` on pkg.go.dev](https://pkg.go.dev/image)","Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives.\n\nBecause these interfaces and primitives wrap lower-level operations with various implementations, unless otherwise informed clients should not assume they are safe for parallel execution.\n\n[`io` on pkg.go.dev](https://pkg.go.dev/io)","Package iter provides basic definitions and operations related to iterators over sequences.\n\n### Iterators {#hdr-Iterators}\n\nAn iterator is a function that passes successive elements of a sequence to a callback function, conventionally named yield. The function stops either when the sequence is finished or when yield returns false, indicating to stop the iteration early. This package defines \\[Seq] and \\[Seq2] (pronounced like seek—the first syllable of sequence) as shorthands for iterators that pass 1 or 2 values per sequence element to yield:\n\n\ttype (\n\t\tSeq[V any]     func(yield func(V) bool)\n\t\tSeq2[K, V any] func(yield func(K, V) bool)\n\t)\n\nSeq2 represents a sequence of paired values, conventionally key-value or index-value pairs.\n\nYield returns true if the iterator should continue with the next element in the sequence, false if it should stop.\n\nIterator functions are most often called by a range loop, as in:\n\n\tfunc PrintAll[V any](seq iter.Seq[V]) {\n\t\tfor v := range seq {\n\t\t\tfmt.Println(v)\n\t\t}\n\t}\n\n### Naming Conventions {#hdr-Naming_Conventions}\n\nIterator functions and methods are named for the sequence being walked:\n\n\t// All returns an iterator over all elements in s.\n\tfunc (s *Set[V]) All() iter.Seq[V]\n\nThe iterator method on a collection type is conventionally named All, because it iterates a sequence of all the values in the collection.\n\nFor a type containing multiple possible sequences, the iterator's name can indicate which sequence is being provided:\n\n\t// Cities returns an iterator over the major cities in the country.\n\tfunc (c *Country) Cities() iter.Seq[*City]\n\n\t// Languages returns an iterator over the official spoken languages of the country.\n\tfunc (c *Country) Languages() iter.Seq[string]\n\nIf an iterator requires additional configuration, the constructor function can take additional configuration arguments:\n\n\t// Scan returns an iterator over key-value pairs with min ≤ key ≤ max.\n\tfunc (m *Map[K, V]) Scan(min, max K) iter.Seq2[K, V]\n\n\t// Split returns an iterator over the (possibly-empty) substrings of s\n\t// separated by sep.\n\tfunc Split(s, sep string) iter.Seq[string]\n\nWhen there are multiple possible iteration orders, the method name may indicate that order:\n\n\t// All returns an iterator over the list from head to tail.\n\tfunc (l *List[V]) All() iter.Seq[V]\n\n\t// Backward returns an iterator over the list from tail to head.\n\tfunc (l *List[V]) Backward() iter.Seq[V]\n\n\t// Preorder returns an iterator over all nodes of the syntax tree\n\t// beneath (and including) the specified root, in depth-first preorder,\n\t// visiting a parent node before its children.\n\tfunc Preorder(root Node) iter.Seq[Node]\n\n### Single-Use Iterators {#hdr-Single_Use_Iterators}\n\nMost iterators provide the ability to walk an entire sequence: when called, the iterator does any setup necessary to start the sequence, then calls yield on successive elements of the sequence, and then cleans up before returning. Calling the iterator again walks the sequence again.\n\nSome iterators break that convention, providing the ability to walk a sequence only once. These “single-use iterators” typically report values from a data stream that cannot be rewound to start over. Calling the iterator again after stopping early may continue the stream, but calling it again after the sequence is finished will yield no values at all. Doc comments for functions or methods that return single-use iterators should document this fact:\n\n\t// Lines returns an iterator over lines read from r.\n\t// It returns a single-use iterator.\n\tfunc (r *Reader) Lines() iter.Seq[string]\n\n### Pulling Values {#hdr-Pulling_Values}\n\nFunctions and methods that accept or return iterators should use the standard \\[Seq] or \\[Seq2] types, to ensure compatibility with range loops and other iterator adapters. The standard iterators can be thought of as “push iterators”, which push values to the yield function.\n\nSometimes a range loop is not the most natural way to consume values of the sequence. In this case, \\[Pull] converts a standard push iterator to a “pull iterator”, which can be called to pull one value at a time from the sequence. \\[Pull] starts an iterator and returns a pair of functions—next and stop—which return the next value from the iterator and stop it, respectively.\n\nFor example:\n\n\t// Pairs returns an iterator over successive pairs of values from seq.\n\tfunc Pairs[V any](seq iter.Seq[V]) iter.Seq2[V, V] {\n\t\treturn func(yield func(V, V) bool) {\n\t\t\tnext, stop := iter.Pull(seq)\n\t\t\tdefer stop()\n\t\t\tfor {\n\t\t\t\tv1, ok1 := next()\n\t\t\t\tif !ok1 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv2, ok2 := next()\n\t\t\t\t// If ok2 is false, v2 should be the\n\t\t\t\t// zero value; yield one last pair.\n\t\t\t\tif !yield(v1, v2) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !ok2 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nIf clients do not consume the sequence to completion, they must call stop, which allows the iterator function to finish and return. As shown in the example, the conventional way to ensure this is to use defer.\n\n### Standard Library Usage {#hdr-Standard_Library_Usage}\n\nA few packages in the standard library provide iterator-based APIs, most notably the [maps](https://pkg.go.dev/maps/) and [slices](https://pkg.go.dev/slices/) packages. For example, [maps.Keys](https://pkg.go.dev/maps/#Keys) returns an iterator over the keys of a map, while [slices.Sorted](https://pkg.go.dev/slices/#Sorted) collects the values of an iterator into a slice, sorts them, and returns the slice, so to iterate over the sorted keys of a map:\n\n\tfor _, key := range slices.Sorted(maps.Keys(m)) {\n\t\t...\n\t}\n\n### Mutation {#hdr-Mutation}\n\nIterators provide only the values of the sequence, not any direct way to modify it. If an iterator wishes to provide a mechanism for modifying a sequence during iteration, the usual approach is to define a position type with the extra operations and then provide an iterator over positions.\n\nFor example, a tree implementation might provide:\n\n\t// Positions returns an iterator over positions in the sequence.\n\tfunc (t *Tree[V]) Positions() iter.Seq[*Pos]\n\n\t// A Pos represents a position in the sequence.\n\t// It is only valid during the yield call it is passed to.\n\ttype Pos[V any] struct { ... }\n\n\t// Pos returns the value at the cursor.\n\tfunc (p *Pos[V]) Value() V\n\n\t// Delete deletes the value at this point in the iteration.\n\tfunc (p *Pos[V]) Delete()\n\n\t// Set changes the value v at the cursor.\n\tfunc (p *Pos[V]) Set(v V)\n\nAnd then a client could delete boring values from the tree using:\n\n\tfor p := range t.Positions() {\n\t\tif boring(p.Value()) {\n\t\t\tp.Delete()\n\t\t}\n\t}\n\n[`iter` on pkg.go.dev](https://pkg.go.dev/iter)","Package log implements a simple logging package. It defines a type, \\[Logger], with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print\\[f|ln], Fatal\\[f|ln], and Panic\\[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call [os.Exit](https://pkg.go.dev/os/#Exit)(1) after writing the log message. The Panic functions call panic after writing the log message.\n\n[`log` on pkg.go.dev](https://pkg.go.dev/log)","Package maps defines various functions useful with maps of any type.\n\nThis package does not have any special handling for non-reflexive keys (keys k where k != k), such as floating-point NaNs.\n\n[`maps` on pkg.go.dev](https://pkg.go.dev/maps)","Package math provides basic constants and mathematical functions.\n\nThis package does not guarantee bit-identical results across architectures.\n\n[`math` on pkg.go.dev](https://pkg.go.dev/math)","Package mime implements parts of the MIME spec.\n\n[`mime` on pkg.go.dev](https://pkg.go.dev/mime)","Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the \\[Dial], \\[Listen], and Accept functions and the associated \\[Conn] and \\[Listener] interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n\t// ...\n\nThe Listen function creates servers:\n\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n\n### Name Resolution {#hdr-Name_Resolution}\n\nThe method for resolving domain names, whether indirectly with functions like Dial or directly with functions like \\[LookupHost] and \\[LookupAddr], varies by operating system.\n\nOn Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.\n\nOn Unix the pure Go resolver is preferred over the cgo resolver, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES\\_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR\\_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement.\n\nOn all systems (except Plan 9), when the cgo resolver is being used this package applies a concurrent cgo lookup limit to prevent the system from running out of system threads. Currently, it is limited to 500 concurrent lookups.\n\nThe resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n\texport GODEBUG=netdns=go    # force pure Go resolver\n\texport GODEBUG=netdns=cgo   # force native resolver (cgo, win32)\n\nThe decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1.\n\nThe Go resolver will send an EDNS0 additional header with a DNS request, to signal a willingness to accept a larger DNS packet size. This can reportedly cause sporadic failures with the DNS server run by some modems and routers. Setting GODEBUG=netedns0=0 will disable sending the additional header.\n\nOn macOS, if Go code that uses the net package is built with -buildmode=c-archive, linking the resulting archive into a C program requires passing -lresolv when linking the C code.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, in Go 1.18.x and earlier, the resolver always used C library functions, such as GetAddrInfo and DnsQuery.\n\n[`net` on pkg.go.dev](https://pkg.go.dev/net)","Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as \\[Open] or \\[Stat], the error will include the failing file name when printed and will be of type \\[\\*PathError], which may be unpacked for more information.\n\nThe os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.\n\nHere is a simple example, opening a file and reading some of it.\n\n\tfile, err := os.Open(\"file.go\") // For read access.\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\nIf the open fails, the error string will be self-explanatory, like\n\n\topen file.go: no such file or directory\n\nThe file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.\n\n\tdata := make([]byte, 100)\n\tcount, err := file.Read(data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n\n### Concurrency {#hdr-Concurrency}\n\nThe methods of \\[File] correspond to file system operations. All are safe for concurrent use. The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding it may degrade performance or cause other issues.\n\n[`os` on pkg.go.dev](https://pkg.go.dev/os)","Package path implements utility routines for manipulating slash-separated paths.\n\nThe path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the [path/filepath](https://pkg.go.dev/path/filepath/) package.\n\n[`path` on pkg.go.dev](https://pkg.go.dev/path)","Package plugin implements loading and symbol resolution of Go plugins.\n\nA plugin is a Go main package with exported functions and variables that has been built with:\n\n\tgo build -buildmode=plugin\n\nWhen a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.\n\n### Warnings {#hdr-Warnings}\n\nThe ability to dynamically load parts of an application during execution, perhaps based on user-defined configuration, may be a useful building block in some designs. In particular, because applications and dynamically loaded functions can share data structures directly, plugins may enable very high-performance integration of separate parts.\n\nHowever, the plugin mechanism has many significant drawbacks that should be considered carefully during the design. For example:\n\n  - Plugins are currently supported only on Linux, FreeBSD, and macOS, making them unsuitable for applications intended to be portable.\n\n  - Applications that use plugins may require careful configuration to ensure that the various parts of the program be made available in the correct location in the file system (or container image). By contrast, deploying an application consisting of a single static executable is straightforward.\n\n  - Reasoning about program initialization is more difficult when some packages may not be initialized until long after the application has started running.\n\n  - Bugs in applications that load plugins could be exploited by an attacker to load dangerous or untrusted libraries.\n\n  - Runtime crashes are likely to occur unless all parts of the program (the application and all its plugins) are compiled using exactly the same version of the toolchain, the same build tags, and the same values of certain flags and environment variables.\n\n  - Similar crashing problems are likely to arise unless all common dependencies of the application and its plugins are built from exactly the same source code.\n\n  - Together, these restrictions mean that, in practice, the application and its plugins must all be built together by a single person or component of a system. In that case, it may be simpler for that person or component to generate Go source files that blank-import the desired set of plugins and then compile a static executable in the usual way.\n\nFor these reasons, many users decide that traditional interprocess communication (IPC) mechanisms such as sockets, pipes, remote procedure call (RPC), shared memory mappings, or file system operations may be more suitable despite the performance overheads.\n\n[`plugin` on pkg.go.dev](https://pkg.go.dev/plugin)","Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.\n\nA call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type.\n\nSee \"The Laws of Reflection\" for an introduction to reflection in Go: [https://golang.org/doc/articles/laws\\_of\\_reflection.html](https://golang.org/doc/articles/laws_of_reflection.html)\n\n[`reflect` on pkg.go.dev](https://pkg.go.dev/reflect)","Package regexp implements regular expression search.\n\nThe syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at [https://golang.org/s/re2syntax](https://golang.org/s/re2syntax), except for \\\\C. For an overview of the syntax, see the [regexp/syntax](https://pkg.go.dev/regexp/syntax/) package.\n\nThe regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see [https://swtch.com/~rsc/regexp/regexp1.html](https://swtch.com/~rsc/regexp/regexp1.html) or any book about automata theory.\n\nAll characters are UTF-8-encoded code points. Following \\[utf8.DecodeRune], each byte of an invalid UTF-8 sequence is treated as if it encoded utf8.RuneError (U+FFFD).\n\nThere are 16 methods of \\[Regexp] that match a regular expression and identify the matched text. Their names are matched by this regular expression:\n\n\tFind(All)?(String)?(Submatch)?(Index)?\n\nIf 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n \u003e= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.\n\nIf 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.\n\nIf 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 is the match of the first parenthesized subexpression, and so on.\n\nIf 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result\\[2\\*n:2\\*n+2] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.\n\nThere is also a subset of the methods that can be applied to text read from an [io.RuneReader](https://pkg.go.dev/io/#RuneReader): \\[Regexp.MatchReader], \\[Regexp.FindReaderIndex], \\[Regexp.FindReaderSubmatchIndex].\n\nThis set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from an [io.RuneReader](https://pkg.go.dev/io/#RuneReader) may read arbitrarily far into the input before returning.\n\n(There are a few other methods that do not match this pattern.)\n\n[`regexp` on pkg.go.dev](https://pkg.go.dev/regexp)","Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see [reflect](https://pkg.go.dev/reflect/)'s documentation for the programmable interface to the run-time type system.\n\n### Environment Variables {#hdr-Environment_Variables}\n\nThe following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.\n\nThe GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. [runtime/debug.SetGCPercent](https://pkg.go.dev/runtime/debug/#SetGCPercent) allows changing this percentage at run time.\n\nThe GOMEMLIMIT variable sets a soft memory limit for the runtime. This memory limit includes the Go heap and all other memory managed by the runtime, and excludes external memory sources such as mappings of the binary itself, memory managed in other languages, and memory held by the operating system on behalf of the Go program. GOMEMLIMIT is a numeric value in bytes with an optional unit suffix. The supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes represent quantities of bytes as defined by the IEC 80000-13 standard. That is, they are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes, and so on. The default setting is [math.MaxInt64](https://pkg.go.dev/math/#MaxInt64), which effectively disables the memory limit. [runtime/debug.SetMemoryLimit](https://pkg.go.dev/runtime/debug/#SetMemoryLimit) allows changing this limit at run time.\n\nThe GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables:\n\n\tclobberfree: setting clobberfree=1 causes the garbage collector to\n\tclobber the memory content of an object with bad content when it frees\n\tthe object.\n\n\tcpu.*: cpu.all=off disables the use of all optional instruction set extensions.\n\tcpu.extension=off disables use of instructions from the specified instruction set extension.\n\textension is the lower case name for the instruction set extension such as sse41 or avx\n\tas listed in internal/cpu package. As an example cpu.avx=off disables runtime detection\n\tand thereby use of AVX instructions.\n\n\tcgocheck: setting cgocheck=0 disables all checks for packages\n\tusing cgo to incorrectly pass Go pointers to non-Go code.\n\tSetting cgocheck=1 (the default) enables relatively cheap\n\tchecks that may miss some errors. A more complete, but slow,\n\tcgocheck mode can be enabled using GOEXPERIMENT (which\n\trequires a rebuild), see https://pkg.go.dev/internal/goexperiment for details.\n\n\tdisablethp: setting disablethp=1 on Linux disables transparent huge pages for the heap.\n\tIt has no effect on other platforms. disablethp is meant for compatibility with versions\n\tof Go before 1.21, which stopped working around a Linux kernel default that can result\n\tin significant memory overuse. See https://go.dev/issue/64332. This setting will be\n\tremoved in a future release, so operators should tweak their Linux configuration to suit\n\ttheir needs before then. See https://go.dev/doc/gc-guide#Linux_transparent_huge_pages.\n\n\tdontfreezetheworld: by default, the start of a fatal panic or throw\n\t\"freezes the world\", preempting all threads to stop all running\n\tgoroutines, which makes it possible to traceback all goroutines, and\n\tkeeps their state close to the point of panic. Setting\n\tdontfreezetheworld=1 disables this preemption, allowing goroutines to\n\tcontinue executing during panic processing. Note that goroutines that\n\tnaturally enter the scheduler will still stop. This can be useful when\n\tdebugging the runtime scheduler, as freezetheworld perturbs scheduler\n\tstate and thus may hide problems.\n\n\tefence: setting efence=1 causes the allocator to run in a mode\n\twhere each object is allocated on a unique page and addresses are\n\tnever recycled.\n\n\tgccheckmark: setting gccheckmark=1 enables verification of the\n\tgarbage collector's concurrent mark phase by performing a\n\tsecond mark pass while the world is stopped.  If the second\n\tpass finds a reachable object that was not found by concurrent\n\tmark, the garbage collector will panic.\n\n\tgcpacertrace: setting gcpacertrace=1 causes the garbage collector to\n\tprint information about the internal state of the concurrent pacer.\n\n\tgcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\n\tonto smaller stacks. In this mode, a goroutine's stack can only grow.\n\n\tgcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\n\tmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2\n\talso disables concurrent sweeping after the garbage collection finishes.\n\n\tgctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\n\terror at each collection, summarizing the amount of memory collected and the\n\tlength of the pause. The format of this line is subject to change. Included in\n\tthe explanation below is also the relevant runtime/metrics metric for each field.\n\tCurrently, it is:\n\t\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-\u003e#-\u003e# MB, # MB goal, # MB stacks, #MB globals, # P\n\twhere the fields are as follows:\n\t\tgc #         the GC number, incremented at each GC\n\t\t@#s          time in seconds since program start\n\t\t#%           percentage of time spent in GC since program start\n\t\t#+...+#      wall-clock/CPU times for the phases of the GC\n\t\t#-\u003e#-\u003e# MB   heap size at GC start, at GC end, and live heap, or /gc/scan/heap:bytes\n\t\t# MB goal    goal heap size, or /gc/heap/goal:bytes\n\t\t# MB stacks  estimated scannable stack size, or /gc/scan/stack:bytes\n\t\t# MB globals scannable global size, or /gc/scan/globals:bytes\n\t\t# P          number of processors used, or /sched/gomaxprocs:threads\n\tThe phases are stop-the-world (STW) sweep termination, concurrent\n\tmark and scan, and STW mark termination. The CPU times\n\tfor mark/scan are broken down in to assist time (GC performed in\n\tline with allocation), background GC time, and idle GC time.\n\tIf the line ends with \"(forced)\", this GC was forced by a\n\truntime.GC() call.\n\n\tharddecommit: setting harddecommit=1 causes memory that is returned to the OS to\n\talso have protections removed on it. This is the only mode of operation on Windows,\n\tbut is helpful in debugging scavenger-related issues on other platforms. Currently,\n\tonly supported on Linux.\n\n\tinittrace: setting inittrace=1 causes the runtime to emit a single line to standard\n\terror for each package with init work, summarizing the execution time and memory\n\tallocation. No information is printed for inits executed as part of plugin loading\n\tand for packages without both user defined and compiler generated init work.\n\tThe format of this line is subject to change. Currently, it is:\n\t\tinit # @#ms, # ms clock, # bytes, # allocs\n\twhere the fields are as follows:\n\t\tinit #      the package name\n\t\t@# ms       time in milliseconds when the init started since program start\n\t\t# clock     wall-clock time for package initialization work\n\t\t# bytes     memory allocated on the heap\n\t\t# allocs    number of heap allocations\n\n\tmadvdontneed: setting madvdontneed=0 will use MADV_FREE\n\tinstead of MADV_DONTNEED on Linux when returning memory to the\n\tkernel. This is more efficient, but means RSS numbers will\n\tdrop only when the OS is under memory pressure. On the BSDs and\n\tIllumos/Solaris, setting madvdontneed=1 will use MADV_DONTNEED instead\n\tof MADV_FREE. This is less efficient, but causes RSS numbers to drop\n\tmore quickly.\n\n\tmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\n\tWhen set to 0 memory profiling is disabled.  Refer to the description of\n\tMemProfileRate for the default value.\n\n\tprofstackdepth: profstackdepth=128 (the default) will set the maximum stack\n\tdepth used by all pprof profilers except for the CPU profiler to 128 frames.\n\tStack traces that exceed this limit will be truncated to the limit starting\n\tfrom the leaf frame. Setting profstackdepth to any value above 1024 will\n\tsilently default to 1024. Future versions of Go may remove this limitation\n\tand extend profstackdepth to apply to the CPU profiler and execution tracer.\n\n\tpagetrace: setting pagetrace=/path/to/file will write out a trace of page events\n\tthat can be viewed, analyzed, and visualized using the x/debug/cmd/pagetrace tool.\n\tBuild your program with GOEXPERIMENT=pagetrace to enable this functionality. Do not\n\tenable this functionality if your program is a setuid binary as it introduces a security\n\trisk in that scenario. Currently not supported on Windows, plan9 or js/wasm. Setting this\n\toption for some applications can produce large traces, so use with care.\n\n\tpanicnil: setting panicnil=1 disables the runtime error when calling panic with nil\n\tinterface value or an untyped nil.\n\n\truntimecontentionstacks: setting runtimecontentionstacks=1 enables inclusion of call stacks\n\trelated to contention on runtime-internal locks in the \"mutex\" profile, subject to the\n\tMutexProfileFraction setting. When runtimecontentionstacks=0, contention on\n\truntime-internal locks will report as \"runtime._LostContendedRuntimeLock\". When\n\truntimecontentionstacks=1, the call stacks will correspond to the unlock call that released\n\tthe lock. But instead of the value corresponding to the amount of contention that call\n\tstack caused, it corresponds to the amount of time the caller of unlock had to wait in its\n\toriginal call to lock. A future release is expected to align those and remove this setting.\n\n\tinvalidptr: invalidptr=1 (the default) causes the garbage collector and stack\n\tcopier to crash the program if an invalid pointer value (for example, 1)\n\tis found in a pointer-typed location. Setting invalidptr=0 disables this check.\n\tThis should only be used as a temporary workaround to diagnose buggy code.\n\tThe real fix is to not store integers in pointer-typed locations.\n\n\tsbrk: setting sbrk=1 replaces the memory allocator and garbage collector\n\twith a trivial allocator that obtains memory from the operating system and\n\tnever reclaims any memory.\n\n\tscavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard\n\terror, roughly once per GC cycle, summarizing the amount of work done by the\n\tscavenger as well as the total amount of memory returned to the operating system\n\tand an estimate of physical memory utilization. The format of this line is subject\n\tto change, but currently it is:\n\t\tscav # KiB work (bg), # KiB work (eager), # KiB total, #% util\n\twhere the fields are as follows:\n\t\t# KiB work (bg)    the amount of memory returned to the OS in the background since\n\t\t                   the last line\n\t\t# KiB work (eager) the amount of memory returned to the OS eagerly since the last line\n\t\t# KiB now          the amount of address space currently returned to the OS\n\t\t#% util            the fraction of all unscavenged heap memory which is in-use\n\tIf the line ends with \"(forced)\", then scavenging was forced by a\n\tdebug.FreeOSMemory() call.\n\n\tscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\n\tdetailed multiline info every X milliseconds, describing state of the scheduler,\n\tprocessors, threads and goroutines.\n\n\tschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\n\terror every X milliseconds, summarizing the scheduler state.\n\n\ttracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at\n\twhich goroutines were created, where N limits the number of ancestor goroutines to\n\treport. This also extends the information returned by runtime.Stack.\n\tSetting N to 0 will report no ancestry information.\n\n\ttracefpunwindoff: setting tracefpunwindoff=1 forces the execution tracer to\n\tuse the runtime's default stack unwinder instead of frame pointer unwinding.\n\tThis increases tracer overhead, but could be helpful as a workaround or for\n\tdebugging unexpected regressions caused by frame pointer unwinding.\n\n\ttraceadvanceperiod: the approximate period in nanoseconds between trace generations. Only\n\tapplies if a program is built with GOEXPERIMENT=exectracer2. Used primarily for testing\n\tand debugging the execution tracer.\n\n\ttracecheckstackownership: setting tracecheckstackownership=1 enables a debug check in the\n\texecution tracer to double-check stack ownership before taking a stack trace.\n\n\tasyncpreemptoff: asyncpreemptoff=1 disables signal-based\n\tasynchronous goroutine preemption. This makes some loops\n\tnon-preemptible for long periods, which may delay GC and\n\tgoroutine scheduling. This is useful for debugging GC issues\n\tbecause it also disables the conservative stack scanning used\n\tfor asynchronously preempted goroutines.\n\nThe [net](https://pkg.go.dev/net/) and [net/http](https://pkg.go.dev/net/http/) packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.\n\nThe GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's \\[GOMAXPROCS] function queries and changes the limit.\n\nThe GORACE variable configures the race detector, for programs built using -race. See the [Race Detector article](https://go.dev/doc/articles/race_detector) for details.\n\nThe GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. GOTRACEBACK=wer is like “crash” but doesn't disable Windows Error Reporting (WER). For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The [runtime/debug.SetTraceback](https://pkg.go.dev/runtime/debug/#SetTraceback) function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable.\n\nThe GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see [cmd/go](https://pkg.go.dev/cmd/go/) and [go/build](https://pkg.go.dev/go/build/)). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system.\n\n### Security {#hdr-Security}\n\nOn Unix platforms, Go's runtime system behaves slightly differently when a binary is setuid/setgid or executed with setuid/setgid-like properties, in order to prevent dangerous behaviors. On Linux this is determined by checking for the AT\\_SECURE flag in the auxiliary vector, on the BSDs and Solaris/Illumos it is determined by checking the issetugid syscall, and on AIX it is determined by checking if the uid/gid match the effective uid/gid.\n\nWhen the runtime determines the binary is setuid/setgid-like, it does three main things:\n\n  - The standard input/output file descriptors (0, 1, 2) are checked to be open. If any of them are closed, they are opened pointing at /dev/null.\n  - The value of the GOTRACEBACK environment variable is set to 'none'.\n  - When a signal is received that terminates the program, or the program encounters an unrecoverable panic that would otherwise override the value of GOTRACEBACK, the goroutine stack, registers, and other memory related information are omitted.\n\n[`runtime` on pkg.go.dev](https://pkg.go.dev/runtime)","Package slices defines various functions useful with slices of any type.\n\n[`slices` on pkg.go.dev](https://pkg.go.dev/slices)","Package sort provides primitives for sorting slices and user-defined collections.\n\n[`sort` on pkg.go.dev](https://pkg.go.dev/sort)","Package strconv implements conversions to and from string representations of basic data types.\n\n### Numeric Conversions {#hdr-Numeric_Conversions}\n\nThe most common numeric conversions are \\[Atoi] (string to int) and \\[Itoa] (int to string).\n\n\ti, err := strconv.Atoi(\"-42\")\n\ts := strconv.Itoa(-42)\n\nThese assume decimal and the Go int type.\n\n\\[ParseBool], \\[ParseFloat], \\[ParseInt], and \\[ParseUint] convert strings to values:\n\n\tb, err := strconv.ParseBool(\"true\")\n\tf, err := strconv.ParseFloat(\"3.1415\", 64)\n\ti, err := strconv.ParseInt(\"-42\", 10, 64)\n\tu, err := strconv.ParseUint(\"42\", 10, 64)\n\nThe parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:\n\n\ts := \"2147483647\" // biggest int32\n\ti64, err := strconv.ParseInt(s, 10, 32)\n\t...\n\ti := int32(i64)\n\n\\[FormatBool], \\[FormatFloat], \\[FormatInt], and \\[FormatUint] convert values to strings:\n\n\ts := strconv.FormatBool(true)\n\ts := strconv.FormatFloat(3.1415, 'E', -1, 64)\n\ts := strconv.FormatInt(-42, 16)\n\ts := strconv.FormatUint(42, 16)\n\n\\[AppendBool], \\[AppendFloat], \\[AppendInt], and \\[AppendUint] are similar but append the formatted value to a destination slice.\n\n### String Conversions {#hdr-String_Conversions}\n\n\\[Quote] and \\[QuoteToASCII] convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \\\\u:\n\n\tq := strconv.Quote(\"Hello, 世界\")\n\tq := strconv.QuoteToASCII(\"Hello, 世界\")\n\n\\[QuoteRune] and \\[QuoteRuneToASCII] are similar but accept runes and return quoted Go rune literals.\n\n\\[Unquote] and \\[UnquoteChar] unquote Go string and rune literals.\n\n[`strconv` on pkg.go.dev](https://pkg.go.dev/strconv)","Package strings implements simple functions to manipulate UTF-8 encoded strings.\n\nFor information about UTF-8 strings in Go, see [https://blog.golang.org/strings](https://blog.golang.org/strings).\n\n[`strings` on pkg.go.dev](https://pkg.go.dev/strings)","Package structs defines marker types that can be used as struct fields to modify the properties of a struct.\n\nBy convention, a marker type should be used as the type of a field named \"\\_\", placed at the beginning of a struct type definition.\n\n[`structs` on pkg.go.dev](https://pkg.go.dev/structs)","Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the \\[Once] and \\[WaitGroup] types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.\n\nValues containing the types defined in this package should not be copied.\n\n[`sync` on pkg.go.dev](https://pkg.go.dev/sync)","Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as \"os\", \"time\" and \"net\".  Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type \\[Errno].\n\nNOTE: Most of the functions, types, and constants defined in this package are also available in the [golang.org/x/sys](https://pkg.go.dev/golang.org/x/sys/) package. That package has more system call support than this one, and most new code should prefer that package where possible. See [https://golang.org/s/go1.4-syscall](https://golang.org/s/go1.4-syscall) for more information.\n\n[`syscall` on pkg.go.dev](https://pkg.go.dev/syscall)","Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the \"go test\" command, which automates execution of any function of the form\n\n\tfunc TestXxx(*testing.T)\n\nwhere Xxx does not start with a lowercase letter. The function name serves to identify the test routine.\n\nWithin these functions, use the Error, Fail or related methods to signal failure.\n\nTo write a new test suite, create a file that contains the TestXxx functions as described here, and give that file a name ending in \"\\_test.go\". The file will be excluded from regular package builds but will be included when the \"go test\" command is run.\n\nThe test file can be in the same package as the one being tested, or in a corresponding package with the suffix \"\\_test\".\n\nIf the test file is in the same package, it may refer to unexported identifiers within the package, as in this example:\n\n\tpackage abs\n\n\timport \"testing\"\n\n\tfunc TestAbs(t *testing.T) {\n\t    got := Abs(-1)\n\t    if got != 1 {\n\t        t.Errorf(\"Abs(-1) = %d; want 1\", got)\n\t    }\n\t}\n\nIf the file is in a separate \"\\_test\" package, the package being tested must be imported explicitly and only its exported identifiers may be used. This is known as \"black box\" testing.\n\n\tpackage abs_test\n\n\timport (\n\t\t\"testing\"\n\n\t\t\"path_to_pkg/abs\"\n\t)\n\n\tfunc TestAbs(t *testing.T) {\n\t    got := abs.Abs(-1)\n\t    if got != 1 {\n\t        t.Errorf(\"Abs(-1) = %d; want 1\", got)\n\t    }\n\t}\n\nFor more detail, run \"go help test\" and \"go help testflag\".\n\n### Benchmarks {#hdr-Benchmarks}\n\nFunctions of the form\n\n\tfunc BenchmarkXxx(*testing.B)\n\nare considered benchmarks, and are executed by the \"go test\" command when its -bench flag is provided. Benchmarks are run sequentially.\n\nFor a description of the testing flags, see [https://golang.org/cmd/go/#hdr-Testing\\_flags](https://golang.org/cmd/go/#hdr-Testing_flags).\n\nA sample benchmark function looks like this:\n\n\tfunc BenchmarkRandInt(b *testing.B) {\n\t    for range b.N {\n\t        rand.Int()\n\t    }\n\t}\n\nThe benchmark function must run the target code b.N times. It is called multiple times with b.N adjusted until the benchmark function lasts long enough to be timed reliably. The output\n\n\tBenchmarkRandInt-8   \t68453040\t        17.8 ns/op\n\nmeans that the loop ran 68453040 times at a speed of 17.8 ns per loop.\n\nIf a benchmark needs some expensive setup before running, the timer may be reset:\n\n\tfunc BenchmarkBigLen(b *testing.B) {\n\t    big := NewBig()\n\t    b.ResetTimer()\n\t    for range b.N {\n\t        big.Len()\n\t    }\n\t}\n\nIf a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:\n\n\tfunc BenchmarkTemplateParallel(b *testing.B) {\n\t    templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n\t    b.RunParallel(func(pb *testing.PB) {\n\t        var buf bytes.Buffer\n\t        for pb.Next() {\n\t            buf.Reset()\n\t            templ.Execute(\u0026buf, \"World\")\n\t        }\n\t    })\n\t}\n\nA detailed specification of the benchmark results format is given in [https://golang.org/design/14313-benchmark-format](https://golang.org/design/14313-benchmark-format).\n\nThere are standard tools for working with benchmark results at [https://golang.org/x/perf/cmd](https://golang.org/x/perf/cmd). In particular, [https://golang.org/x/perf/cmd/benchstat](https://golang.org/x/perf/cmd/benchstat) performs statistically robust A/B comparisons.\n\n### Examples {#hdr-Examples}\n\nThe package also runs and verifies example code. Example functions may include a concluding line comment that begins with \"Output:\" and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:\n\n\tfunc ExampleHello() {\n\t    fmt.Println(\"hello\")\n\t    // Output: hello\n\t}\n\n\tfunc ExampleSalutations() {\n\t    fmt.Println(\"hello, and\")\n\t    fmt.Println(\"goodbye\")\n\t    // Output:\n\t    // hello, and\n\t    // goodbye\n\t}\n\nThe comment prefix \"Unordered output:\" is like \"Output:\", but matches any line order:\n\n\tfunc ExamplePerm() {\n\t    for _, value := range Perm(5) {\n\t        fmt.Println(value)\n\t    }\n\t    // Unordered output: 4\n\t    // 2\n\t    // 1\n\t    // 3\n\t    // 0\n\t}\n\nExample functions without output comments are compiled but not executed.\n\nThe naming convention to declare examples for the package, a function F, a type T and method M on type T are:\n\n\tfunc Example() { ... }\n\tfunc ExampleF() { ... }\n\tfunc ExampleT() { ... }\n\tfunc ExampleT_M() { ... }\n\nMultiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter.\n\n\tfunc Example_suffix() { ... }\n\tfunc ExampleF_suffix() { ... }\n\tfunc ExampleT_suffix() { ... }\n\tfunc ExampleT_M_suffix() { ... }\n\nThe entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.\n\n### Fuzzing {#hdr-Fuzzing}\n\n'go test' and the testing package support fuzzing, a testing technique where a function is called with randomly generated inputs to find bugs not anticipated by unit tests.\n\nFunctions of the form\n\n\tfunc FuzzXxx(*testing.F)\n\nare considered fuzz tests.\n\nFor example:\n\n\tfunc FuzzHex(f *testing.F) {\n\t  for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {\n\t    f.Add(seed)\n\t  }\n\t  f.Fuzz(func(t *testing.T, in []byte) {\n\t    enc := hex.EncodeToString(in)\n\t    out, err := hex.DecodeString(enc)\n\t    if err != nil {\n\t      t.Fatalf(\"%v: decode: %v\", in, err)\n\t    }\n\t    if !bytes.Equal(in, out) {\n\t      t.Fatalf(\"%v: not equal after round trip: %v\", in, out)\n\t    }\n\t  })\n\t}\n\nA fuzz test maintains a seed corpus, or a set of inputs which are run by default, and can seed input generation. Seed inputs may be registered by calling (\\*F).Add or by storing files in the directory testdata/fuzz/\\\u003cName\u003e (where \\\u003cName\u003e is the name of the fuzz test) within the package containing the fuzz test. Seed inputs are optional, but the fuzzing engine may find bugs more efficiently when provided with a set of small seed inputs with good code coverage. These seed inputs can also serve as regression tests for bugs identified through fuzzing.\n\nThe function passed to (\\*F).Fuzz within the fuzz test is considered the fuzz target. A fuzz target must accept a \\*T parameter, followed by one or more parameters for random inputs. The types of arguments passed to (\\*F).Add must be identical to the types of these parameters. The fuzz target may signal that it's found a problem the same way tests do: by calling T.Fail (or any method that calls it like T.Error or T.Fatal) or by panicking.\n\nWhen fuzzing is enabled (by setting the -fuzz flag to a regular expression that matches a specific fuzz test), the fuzz target is called with arguments generated by repeatedly making random changes to the seed inputs. On supported platforms, 'go test' compiles the test executable with fuzzing coverage instrumentation. The fuzzing engine uses that instrumentation to find and cache inputs that expand coverage, increasing the likelihood of finding bugs. If the fuzz target fails for a given input, the fuzzing engine writes the inputs that caused the failure to a file in the directory testdata/fuzz/\\\u003cName\u003e within the package directory. This file later serves as a seed input. If the file can't be written at that location (for example, because the directory is read-only), the fuzzing engine writes the file to the fuzz cache directory within the build cache instead.\n\nWhen fuzzing is disabled, the fuzz target is called with the seed inputs registered with F.Add and seed inputs from testdata/fuzz/\\\u003cName\u003e. In this mode, the fuzz test acts much like a regular test, with subtests started with F.Fuzz instead of T.Run.\n\nSee [https://go.dev/doc/fuzz](https://go.dev/doc/fuzz) for documentation about fuzzing.\n\n### Skipping {#hdr-Skipping}\n\nTests or benchmarks may be skipped at run time with a call to the Skip method of \\*T or \\*B:\n\n\tfunc TestTimeConsuming(t *testing.T) {\n\t    if testing.Short() {\n\t        t.Skip(\"skipping test in short mode.\")\n\t    }\n\t    ...\n\t}\n\nThe Skip method of \\*T can be used in a fuzz target if the input is invalid, but should not be considered a failing input. For example:\n\n\tfunc FuzzJSONMarshaling(f *testing.F) {\n\t    f.Fuzz(func(t *testing.T, b []byte) {\n\t        var v interface{}\n\t        if err := json.Unmarshal(b, \u0026v); err != nil {\n\t            t.Skip()\n\t        }\n\t        if _, err := json.Marshal(v); err != nil {\n\t            t.Errorf(\"Marshal: %v\", err)\n\t        }\n\t    })\n\t}\n\n### Subtests and Sub-benchmarks {#hdr-Subtests_and_Sub_benchmarks}\n\nThe Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code:\n\n\tfunc TestFoo(t *testing.T) {\n\t    // \u003csetup code\u003e\n\t    t.Run(\"A=1\", func(t *testing.T) { ... })\n\t    t.Run(\"A=2\", func(t *testing.T) { ... })\n\t    t.Run(\"B=1\", func(t *testing.T) { ... })\n\t    // \u003ctear-down code\u003e\n\t}\n\nEach subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation.\n\nThe argument to the -run, -bench, and -fuzz command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using \"matching\" to mean \"whose name contains\":\n\n\tgo test -run ''        # Run all tests.\n\tgo test -run Foo       # Run top-level tests matching \"Foo\", such as \"TestFooBar\".\n\tgo test -run Foo/A=    # For top-level tests matching \"Foo\", run subtests matching \"A=\".\n\tgo test -run /A=1      # For all top-level tests, run subtests matching \"A=1\".\n\tgo test -fuzz FuzzFoo  # Fuzz the target matching \"FuzzFoo\"\n\nThe -run argument can also be used to run a specific value in the seed corpus, for debugging. For example:\n\n\tgo test -run=FuzzFoo/9ddb952d9814\n\nThe -fuzz and -run flags can both be set, in order to fuzz a target but skip the execution of all other tests.\n\nSubtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined:\n\n\tfunc TestGroupedParallel(t *testing.T) {\n\t    for _, tc := range tests {\n\t        tc := tc // capture range variable\n\t        t.Run(tc.Name, func(t *testing.T) {\n\t            t.Parallel()\n\t            ...\n\t        })\n\t    }\n\t}\n\nRun does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests:\n\n\tfunc TestTeardownParallel(t *testing.T) {\n\t    // This Run will not return until the parallel tests finish.\n\t    t.Run(\"group\", func(t *testing.T) {\n\t        t.Run(\"Test1\", parallelTest1)\n\t        t.Run(\"Test2\", parallelTest2)\n\t        t.Run(\"Test3\", parallelTest3)\n\t    })\n\t    // \u003ctear-down code\u003e\n\t}\n\n### Main {#hdr-Main}\n\nIt is sometimes necessary for a test or benchmark program to do extra setup or teardown before or after it executes. It is also sometimes necessary to control which code runs on the main thread. To support these and other cases, if a test file contains a function:\n\n\tfunc TestMain(m *testing.M)\n\nthen the generated test will call TestMain(m) instead of running the tests or benchmarks directly. TestMain runs in the main goroutine and can do whatever setup and teardown is necessary around a call to m.Run. m.Run will return an exit code that may be passed to os.Exit. If TestMain returns, the test wrapper will pass the result of m.Run to os.Exit itself.\n\nWhen TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.\n\nA simple implementation of TestMain is:\n\n\tfunc TestMain(m *testing.M) {\n\t\t// call flag.Parse() here if TestMain uses flags\n\t\tm.Run()\n\t}\n\nTestMain is a low-level primitive and should not be necessary for casual testing needs, where ordinary test functions suffice.\n\n[`testing` on pkg.go.dev](https://pkg.go.dev/testing)","Package time provides functionality for measuring and displaying time.\n\nThe calendrical calculations always assume a Gregorian calendar, with no leap seconds.\n\n### Monotonic Clocks {#hdr-Monotonic_Clocks}\n\nOperating systems provide both a “wall clock,” which is subject to changes for clock synchronization, and a “monotonic clock,” which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by [time.Now](https://pkg.go.dev/time/#Now) contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.\n\nFor example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:\n\n\tstart := time.Now()\n\t... operation that takes 20 milliseconds ...\n\tt := time.Now()\n\telapsed := t.Sub(start)\n\nOther idioms, such as [time.Since](https://pkg.go.dev/time/#Since)(start), [time.Until](https://pkg.go.dev/time/#Until)(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.\n\nThe rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.\n\nThe Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).\n\nIf Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.\n\nOn some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. The same applies to other functions and methods that subtract times, such as \\[Since], \\[Until], \\[Before], \\[After], \\[Add], \\[Sub], \\[Equal] and \\[Compare]. In some cases, you may need to strip the monotonic clock to get accurate results.\n\nBecause the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors [time.Date](https://pkg.go.dev/time/#Date), [time.Parse](https://pkg.go.dev/time/#Parse), [time.ParseInLocation](https://pkg.go.dev/time/#ParseInLocation), and [time.Unix](https://pkg.go.dev/time/#Unix), as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.\n\nThe monotonic clock reading exists only in \\[Time] values. It is not a part of \\[Duration] values or the Unix times returned by t.Unix and friends.\n\nNote that the Go == operator compares not just the time instant but also the \\[Location] and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.\n\nFor debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().\n\n### Timer Resolution {#hdr-Timer_Resolution}\n\n\\[Timer] resolution varies depending on the Go runtime, the operating system and the underlying hardware. On Unix, the resolution is ~1ms. On Windows version 1803 and newer, the resolution is ~0.5ms. On older Windows versions, the default resolution is ~16ms, but a higher resolution may be requested using [golang.org/x/sys/windows.TimeBeginPeriod](https://pkg.go.dev/golang.org/x/sys/windows/#TimeBeginPeriod).\n\n[`time` on pkg.go.dev](https://pkg.go.dev/time)","Package unicode provides data and functions to test some properties of Unicode code points.\n\n[`unicode` on pkg.go.dev](https://pkg.go.dev/unicode)","","Package unsafe contains operations that step around the type safety of Go programs.\n\nPackages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.\n\n[`unsafe` on pkg.go.dev](https://pkg.go.dev/unsafe)","Package tar implements access to tar archives.\n\nTape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.\n\n[`archive/tar` on pkg.go.dev](https://pkg.go.dev/archive/tar)","Package zip provides support for reading and writing ZIP archives.\n\nSee the [ZIP specification](https://support.pkware.com/pkzip/appnote) for details.\n\nThis package does not support disk spanning.\n\nA note about ZIP64:\n\nTo be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.\n\n[`archive/zip` on pkg.go.dev](https://pkg.go.dev/archive/zip)","Package bzip2 implements bzip2 decompression.\n\n[`compress/bzip2` on pkg.go.dev](https://pkg.go.dev/compress/bzip2)","Package flate implements the DEFLATE compressed data format, described in RFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file formats.\n\n[`compress/flate` on pkg.go.dev](https://pkg.go.dev/compress/flate)","Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.\n\n[`compress/gzip` on pkg.go.dev](https://pkg.go.dev/compress/gzip)","Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.\n\nIn particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.\n\nThe TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org/x/image/tiff/lzw package for an implementation.\n\n[`compress/lzw` on pkg.go.dev](https://pkg.go.dev/compress/lzw)","Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.\n\nThe implementation provides filters that uncompress during reading and compress during writing.  For example, to write compressed data to a buffer:\n\n\tvar b bytes.Buffer\n\tw := zlib.NewWriter(\u0026b)\n\tw.Write([]byte(\"hello, world\\n\"))\n\tw.Close()\n\nand to read that data back:\n\n\tr, err := zlib.NewReader(\u0026b)\n\tio.Copy(os.Stdout, r)\n\tr.Close()\n\n[`compress/zlib` on pkg.go.dev](https://pkg.go.dev/compress/zlib)","Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.\n\nThe minimum element in the tree is the root, at index 0.\n\nA heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example\\_pq\\_test.go has the complete source.\n\n[`container/heap` on pkg.go.dev](https://pkg.go.dev/container/heap)","Package list implements a doubly linked list.\n\nTo iterate over a list (where l is a \\*List):\n\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\t// do something with e.Value\n\t}\n\n[`container/list` on pkg.go.dev](https://pkg.go.dev/container/list)","Package ring implements operations on circular lists.\n\n[`container/ring` on pkg.go.dev](https://pkg.go.dev/container/ring)","Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.\n\nThe AES operations in this package are not implemented using constant-time algorithms. An exception is when running on systems with enabled hardware support for AES that makes these operations constant-time. Examples include amd64 systems using AES-NI extensions and s390x systems using Message-Security-Assist extensions. On such systems, when the result of NewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also constant-time.\n\n[`crypto/aes` on pkg.go.dev](https://pkg.go.dev/crypto/aes)","Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. See [https://csrc.nist.gov/groups/ST/toolkit/BCM/current\\_modes.html](https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html) and NIST Special Publication 800-38A.\n\n[`crypto/cipher` on pkg.go.dev](https://pkg.go.dev/crypto/cipher)","Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.\n\nDES is cryptographically broken and should not be used for secure applications.\n\n[`crypto/des` on pkg.go.dev](https://pkg.go.dev/crypto/des)","Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.\n\nThe DSA operations in this package are not implemented using constant-time algorithms.\n\nDeprecated: DSA is a legacy algorithm, and modern alternatives such as Ed25519 (implemented by package crypto/ed25519) should be used instead. Keys with 1024-bit moduli (L1024N160 parameters) are cryptographically weak, while bigger keys are not widely supported. Note that FIPS 186-5 no longer approves DSA for signature generation.\n\n[`crypto/dsa` on pkg.go.dev](https://pkg.go.dev/crypto/dsa)","Package ecdh implements Elliptic Curve Diffie-Hellman over NIST curves and Curve25519.\n\n[`crypto/ecdh` on pkg.go.dev](https://pkg.go.dev/crypto/ecdh)","Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-4 and SEC 1, Version 2.0.\n\nSignatures generated by this package are not deterministic, but entropy is mixed with the private key and the message, achieving the same level of security in case of randomness source failure.\n\nOperations involving private keys are implemented using constant-time algorithms, as long as an \\[elliptic.Curve] returned by \\[elliptic.P224], \\[elliptic.P256], \\[elliptic.P384], or \\[elliptic.P521] is used.\n\n[`crypto/ecdsa` on pkg.go.dev](https://pkg.go.dev/crypto/ecdsa)","Package ed25519 implements the Ed25519 signature algorithm. See [https://ed25519.cr.yp.to/](https://ed25519.cr.yp.to/).\n\nThese functions are also compatible with the “Ed25519” function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the “seed”.\n\nOperations involving private keys are implemented using constant-time algorithms.\n\n[`crypto/ed25519` on pkg.go.dev](https://pkg.go.dev/crypto/ed25519)","Package elliptic implements the standard NIST P-224, P-256, P-384, and P-521 elliptic curves over prime fields.\n\nDirect use of this package is deprecated, beyond the \\[P224], \\[P256], \\[P384], and \\[P521] values necessary to use [crypto/ecdsa](https://pkg.go.dev/crypto/ecdsa/). Most other uses should migrate to the more efficient and safer [crypto/ecdh](https://pkg.go.dev/crypto/ecdh/), or to third-party modules for lower-level functionality.\n\n[`crypto/elliptic` on pkg.go.dev](https://pkg.go.dev/crypto/elliptic)","Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key.\n\nReceivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:\n\n\t// ValidMAC reports whether messageMAC is a valid HMAC tag for message.\n\tfunc ValidMAC(message, messageMAC, key []byte) bool {\n\t\tmac := hmac.New(sha256.New, key)\n\t\tmac.Write(message)\n\t\texpectedMAC := mac.Sum(nil)\n\t\treturn hmac.Equal(messageMAC, expectedMAC)\n\t}\n\n[`crypto/hmac` on pkg.go.dev](https://pkg.go.dev/crypto/hmac)","Package md5 implements the MD5 hash algorithm as defined in RFC 1321.\n\nMD5 is cryptographically broken and should not be used for secure applications.\n\n[`crypto/md5` on pkg.go.dev](https://pkg.go.dev/crypto/md5)","Package rand implements a cryptographically secure random number generator.\n\n[`crypto/rand` on pkg.go.dev](https://pkg.go.dev/crypto/rand)","Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.\n\nRC4 is cryptographically broken and should not be used for secure applications.\n\n[`crypto/rc4` on pkg.go.dev](https://pkg.go.dev/crypto/rc4)","Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.\n\nRSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.\n\nThe original specification for encryption and signatures with RSA is PKCS #1 and the terms \"RSA encryption\" and \"RSA signatures\" by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.\n\nTwo sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.\n\nOperations involving private keys are implemented using constant-time algorithms, except for \\[GenerateKey], \\[PrivateKey.Precompute], and \\[PrivateKey.Validate].\n\n[`crypto/rsa` on pkg.go.dev](https://pkg.go.dev/crypto/rsa)","Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.\n\nSHA-1 is cryptographically broken and should not be used for secure applications.\n\n[`crypto/sha1` on pkg.go.dev](https://pkg.go.dev/crypto/sha1)","Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.\n\n[`crypto/sha256` on pkg.go.dev](https://pkg.go.dev/crypto/sha256)","Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.\n\nAll the hash.Hash implementations returned by this package also implement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.\n\n[`crypto/sha512` on pkg.go.dev](https://pkg.go.dev/crypto/sha512)","Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.\n\n[`crypto/subtle` on pkg.go.dev](https://pkg.go.dev/crypto/subtle)","Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.\n\n[`crypto/tls` on pkg.go.dev](https://pkg.go.dev/crypto/tls)","Package x509 implements a subset of the X.509 standard.\n\nIt allows parsing and generating certificates, certificate signing requests, certificate revocation lists, and encoded public and private keys. It provides a certificate verifier, complete with a chain builder.\n\nThe package targets the X.509 technical profile defined by the IETF (RFC 2459/3280/5280), and as further restricted by the CA/Browser Forum Baseline Requirements. There is minimal support for features outside of these profiles, as the primary goal of the package is to provide compatibility with the publicly trusted TLS certificate ecosystem and its policies and constraints.\n\nOn macOS and Windows, certificate verification is handled by system APIs, but the package aims to apply consistent validation rules across operating systems.\n\n[`crypto/x509` on pkg.go.dev](https://pkg.go.dev/crypto/x509)","Package sql provides a generic interface around SQL (or SQL-like) databases.\n\nThe sql package must be used in conjunction with a database driver. See [https://golang.org/s/sqldrivers](https://golang.org/s/sqldrivers) for a list of drivers.\n\nDrivers that do not support context cancellation will not return until after the query is completed.\n\nFor usage examples, see the wiki page at [https://golang.org/s/sqlwiki](https://golang.org/s/sqlwiki).\n\n[`database/sql` on pkg.go.dev](https://pkg.go.dev/database/sql)","Package buildinfo provides access to information embedded in a Go binary about how it was built. This includes the Go toolchain version, and the set of modules used (for binaries built in module mode).\n\nBuild information is available for the currently running binary in runtime/debug.ReadBuildInfo.\n\n[`debug/buildinfo` on pkg.go.dev](https://pkg.go.dev/debug/buildinfo)","Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at [http://dwarfstd.org/doc/dwarf-2.0.0.pdf](http://dwarfstd.org/doc/dwarf-2.0.0.pdf).\n\n### Security {#hdr-Security}\n\nThis package is not designed to be hardened against adversarial inputs, and is outside the scope of [https://go.dev/security/policy](https://go.dev/security/policy). In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.\n\n[`debug/dwarf` on pkg.go.dev](https://pkg.go.dev/debug/dwarf)","Package elf implements access to ELF object files.\n\n### Security {#hdr-Security}\n\nThis package is not designed to be hardened against adversarial inputs, and is outside the scope of [https://go.dev/security/policy](https://go.dev/security/policy). In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.\n\n[`debug/elf` on pkg.go.dev](https://pkg.go.dev/debug/elf)","Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.\n\n[`debug/gosym` on pkg.go.dev](https://pkg.go.dev/debug/gosym)","Package macho implements access to Mach-O object files.\n\n### Security {#hdr-Security}\n\nThis package is not designed to be hardened against adversarial inputs, and is outside the scope of [https://go.dev/security/policy](https://go.dev/security/policy). In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.\n\n[`debug/macho` on pkg.go.dev](https://pkg.go.dev/debug/macho)","Package pe implements access to PE (Microsoft Windows Portable Executable) files.\n\n### Security {#hdr-Security}\n\nThis package is not designed to be hardened against adversarial inputs, and is outside the scope of [https://go.dev/security/policy](https://go.dev/security/policy). In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.\n\n[`debug/pe` on pkg.go.dev](https://pkg.go.dev/debug/pe)","Package plan9obj implements access to Plan 9 a.out object files.\n\n### Security {#hdr-Security}\n\nThis package is not designed to be hardened against adversarial inputs, and is outside the scope of [https://go.dev/security/policy](https://go.dev/security/policy). In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.\n\n[`debug/plan9obj` on pkg.go.dev](https://pkg.go.dev/debug/plan9obj)","Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.\n\n[`encoding/ascii85` on pkg.go.dev](https://pkg.go.dev/encoding/ascii85)","Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.\n\nSee also “A Layman's Guide to a Subset of ASN.1, BER, and DER,” [http://luca.ntop.org/Teaching/Appunti/asn1.html](http://luca.ntop.org/Teaching/Appunti/asn1.html).\n\n[`encoding/asn1` on pkg.go.dev](https://pkg.go.dev/encoding/asn1)","Package base32 implements base32 encoding as specified by RFC 4648.\n\n[`encoding/base32` on pkg.go.dev](https://pkg.go.dev/encoding/base32)","Package base64 implements base64 encoding as specified by RFC 4648.\n\n[`encoding/base64` on pkg.go.dev](https://pkg.go.dev/encoding/base64)","Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.\n\nNumbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values.\n\nThe varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see [https://developers.google.com/protocol-buffers/docs/encoding](https://developers.google.com/protocol-buffers/docs/encoding).\n\nThis package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the [encoding/gob](https://pkg.go.dev/encoding/gob/) package or [google.golang.org/protobuf](https://pkg.go.dev/google.golang.org/protobuf/) for protocol buffers.\n\n[`encoding/binary` on pkg.go.dev](https://pkg.go.dev/encoding/binary)","Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180, except that \\[Writer] uses LF instead of CRLF as newline character by default.\n\nA csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character.\n\n\tfield1,field2,field3\n\nWhite space is considered part of a field.\n\nCarriage returns before newline characters are silently removed.\n\nBlank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line.\n\nFields which start and stop with the quote character \" are called quoted-fields. The beginning and ending quote are not part of the field.\n\nThe source:\n\n\tnormal string,\"quoted-field\"\n\nresults in the fields\n\n\t{`normal string`, `quoted-field`}\n\nWithin a quoted-field a quote character followed by a second quote character is considered a single quote.\n\n\t\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\nresults in\n\n\t{`the \"word\" is true`, `a \"quoted-field\"`}\n\nNewlines and commas may be included in a quoted-field\n\n\t\"Multi-line\n\tfield\",\"comma is ,\"\n\nresults in\n\n\t{`Multi-line\n\tfield`, `comma is ,`}\n\n[`encoding/csv` on pkg.go.dev](https://pkg.go.dev/encoding/csv)","Package gob manages streams of gobs - binary values exchanged between an \\[Encoder] (transmitter) and a \\[Decoder] (receiver). A typical use is transporting arguments and results of remote procedure calls (RPCs) such as those provided by [net/rpc](https://pkg.go.dev/net/rpc/).\n\nThe implementation compiles a custom codec for each data type in the stream and is most efficient when a single \\[Encoder] is used to transmit a stream of values, amortizing the cost of compilation.\n\n### Basics {#hdr-Basics}\n\nA stream of gobs is self-describing. Each data item in the stream is preceded by a specification of its type, expressed in terms of a small set of predefined types. Pointers are not transmitted, but the things they point to are transmitted; that is, the values are flattened. Nil pointers are not permitted, as they have no value. Recursive types work fine, but recursive values (data with cycles) are problematic. This may change.\n\nTo use gobs, create an \\[Encoder] and present it with a series of data items as values or addresses that can be dereferenced to values. The \\[Encoder] makes sure all type information is sent before it is needed. At the receive side, a \\[Decoder] retrieves values from the encoded stream and unpacks them into local variables.\n\n### Types and Values {#hdr-Types_and_Values}\n\nThe source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,\n\n\tstruct { A, B int }\n\ncan be sent from or received into any of these Go types:\n\n\tstruct { A, B int }\t// the same\n\t*struct { A, B int }\t// extra indirection of the struct\n\tstruct { *A, **B int }\t// extra indirection of the fields\n\tstruct { A, B int64 }\t// different concrete value type; see below\n\nIt may also be received into any of these:\n\n\tstruct { A, B int }\t// the same\n\tstruct { B, A int }\t// ordering doesn't matter; matching is by name\n\tstruct { A, B, C int }\t// extra field (C) ignored\n\tstruct { B int }\t// missing field (A) ignored; data will be dropped\n\tstruct { B, C int }\t// missing field (A) ignored; extra field (C) ignored.\n\nAttempting to receive into these types will draw a decode error:\n\n\tstruct { A int; B uint }\t// change of signedness for B\n\tstruct { A int; B float }\t// change of type for B\n\tstruct { }\t\t\t// no field names in common\n\tstruct { C, D int }\t\t// no field names in common\n\nIntegers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE 754 64-bit precision (see below).\n\nSigned integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail.\n\nStructs, arrays and slices are also supported. Structs encode and decode only exported fields. Strings and arrays of bytes are supported with a special, efficient representation (see below). When a slice is decoded, if the existing slice has capacity the slice will be extended in place; if not, a new array is allocated. Regardless, the length of the resulting slice reports the number of elements decoded.\n\nIn general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables.\n\nFunctions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored.\n\nGob can encode a value of any type implementing the \\[GobEncoder] or [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) interfaces by calling the corresponding method, in that order of preference.\n\nGob can decode a value of any type implementing the \\[GobDecoder] or [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) interfaces by calling the corresponding method, again in that order of preference.\n\n### Encoding Details {#hdr-Encoding_Details}\n\nThis section documents the encoding, details that are not important for most users. Details are presented bottom-up.\n\nAn unsigned integer is sent one of two ways. If it is less than 128, it is sent as a byte with that value. Otherwise it is sent as a minimal-length big-endian (high byte first) byte stream holding the value, preceded by one byte holding the byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and 256 is transmitted as (FE 01 00).\n\nA boolean is encoded within an unsigned integer: 0 for false, 1 for true.\n\nA signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1 upward contain the value; bit 0 says whether they should be complemented upon receipt. The encode algorithm looks like this:\n\n\tvar u uint\n\tif i \u003c 0 {\n\t\tu = (^uint(i) \u003c\u003c 1) | 1 // complement i, bit 0 is 1\n\t} else {\n\t\tu = (uint(i) \u003c\u003c 1) // do not complement i, bit 0 is 0\n\t}\n\tencodeUnsigned(u)\n\nThe low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256\u003e\u003e1) encodes as (FE 01 01).\n\nFloating-point numbers are always sent as a representation of a float64 value. That value is converted to a uint64 using [math.Float64bits](https://pkg.go.dev/math/#Float64bits). The uint64 is then byte-reversed and sent as a regular unsigned integer. The byte-reversal means the exponent and high-precision part of the mantissa go first. Since the low bits are often zero, this can save encoding bytes. For instance, 17.0 is encoded in only three bytes (FE 31 40).\n\nStrings and slices of bytes are sent as an unsigned count followed by that many uninterpreted bytes of the value.\n\nAll other slices and arrays are sent as an unsigned count followed by that many elements using the standard gob encoding for their type, recursively.\n\nMaps are sent as an unsigned count followed by that many key, element pairs. Empty but non-nil maps are sent, so if the receiver has not allocated one already, one will always be allocated on receipt unless the transmitted map is nil and not at the top level.\n\nIn slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero.\n\nStructs are sent as a sequence of (field number, field value) pairs. The field value is sent using the standard gob encoding for its type, recursively. If a field has the zero value for its type (except for arrays; see above), it is omitted from the transmission. The field number is defined by the type of the encoded struct: the first field of the encoded type is field 0, the second is field 1, etc. When encoding a value, the field numbers are delta encoded for efficiency and the fields are always sent in order of increasing field number; the deltas are therefore unsigned. The initialization for the delta encoding sets the field number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been sent a terminating mark denotes the end of the struct. That mark is a delta=0 value, which has representation (00).\n\nInterface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single \"interface\" type, analogous to int or \\[]byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling \\[Register]), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable.\n\nIf a value is passed to \\[Encoder.Encode] and the type is not a struct (or pointer to struct, etc.), for simplicity of processing it is represented as a struct of one field. The only visible effect of this is to encode a zero byte after the value, just as after the last field of an encoded struct, so that the decode algorithm knows when the top-level value is complete.\n\nThe representation of types is described below. When a type is defined on a given connection between an \\[Encoder] and \\[Decoder], it is assigned a signed integer type id. When \\[Encoder.Encode](v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.\n\nTo define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:\n\n\ttype wireType struct {\n\t\tArrayT           *ArrayType\n\t\tSliceT           *SliceType\n\t\tStructT          *StructType\n\t\tMapT             *MapType\n\t\tGobEncoderT      *gobEncoderType\n\t\tBinaryMarshalerT *gobEncoderType\n\t\tTextMarshalerT   *gobEncoderType\n\n\t}\n\ttype arrayType struct {\n\t\tCommonType\n\t\tElem typeId\n\t\tLen  int\n\t}\n\ttype CommonType struct {\n\t\tName string // the name of the struct type\n\t\tId  int    // the id of the type, repeated so it's inside the type\n\t}\n\ttype sliceType struct {\n\t\tCommonType\n\t\tElem typeId\n\t}\n\ttype structType struct {\n\t\tCommonType\n\t\tField []*fieldType // the fields of the struct.\n\t}\n\ttype fieldType struct {\n\t\tName string // the name of the field.\n\t\tId   int    // the type id of the field, which must be already defined\n\t}\n\ttype mapType struct {\n\t\tCommonType\n\t\tKey  typeId\n\t\tElem typeId\n\t}\n\ttype gobEncoderType struct {\n\t\tCommonType\n\t}\n\nIf there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v.\n\nFor simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are:\n\n\tbool        1\n\tint         2\n\tuint        3\n\tfloat       4\n\t[]byte      5\n\tstring      6\n\tcomplex     7\n\tinterface   8\n\t// gap for reserved ids.\n\tWireType    16\n\tArrayType   17\n\tCommonType  18\n\tSliceType   19\n\tStructType  20\n\tFieldType   21\n\t// 22 is slice of fieldType.\n\tMapType     23\n\nFinally, each message created by a call to Encode is preceded by an encoded unsigned integer count of the number of bytes remaining in the message. After the initial type name, interface values are wrapped the same way; in effect, the interface value acts like a recursive invocation of Encode.\n\nIn summary, a gob stream looks like\n\n\t(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*\n\nwhere \\* signifies zero or more repetitions and the type id of a value must be predefined or be defined before the value in the stream.\n\nCompatibility: Any future changes to the package will endeavor to maintain compatibility with streams encoded using previous versions. That is, any released version of this package should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: [https://golang.org/doc/go1compat](https://golang.org/doc/go1compat)\n\nSee \"Gobs of data\" for a design discussion of the gob wire format: [https://blog.golang.org/gobs-of-data](https://blog.golang.org/gobs-of-data)\n\n### Security {#hdr-Security}\n\nThis package is not designed to be hardened against adversarial inputs, and is outside the scope of [https://go.dev/security/policy](https://go.dev/security/policy). In particular, the \\[Decoder] does only basic sanity checking on decoded input sizes, and its limits are not configurable. Care should be taken when decoding gob data from untrusted sources, which may consume significant resources.\n\n[`encoding/gob` on pkg.go.dev](https://pkg.go.dev/encoding/gob)","Package hex implements hexadecimal encoding and decoding.\n\n[`encoding/hex` on pkg.go.dev](https://pkg.go.dev/encoding/hex)","Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.\n\nSee \"JSON and Go\" for an introduction to this package: [https://golang.org/doc/articles/json\\_and\\_go.html](https://golang.org/doc/articles/json_and_go.html)\n\n[`encoding/json` on pkg.go.dev](https://pkg.go.dev/encoding/json)","Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. The most common use of PEM encoding today is in TLS keys and certificates. See RFC 1421.\n\n[`encoding/pem` on pkg.go.dev](https://pkg.go.dev/encoding/pem)","Package xml implements a simple XML 1.0 parser that understands XML name spaces.\n\n[`encoding/xml` on pkg.go.dev](https://pkg.go.dev/encoding/xml)","Package ast declares the types used to represent syntax trees for Go packages.\n\n[`go/ast` on pkg.go.dev](https://pkg.go.dev/go/ast)","Package build gathers information about Go packages.\n\n### Go Path {#hdr-Go_Path}\n\nThe Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list).\n\nEach directory listed in the Go path must have a prescribed structure:\n\nThe src/ directory holds source code. The path below 'src' determines the import path or executable name.\n\nThe pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS\\_GOARCH).\n\nIf DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as \"foo/bar\" and has its compiled form installed to \"DIR/pkg/GOOS\\_GOARCH/foo/bar.a\" (or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").\n\nThe bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands.\n\nHere's an example directory layout:\n\n\tGOPATH=/home/user/gocode\n\n\t/home/user/gocode/\n\t    src/\n\t        foo/\n\t            bar/               (go code in package bar)\n\t                x.go\n\t            quux/              (go code in package main)\n\t                y.go\n\t    bin/\n\t        quux                   (installed command)\n\t    pkg/\n\t        linux_amd64/\n\t            foo/\n\t                bar.a          (installed package object)\n\n### Build Constraints {#hdr-Build_Constraints}\n\nA build constraint, also known as a build tag, is a condition under which a file should be included in the package. Build constraints are given by a line comment that begins\n\n\t//go:build\n\nBuild constraints may also be part of a file's name (for example, source\\_windows.go will only be included if the target operating system is windows).\n\nSee 'go help buildconstraint' ([https://golang.org/cmd/go/#hdr-Build\\_constraints](https://golang.org/cmd/go/#hdr-Build_constraints)) for details.\n\n### Binary-Only Packages {#hdr-Binary_Only_Packages}\n\nIn Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a \"//go:binary-only-package\" comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.\n\nThe minimal source code for a binary-only package was therefore:\n\n\t//go:binary-only-package\n\n\tpackage mypkg\n\nThe source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.\n\n\"go build\" and other commands no longer support binary-only-packages. \\[Import] and \\[ImportDir] will still set the BinaryOnly flag in packages containing these comments for use in tools and error messages.\n\n[`go/build` on pkg.go.dev](https://pkg.go.dev/go/build)","Package constant implements Values representing untyped Go constants and their corresponding operations.\n\nA special Unknown value may be used when a value is unknown due to an error. Operations on unknown values produce unknown values unless specified otherwise.\n\n[`go/constant` on pkg.go.dev](https://pkg.go.dev/go/constant)","Package doc extracts source code documentation from a Go AST.\n\n[`go/doc` on pkg.go.dev](https://pkg.go.dev/go/doc)","Package format implements standard formatting of Go source.\n\nNote that formatting of Go source code changes over time, so tools relying on consistent formatting should execute a specific version of the gofmt binary instead of using this package. That way, the formatting will be stable, and the tools won't need to be recompiled each time gofmt changes.\n\nFor example, pre-submit checks that use this package directly would behave differently depending on what Go version each developer uses, causing the check to be inherently fragile.\n\n[`go/format` on pkg.go.dev](https://pkg.go.dev/go/format)","Package importer provides access to export data importers.\n\n[`go/importer` on pkg.go.dev](https://pkg.go.dev/go/importer)","Package parser implements a parser for Go source files. Input may be provided in a variety of forms (see the various Parse\\* functions); the output is an abstract syntax tree (AST) representing the Go source. The parser is invoked through one of the Parse\\* functions.\n\nThe parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.\n\n[`go/parser` on pkg.go.dev](https://pkg.go.dev/go/parser)","Package printer implements printing of AST nodes.\n\n[`go/printer` on pkg.go.dev](https://pkg.go.dev/go/printer)","Package scanner implements a scanner for Go source text. It takes a \\[]byte as source which can then be tokenized through repeated calls to the Scan method.\n\n[`go/scanner` on pkg.go.dev](https://pkg.go.dev/go/scanner)","Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates).\n\n[`go/token` on pkg.go.dev](https://pkg.go.dev/go/token)","Package types declares the data types and implements the algorithms for type-checking of Go packages. Use \\[Config.Check] to invoke the type checker for a package. Alternatively, create a new type checker with \\[NewChecker] and invoke it incrementally by calling \\[Checker.Files].\n\nType-checking consists of several interdependent phases:\n\nName resolution maps each identifier (\\[ast.Ident]) in the program to the symbol (\\[Object]) it denotes. Use the Defs and Uses fields of \\[Info] or the \\[Info.ObjectOf] method to find the symbol for an identifier, and use the Implicits field of \\[Info] to find the symbol for certain other kinds of syntax node.\n\nConstant folding computes the exact constant value (\\[constant.Value]) of every expression (\\[ast.Expr]) that is a compile-time constant. Use the Types field of \\[Info] to find the results of constant folding for an expression.\n\nType deduction computes the type (\\[Type]) of every expression (\\[ast.Expr]) and checks for compliance with the language specification. Use the Types field of \\[Info] for the results of type deduction.\n\nFor a tutorial, see [https://go.dev/s/types-tutorial](https://go.dev/s/types-tutorial).\n\n[`go/types` on pkg.go.dev](https://pkg.go.dev/go/types)","Package version provides operations on [Go versions](https://go.dev/doc/toolchain#version) in [Go toolchain name syntax](https://go.dev/doc/toolchain#name): strings like \"go1.20\", \"go1.21.0\", \"go1.22rc2\", and \"go1.23.4-bigcorp\".\n\n[`go/version` on pkg.go.dev](https://pkg.go.dev/go/version)","Package adler32 implements the Adler-32 checksum.\n\nIt is defined in RFC 1950:\n\n\tAdler-32 is composed of two sums accumulated per byte: s1 is\n\tthe sum of all bytes, s2 is the sum of all s1 values. Both sums\n\tare done modulo 65521. s1 is initialized to 1, s2 to zero.  The\n\tAdler-32 checksum is stored as s2*65536 + s1 in most-\n\tsignificant-byte first (network) order.\n\n[`hash/adler32` on pkg.go.dev](https://pkg.go.dev/hash/adler32)","Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See [https://en.wikipedia.org/wiki/Cyclic\\_redundancy\\_check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) for information.\n\nPolynomials are represented in LSB-first form also known as reversed representation.\n\nSee [https://en.wikipedia.org/wiki/Mathematics\\_of\\_cyclic\\_redundancy\\_checks#Reversed\\_representations\\_and\\_reciprocal\\_polynomials](https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials) for information.\n\n[`hash/crc32` on pkg.go.dev](https://pkg.go.dev/hash/crc32)","Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See [https://en.wikipedia.org/wiki/Cyclic\\_redundancy\\_check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) for information.\n\n[`hash/crc64` on pkg.go.dev](https://pkg.go.dev/hash/crc64)","Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See [https://en.wikipedia.org/wiki/Fowler-Noll-Vo\\_hash\\_function](https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function).\n\nAll the hash.Hash implementations returned by this package also implement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.\n\n[`hash/fnv` on pkg.go.dev](https://pkg.go.dev/hash/fnv)","Package maphash provides hash functions on byte sequences. These hash functions are intended to be used to implement hash tables or other data structures that need to map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers. Each different instance of a hash table or data structure should use its own \\[Seed].\n\nThe hash functions are not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)\n\n[`hash/maphash` on pkg.go.dev](https://pkg.go.dev/hash/maphash)","Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as [text/template](https://pkg.go.dev/text/template/) and should be used instead of [text/template](https://pkg.go.dev/text/template/) whenever the output is HTML.\n\nThe documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for [text/template](https://pkg.go.dev/text/template/).\n\n### Introduction {#hdr-Introduction}\n\nThis package wraps [text/template](https://pkg.go.dev/text/template/) so you can share its template API to parse and execute HTML templates safely.\n\n\ttmpl, err := template.New(\"name\").Parse(...)\n\t// Error checking elided\n\terr = tmpl.Execute(out, data)\n\nIf successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.\n\nHTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.\n\nThe security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.\n\nExample\n\n\timport \"text/template\"\n\t...\n\tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n\terr = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")\n\nproduces\n\n\tHello, \u003cscript\u003ealert('you have been pwned')\u003c/script\u003e!\n\nbut the contextual autoescaping in html/template\n\n\timport \"html/template\"\n\t...\n\tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n\terr = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")\n\nproduces safe, escaped HTML output\n\n\tHello, \u0026lt;script\u0026gt;alert(\u0026#39;you have been pwned\u0026#39;)\u0026lt;/script\u0026gt;!\n\n### Contexts {#hdr-Contexts}\n\nThis package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt\n\n\t\u003ca href=\"/search?q={{.}}\"\u003e{{.}}\u003c/a\u003e\n\nAt parse time each {{.}} is overwritten to add escaping functions as necessary. In this case it becomes\n\n\t\u003ca href=\"/search?q={{. | urlescaper | attrescaper}}\"\u003e{{. | htmlescaper}}\u003c/a\u003e\n\nwhere urlescaper, attrescaper, and htmlescaper are aliases for internal escaping functions.\n\nFor these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.\n\n### Namespaced and data- attributes {#hdr-Namespaced_and_data__attributes}\n\nAttributes with a namespace are treated as if they had no namespace. Given the excerpt\n\n\t\u003ca my:href=\"{{.}}\"\u003e\u003c/a\u003e\n\nAt parse time the attribute will be treated as if it were just \"href\". So at parse time the template becomes:\n\n\t\u003ca my:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\nSimilarly to attributes with namespaces, attributes with a \"data-\" prefix are treated as if they had no \"data-\" prefix. So given\n\n\t\u003ca data-href=\"{{.}}\"\u003e\u003c/a\u003e\n\nAt parse time this becomes\n\n\t\u003ca data-href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\nIf an attribute has both a namespace and a \"data-\" prefix, only the namespace will be removed when determining the context. For example\n\n\t\u003ca my:data-href=\"{{.}}\"\u003e\u003c/a\u003e\n\nThis is handled as if \"my:data-href\" was just \"data-href\" and not \"href\" as it would be if the \"data-\" prefix were to be ignored too. Thus at parse time this becomes just\n\n\t\u003ca my:data-href=\"{{. | attrescaper}}\"\u003e\u003c/a\u003e\n\nAs a special case, attributes with the namespace \"xmlns\" are always treated as containing URLs. Given the excerpts\n\n\t\u003ca xmlns:title=\"{{.}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:href=\"{{.}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:onclick=\"{{.}}\"\u003e\u003c/a\u003e\n\nAt parse time they become:\n\n\t\u003ca xmlns:title=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:onclick=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\n### Errors {#hdr-Errors}\n\nSee the documentation of ErrorCode for details.\n\n### A fuller picture {#hdr-A_fuller_picture}\n\nThe rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.\n\n### Contexts {#hdr-Contexts}\n\nAssuming {{.}} is \\`O'Reilly: How are \\\u003ci\u003eyou\\\u003c/i\u003e?\\`, the table below shows how {{.}} appears when used in the context to the left.\n\n\tContext                          {{.}} After\n\t{{.}}                            O'Reilly: How are \u0026lt;i\u0026gt;you\u0026lt;/i\u0026gt;?\n\t\u003ca title='{{.}}'\u003e                O\u0026#39;Reilly: How are you?\n\t\u003ca href=\"/{{.}}\"\u003e                O\u0026#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n\t\u003ca href=\"?q={{.}}\"\u003e              O\u0026#39;Reilly%3a%20How%20are%3ci%3e...%3f\n\t\u003ca onx='f(\"{{.}}\")'\u003e             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n\t\u003ca onx='f({{.}})'\u003e               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n\t\u003ca onx='pattern = /{{.}}/;'\u003e     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n\nIf used in an unsafe context, then the value might be filtered out:\n\n\tContext                          {{.}} After\n\t\u003ca href=\"{{.}}\"\u003e                 #ZgotmplZ\n\nsince \"O'Reilly:\" is not an allowed protocol like \"http:\".\n\nIf {{.}} is the innocuous word, \\`left\\`, then it can appear more widely,\n\n\tContext                              {{.}} After\n\t{{.}}                                left\n\t\u003ca title='{{.}}'\u003e                    left\n\t\u003ca href='{{.}}'\u003e                     left\n\t\u003ca href='/{{.}}'\u003e                    left\n\t\u003ca href='?dir={{.}}'\u003e                left\n\t\u003ca style=\"border-{{.}}: 4px\"\u003e        left\n\t\u003ca style=\"align: {{.}}\"\u003e             left\n\t\u003ca style=\"background: '{{.}}'\u003e       left\n\t\u003ca style=\"background: url('{{.}}')\u003e  left\n\t\u003cstyle\u003ep.{{.}} {color:red}\u003c/style\u003e   left\n\nNon-string values can be used in JavaScript contexts. If {{.}} is\n\n\tstruct{A,B string}{ \"foo\", \"bar\" }\n\nin the escaped template\n\n\t\u003cscript\u003evar pair = {{.}};\u003c/script\u003e\n\nthen the template output is\n\n\t\u003cscript\u003evar pair = {\"A\": \"foo\", \"B\": \"bar\"};\u003c/script\u003e\n\nSee package json to understand how non-string content is marshaled for embedding in JavaScript contexts.\n\n### Typed Strings {#hdr-Typed_Strings}\n\nBy default, this package assumes that all pipelines produce a plain text string. It adds escaping pipeline stages necessary to correctly and safely embed that plain text string in the appropriate context.\n\nWhen a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.\n\nTypes HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.\n\nThe template\n\n\tHello, {{.}}!\n\ncan be invoked with\n\n\ttmpl.Execute(out, template.HTML(`\u003cb\u003eWorld\u003c/b\u003e`))\n\nto produce\n\n\tHello, \u003cb\u003eWorld\u003c/b\u003e!\n\ninstead of the\n\n\tHello, \u0026lt;b\u0026gt;World\u0026lt;b\u0026gt;!\n\nthat would have been produced if {{.}} was a regular string.\n\n### Security Model {#hdr-Security_Model}\n\n[https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem\\_definition](https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition) defines \"safe\" as used by this package.\n\nThis package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:\n\nStructure Preservation Property: \"... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.\"\n\nCode Effect Property: \"... only code specified by the template author should run as a result of injecting the template output into a page and all code specified by the template author should run as a result of the same.\"\n\nLeast Surprise Property: \"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.\"\n\nPreviously, ECMAScript 6 template literal were disabled by default, and could be enabled with the GODEBUG=jstmpllitinterp=1 environment variable. Template literals are now supported by default, and setting jstmpllitinterp has no effect.\n\n[`html/template` on pkg.go.dev](https://pkg.go.dev/html/template)","Package color implements a basic color library.\n\n[`image/color` on pkg.go.dev](https://pkg.go.dev/image/color)","Package draw provides image composition functions.\n\nSee \"The Go image/draw package\" for an introduction to this package: [https://golang.org/doc/articles/image\\_draw.html](https://golang.org/doc/articles/image_draw.html)\n\n[`image/draw` on pkg.go.dev](https://pkg.go.dev/image/draw)","Package gif implements a GIF image decoder and encoder.\n\nThe GIF specification is at [https://www.w3.org/Graphics/GIF/spec-gif89a.txt](https://www.w3.org/Graphics/GIF/spec-gif89a.txt).\n\n[`image/gif` on pkg.go.dev](https://pkg.go.dev/image/gif)","Package jpeg implements a JPEG image decoder and encoder.\n\nJPEG is defined in ITU-T T.81: [https://www.w3.org/Graphics/JPEG/itu-t81.pdf](https://www.w3.org/Graphics/JPEG/itu-t81.pdf).\n\n[`image/jpeg` on pkg.go.dev](https://pkg.go.dev/image/jpeg)","Package png implements a PNG image decoder and encoder.\n\nThe PNG specification is at [https://www.w3.org/TR/PNG/](https://www.w3.org/TR/PNG/).\n\n[`image/png` on pkg.go.dev](https://pkg.go.dev/image/png)","Package suffixarray implements substring search in logarithmic time using an in-memory suffix array.\n\nExample use:\n\n\t// create index for some data\n\tindex := suffixarray.New(data)\n\n\t// lookup byte slice s\n\toffsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\n\toffsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n\n[`index/suffixarray` on pkg.go.dev](https://pkg.go.dev/index/suffixarray)","Package fs defines basic interfaces to a file system. A file system can be provided by the host operating system but also by other packages.\n\nSee the [testing/fstest](https://pkg.go.dev/testing/fstest/) package for support with testing implementations of file systems.\n\n[`io/fs` on pkg.go.dev](https://pkg.go.dev/io/fs)","Package ioutil implements some I/O utility functions.\n\nDeprecated: As of Go 1.16, the same functionality is now provided by package [io](https://pkg.go.dev/io/) or package [os](https://pkg.go.dev/os/), and those implementations should be preferred in new code. See the specific function documentation for details.\n\n[`io/ioutil` on pkg.go.dev](https://pkg.go.dev/io/ioutil)","Package slog provides structured logging, in which log records include a message, a severity level, and various other attributes expressed as key-value pairs.\n\nIt defines a type, \\[Logger], which provides several methods (such as \\[Logger.Info] and \\[Logger.Error]) for reporting events of interest.\n\nEach Logger is associated with a \\[Handler]. A Logger output method creates a \\[Record] from the method arguments and passes it to the Handler, which decides how to handle it. There is a default Logger accessible through top-level functions (such as \\[Info] and \\[Error]) that call the corresponding Logger methods.\n\nA log record consists of a time, a level, a message, and a set of key-value pairs, where the keys are strings and the values may be of any type. As an example,\n\n\tslog.Info(\"hello\", \"count\", 3)\n\ncreates a record containing the time of the call, a level of Info, the message \"hello\", and a single pair with key \"count\" and value 3.\n\nThe \\[Info] top-level function calls the \\[Logger.Info] method on the default Logger. In addition to \\[Logger.Info], there are methods for Debug, Warn and Error levels. Besides these convenience methods for common levels, there is also a \\[Logger.Log] method which takes the level as an argument. Each of these methods has a corresponding top-level function that uses the default logger.\n\nThe default handler formats the log record's message, time, level, and attributes as a string and passes it to the [log](https://pkg.go.dev/log/) package.\n\n\t2022/11/08 15:28:26 INFO hello count=3\n\nFor more control over the output format, create a logger with a different handler. This statement uses \\[New] to create a new logger with a \\[TextHandler] that writes structured records in text form to standard error:\n\n\tlogger := slog.New(slog.NewTextHandler(os.Stderr, nil))\n\n\\[TextHandler] output is a sequence of key=value pairs, easily and unambiguously parsed by machine. This statement:\n\n\tlogger.Info(\"hello\", \"count\", 3)\n\nproduces this output:\n\n\ttime=2022-11-08T15:28:26.000-05:00 level=INFO msg=hello count=3\n\nThe package also provides \\[JSONHandler], whose output is line-delimited JSON:\n\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\tlogger.Info(\"hello\", \"count\", 3)\n\nproduces this output:\n\n\t{\"time\":\"2022-11-08T15:28:26.000000000-05:00\",\"level\":\"INFO\",\"msg\":\"hello\",\"count\":3}\n\nBoth \\[TextHandler] and \\[JSONHandler] can be configured with \\[HandlerOptions]. There are options for setting the minimum level (see Levels, below), displaying the source file and line of the log call, and modifying attributes before they are logged.\n\nSetting a logger as the default with\n\n\tslog.SetDefault(logger)\n\nwill cause the top-level functions like \\[Info] to use it. \\[SetDefault] also updates the default logger used by the [log](https://pkg.go.dev/log/) package, so that existing applications that use [log.Printf](https://pkg.go.dev/log/#Printf) and related functions will send log records to the logger's handler without needing to be rewritten.\n\nSome attributes are common to many log calls. For example, you may wish to include the URL or trace identifier of a server request with all log events arising from the request. Rather than repeat the attribute with every log call, you can use \\[Logger.With] to construct a new Logger containing the attributes:\n\n\tlogger2 := logger.With(\"url\", r.URL)\n\nThe arguments to With are the same key-value pairs used in \\[Logger.Info]. The result is a new Logger with the same handler as the original, but additional attributes that will appear in the output of every call.\n\n### Levels {#hdr-Levels}\n\nA \\[Level] is an integer representing the importance or severity of a log event. The higher the level, the more severe the event. This package defines constants for the most common levels, but any int can be used as a level.\n\nIn an application, you may wish to log messages only at a certain level or greater. One common configuration is to log messages at Info or higher levels, suppressing debug logging until it is needed. The built-in handlers can be configured with the minimum level to output by setting \\[HandlerOptions.Level]. The program's \\`main\\` function typically does this. The default value is LevelInfo.\n\nSetting the \\[HandlerOptions.Level] field to a \\[Level] value fixes the handler's minimum level throughout its lifetime. Setting it to a \\[LevelVar] allows the level to be varied dynamically. A LevelVar holds a Level and is safe to read or write from multiple goroutines. To vary the level dynamically for an entire program, first initialize a global LevelVar:\n\n\tvar programLevel = new(slog.LevelVar) // Info by default\n\nThen use the LevelVar to construct a handler, and make it the default:\n\n\th := slog.NewJSONHandler(os.Stderr, \u0026slog.HandlerOptions{Level: programLevel})\n\tslog.SetDefault(slog.New(h))\n\nNow the program can change its logging level with a single statement:\n\n\tprogramLevel.Set(slog.LevelDebug)\n\n### Groups {#hdr-Groups}\n\nAttributes can be collected into groups. A group has a name that is used to qualify the names of its attributes. How this qualification is displayed depends on the handler. \\[TextHandler] separates the group and attribute names with a dot. \\[JSONHandler] treats each group as a separate JSON object, with the group name as the key.\n\nUse \\[Group] to create a Group attribute from a name and a list of key-value pairs:\n\n\tslog.Group(\"request\",\n\t    \"method\", r.Method,\n\t    \"url\", r.URL)\n\nTextHandler would display this group as\n\n\trequest.method=GET request.url=http://example.com\n\nJSONHandler would display it as\n\n\t\"request\":{\"method\":\"GET\",\"url\":\"http://example.com\"}\n\nUse \\[Logger.WithGroup] to qualify all of a Logger's output with a group name. Calling WithGroup on a Logger results in a new Logger with the same Handler as the original, but with all its attributes qualified by the group name.\n\nThis can help prevent duplicate attribute keys in large systems, where subsystems might use the same keys. Pass each subsystem a different Logger with its own group name so that potential duplicates are qualified:\n\n\tlogger := slog.Default().With(\"id\", systemID)\n\tparserLogger := logger.WithGroup(\"parser\")\n\tparseInput(input, parserLogger)\n\nWhen parseInput logs with parserLogger, its keys will be qualified with \"parser\", so even if it uses the common key \"id\", the log line will have distinct keys.\n\n### Contexts {#hdr-Contexts}\n\nSome handlers may wish to include information from the [context.Context](https://pkg.go.dev/context/#Context) that is available at the call site. One example of such information is the identifier for the current span when tracing is enabled.\n\nThe \\[Logger.Log] and \\[Logger.LogAttrs] methods take a context as a first argument, as do their corresponding top-level functions.\n\nAlthough the convenience methods on Logger (Info and so on) and the corresponding top-level functions do not take a context, the alternatives ending in \"Context\" do. For example,\n\n\tslog.InfoContext(ctx, \"message\")\n\nIt is recommended to pass a context to an output method if one is available.\n\n### Attrs and Values {#hdr-Attrs_and_Values}\n\nAn \\[Attr] is a key-value pair. The Logger output methods accept Attrs as well as alternating keys and values. The statement\n\n\tslog.Info(\"hello\", slog.Int(\"count\", 3))\n\nbehaves the same as\n\n\tslog.Info(\"hello\", \"count\", 3)\n\nThere are convenience constructors for \\[Attr] such as \\[Int], \\[String], and \\[Bool] for common types, as well as the function \\[Any] for constructing Attrs of any type.\n\nThe value part of an Attr is a type called \\[Value]. Like an \\[any], a Value can hold any Go value, but it can represent typical values, including all numbers and strings, without an allocation.\n\nFor the most efficient log output, use \\[Logger.LogAttrs]. It is similar to \\[Logger.Log] but accepts only Attrs, not alternating keys and values; this allows it, too, to avoid allocation.\n\nThe call\n\n\tlogger.LogAttrs(ctx, slog.LevelInfo, \"hello\", slog.Int(\"count\", 3))\n\nis the most efficient way to achieve the same output as\n\n\tslog.InfoContext(ctx, \"hello\", \"count\", 3)\n\n### Customizing a type's logging behavior {#hdr-Customizing_a_type_s_logging_behavior}\n\nIf a type implements the \\[LogValuer] interface, the \\[Value] returned from its LogValue method is used for logging. You can use this to control how values of the type appear in logs. For example, you can redact secret information like passwords, or gather a struct's fields in a Group. See the examples under \\[LogValuer] for details.\n\nA LogValue method may return a Value that itself implements \\[LogValuer]. The \\[Value.Resolve] method handles these cases carefully, avoiding infinite loops and unbounded recursion. Handler authors and others may wish to use \\[Value.Resolve] instead of calling LogValue directly.\n\n### Wrapping output methods {#hdr-Wrapping_output_methods}\n\nThe logger functions use reflection over the call stack to find the file name and line number of the logging call within the application. This can produce incorrect source information for functions that wrap slog. For instance, if you define this function in file mylog.go:\n\n\tfunc Infof(logger *slog.Logger, format string, args ...any) {\n\t    logger.Info(fmt.Sprintf(format, args...))\n\t}\n\nand you call it like this in main.go:\n\n\tInfof(slog.Default(), \"hello, %s\", \"world\")\n\nthen slog will report the source file as mylog.go, not main.go.\n\nA correct implementation of Infof will obtain the source location (pc) and pass it to NewRecord. The Infof function in the package-level example called \"wrapping\" demonstrates how to do this.\n\n### Working with Records {#hdr-Working_with_Records}\n\nSometimes a Handler will need to modify a Record before passing it on to another Handler or backend. A Record contains a mixture of simple public fields (e.g. Time, Level, Message) and hidden fields that refer to state (such as attributes) indirectly. This means that modifying a simple copy of a Record (e.g. by calling \\[Record.Add] or \\[Record.AddAttrs] to add attributes) may have unexpected effects on the original. Before modifying a Record, use \\[Record.Clone] to create a copy that shares no state with the original, or create a new Record with \\[NewRecord] and build up its Attrs by traversing the old ones with \\[Record.Attrs].\n\n### Performance considerations {#hdr-Performance_considerations}\n\nIf profiling your application demonstrates that logging is taking significant time, the following suggestions may help.\n\nIf many log lines have a common attribute, use \\[Logger.With] to create a Logger with that attribute. The built-in handlers will format that attribute only once, at the call to \\[Logger.With]. The \\[Handler] interface is designed to allow that optimization, and a well-written Handler should take advantage of it.\n\nThe arguments to a log call are always evaluated, even if the log event is discarded. If possible, defer computation so that it happens only if the value is actually logged. For example, consider the call\n\n\tslog.Info(\"starting request\", \"url\", r.URL.String())  // may compute String unnecessarily\n\nThe URL.String method will be called even if the logger discards Info-level events. Instead, pass the URL directly:\n\n\tslog.Info(\"starting request\", \"url\", \u0026r.URL) // calls URL.String only if needed\n\nThe built-in \\[TextHandler] will call its String method, but only if the log event is enabled. Avoiding the call to String also preserves the structure of the underlying value. For example \\[JSONHandler] emits the components of the parsed URL as a JSON object. If you want to avoid eagerly paying the cost of the String call without causing the handler to potentially inspect the structure of the value, wrap the value in a fmt.Stringer implementation that hides its Marshal methods.\n\nYou can also use the \\[LogValuer] interface to avoid unnecessary work in disabled log calls. Say you need to log some expensive value:\n\n\tslog.Debug(\"frobbing\", \"value\", computeExpensiveValue(arg))\n\nEven if this line is disabled, computeExpensiveValue will be called. To avoid that, define a type implementing LogValuer:\n\n\ttype expensive struct { arg int }\n\n\tfunc (e expensive) LogValue() slog.Value {\n\t    return slog.AnyValue(computeExpensiveValue(e.arg))\n\t}\n\nThen use a value of that type in log calls:\n\n\tslog.Debug(\"frobbing\", \"value\", expensive{arg})\n\nNow computeExpensiveValue will only be called when the line is enabled.\n\nThe built-in handlers acquire a lock before calling [io.Writer.Write](https://pkg.go.dev/io/#Writer.Write) to ensure that exactly one \\[Record] is written at a time in its entirety. Although each log record has a timestamp, the built-in handlers do not use that time to sort the written records. User-defined handlers are responsible for their own locking and sorting.\n\n### Writing a handler {#hdr-Writing_a_handler}\n\nFor a guide to writing a custom handler, see [https://golang.org/s/slog-handler-guide](https://golang.org/s/slog-handler-guide).\n\n[`log/slog` on pkg.go.dev](https://pkg.go.dev/log/slog)","Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP.\n\nOnly one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again.\n\nThe syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:\n\n\thttps://godoc.org/?q=syslog\n\n[`log/syslog` on pkg.go.dev](https://pkg.go.dev/log/syslog)","Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:\n\n\tInt    signed integers\n\tRat    rational numbers\n\tFloat  floating-point numbers\n\nThe zero value for an \\[Int], \\[Rat], or \\[Float] correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:\n\n\tvar x Int        // \u0026x is an *Int of value 0\n\tvar r = \u0026Rat{}   // r is a *Rat of value 0\n\ty := new(Float)  // y is a *Float of value 0\n\nAlternatively, new values can be allocated and initialized with factory functions of the form:\n\n\tfunc NewT(v V) *T\n\nFor instance, \\[NewInt](x) returns an \\*\\[Int] set to the value of the int64 argument x, \\[NewRat](a, b) returns a \\*\\[Rat] set to the fraction a/b where a and b are int64 values, and \\[NewFloat](f) returns a \\*\\[Float] initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:\n\n\tvar z1 Int\n\tz1.SetUint64(123)                 // z1 := 123\n\tz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\n\tz3 := new(Float).SetInt(z1)       // z3 := 123.0\n\nSetters, numeric operations and predicates are represented as methods of the form:\n\n\tfunc (z *T) SetV(v V) *T          // z = v\n\tfunc (z *T) Unary(x *T) *T        // z = unary x\n\tfunc (z *T) Binary(x, y *T) *T    // z = x binary y\n\tfunc (x *T) Pred() P              // p = pred(x)\n\nwith T one of \\[Int], \\[Rat], or \\[Float]. For unary and binary operations, the result is the receiver (usually named z in that case; see below); if it is one of the operands x or y it may be safely overwritten (and its memory reused).\n\nArithmetic expressions are typically written as a sequence of individual method calls, with each call corresponding to an operation. The receiver denotes the result and the method arguments are the operation's operands. For instance, given three \\*Int values a, b and c, the invocation\n\n\tc.Add(a, b)\n\ncomputes the sum a + b and stores the result in c, overwriting whatever value was held in c before. Unless specified otherwise, operations permit aliasing of parameters, so it is perfectly ok to write\n\n\tsum.Add(sum, x)\n\nto accumulate values x in a sum.\n\n(By always passing in a result value via the receiver, memory use can be much better controlled. Instead of having to allocate new memory for each result, an operation can reuse the space allocated for the result value, and overwrite that value with the new result in the process.)\n\nNotational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).\n\nFor instance, the arguments for (\\*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:\n\n\tfunc (z *Int) Add(x, y *Int) *Int\n\nMethods of this form typically return the incoming receiver as well, to enable simple call chaining.\n\nMethods which don't require a result value to be passed in (for instance, \\[Int.Sign]), simply return the result. In this case, the receiver is typically the first operand, named x:\n\n\tfunc (x *Int) Sign() int\n\nVarious methods support conversions between strings and corresponding numeric values, and vice versa: \\*\\[Int], \\*\\[Rat], and \\*\\[Float] values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).\n\nFinally, \\*\\[Int], \\*\\[Rat], and \\*\\[Float] satisfy [fmt.Scanner](https://pkg.go.dev/fmt/#Scanner) for scanning and (except for \\*\\[Rat]) the Formatter interface for formatted printing.\n\n[`math/big` on pkg.go.dev](https://pkg.go.dev/math/big)","Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.\n\nFunctions in this package may be implemented directly by the compiler, for better performance. For those functions the code in this package will not be used. Which functions are implemented by the compiler depends on the architecture and the Go release.\n\n[`math/bits` on pkg.go.dev](https://pkg.go.dev/math/bits)","Package cmplx provides basic constants and mathematical functions for complex numbers. Special case handling conforms to the C99 standard Annex G IEC 60559-compatible complex arithmetic.\n\n[`math/cmplx` on pkg.go.dev](https://pkg.go.dev/math/cmplx)","Package rand implements pseudo-random number generators suitable for tasks such as simulation, but it should not be used for security-sensitive work.\n\nRandom numbers are generated by a \\[Source], usually wrapped in a \\[Rand]. Both types should be used by a single goroutine at a time: sharing among multiple goroutines requires some kind of synchronization.\n\nTop-level functions, such as \\[Float64] and \\[Int], are safe for concurrent use by multiple goroutines.\n\nThis package's outputs might be easily predictable regardless of how it's seeded. For random numbers suitable for security-sensitive work, see the crypto/rand package.\n\n[`math/rand` on pkg.go.dev](https://pkg.go.dev/math/rand)","Package multipart implements MIME multipart parsing, as defined in RFC 2046.\n\nThe implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.\n\n### Limits {#hdr-Limits}\n\nTo protect against malicious inputs, this package sets limits on the size of the MIME data it processes.\n\n\\[Reader.NextPart] and \\[Reader.NextRawPart] limit the number of headers in a part to 10000 and \\[Reader.ReadForm] limits the total number of headers in all FileHeaders to 10000. These limits may be adjusted with the GODEBUG=multipartmaxheaders=\\\u003cvalues\u003e setting.\n\nReader.ReadForm further limits the number of parts in a form to 1000. This limit may be adjusted with the GODEBUG=multipartmaxparts=\\\u003cvalue\u003e setting.\n\n[`mime/multipart` on pkg.go.dev](https://pkg.go.dev/mime/multipart)","Package quotedprintable implements quoted-printable encoding as specified by RFC 2045.\n\n[`mime/quotedprintable` on pkg.go.dev](https://pkg.go.dev/mime/quotedprintable)","Package http provides HTTP client and server implementations.\n\n\\[Get], \\[Head], \\[Post], and \\[PostForm] make HTTP (or HTTPS) requests:\n\n\tresp, err := http.Get(\"http://example.com/\")\n\t...\n\tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf)\n\t...\n\tresp, err := http.PostForm(\"http://example.com/form\",\n\t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\nThe caller must close the response body when finished with it:\n\n\tresp, err := http.Get(\"http://example.com/\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := io.ReadAll(resp.Body)\n\t// ...\n\n### Clients and Transports {#hdr-Clients_and_Transports}\n\nFor control over HTTP client headers, redirect policy, and other settings, create a \\[Client]:\n\n\tclient := \u0026http.Client{\n\t\tCheckRedirect: redirectPolicyFunc,\n\t}\n\n\tresp, err := client.Get(\"http://example.com\")\n\t// ...\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t// ...\n\treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n\tresp, err := client.Do(req)\n\t// ...\n\nFor control over proxies, TLS configuration, keep-alives, compression, and other settings, create a \\[Transport]:\n\n\ttr := \u0026http.Transport{\n\t\tMaxIdleConns:       10,\n\t\tIdleConnTimeout:    30 * time.Second,\n\t\tDisableCompression: true,\n\t}\n\tclient := \u0026http.Client{Transport: tr}\n\tresp, err := client.Get(\"https://example.com\")\n\nClients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used.\n\n### Servers {#hdr-Servers}\n\nListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use \\[DefaultServeMux]. \\[Handle] and \\[HandleFunc] add handlers to \\[DefaultServeMux]:\n\n\thttp.Handle(\"/foo\", fooHandler)\n\n\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\nMore control over the server's behavior is available by creating a custom Server:\n\n\ts := \u0026http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        myHandler,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t}\n\tlog.Fatal(s.ListenAndServe())\n\n### HTTP/2 {#hdr-HTTP_2}\n\nStarting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting \\[Transport.TLSNextProto] (for clients) or \\[Server.TLSNextProto] (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG settings are currently supported:\n\n\tGODEBUG=http2client=0  # disable HTTP/2 client support\n\tGODEBUG=http2server=0  # disable HTTP/2 server support\n\tGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\n\tGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\nPlease report any issues before disabling HTTP/2 support: [https://golang.org/s/http2bug](https://golang.org/s/http2bug)\n\nThe http package's \\[Transport] and \\[Server] both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import \"golang.org/x/net/http2\" directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.\n\n[`net/http` on pkg.go.dev](https://pkg.go.dev/net/http)","Package mail implements parsing of mail messages.\n\nFor the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences:\n\n  - Obsolete address formats are not parsed, including addresses with embedded route information.\n  - The full range of spacing (the CFWS syntax element) is not supported, such as breaking addresses across lines.\n  - No unicode normalization is performed.\n  - A leading From line is permitted, as in mbox format (RFC 4155).\n\n[`net/mail` on pkg.go.dev](https://pkg.go.dev/net/mail)","Package netip defines an IP address type that's a small value type. Building on that \\[Addr] type, the package also defines \\[AddrPort] (an IP address and a port) and \\[Prefix] (an IP address and a bit length prefix).\n\nCompared to the [net.IP](https://pkg.go.dev/net/#IP) type, \\[Addr] type takes less memory, is immutable, and is comparable (supports == and being a map key).\n\n[`net/netip` on pkg.go.dev](https://pkg.go.dev/net/netip)","Package rpc provides access to the exported methods of an object across a network or other I/O connection.  A server registers an object, making it visible as a service with the name of the type of the object.  After registration, exported methods of the object will be accessible remotely.  A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.\n\nOnly methods that satisfy these criteria will be made available for remote access; other methods will be ignored:\n\n  - the method's type is exported.\n  - the method is exported.\n  - the method has two arguments, both exported (or builtin) types.\n  - the method's second argument is a pointer.\n  - the method has return type error.\n\nIn effect, the method must look schematically like\n\n\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n\nwhere T1 and T2 can be marshaled by encoding/gob. These requirements apply even if a different codec is used. (In the future, these requirements may soften for custom codecs.)\n\nThe method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by [errors.New](https://pkg.go.dev/errors/#New).  If an error is returned, the reply parameter will not be sent back to the client.\n\nThe server may handle requests on a single connection by calling \\[ServeConn].  More typically it will create a network listener and call \\[Accept] or, for an HTTP listener, \\[HandleHTTP] and \\[http.Serve].\n\nA client wishing to use the service establishes a connection and then invokes \\[NewClient] on the connection.  The convenience function \\[Dial] (\\[DialHTTP]) performs both steps for a raw network connection (an HTTP connection).  The resulting \\[Client] object has two methods, \\[Call] and Go, that specify the service and method to call, a pointer containing the arguments, and a pointer to receive the result parameters.\n\nThe Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel.\n\nUnless an explicit codec is set up, package [encoding/gob](https://pkg.go.dev/encoding/gob/) is used to transport the data.\n\nHere is a simple example.  A server wishes to export an object of type Arith:\n\n\tpackage server\n\n\timport \"errors\"\n\n\ttype Args struct {\n\t\tA, B int\n\t}\n\n\ttype Quotient struct {\n\t\tQuo, Rem int\n\t}\n\n\ttype Arith int\n\n\tfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t\t*reply = args.A * args.B\n\t\treturn nil\n\t}\n\n\tfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\t\tif args.B == 0 {\n\t\t\treturn errors.New(\"divide by zero\")\n\t\t}\n\t\tquo.Quo = args.A / args.B\n\t\tquo.Rem = args.A % args.B\n\t\treturn nil\n\t}\n\nThe server calls (for HTTP service):\n\n\tarith := new(Arith)\n\trpc.Register(arith)\n\trpc.HandleHTTP()\n\tl, err := net.Listen(\"tcp\", \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"listen error:\", err)\n\t}\n\tgo http.Serve(l, nil)\n\nAt this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and \"Arith.Divide\".  To invoke one, a client first dials the server:\n\n\tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"dialing:\", err)\n\t}\n\nThen it can make a remote call:\n\n\t// Synchronous call\n\targs := \u0026server.Args{7,8}\n\tvar reply int\n\terr = client.Call(\"Arith.Multiply\", args, \u0026reply)\n\tif err != nil {\n\t\tlog.Fatal(\"arith error:\", err)\n\t}\n\tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\nor\n\n\t// Asynchronous call\n\tquotient := new(Quotient)\n\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n\treplyCall := \u003c-divCall.Done\t// will be equal to divCall\n\t// check errors, print, etc.\n\nA server implementation will often provide a simple, type-safe wrapper for the client.\n\nThe net/rpc package is frozen and is not accepting new features.\n\n[`net/rpc` on pkg.go.dev](https://pkg.go.dev/net/rpc)","Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. It also implements the following extensions:\n\n\t8BITMIME  RFC 1652\n\tAUTH      RFC 2554\n\tSTARTTLS  RFC 3207\n\nAdditional extensions may be handled by clients.\n\nThe smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:\n\n\thttps://godoc.org/?q=smtp\n\n[`net/smtp` on pkg.go.dev](https://pkg.go.dev/net/smtp)","Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.\n\nThe package provides:\n\n\\[Error], which represents a numeric error response from a server.\n\n\\[Pipeline], to manage pipelined requests and responses in a client.\n\n\\[Reader], to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.\n\n\\[Writer], to write dot-encoded text blocks.\n\n\\[Conn], a convenient packaging of \\[Reader], \\[Writer], and \\[Pipeline] for use with a single network connection.\n\n[`net/textproto` on pkg.go.dev](https://pkg.go.dev/net/textproto)","Package url parses URLs and implements query escaping.\n\n[`net/url` on pkg.go.dev](https://pkg.go.dev/net/url)","Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments.\n\nUnlike the \"system\" library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's \"exec\" family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the [path/filepath](https://pkg.go.dev/path/filepath/) package's Glob function. To expand environment variables, use package os's ExpandEnv.\n\nNote that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org.\n\n### Executables in the current directory {#hdr-Executables_in_the_current_directory}\n\nThe functions \\[Command] and \\[LookPath] look for a program in the directories listed in the current path, following the conventions of the host operating system. Operating systems have for decades included the current directory in this search, sometimes implicitly and sometimes configured explicitly that way by default. Modern practice is that including the current directory is usually unexpected and often leads to security problems.\n\nTo avoid those security problems, as of Go 1.19, this package will not resolve a program using an implicit or explicit path entry relative to the current directory. That is, if you run \\[LookPath](\"go\"), it will not successfully return ./go on Unix nor .\\\\go.exe on Windows, no matter how the path is configured. Instead, if the usual path algorithms would result in that answer, these functions return an error err satisfying [errors.Is](https://pkg.go.dev/errors/#Is)(err, \\[ErrDot]).\n\nFor example, consider these two program snippets:\n\n\tpath, err := exec.LookPath(\"prog\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tuse(path)\n\nand\n\n\tcmd := exec.Command(\"prog\")\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\nThese will not find and run ./prog or .\\\\prog.exe, no matter how the current path is configured.\n\nCode that always wants to run a program from the current directory can be rewritten to say \"./prog\" instead of \"prog\".\n\nCode that insists on including results from relative path entries can instead override the error using an errors.Is check:\n\n\tpath, err := exec.LookPath(\"prog\")\n\tif errors.Is(err, exec.ErrDot) {\n\t\terr = nil\n\t}\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tuse(path)\n\nand\n\n\tcmd := exec.Command(\"prog\")\n\tif errors.Is(cmd.Err, exec.ErrDot) {\n\t\tcmd.Err = nil\n\t}\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\nSetting the environment variable GODEBUG=execerrdot=0 disables generation of ErrDot entirely, temporarily restoring the pre-Go 1.19 behavior for programs that are unable to apply more targeted fixes. A future version of Go may remove support for this variable.\n\nBefore adding such overrides, make sure you understand the security implications of doing so. See [https://go.dev/blog/path-security](https://go.dev/blog/path-security) for more information.\n\n[`os/exec` on pkg.go.dev](https://pkg.go.dev/os/exec)","Package signal implements access to incoming signals.\n\nSignals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.\n\n### Types of signals {#hdr-Types_of_signals}\n\nThe signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.\n\nSynchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using [os.Process.Kill](https://pkg.go.dev/os/#Process.Kill) or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic.\n\nThe remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.\n\nOf the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\\\\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\\\\.\n\n### Default behavior of signals in Go programs {#hdr-Default_behavior_of_signals_in_Go_programs}\n\nBy default, a synchronous signal is converted into a run-time panic. A SIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control). The SIGPROF signal is handled directly by the Go runtime to implement runtime.CPUProfile. Other signals will be caught but no action will be taken.\n\nIf the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG\\_IGN), they will remain ignored.\n\nIf the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by [os.Exec](https://pkg.go.dev/os/#Exec), or by [os/exec](https://pkg.go.dev/os/exec/), will inherit the modified signal mask.\n\n### Changing the behavior of signals in Go programs {#hdr-Changing_the_behavior_of_signals_in_Go_programs}\n\nThe functions in this package allow a program to change the way Go programs handle signals.\n\nNotify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems.\n\nIf the program was started with SIGHUP or SIGINT ignored, and \\[Notify] is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, \\[Reset] or \\[Ignore] is called for that signal, or \\[Stop] is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.\n\nIf the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.\n\n### SIGPIPE {#hdr-SIGPIPE}\n\nWhen a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.\n\nIf the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error.\n\nIf the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error.\n\nThis means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.\n\n### Go programs that use cgo or SWIG {#hdr-Go_programs_that_use_cgo_or_SWIG}\n\nIn a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.\n\nIf the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.\n\nIf the non-Go code installs any signal handlers, it must use the SA\\_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack.\n\nIf the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.\n\nIf the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.\n\nThe non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads itself, those threads may set the signal mask as they please.\n\nIf the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.\n\nIf the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.\n\nIf a SIGPIPE signal is received, the Go program will invoke the special handling described above if the SIGPIPE is received on a Go thread.  If the SIGPIPE is received on a non-Go thread the signal will be forwarded to the non-Go handler, if any; if there is none the default system handler will cause the program to terminate.\n\n### Non-Go programs that call Go code {#hdr-Non_Go_programs_that_call_Go_code}\n\nWhen Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies).  For -buildmode=c-archive the Go runtime will initialize signals at global constructor time.  For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.\n\nIf the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on Linux), it will turn on the SA\\_ONSTACK flag and otherwise keep the signal handler.\n\nFor the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.\n\nGo code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA\\_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.\n\nGo code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.\n\n### Windows {#hdr-Windows}\n\nOn Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for [os.Interrupt](https://pkg.go.dev/os/#Interrupt), ^C or ^BREAK will cause [os.Interrupt](https://pkg.go.dev/os/#Interrupt) to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored.\n\nAdditionally, if Notify is called, and Windows sends CTRL\\_CLOSE\\_EVENT, CTRL\\_LOGOFF\\_EVENT or CTRL\\_SHUTDOWN\\_EVENT to the process, Notify will return syscall.SIGTERM. Unlike Control-C and Control-Break, Notify does not change process behavior when either CTRL\\_CLOSE\\_EVENT, CTRL\\_LOGOFF\\_EVENT or CTRL\\_SHUTDOWN\\_EVENT is received - the process will still get terminated unless it exits. But receiving syscall.SIGTERM will give the process an opportunity to clean up before termination.\n\n### Plan 9 {#hdr-Plan_9}\n\nOn Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note.\n\n[`os/signal` on pkg.go.dev](https://pkg.go.dev/os/signal)","Package user allows user account lookups by name or id.\n\nFor most Unix systems, this package has two internal implementations of resolving user and group ids to names, and listing supplementary group IDs. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid\\_r, getgrnam\\_r, and getgrouplist.\n\nWhen cgo is available, and the required routines are implemented in libc for a particular platform, cgo-based (libc-backed) code is used. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.\n\n[`os/user` on pkg.go.dev](https://pkg.go.dev/os/user)","Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.\n\nThe filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the [path](https://pkg.go.dev/path/) package.\n\n[`path/filepath` on pkg.go.dev](https://pkg.go.dev/path/filepath)","Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package [regexp](https://pkg.go.dev/regexp/) (such as [regexp.Compile](https://pkg.go.dev/regexp/#Compile) and [regexp.Match](https://pkg.go.dev/regexp/#Match)) instead of this package.\n\n### Syntax {#hdr-Syntax}\n\nThe regular expression syntax understood by this package when parsing with the \\[Perl] flag is as follows. Parts of the syntax can be disabled by passing alternate flags to \\[Parse].\n\nSingle characters:\n\n\t.              any character, possibly including newline (flag s=true)\n\t[xyz]          character class\n\t[^xyz]         negated character class\n\t\\d             Perl character class\n\t\\D             negated Perl character class\n\t[[:alpha:]]    ASCII character class\n\t[[:^alpha:]]   negated ASCII character class\n\t\\pN            Unicode character class (one-letter name)\n\t\\p{Greek}      Unicode character class\n\t\\PN            negated Unicode character class (one-letter name)\n\t\\P{Greek}      negated Unicode character class\n\nComposites:\n\n\txy             x followed by y\n\tx|y            x or y (prefer x)\n\nRepetitions:\n\n\tx*             zero or more x, prefer more\n\tx+             one or more x, prefer more\n\tx?             zero or one x, prefer one\n\tx{n,m}         n or n+1 or ... or m x, prefer more\n\tx{n,}          n or more x, prefer more\n\tx{n}           exactly n x\n\tx*?            zero or more x, prefer fewer\n\tx+?            one or more x, prefer fewer\n\tx??            zero or one x, prefer zero\n\tx{n,m}?        n or n+1 or ... or m x, prefer fewer\n\tx{n,}?         n or more x, prefer fewer\n\tx{n}?          exactly n x\n\nImplementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.\n\nGrouping:\n\n\t(re)           numbered capturing group (submatch)\n\t(?P\u003cname\u003ere)   named \u0026 numbered capturing group (submatch)\n\t(?\u003cname\u003ere)    named \u0026 numbered capturing group (submatch)\n\t(?:re)         non-capturing group\n\t(?flags)       set flags within current group; non-capturing\n\t(?flags:re)    set flags during re; non-capturing\n\n\tFlag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\n\ti              case-insensitive (default false)\n\tm              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\n\ts              let . match \\n (default false)\n\tU              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n\nEmpty strings:\n\n\t^              at beginning of text or line (flag m=true)\n\t$              at end of text (like \\z not \\Z) or line (flag m=true)\n\t\\A             at beginning of text\n\t\\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n\t\\B             not at ASCII word boundary\n\t\\z             at end of text\n\nEscape sequences:\n\n\t\\a             bell (== \\007)\n\t\\f             form feed (== \\014)\n\t\\t             horizontal tab (== \\011)\n\t\\n             newline (== \\012)\n\t\\r             carriage return (== \\015)\n\t\\v             vertical tab character (== \\013)\n\t\\*             literal *, for any punctuation character *\n\t\\123           octal character code (up to three digits)\n\t\\x7F           hex character code (exactly two digits)\n\t\\x{10FFFF}     hex character code\n\t\\Q...\\E        literal text ... even if ... has punctuation\n\nCharacter class elements:\n\n\tx              single character\n\tA-Z            character range (inclusive)\n\t\\d             Perl character class\n\t[:foo:]        ASCII character class foo\n\t\\p{Foo}        Unicode character class Foo\n\t\\pF            Unicode character class F (one-letter name)\n\nNamed character classes as character class elements:\n\n\t[\\d]           digits (== \\d)\n\t[^\\d]          not digits (== \\D)\n\t[\\D]           not digits (== \\D)\n\t[^\\D]          not not digits (== \\d)\n\t[[:name:]]     named ASCII class inside character class (== [:name:])\n\t[^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n\t[\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n\t[^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n\nPerl character classes (all ASCII-only):\n\n\t\\d             digits (== [0-9])\n\t\\D             not digits (== [^0-9])\n\t\\s             whitespace (== [\\t\\n\\f\\r ])\n\t\\S             not whitespace (== [^\\t\\n\\f\\r ])\n\t\\w             word characters (== [0-9A-Za-z_])\n\t\\W             not word characters (== [^0-9A-Za-z_])\n\nASCII character classes:\n\n\t[[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n\t[[:alpha:]]    alphabetic (== [A-Za-z])\n\t[[:ascii:]]    ASCII (== [\\x00-\\x7F])\n\t[[:blank:]]    blank (== [\\t ])\n\t[[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n\t[[:digit:]]    digits (== [0-9])\n\t[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%\u0026'()*+,\\-./:;\u003c=\u003e?@[\\\\\\]^_`{|}~])\n\t[[:lower:]]    lower case (== [a-z])\n\t[[:print:]]    printable (== [ -~] == [ [:graph:]])\n\t[[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n\t[[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n\t[[:upper:]]    upper case (== [A-Z])\n\t[[:word:]]     word characters (== [0-9A-Za-z_])\n\t[[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n\nUnicode character classes are those in [unicode.Categories](https://pkg.go.dev/unicode/#Categories) and [unicode.Scripts](https://pkg.go.dev/unicode/#Scripts).\n\n[`regexp/syntax` on pkg.go.dev](https://pkg.go.dev/regexp/syntax)","Package cgo contains runtime support for code generated by the cgo tool.  See the documentation for the cgo command for details on using cgo.\n\n[`runtime/cgo` on pkg.go.dev](https://pkg.go.dev/runtime/cgo)","","Package debug contains facilities for programs to debug themselves while they are running.\n\n[`runtime/debug` on pkg.go.dev](https://pkg.go.dev/runtime/debug)","Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime. This package is similar to existing functions like [runtime.ReadMemStats](https://pkg.go.dev/runtime/#ReadMemStats) and [runtime/debug.ReadGCStats](https://pkg.go.dev/runtime/debug/#ReadGCStats), but significantly more general.\n\nThe set of metrics defined by this package may evolve as the runtime itself evolves, and also enables variation across Go implementations, whose relevant metric sets may not intersect.\n\n### Interface {#hdr-Interface}\n\nMetrics are designated by a string key, rather than, for example, a field name in a struct. The full list of supported metrics is always available in the slice of Descriptions returned by \\[All]. Each \\[Description] also includes useful information about the metric.\n\nThus, users of this API are encouraged to sample supported metrics defined by the slice returned by All to remain compatible across Go versions. Of course, situations arise where reading specific metrics is critical. For these cases, users are encouraged to use build tags, and although metrics may be deprecated and removed, users should consider this to be an exceptional and rare event, coinciding with a very large change in a particular Go implementation.\n\nEach metric key also has a \"kind\" (see \\[ValueKind]) that describes the format of the metric's value. In the interest of not breaking users of this package, the \"kind\" for a given metric is guaranteed not to change. If it must change, then a new metric will be introduced with a new key and a new \"kind.\"\n\n### Metric key format {#hdr-Metric_key_format}\n\nAs mentioned earlier, metric keys are strings. Their format is simple and well-defined, designed to be both human and machine readable. It is split into two components, separated by a colon: a rooted path and a unit. The choice to include the unit in the key is motivated by compatibility: if a metric's unit changes, its semantics likely did also, and a new key should be introduced.\n\nFor more details on the precise definition of the metric key's path and unit formats, see the documentation of the Name field of the Description struct.\n\n### A note about floats {#hdr-A_note_about_floats}\n\nThis package supports metrics whose values have a floating-point representation. In order to improve ease-of-use, this package promises to never produce the following classes of floating-point values: NaN, infinity.\n\n### Supported metrics {#hdr-Supported_metrics}\n\nBelow is the full list of supported metrics, ordered lexicographically.\n\n\t/cgo/go-to-c-calls:calls\n\t\tCount of calls made from Go to C by the current process.\n\n\t/cpu/classes/gc/mark/assist:cpu-seconds\n\t\tEstimated total CPU time goroutines spent performing GC\n\t\ttasks to assist the GC and prevent it from falling behind the\n\t\tapplication. This metric is an overestimate, and not directly\n\t\tcomparable to system CPU time measurements. Compare only with\n\t\tother /cpu/classes metrics.\n\n\t/cpu/classes/gc/mark/dedicated:cpu-seconds\n\t\tEstimated total CPU time spent performing GC tasks on processors\n\t\t(as defined by GOMAXPROCS) dedicated to those tasks. This metric\n\t\tis an overestimate, and not directly comparable to system CPU\n\t\ttime measurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/gc/mark/idle:cpu-seconds\n\t\tEstimated total CPU time spent performing GC tasks on spare CPU\n\t\tresources that the Go scheduler could not otherwise find a use\n\t\tfor. This should be subtracted from the total GC CPU time to\n\t\tobtain a measure of compulsory GC CPU time. This metric is an\n\t\toverestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/gc/pause:cpu-seconds\n\t\tEstimated total CPU time spent with the application paused by\n\t\tthe GC. Even if only one thread is running during the pause,\n\t\tthis is computed as GOMAXPROCS times the pause latency because\n\t\tnothing else can be executing. This is the exact sum of samples\n\t\tin /sched/pauses/total/gc:seconds if each sample is multiplied\n\t\tby GOMAXPROCS at the time it is taken. This metric is an\n\t\toverestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/gc/total:cpu-seconds\n\t\tEstimated total CPU time spent performing GC tasks. This metric\n\t\tis an overestimate, and not directly comparable to system CPU\n\t\ttime measurements. Compare only with other /cpu/classes metrics.\n\t\tSum of all metrics in /cpu/classes/gc.\n\n\t/cpu/classes/idle:cpu-seconds\n\t\tEstimated total available CPU time not spent executing\n\t\tany Go or Go runtime code. In other words, the part of\n\t\t/cpu/classes/total:cpu-seconds that was unused. This metric is\n\t\tan overestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/scavenge/assist:cpu-seconds\n\t\tEstimated total CPU time spent returning unused memory to the\n\t\tunderlying platform in response eagerly in response to memory\n\t\tpressure. This metric is an overestimate, and not directly\n\t\tcomparable to system CPU time measurements. Compare only with\n\t\tother /cpu/classes metrics.\n\n\t/cpu/classes/scavenge/background:cpu-seconds\n\t\tEstimated total CPU time spent performing background tasks to\n\t\treturn unused memory to the underlying platform. This metric is\n\t\tan overestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/scavenge/total:cpu-seconds\n\t\tEstimated total CPU time spent performing tasks that return\n\t\tunused memory to the underlying platform. This metric is an\n\t\toverestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\t\tSum of all metrics in /cpu/classes/scavenge.\n\n\t/cpu/classes/total:cpu-seconds\n\t\tEstimated total available CPU time for user Go code or the Go\n\t\truntime, as defined by GOMAXPROCS. In other words, GOMAXPROCS\n\t\tintegrated over the wall-clock duration this process has been\n\t\texecuting for. This metric is an overestimate, and not directly\n\t\tcomparable to system CPU time measurements. Compare only with\n\t\tother /cpu/classes metrics. Sum of all metrics in /cpu/classes.\n\n\t/cpu/classes/user:cpu-seconds\n\t\tEstimated total CPU time spent running user Go code. This may\n\t\talso include some small amount of time spent in the Go runtime.\n\t\tThis metric is an overestimate, and not directly comparable\n\t\tto system CPU time measurements. Compare only with other\n\t\t/cpu/classes metrics.\n\n\t/gc/cycles/automatic:gc-cycles\n\t\tCount of completed GC cycles generated by the Go runtime.\n\n\t/gc/cycles/forced:gc-cycles\n\t\tCount of completed GC cycles forced by the application.\n\n\t/gc/cycles/total:gc-cycles\n\t\tCount of all completed GC cycles.\n\n\t/gc/gogc:percent\n\t\tHeap size target percentage configured by the user, otherwise\n\t\t100. This value is set by the GOGC environment variable, and the\n\t\truntime/debug.SetGCPercent function.\n\n\t/gc/gomemlimit:bytes\n\t\tGo runtime memory limit configured by the user, otherwise\n\t\tmath.MaxInt64. This value is set by the GOMEMLIMIT environment\n\t\tvariable, and the runtime/debug.SetMemoryLimit function.\n\n\t/gc/heap/allocs-by-size:bytes\n\t\tDistribution of heap allocations by approximate size.\n\t\tBucket counts increase monotonically. Note that this does not\n\t\tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\t\tonly tiny blocks.\n\n\t/gc/heap/allocs:bytes\n\t\tCumulative sum of memory allocated to the heap by the\n\t\tapplication.\n\n\t/gc/heap/allocs:objects\n\t\tCumulative count of heap allocations triggered by the\n\t\tapplication. Note that this does not include tiny objects as\n\t\tdefined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n\n\t/gc/heap/frees-by-size:bytes\n\t\tDistribution of freed heap allocations by approximate size.\n\t\tBucket counts increase monotonically. Note that this does not\n\t\tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\t\tonly tiny blocks.\n\n\t/gc/heap/frees:bytes\n\t\tCumulative sum of heap memory freed by the garbage collector.\n\n\t/gc/heap/frees:objects\n\t\tCumulative count of heap allocations whose storage was freed\n\t\tby the garbage collector. Note that this does not include tiny\n\t\tobjects as defined by /gc/heap/tiny/allocs:objects, only tiny\n\t\tblocks.\n\n\t/gc/heap/goal:bytes\n\t\tHeap size target for the end of the GC cycle.\n\n\t/gc/heap/live:bytes\n\t\tHeap memory occupied by live objects that were marked by the\n\t\tprevious GC.\n\n\t/gc/heap/objects:objects\n\t\tNumber of objects, live or unswept, occupying heap memory.\n\n\t/gc/heap/tiny/allocs:objects\n\t\tCount of small allocations that are packed together into blocks.\n\t\tThese allocations are counted separately from other allocations\n\t\tbecause each individual allocation is not tracked by the\n\t\truntime, only their block. Each block is already accounted for\n\t\tin allocs-by-size and frees-by-size.\n\n\t/gc/limiter/last-enabled:gc-cycle\n\t\tGC cycle the last time the GC CPU limiter was enabled.\n\t\tThis metric is useful for diagnosing the root cause of an\n\t\tout-of-memory error, because the limiter trades memory for CPU\n\t\ttime when the GC's CPU time gets too high. This is most likely\n\t\tto occur with use of SetMemoryLimit. The first GC cycle is cycle\n\t\t1, so a value of 0 indicates that it was never enabled.\n\n\t/gc/pauses:seconds\n\t\tDeprecated. Prefer the identical /sched/pauses/total/gc:seconds.\n\n\t/gc/scan/globals:bytes\n\t\tThe total amount of global variable space that is scannable.\n\n\t/gc/scan/heap:bytes\n\t\tThe total amount of heap space that is scannable.\n\n\t/gc/scan/stack:bytes\n\t\tThe number of bytes of stack that were scanned last GC cycle.\n\n\t/gc/scan/total:bytes\n\t\tThe total amount space that is scannable. Sum of all metrics in\n\t\t/gc/scan.\n\n\t/gc/stack/starting-size:bytes\n\t\tThe stack size of new goroutines.\n\n\t/godebug/non-default-behavior/asynctimerchan:events\n\t\tThe number of non-default behaviors executed by the time package\n\t\tdue to a non-default GODEBUG=asynctimerchan=... setting.\n\n\t/godebug/non-default-behavior/execerrdot:events\n\t\tThe number of non-default behaviors executed by the os/exec\n\t\tpackage due to a non-default GODEBUG=execerrdot=... setting.\n\n\t/godebug/non-default-behavior/gocachehash:events\n\t\tThe number of non-default behaviors executed by the cmd/go\n\t\tpackage due to a non-default GODEBUG=gocachehash=... setting.\n\n\t/godebug/non-default-behavior/gocachetest:events\n\t\tThe number of non-default behaviors executed by the cmd/go\n\t\tpackage due to a non-default GODEBUG=gocachetest=... setting.\n\n\t/godebug/non-default-behavior/gocacheverify:events\n\t\tThe number of non-default behaviors executed by the cmd/go\n\t\tpackage due to a non-default GODEBUG=gocacheverify=... setting.\n\n\t/godebug/non-default-behavior/gotypesalias:events\n\t\tThe number of non-default behaviors executed by the go/types\n\t\tpackage due to a non-default GODEBUG=gotypesalias=... setting.\n\n\t/godebug/non-default-behavior/http2client:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=http2client=... setting.\n\n\t/godebug/non-default-behavior/http2server:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=http2server=... setting.\n\n\t/godebug/non-default-behavior/httplaxcontentlength:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=httplaxcontentlength=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/httpmuxgo121:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=httpmuxgo121=... setting.\n\n\t/godebug/non-default-behavior/httpservecontentkeepheaders:events\n\t\tThe number of non-default behaviors executed\n\t\tby the net/http package due to a non-default\n\t\tGODEBUG=httpservecontentkeepheaders=... setting.\n\n\t/godebug/non-default-behavior/installgoroot:events\n\t\tThe number of non-default behaviors executed by the go/build\n\t\tpackage due to a non-default GODEBUG=installgoroot=... setting.\n\n\t/godebug/non-default-behavior/multipartmaxheaders:events\n\t\tThe number of non-default behaviors executed by\n\t\tthe mime/multipart package due to a non-default\n\t\tGODEBUG=multipartmaxheaders=... setting.\n\n\t/godebug/non-default-behavior/multipartmaxparts:events\n\t\tThe number of non-default behaviors executed by\n\t\tthe mime/multipart package due to a non-default\n\t\tGODEBUG=multipartmaxparts=... setting.\n\n\t/godebug/non-default-behavior/multipathtcp:events\n\t\tThe number of non-default behaviors executed by the net package\n\t\tdue to a non-default GODEBUG=multipathtcp=... setting.\n\n\t/godebug/non-default-behavior/netedns0:events\n\t\tThe number of non-default behaviors executed by the net package\n\t\tdue to a non-default GODEBUG=netedns0=... setting.\n\n\t/godebug/non-default-behavior/panicnil:events\n\t\tThe number of non-default behaviors executed by the runtime\n\t\tpackage due to a non-default GODEBUG=panicnil=... setting.\n\n\t/godebug/non-default-behavior/randautoseed:events\n\t\tThe number of non-default behaviors executed by the math/rand\n\t\tpackage due to a non-default GODEBUG=randautoseed=... setting.\n\n\t/godebug/non-default-behavior/tarinsecurepath:events\n\t\tThe number of non-default behaviors executed by the archive/tar\n\t\tpackage due to a non-default GODEBUG=tarinsecurepath=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/tls10server:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tls10server=... setting.\n\n\t/godebug/non-default-behavior/tls3des:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tls3des=... setting.\n\n\t/godebug/non-default-behavior/tlsmaxrsasize:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tlsmaxrsasize=... setting.\n\n\t/godebug/non-default-behavior/tlsrsakex:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tlsrsakex=... setting.\n\n\t/godebug/non-default-behavior/tlsunsafeekm:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tlsunsafeekm=... setting.\n\n\t/godebug/non-default-behavior/winreadlinkvolume:events\n\t\tThe number of non-default behaviors executed by the os package\n\t\tdue to a non-default GODEBUG=winreadlinkvolume=... setting.\n\n\t/godebug/non-default-behavior/winsymlink:events\n\t\tThe number of non-default behaviors executed by the os package\n\t\tdue to a non-default GODEBUG=winsymlink=... setting.\n\n\t/godebug/non-default-behavior/x509keypairleaf:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=x509keypairleaf=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/x509negativeserial:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509negativeserial=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/x509sha1:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509sha1=... setting.\n\n\t/godebug/non-default-behavior/x509usefallbackroots:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509usefallbackroots=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/x509usepolicies:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509usepolicies=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/zipinsecurepath:events\n\t\tThe number of non-default behaviors executed by the archive/zip\n\t\tpackage due to a non-default GODEBUG=zipinsecurepath=...\n\t\tsetting.\n\n\t/memory/classes/heap/free:bytes\n\t\tMemory that is completely free and eligible to be returned to\n\t\tthe underlying system, but has not been. This metric is the\n\t\truntime's estimate of free address space that is backed by\n\t\tphysical memory.\n\n\t/memory/classes/heap/objects:bytes\n\t\tMemory occupied by live objects and dead objects that have not\n\t\tyet been marked free by the garbage collector.\n\n\t/memory/classes/heap/released:bytes\n\t\tMemory that is completely free and has been returned to the\n\t\tunderlying system. This metric is the runtime's estimate of free\n\t\taddress space that is still mapped into the process, but is not\n\t\tbacked by physical memory.\n\n\t/memory/classes/heap/stacks:bytes\n\t\tMemory allocated from the heap that is reserved for stack space,\n\t\twhether or not it is currently in-use. Currently, this\n\t\trepresents all stack memory for goroutines. It also includes all\n\t\tOS thread stacks in non-cgo programs. Note that stacks may be\n\t\tallocated differently in the future, and this may change.\n\n\t/memory/classes/heap/unused:bytes\n\t\tMemory that is reserved for heap objects but is not currently\n\t\tused to hold heap objects.\n\n\t/memory/classes/metadata/mcache/free:bytes\n\t\tMemory that is reserved for runtime mcache structures, but not\n\t\tin-use.\n\n\t/memory/classes/metadata/mcache/inuse:bytes\n\t\tMemory that is occupied by runtime mcache structures that are\n\t\tcurrently being used.\n\n\t/memory/classes/metadata/mspan/free:bytes\n\t\tMemory that is reserved for runtime mspan structures, but not\n\t\tin-use.\n\n\t/memory/classes/metadata/mspan/inuse:bytes\n\t\tMemory that is occupied by runtime mspan structures that are\n\t\tcurrently being used.\n\n\t/memory/classes/metadata/other:bytes\n\t\tMemory that is reserved for or used to hold runtime metadata.\n\n\t/memory/classes/os-stacks:bytes\n\t\tStack memory allocated by the underlying operating system.\n\t\tIn non-cgo programs this metric is currently zero. This may\n\t\tchange in the future.In cgo programs this metric includes\n\t\tOS thread stacks allocated directly from the OS. Currently,\n\t\tthis only accounts for one stack in c-shared and c-archive build\n\t\tmodes, and other sources of stacks from the OS are not measured.\n\t\tThis too may change in the future.\n\n\t/memory/classes/other:bytes\n\t\tMemory used by execution trace buffers, structures for debugging\n\t\tthe runtime, finalizer and profiler specials, and more.\n\n\t/memory/classes/profiling/buckets:bytes\n\t\tMemory that is used by the stack trace hash map used for\n\t\tprofiling.\n\n\t/memory/classes/total:bytes\n\t\tAll memory mapped by the Go runtime into the current process\n\t\tas read-write. Note that this does not include memory mapped\n\t\tby code called via cgo or via the syscall package. Sum of all\n\t\tmetrics in /memory/classes.\n\n\t/sched/gomaxprocs:threads\n\t\tThe current runtime.GOMAXPROCS setting, or the number of\n\t\toperating system threads that can execute user-level Go code\n\t\tsimultaneously.\n\n\t/sched/goroutines:goroutines\n\t\tCount of live goroutines.\n\n\t/sched/latencies:seconds\n\t\tDistribution of the time goroutines have spent in the scheduler\n\t\tin a runnable state before actually running. Bucket counts\n\t\tincrease monotonically.\n\n\t/sched/pauses/stopping/gc:seconds\n\t\tDistribution of individual GC-related stop-the-world stopping\n\t\tlatencies. This is the time it takes from deciding to stop the\n\t\tworld until all Ps are stopped. This is a subset of the total\n\t\tGC-related stop-the-world time (/sched/pauses/total/gc:seconds).\n\t\tDuring this time, some threads may be executing. Bucket counts\n\t\tincrease monotonically.\n\n\t/sched/pauses/stopping/other:seconds\n\t\tDistribution of individual non-GC-related stop-the-world\n\t\tstopping latencies. This is the time it takes from deciding\n\t\tto stop the world until all Ps are stopped. This is a\n\t\tsubset of the total non-GC-related stop-the-world time\n\t\t(/sched/pauses/total/other:seconds). During this time, some\n\t\tthreads may be executing. Bucket counts increase monotonically.\n\n\t/sched/pauses/total/gc:seconds\n\t\tDistribution of individual GC-related stop-the-world pause\n\t\tlatencies. This is the time from deciding to stop the world\n\t\tuntil the world is started again. Some of this time is spent\n\t\tgetting all threads to stop (this is measured directly in\n\t\t/sched/pauses/stopping/gc:seconds), during which some threads\n\t\tmay still be running. Bucket counts increase monotonically.\n\n\t/sched/pauses/total/other:seconds\n\t\tDistribution of individual non-GC-related stop-the-world\n\t\tpause latencies. This is the time from deciding to stop the\n\t\tworld until the world is started again. Some of this time\n\t\tis spent getting all threads to stop (measured directly in\n\t\t/sched/pauses/stopping/other:seconds). Bucket counts increase\n\t\tmonotonically.\n\n\t/sync/mutex/wait/total:seconds\n\t\tApproximate cumulative time goroutines have spent blocked on a\n\t\tsync.Mutex, sync.RWMutex, or runtime-internal lock. This metric\n\t\tis useful for identifying global changes in lock contention.\n\t\tCollect a mutex or block profile using the runtime/pprof package\n\t\tfor more detailed contention data.\n\n[`runtime/metrics` on pkg.go.dev](https://pkg.go.dev/runtime/metrics)","Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.\n\n### Profiling a Go program {#hdr-Profiling_a_Go_program}\n\nThe first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:\n\n\tgo test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n\nTo add equivalent profiling support to a standalone program, add code like the following to your main function:\n\n\tvar cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\n\tvar memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\n\tfunc main() {\n\t    flag.Parse()\n\t    if *cpuprofile != \"\" {\n\t        f, err := os.Create(*cpuprofile)\n\t        if err != nil {\n\t            log.Fatal(\"could not create CPU profile: \", err)\n\t        }\n\t        defer f.Close() // error handling omitted for example\n\t        if err := pprof.StartCPUProfile(f); err != nil {\n\t            log.Fatal(\"could not start CPU profile: \", err)\n\t        }\n\t        defer pprof.StopCPUProfile()\n\t    }\n\n\t    // ... rest of the program ...\n\n\t    if *memprofile != \"\" {\n\t        f, err := os.Create(*memprofile)\n\t        if err != nil {\n\t            log.Fatal(\"could not create memory profile: \", err)\n\t        }\n\t        defer f.Close() // error handling omitted for example\n\t        runtime.GC() // get up-to-date statistics\n\t        if err := pprof.WriteHeapProfile(f); err != nil {\n\t            log.Fatal(\"could not write memory profile: \", err)\n\t        }\n\t    }\n\t}\n\nThere is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:\n\n\timport _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details.\n\nProfiles can then be visualized with the pprof tool:\n\n\tgo tool pprof cpu.prof\n\nThere are many commands available from the pprof command line. Commonly used commands include \"top\", which prints a summary of the top program hot-spots, and \"web\", which opens an interactive graph of hot-spots and their call graphs. Use \"help\" for information on all pprof commands.\n\nFor more information about pprof, see [https://github.com/google/pprof/blob/main/doc/README.md](https://github.com/google/pprof/blob/main/doc/README.md).\n\n[`runtime/pprof` on pkg.go.dev](https://pkg.go.dev/runtime/pprof)","Package trace contains facilities for programs to generate traces for the Go execution tracer.\n\n### Tracing runtime activities {#hdr-Tracing_runtime_activities}\n\nThe execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. When CPU profiling is active, the execution tracer makes an effort to include those samples as well. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using \\`go tool trace\\`.\n\nSupport for tracing tests and benchmarks built with the standard testing package is built into \\`go test\\`. For example, the following command runs the test in the current directory and writes the trace file (trace.out).\n\n\tgo test -trace=trace.out\n\nThis runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.\n\nThere is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:\n\n\timport _ \"net/http/pprof\"\n\nSee the [net/http/pprof](https://pkg.go.dev/net/http/pprof/) package for more details about all of the debug endpoints installed by this import.\n\n### User annotation {#hdr-User_annotation}\n\nPackage trace provides user annotation APIs that can be used to log interesting events during execution.\n\nThere are three types of user annotations: log messages, regions, and tasks.\n\n\\[Log] emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called \\[Log]. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in \\[Log].\n\nA region is for logging a time interval during a goroutine's execution. By definition, a region starts and ends in the same goroutine. Regions can be nested to represent subintervals. For example, the following code records four regions in the execution trace to trace the durations of sequential steps in a cappuccino making operation.\n\n\ttrace.WithRegion(ctx, \"makeCappuccino\", func() {\n\n\t   // orderID allows to identify a specific order\n\t   // among many cappuccino order region records.\n\t   trace.Log(ctx, \"orderID\", orderID)\n\n\t   trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n\t   trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n\t   trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n\t})\n\nA task is a higher-level component that aids tracing of logical operations such as an RPC request, an HTTP request, or an interesting local operation which may require multiple goroutines working together. Since tasks can involve multiple goroutines, they are tracked via a [context.Context](https://pkg.go.dev/context/#Context) object. \\[NewTask] creates a new task and embeds it in the returned [context.Context](https://pkg.go.dev/context/#Context) object. Log messages and regions are attached to the task, if any, in the Context passed to \\[Log] and \\[WithRegion].\n\nFor example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.\n\n\tctx, task := trace.NewTask(ctx, \"makeCappuccino\")\n\ttrace.Log(ctx, \"orderID\", orderID)\n\n\tmilk := make(chan bool)\n\tespresso := make(chan bool)\n\n\tgo func() {\n\t        trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n\t        milk \u003c- true\n\t}()\n\tgo func() {\n\t        trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n\t        espresso \u003c- true\n\t}()\n\tgo func() {\n\t        defer task.End() // When assemble is done, the order is complete.\n\t        \u003c-espresso\n\t        \u003c-milk\n\t        trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n\t}()\n\nThe trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.\n\n[`runtime/trace` on pkg.go.dev](https://pkg.go.dev/runtime/trace)","Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.\n\nThese functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the [sync](https://pkg.go.dev/sync/) package. Share memory by communicating; don't communicate by sharing memory.\n\nThe swap operation, implemented by the SwapT functions, is the atomic equivalent of:\n\n\told = *addr\n\t*addr = new\n\treturn old\n\nThe compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of:\n\n\tif *addr == old {\n\t\t*addr = new\n\t\treturn true\n\t}\n\treturn false\n\nThe add operation, implemented by the AddT functions, is the atomic equivalent of:\n\n\t*addr += delta\n\treturn *addr\n\nThe load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of \"return \\*addr\" and \"\\*addr = val\".\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), if the effect of an atomic operation A is observed by atomic operation B, then A “synchronizes before” B. Additionally, all the atomic operations executed in a program behave as though executed in some sequentially consistent order. This definition provides the same semantics as C++'s sequentially consistent atomics and Java's volatile variables.\n\n[`sync/atomic` on pkg.go.dev](https://pkg.go.dev/sync/atomic)","Package js gives access to the WebAssembly host environment when using the js/wasm architecture. Its API is based on JavaScript semantics.\n\nThis package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.\n\n[`syscall/js` on pkg.go.dev](https://pkg.go.dev/syscall/js)","Package fstest implements support for testing implementations and users of file systems.\n\n[`testing/fstest` on pkg.go.dev](https://pkg.go.dev/testing/fstest)","Package iotest implements Readers and Writers useful mainly for testing.\n\n[`testing/iotest` on pkg.go.dev](https://pkg.go.dev/testing/iotest)","Package quick implements utility functions to help with black box testing.\n\nThe testing/quick package is frozen and is not accepting new features.\n\n[`testing/quick` on pkg.go.dev](https://pkg.go.dev/testing/quick)","Package slogtest implements support for testing implementations of log/slog.Handler.\n\n[`testing/slogtest` on pkg.go.dev](https://pkg.go.dev/testing/slogtest)","Package scanner provides a scanner and tokenizer for UTF-8-encoded text. It takes an io.Reader providing the source, which then can be tokenized through repeated calls to the Scan function. For compatibility with existing tools, the NUL character is not allowed. If the first character in the source is a UTF-8 encoded byte order mark (BOM), it is discarded.\n\nBy default, a \\[Scanner] skips white space and Go comments and recognizes all literals as defined by the Go language specification. It may be customized to recognize only a subset of those literals and to recognize different identifier and white space characters.\n\n[`text/scanner` on pkg.go.dev](https://pkg.go.dev/text/scanner)","Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text.\n\nThe package is using the Elastic Tabstops algorithm described at [http://nickgravgaard.com/elastictabstops/index.html](http://nickgravgaard.com/elastictabstops/index.html).\n\nThe text/tabwriter package is frozen and is not accepting new features.\n\n[`text/tabwriter` on pkg.go.dev](https://pkg.go.dev/text/tabwriter)","Package template implements data-driven templates for generating textual output.\n\nTo generate HTML output, see [html/template](https://pkg.go.dev/html/template/), which has the same interface as this package but automatically secures HTML output against certain attacks.\n\nTemplates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called \"dot\", to the value at the current location in the structure as execution proceeds.\n\nThe input text for a template is UTF-8-encoded text in any format. \"Actions\"--data evaluations or control structures--are delimited by \"{{\" and \"}}\"; all text outside actions is copied to the output unchanged.\n\nOnce parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.\n\nHere is a trivial example that prints \"17 items are made of wool\".\n\n\ttype Inventory struct {\n\t\tMaterial string\n\t\tCount    uint\n\t}\n\tsweaters := Inventory{\"wool\", 17}\n\ttmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\n\tif err != nil { panic(err) }\n\terr = tmpl.Execute(os.Stdout, sweaters)\n\tif err != nil { panic(err) }\n\nMore intricate examples appear below.\n\n### Text and spaces {#hdr-Text_and_spaces}\n\nBy default, all text between actions is copied verbatim when the template is executed. For example, the string \" items are made of \" in the example above appears on standard output when the program is run.\n\nHowever, to aid in formatting template source code, if an action's left delimiter (by default \"{{\") is followed immediately by a minus sign and white space, all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (\"}}\") is preceded by white space and a minus sign, all leading white space is trimmed from the immediately following text. In these trim markers, the white space must be present: \"{{- 3}}\" is like \"{{3}}\" but trims the immediately preceding text, while \"{{-3}}\" parses as an action containing the number -3.\n\nFor instance, when executing the template whose source is\n\n\t\"{{23 -}} \u003c {{- 45}}\"\n\nthe generated output would be\n\n\t\"23\u003c45\"\n\nFor this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.\n\n### Actions {#hdr-Actions}\n\nHere is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of data, defined in detail in the corresponding sections that follow.\n\n\t{{/* a comment */}}\n\t{{- /* a comment with white space trimmed from preceding and following text */ -}}\n\t\tA comment; discarded. May contain newlines.\n\t\tComments do not nest and must start and end at the\n\t\tdelimiters, as shown here.\n\n\t{{pipeline}}\n\t\tThe default textual representation (the same as would be\n\t\tprinted by fmt.Print) of the value of the pipeline is copied\n\t\tto the output.\n\n\t{{if pipeline}} T1 {{end}}\n\t\tIf the value of the pipeline is empty, no output is generated;\n\t\totherwise, T1 is executed. The empty values are false, 0, any\n\t\tnil pointer or interface value, and any array, slice, map, or\n\t\tstring of length zero.\n\t\tDot is unaffected.\n\n\t{{if pipeline}} T1 {{else}} T0 {{end}}\n\t\tIf the value of the pipeline is empty, T0 is executed;\n\t\totherwise, T1 is executed. Dot is unaffected.\n\n\t{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\t\tTo simplify the appearance of if-else chains, the else action\n\t\tof an if may include another if directly; the effect is exactly\n\t\tthe same as writing\n\t\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n\t{{range pipeline}} T1 {{end}}\n\t\tThe value of the pipeline must be an array, slice, map, or channel.\n\t\tIf the value of the pipeline has length zero, nothing is output;\n\t\totherwise, dot is set to the successive elements of the array,\n\t\tslice, or map and T1 is executed. If the value is a map and the\n\t\tkeys are of basic type with a defined order, the elements will be\n\t\tvisited in sorted key order.\n\n\t{{range pipeline}} T1 {{else}} T0 {{end}}\n\t\tThe value of the pipeline must be an array, slice, map, or channel.\n\t\tIf the value of the pipeline has length zero, dot is unaffected and\n\t\tT0 is executed; otherwise, dot is set to the successive elements\n\t\tof the array, slice, or map and T1 is executed.\n\n\t{{break}}\n\t\tThe innermost {{range pipeline}} loop is ended early, stopping the\n\t\tcurrent iteration and bypassing all remaining iterations.\n\n\t{{continue}}\n\t\tThe current iteration of the innermost {{range pipeline}} loop is\n\t\tstopped, and the loop starts the next iteration.\n\n\t{{template \"name\"}}\n\t\tThe template with the specified name is executed with nil data.\n\n\t{{template \"name\" pipeline}}\n\t\tThe template with the specified name is executed with dot set\n\t\tto the value of the pipeline.\n\n\t{{block \"name\" pipeline}} T1 {{end}}\n\t\tA block is shorthand for defining a template\n\t\t\t{{define \"name\"}} T1 {{end}}\n\t\tand then executing it in place\n\t\t\t{{template \"name\" pipeline}}\n\t\tThe typical use is to define a set of root templates that are\n\t\tthen customized by redefining the block templates within.\n\n\t{{with pipeline}} T1 {{end}}\n\t\tIf the value of the pipeline is empty, no output is generated;\n\t\totherwise, dot is set to the value of the pipeline and T1 is\n\t\texecuted.\n\n\t{{with pipeline}} T1 {{else}} T0 {{end}}\n\t\tIf the value of the pipeline is empty, dot is unaffected and T0\n\t\tis executed; otherwise, dot is set to the value of the pipeline\n\t\tand T1 is executed.\n\n\t{{with pipeline}} T1 {{else with pipeline}} T0 {{end}}\n\t\tTo simplify the appearance of with-else chains, the else action\n\t\tof a with may include another with directly; the effect is exactly\n\t\tthe same as writing\n\t\t\t{{with pipeline}} T1 {{else}}{{with pipeline}} T0 {{end}}{{end}}\n\n### Arguments {#hdr-Arguments}\n\nAn argument is a simple value, denoted by one of the following.\n\n  - A boolean, string, character, integer, floating-point, imaginary or complex constant in Go syntax. These behave like Go's untyped constants. Note that, as in Go, whether a large integer constant overflows when assigned or passed to a function can depend on whether the host machine's ints are 32 or 64 bits.\n  - The keyword nil, representing an untyped Go nil.\n  - The character '.' (period): . The result is the value of dot.\n  - A variable name, which is a (possibly empty) alphanumeric string preceded by a dollar sign, such as $piOver2 or $ The result is the value of the variable. Variables are described below.\n  - The name of a field of the data, which must be a struct, preceded by a period, such as .Field The result is the value of the field. Field invocations may be chained: .Field1.Field2 Fields can also be evaluated on variables, including chaining: $x.Field1.Field2\n  - The name of a key of the data, which must be a map, preceded by a period, such as .Key The result is the map element value indexed by the key. Key invocations may be chained and combined with fields to any depth: .Field1.Key1.Field2.Key2 Although the key must be an alphanumeric identifier, unlike with field names they do not need to start with an upper case letter. Keys can also be evaluated on variables, including chaining: $x.key1.key2\n  - The name of a niladic method of the data, preceded by a period, such as .Method The result is the value of invoking the method with dot as the receiver, dot.Method(). Such a method must have one return value (of any type) or two return values, the second of which is an error. If it has two and the returned error is non-nil, execution terminates and an error is returned to the caller as the value of Execute. Method invocations may be chained and combined with fields and keys to any depth: .Field1.Key1.Method1.Field2.Key2.Method2 Methods can also be evaluated on variables, including chaining: $x.Method1.Field\n  - The name of a niladic function, such as fun The result is the value of invoking the function, fun(). The return types and values behave as in methods. Functions and function names are described below.\n  - A parenthesized instance of one the above, for grouping. The result may be accessed by a field or map key invocation. print (.F1 arg1) (.F2 arg2) (.StructValuedMethod \"arg\").Field\n\nArguments may evaluate to any type; if they are pointers the implementation automatically indirects to the base type when required. If an evaluation yields a function value, such as a function-valued field of a struct, the function is not invoked automatically, but it can be used as a truth value for an if action and the like. To invoke it, use the call function, defined below.\n\n### Pipelines {#hdr-Pipelines}\n\nA pipeline is a possibly chained sequence of \"commands\". A command is a simple value (argument) or a function or method call, possibly with multiple arguments:\n\n\tArgument\n\t\tThe result is the value of evaluating the argument.\n\t.Method [Argument...]\n\t\tThe method can be alone or the last element of a chain but,\n\t\tunlike methods in the middle of a chain, it can take arguments.\n\t\tThe result is the value of calling the method with the\n\t\targuments:\n\t\t\tdot.Method(Argument1, etc.)\n\tfunctionName [Argument...]\n\t\tThe result is the value of calling the function associated\n\t\twith the name:\n\t\t\tfunction(Argument1, etc.)\n\t\tFunctions and function names are described below.\n\nA pipeline may be \"chained\" by separating a sequence of commands with pipeline characters '|'. In a chained pipeline, the result of each command is passed as the last argument of the following command. The output of the final command in the pipeline is the value of the pipeline.\n\nThe output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.\n\n### Variables {#hdr-Variables}\n\nA pipeline inside an action may initialize a variable to capture the result. The initialization has syntax\n\n\t$variable := pipeline\n\nwhere $variable is the name of the variable. An action that declares a variable produces no output.\n\nVariables previously declared can also be assigned, using the syntax\n\n\t$variable = pipeline\n\nIf a \"range\" action initializes a variable, the variable is set to the successive elements of the iteration. Also, a \"range\" may declare two variables, separated by a comma:\n\n\trange $index, $element := pipeline\n\nin which case $index and $element are set to the successive values of the array/slice index or map key and element, respectively. Note that if there is only one variable, it is assigned the element; this is opposite to the convention in Go range clauses.\n\nA variable's scope extends to the \"end\" action of the control structure (\"if\", \"with\", or \"range\") in which it is declared, or to the end of the template if there is no such control structure. A template invocation does not inherit variables from the point of its invocation.\n\nWhen execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.\n\n### Examples {#hdr-Examples}\n\nHere are some example one-line templates demonstrating pipelines and variables. All produce the quoted word \"output\":\n\n\t{{\"\\\"output\\\"\"}}\n\t\tA string constant.\n\t{{`\"output\"`}}\n\t\tA raw string constant.\n\t{{printf \"%q\" \"output\"}}\n\t\tA function call.\n\t{{\"output\" | printf \"%q\"}}\n\t\tA function call whose final argument comes from the previous\n\t\tcommand.\n\t{{printf \"%q\" (print \"out\" \"put\")}}\n\t\tA parenthesized argument.\n\t{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n\t\tA more elaborate call.\n\t{{\"output\" | printf \"%s\" | printf \"%q\"}}\n\t\tA longer chain.\n\t{{with \"output\"}}{{printf \"%q\" .}}{{end}}\n\t\tA with action using dot.\n\t{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n\t\tA with action that creates and uses a variable.\n\t{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n\t\tA with action that uses the variable in another action.\n\t{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n\t\tThe same, but pipelined.\n\n### Functions {#hdr-Functions}\n\nDuring execution functions are found in two function maps: first in the template, then in the global function map. By default, no functions are defined in the template but the Funcs method can be used to add them.\n\nPredefined global functions are named as follows.\n\n\tand\n\t\tReturns the boolean AND of its arguments by returning the\n\t\tfirst empty argument or the last argument. That is,\n\t\t\"and x y\" behaves as \"if x then y else x.\"\n\t\tEvaluation proceeds through the arguments left to right\n\t\tand returns when the result is determined.\n\tcall\n\t\tReturns the result of calling the first argument, which\n\t\tmust be a function, with the remaining arguments as parameters.\n\t\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n\t\tY is a func-valued field, map entry, or the like.\n\t\tThe first argument must be the result of an evaluation\n\t\tthat yields a value of function type (as distinct from\n\t\ta predefined function such as print). The function must\n\t\treturn either one or two result values, the second of which\n\t\tis of type error. If the arguments don't match the function\n\t\tor the returned error value is non-nil, execution stops.\n\thtml\n\t\tReturns the escaped HTML equivalent of the textual\n\t\trepresentation of its arguments. This function is unavailable\n\t\tin html/template, with a few exceptions.\n\tindex\n\t\tReturns the result of indexing its first argument by the\n\t\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n\t\tx[1][2][3]. Each indexed item must be a map, slice, or array.\n\tslice\n\t\tslice returns the result of slicing its first argument by the\n\t\tremaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2],\n\t\twhile \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\"\n\t\tis x[1:2:3]. The first argument must be a string, slice, or array.\n\tjs\n\t\tReturns the escaped JavaScript equivalent of the textual\n\t\trepresentation of its arguments.\n\tlen\n\t\tReturns the integer length of its argument.\n\tnot\n\t\tReturns the boolean negation of its single argument.\n\tor\n\t\tReturns the boolean OR of its arguments by returning the\n\t\tfirst non-empty argument or the last argument, that is,\n\t\t\"or x y\" behaves as \"if x then x else y\".\n\t\tEvaluation proceeds through the arguments left to right\n\t\tand returns when the result is determined.\n\tprint\n\t\tAn alias for fmt.Sprint\n\tprintf\n\t\tAn alias for fmt.Sprintf\n\tprintln\n\t\tAn alias for fmt.Sprintln\n\turlquery\n\t\tReturns the escaped value of the textual representation of\n\t\tits arguments in a form suitable for embedding in a URL query.\n\t\tThis function is unavailable in html/template, with a few\n\t\texceptions.\n\nThe boolean functions take any zero value to be false and a non-zero value to be true.\n\nThere is also a set of binary comparison operators defined as functions:\n\n\teq\n\t\tReturns the boolean truth of arg1 == arg2\n\tne\n\t\tReturns the boolean truth of arg1 != arg2\n\tlt\n\t\tReturns the boolean truth of arg1 \u003c arg2\n\tle\n\t\tReturns the boolean truth of arg1 \u003c= arg2\n\tgt\n\t\tReturns the boolean truth of arg1 \u003e arg2\n\tge\n\t\tReturns the boolean truth of arg1 \u003e= arg2\n\nFor simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect\n\n\targ1==arg2 || arg1==arg3 || arg1==arg4 ...\n\n(Unlike with || in Go, however, eq is a function call and all the arguments will be evaluated.)\n\nThe comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.\n\n### Associated templates {#hdr-Associated_templates}\n\nEach template is named by a string specified when it is created. Also, each template is associated with zero or more other templates that it may invoke by name; such associations are transitive and form a name space of templates.\n\nA template may use a template invocation to instantiate another associated template; see the explanation of the \"template\" action above. The name must be that of a template associated with the template that contains the invocation.\n\n### Nested template definitions {#hdr-Nested_template_definitions}\n\nWhen parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.\n\nThe syntax of such definitions is to surround each template declaration with a \"define\" and \"end\" action.\n\nThe define action names the template being created by providing a string constant. Here is a simple example:\n\n\t{{define \"T1\"}}ONE{{end}}\n\t{{define \"T2\"}}TWO{{end}}\n\t{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n\t{{template \"T3\"}}\n\nThis defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text\n\n\tONE TWO\n\nBy construction, a template may reside in only one association. If it's necessary to have a template addressable from multiple associations, the template definition must be parsed multiple times to create distinct \\*Template values, or must be copied with \\[Template.Clone] or \\[Template.AddParseTree].\n\nParse may be called multiple times to assemble the various associated templates; see \\[ParseFiles], \\[ParseGlob], \\[Template.ParseFiles] and \\[Template.ParseGlob] for simple ways to parse related templates stored in files.\n\nA template may be executed directly or through \\[Template.ExecuteTemplate], which executes an associated template identified by name. To invoke our example above, we might write,\n\n\terr := tmpl.Execute(os.Stdout, \"no data needed\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution failed: %s\", err)\n\t}\n\nor to invoke a particular template explicitly by name,\n\n\terr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution failed: %s\", err)\n\t}\n\n[`text/template` on pkg.go.dev](https://pkg.go.dev/text/template)","Package utf16 implements encoding and decoding of UTF-16 sequences.\n\n[`unicode/utf16` on pkg.go.dev](https://pkg.go.dev/unicode/utf16)","Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences. See [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)\n\n[`unicode/utf8` on pkg.go.dev](https://pkg.go.dev/unicode/utf8)","Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.\n\n[`crypto/x509/pkix` on pkg.go.dev](https://pkg.go.dev/crypto/x509/pkix)","Package driver defines interfaces to be implemented by database drivers as used by package sql.\n\nMost code should use the [database/sql](https://pkg.go.dev/database/sql/) package.\n\nThe driver interface has evolved over time. Drivers should implement \\[Connector] and \\[DriverContext] interfaces. The Connector.Connect and Driver.Open methods should never return \\[ErrBadConn]. \\[ErrBadConn] should only be returned from \\[Validator], \\[SessionResetter], or a query method if the connection is already in an invalid (e.g. closed) state.\n\nAll \\[Conn] implementations should implement the following interfaces: \\[Pinger], \\[SessionResetter], and \\[Validator].\n\nIf named parameters or context are supported, the driver's \\[Conn] should implement: \\[ExecerContext], \\[QueryerContext], \\[ConnPrepareContext], and \\[ConnBeginTx].\n\nTo support custom data types, implement \\[NamedValueChecker]. \\[NamedValueChecker] also allows queries to accept per-query options as a parameter by returning \\[ErrRemoveArgument] from CheckNamedValue.\n\nIf multiple result sets are supported, \\[Rows] should implement \\[RowsNextResultSet]. If the driver knows how to describe the types present in the returned result it should implement the following interfaces: \\[RowsColumnTypeScanType], \\[RowsColumnTypeDatabaseTypeName], \\[RowsColumnTypeLength], \\[RowsColumnTypeNullable], and \\[RowsColumnTypePrecisionScale]. A given row value may also return a \\[Rows] type, which may represent a database cursor value.\n\nIf a \\[Conn] implements \\[Validator], then the IsValid method is called before returning the connection to the connection pool. If an entry in the connection pool implements \\[SessionResetter], then ResetSession is called before reusing the connection for another query. If a connection is never returned to the connection pool but is immediately reused, then ResetSession is called prior to reuse but IsValid is not called.\n\n[`database/sql/driver` on pkg.go.dev](https://pkg.go.dev/database/sql/driver)","Package constraint implements parsing and evaluation of build constraint lines. See [https://golang.org/cmd/go/#hdr-Build\\_constraints](https://golang.org/cmd/go/#hdr-Build_constraints) for documentation about build constraints themselves.\n\nThis package parses both the original “// +build” syntax and the “//go:build” syntax that was added in Go 1.17. See [https://golang.org/design/draft-gobuild](https://golang.org/design/draft-gobuild) for details about the “//go:build” syntax.\n\n[`go/build/constraint` on pkg.go.dev](https://pkg.go.dev/go/build/constraint)","Package comment implements parsing and reformatting of Go doc comments, (documentation comments), which are comments that immediately precede a top-level declaration of a package, const, func, type, or var.\n\nGo doc comment syntax is a simplified subset of Markdown that supports links, headings, paragraphs, lists (without nesting), and preformatted text blocks. The details of the syntax are documented at [https://go.dev/doc/comment](https://go.dev/doc/comment).\n\nTo parse the text associated with a doc comment (after removing comment markers), use a \\[Parser]:\n\n\tvar p comment.Parser\n\tdoc := p.Parse(text)\n\nThe result is a \\[\\*Doc]. To reformat it as a doc comment, HTML, Markdown, or plain text, use a \\[Printer]:\n\n\tvar pr comment.Printer\n\tos.Stdout.Write(pr.Text(doc))\n\nThe \\[Parser] and \\[Printer] types are structs whose fields can be modified to customize the operations. For details, see the documentation for those types.\n\nUse cases that need additional control over reformatting can implement their own logic by inspecting the parsed syntax itself. See the documentation for \\[Doc], \\[Block], \\[Text] for an overview and links to additional types.\n\n[`go/doc/comment` on pkg.go.dev](https://pkg.go.dev/go/doc/comment)","Package palette provides standard color palettes.\n\n[`image/color/palette` on pkg.go.dev](https://pkg.go.dev/image/color/palette)","Package rand implements pseudo-random number generators suitable for tasks such as simulation, but it should not be used for security-sensitive work.\n\nRandom numbers are generated by a \\[Source], usually wrapped in a \\[Rand]. Both types should be used by a single goroutine at a time: sharing among multiple goroutines requires some kind of synchronization.\n\nTop-level functions, such as \\[Float64] and \\[Int], are safe for concurrent use by multiple goroutines.\n\nThis package's outputs might be easily predictable regardless of how it's seeded. For random numbers suitable for security-sensitive work, see the [crypto/rand](https://pkg.go.dev/crypto/rand/) package.\n\n[`math/rand/v2` on pkg.go.dev](https://pkg.go.dev/math/rand/v2)","Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.\n\nNote that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems.\n\n[`net/http/cgi` on pkg.go.dev](https://pkg.go.dev/net/http/cgi)","Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.\n\n[`net/http/cookiejar` on pkg.go.dev](https://pkg.go.dev/net/http/cookiejar)","Package fcgi implements the FastCGI protocol.\n\nSee [https://fast-cgi.github.io/](https://fast-cgi.github.io/) for an unofficial mirror of the original documentation.\n\nCurrently only the responder role is supported.\n\n[`net/http/fcgi` on pkg.go.dev](https://pkg.go.dev/net/http/fcgi)","Package httptest provides utilities for HTTP testing.\n\n[`net/http/httptest` on pkg.go.dev](https://pkg.go.dev/net/http/httptest)","Package httptrace provides mechanisms to trace the events within HTTP client requests.\n\n[`net/http/httptrace` on pkg.go.dev](https://pkg.go.dev/net/http/httptrace)","Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.\n\n[`net/http/httputil` on pkg.go.dev](https://pkg.go.dev/net/http/httputil)","Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.\n\nThe package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/. As of Go 1.22, all the paths must be requested with GET.\n\nTo use pprof, link this package into your program:\n\n\timport _ \"net/http/pprof\"\n\nIf your application is not already running an http server, you need to start one. Add \"net/http\" and \"log\" to your imports and the following code to your main function:\n\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n\t}()\n\nBy default, all the profiles listed in [runtime/pprof.Profile](https://pkg.go.dev/runtime/pprof/#Profile) are available (via \\[Handler]), in addition to the \\[Cmdline], \\[Profile], \\[Symbol], and \\[Trace] profiles defined in this package. If you are not using DefaultServeMux, you will have to register handlers with the mux you are using.\n\n### Parameters {#hdr-Parameters}\n\nParameters can be passed via GET query params:\n\n  - debug=N (all profiles): response format: N = 0: binary (default), N \u003e 0: plaintext\n  - gc=N (heap profile): N \u003e 0: run a garbage collection cycle before profiling\n  - seconds=N (allocs, block, goroutine, heap, mutex, threadcreate profiles): return a delta profile\n  - seconds=N (cpu (profile), trace profiles): profile for the given duration\n\n### Usage examples {#hdr-Usage_examples}\n\nUse the pprof tool to look at the heap profile:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/heap\n\nOr to look at a 30-second CPU profile:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n\nOr to look at the goroutine blocking profile, after calling [runtime.SetBlockProfileRate](https://pkg.go.dev/runtime/#SetBlockProfileRate) in your program:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/block\n\nOr to look at the holders of contended mutexes, after calling [runtime.SetMutexProfileFraction](https://pkg.go.dev/runtime/#SetMutexProfileFraction) in your program:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/mutex\n\nThe package also exports a handler that serves execution trace data for the \"go tool trace\" command. To collect a 5-second execution trace:\n\n\tcurl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5\n\tgo tool trace trace.out\n\nTo view all available profiles, open [http://localhost:6060/debug/pprof/](http://localhost:6060/debug/pprof/) in your browser.\n\nFor a study of the facility in action, visit [https://blog.golang.org/2011/06/profiling-go-programs.html](https://blog.golang.org/2011/06/profiling-go-programs.html).\n\n[`net/http/pprof` on pkg.go.dev](https://pkg.go.dev/net/http/pprof)","Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. For JSON-RPC 2.0 support, see [https://godoc.org/?q=json-rpc+2.0](https://godoc.org/?q=json-rpc+2.0)\n\n[`net/rpc/jsonrpc` on pkg.go.dev](https://pkg.go.dev/net/rpc/jsonrpc)","Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use.\n\n[`text/template/parse` on pkg.go.dev](https://pkg.go.dev/text/template/parse)","Package chacha20 implements the ChaCha20 and XChaCha20 encryption algorithms as specified in RFC 8439 and draft-irtf-cfrg-xchacha-01.\n\n[`golang.org/x/crypto/chacha20` on pkg.go.dev](https://pkg.go.dev/golang.org/x/crypto/chacha20)","Package chacha20poly1305 implements the ChaCha20-Poly1305 AEAD and its extended nonce variant XChaCha20-Poly1305, as specified in RFC 8439 and draft-irtf-cfrg-xchacha-01.\n\n[`golang.org/x/crypto/chacha20poly1305` on pkg.go.dev](https://pkg.go.dev/golang.org/x/crypto/chacha20poly1305)","Package cryptobyte contains types that help with parsing and constructing length-prefixed, binary messages, including ASN.1 DER. (The asn1 subpackage contains useful ASN.1 constants.)\n\nThe String type is for parsing. It wraps a \\[]byte slice and provides helper functions for consuming structures, value by value.\n\nThe Builder type is for constructing messages. It providers helper functions for appending values and also for appending length-prefixed submessages – without having to worry about calculating the length prefix ahead of time.\n\nSee the documentation and examples for the Builder and String types to get started.\n\n[`golang.org/x/crypto/cryptobyte` on pkg.go.dev](https://pkg.go.dev/golang.org/x/crypto/cryptobyte)","Package hkdf implements the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) as defined in RFC 5869.\n\nHKDF is a cryptographic key derivation function (KDF) with the goal of expanding limited input keying material into one or more cryptographically strong secret keys.\n\n[`golang.org/x/crypto/hkdf` on pkg.go.dev](https://pkg.go.dev/golang.org/x/crypto/hkdf)","Package sha3 implements the SHA-3 fixed-output-length hash functions and the SHAKE variable-output-length hash functions defined by FIPS-202.\n\nBoth types of hash function use the \"sponge\" construction and the Keccak permutation. For a detailed specification see [http://keccak.noekeon.org/](http://keccak.noekeon.org/)\n\n### Guidance {#hdr-Guidance}\n\nIf you aren't sure what function you need, use SHAKE256 with at least 64 bytes of output. The SHAKE instances are faster than the SHA3 instances; the latter have to allocate memory to conform to the hash.Hash interface.\n\nIf you need a secret-key MAC (message authentication code), prepend the secret key to the input, hash with SHAKE256 and read at least 32 bytes of output.\n\n### Security strengths {#hdr-Security_strengths}\n\nThe SHA3-x (x equals 224, 256, 384, or 512) functions have a security strength against preimage attacks of x bits. Since they only produce \"x\" bits of output, their collision-resistance is only \"x/2\" bits.\n\nThe SHAKE-256 and -128 functions have a generic security strength of 256 and 128 bits against all attacks, provided that at least 2x bits of their output is used.  Requesting more than 64 or 32 bytes of output, respectively, does not increase the collision-resistance of the SHAKE functions.\n\n### The sponge construction {#hdr-The_sponge_construction}\n\nA sponge builds a pseudo-random function from a public pseudo-random permutation, by applying the permutation to a state of \"rate + capacity\" bytes, but hiding \"capacity\" of the bytes.\n\nA sponge starts out with a zero state. To hash an input using a sponge, up to \"rate\" bytes of the input are XORed into the sponge's state. The sponge is then \"full\" and the permutation is applied to \"empty\" it. This process is repeated until all the input has been \"absorbed\". The input is then padded. The digest is \"squeezed\" from the sponge in the same way, except that output is copied out instead of input being XORed in.\n\nA sponge is parameterized by its generic security strength, which is equal to half its capacity; capacity + rate is equal to the permutation's width. Since the KeccakF-1600 permutation is 1600 bits (200 bytes) wide, this means that the security strength of a sponge instance is equal to (1600 - bitrate) / 2.\n\n### Recommendations {#hdr-Recommendations}\n\nThe SHAKE functions are recommended for most new uses. They can produce output of arbitrary length. SHAKE256, with an output length of at least 64 bytes, provides 256-bit security against all attacks.  The Keccak team recommends it for most applications upgrading from SHA2-512. (NIST chose a much stronger, but much slower, sponge instance for SHA3-512.)\n\nThe SHA-3 functions are \"drop-in\" replacements for the SHA-2 functions. They produce output of the same length, with the same security strengths against all attacks. This means, in particular, that SHA3-256 only has 128-bit collision resistance, because its output length is 32 bytes.\n\n[`golang.org/x/crypto/sha3` on pkg.go.dev](https://pkg.go.dev/golang.org/x/crypto/sha3)","Package idna implements IDNA2008 using the compatibility processing defined by UTS (Unicode Technical Standard) #46, which defines a standard to deal with the transition from IDNA2003.\n\nIDNA2008 (Internationalized Domain Names for Applications), is defined in RFC 5890, RFC 5891, RFC 5892, RFC 5893 and RFC 5894. UTS #46 is defined in [https://www.unicode.org/reports/tr46](https://www.unicode.org/reports/tr46). See [https://unicode.org/cldr/utility/idna.jsp](https://unicode.org/cldr/utility/idna.jsp) for a visualization of the differences between these two standards.\n\n[`golang.org/x/net/idna` on pkg.go.dev](https://pkg.go.dev/golang.org/x/net/idna)","Package nettest provides utilities for network testing.\n\n[`golang.org/x/net/nettest` on pkg.go.dev](https://pkg.go.dev/golang.org/x/net/nettest)","Package cpu implements processor feature detection for various CPU architectures.\n\n[`golang.org/x/sys/cpu` on pkg.go.dev](https://pkg.go.dev/golang.org/x/sys/cpu)","Package transform provides reader and writer wrappers that transform the bytes passing through as well as various transformations. Example transformations provided by other packages include normalization and conversion between character sets.\n\n[`golang.org/x/text/transform` on pkg.go.dev](https://pkg.go.dev/golang.org/x/text/transform)","Package asn1 contains supporting types for parsing and building ASN.1 messages with the cryptobyte package.\n\n[`golang.org/x/crypto/cryptobyte/asn1` on pkg.go.dev](https://pkg.go.dev/golang.org/x/crypto/cryptobyte/asn1)","Package dnsmessage provides a mostly RFC 1035 compliant implementation of DNS message packing and unpacking.\n\nThe package also supports messages with Extension Mechanisms for DNS (EDNS(0)) as defined in RFC 6891.\n\nThis implementation is designed to minimize heap allocations and avoid unnecessary packing and unpacking as much as possible.\n\n[`golang.org/x/net/dns/dnsmessage` on pkg.go.dev](https://pkg.go.dev/golang.org/x/net/dns/dnsmessage)","Package httpguts provides functions implementing various details of the HTTP specification.\n\nThis package is shared by the standard library (which vendors it) and x/net/http2. It comes with no API stability promise.\n\n[`golang.org/x/net/http/httpguts` on pkg.go.dev](https://pkg.go.dev/golang.org/x/net/http/httpguts)","Package httpproxy provides support for HTTP proxy determination based on environment variables, as provided by net/http's ProxyFromEnvironment function.\n\nThe API is not subject to the Go 1 compatibility promise and may change at any time.\n\n[`golang.org/x/net/http/httpproxy` on pkg.go.dev](https://pkg.go.dev/golang.org/x/net/http/httpproxy)","Package hpack implements HPACK, a compression format for efficiently representing HTTP header fields in the context of HTTP/2.\n\nSee [http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09](http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09)\n\n[`golang.org/x/net/http2/hpack` on pkg.go.dev](https://pkg.go.dev/golang.org/x/net/http2/hpack)","Package bidirule implements the Bidi Rule defined by RFC 5893.\n\nThis package is under development. The API may change without notice and without preserving backward compatibility.\n\n[`golang.org/x/text/secure/bidirule` on pkg.go.dev](https://pkg.go.dev/golang.org/x/text/secure/bidirule)","Package bidi contains functionality for bidirectional text support.\n\nSee [https://www.unicode.org/reports/tr9](https://www.unicode.org/reports/tr9).\n\nNOTE: UNDER CONSTRUCTION. This API may change in backwards incompatible ways and without notice.\n\n[`golang.org/x/text/unicode/bidi` on pkg.go.dev](https://pkg.go.dev/golang.org/x/text/unicode/bidi)","Package norm contains types and functions for normalizing Unicode strings.\n\n[`golang.org/x/text/unicode/norm` on pkg.go.dev](https://pkg.go.dev/golang.org/x/text/unicode/norm)"]},"symbols":{"names":["ErrInvalidUnreadByte","ErrInvalidUnreadRune","ErrBufferFull","ErrNegativeCount","Reader","NewReaderSize","NewReader","Writer","NewWriterSize","NewWriter","ReadWriter","NewReadWriter","Scanner","SplitFunc","ErrTooLong","ErrNegativeAdvance","ErrAdvanceTooFar","ErrBadReadCount","MaxScanTokenSize","NewScanner","ErrFinalToken","ScanBytes","ScanRunes","ScanLines","ScanWords","bool","true","false","uint8","uint16","uint32","uint64","int8","int16","int32","int64","float32","float64","complex64","complex128","string","int","uint","uintptr","byte","rune","any","comparable","iota","nil","append","copy","delete","len","cap","make","max","min","new","complex","real","imag","clear","close","panic","recover","print","println","error","Buffer","ErrTooLarge","MinRead","NewBuffer","NewBufferString","Equal","Compare","Count","Contains","ContainsAny","ContainsRune","ContainsFunc","IndexByte","LastIndex","LastIndexByte","IndexRune","IndexAny","LastIndexAny","SplitN","SplitAfterN","Split","SplitAfter","Fields","FieldsFunc","Join","HasPrefix","HasSuffix","Map","Repeat","ToUpper","ToLower","ToTitle","ToUpperSpecial","ToLowerSpecial","ToTitleSpecial","ToValidUTF8","Title","TrimLeftFunc","TrimRightFunc","TrimFunc","TrimPrefix","TrimSuffix","IndexFunc","LastIndexFunc","Trim","TrimLeft","TrimRight","TrimSpace","Runes","Replace","ReplaceAll","EqualFold","Index","Cut","Clone","CutPrefix","CutSuffix","Reader","NewReader","Ordered","Less","Compare","Or","Context","Canceled","DeadlineExceeded","Background","TODO","CancelFunc","WithCancel","CancelCauseFunc","WithCancelCause","Cause","AfterFunc","WithoutCancel","WithDeadline","WithDeadlineCause","WithTimeout","WithTimeoutCause","WithValue","Hash","MD4","MD5","SHA1","SHA224","SHA256","SHA384","SHA512","MD5SHA1","RIPEMD160","SHA3_224","SHA3_256","SHA3_384","SHA3_512","SHA512_224","SHA512_256","BLAKE2s_256","BLAKE2b_256","BLAKE2b_384","BLAKE2b_512","RegisterHash","PublicKey","PrivateKey","Signer","SignerOpts","Decrypter","DecrypterOpts","FS","BinaryMarshaler","BinaryUnmarshaler","TextMarshaler","TextUnmarshaler","New","ErrUnsupported","Join","Unwrap","Is","As","Var","Int","Float","Map","KeyValue","String","Func","Publish","Get","NewInt","NewFloat","NewMap","NewString","Do","Handler","ErrHelp","Value","Getter","ErrorHandling","ContinueOnError","ExitOnError","PanicOnError","FlagSet","Flag","VisitAll","Visit","Lookup","Set","UnquoteUsage","PrintDefaults","Usage","NFlag","Arg","NArg","Args","BoolVar","Bool","IntVar","Int","Int64Var","Int64","UintVar","Uint","Uint64Var","Uint64","StringVar","String","Float64Var","Float64","DurationVar","Duration","TextVar","Func","BoolFunc","Var","Parse","Parsed","CommandLine","NewFlagSet","Errorf","State","Formatter","Stringer","GoStringer","FormatString","Fprintf","Printf","Sprintf","Appendf","Fprint","Print","Sprint","Append","Fprintln","Println","Sprintln","Appendln","ScanState","Scanner","Scan","Scanln","Scanf","Sscan","Sscanln","Sscanf","Fscan","Fscanln","Fscanf","Hash","Hash32","Hash64","EscapeString","UnescapeString","ErrFormat","RegisterFormat","Decode","DecodeConfig","Point","ZP","Pt","Rectangle","ZR","Rect","Config","Image","RGBA64Image","PalettedImage","RGBA","NewRGBA","RGBA64","NewRGBA64","NRGBA","NewNRGBA","NRGBA64","NewNRGBA64","Alpha","NewAlpha","Alpha16","NewAlpha16","Gray","NewGray","Gray16","NewGray16","CMYK","NewCMYK","Paletted","NewPaletted","Black","White","Transparent","Opaque","Uniform","NewUniform","YCbCrSubsampleRatio","YCbCrSubsampleRatio444","YCbCrSubsampleRatio422","YCbCrSubsampleRatio420","YCbCrSubsampleRatio440","YCbCrSubsampleRatio411","YCbCrSubsampleRatio410","YCbCr","NewYCbCr","NYCbCrA","NewNYCbCrA","SeekStart","SeekCurrent","SeekEnd","ErrShortWrite","ErrShortBuffer","EOF","ErrUnexpectedEOF","ErrNoProgress","Reader","Writer","Closer","Seeker","ReadWriter","ReadCloser","WriteCloser","ReadWriteCloser","ReadSeeker","ReadSeekCloser","WriteSeeker","ReadWriteSeeker","ReaderFrom","WriterTo","ReaderAt","WriterAt","ByteReader","ByteScanner","ByteWriter","RuneReader","RuneScanner","StringWriter","WriteString","ReadAtLeast","ReadFull","CopyN","Copy","CopyBuffer","LimitReader","LimitedReader","NewSectionReader","SectionReader","OffsetWriter","NewOffsetWriter","TeeReader","Discard","NopCloser","ReadAll","MultiReader","MultiWriter","ErrClosedPipe","PipeReader","PipeWriter","Pipe","Seq","Seq2","Pull","Pull2","Ldate","Ltime","Lmicroseconds","Llongfile","Lshortfile","LUTC","Lmsgprefix","LstdFlags","Logger","New","Default","SetOutput","Flags","SetFlags","Prefix","SetPrefix","Writer","Print","Printf","Println","Fatal","Fatalf","Fatalln","Panic","Panicf","Panicln","Output","All","Keys","Values","Insert","Collect","Equal","EqualFunc","Clone","Copy","DeleteFunc","Abs","Acosh","Asin","Acos","Asinh","Atan","Atan2","Atanh","Inf","NaN","IsNaN","IsInf","Cbrt","E","Pi","Phi","Sqrt2","SqrtE","SqrtPi","SqrtPhi","Ln2","Log2E","Ln10","Log10E","MaxFloat32","SmallestNonzeroFloat32","MaxFloat64","SmallestNonzeroFloat64","MaxInt","MinInt","MaxInt8","MinInt8","MaxInt16","MinInt16","MaxInt32","MinInt32","MaxInt64","MinInt64","MaxUint","MaxUint8","MaxUint16","MaxUint32","MaxUint64","Copysign","Dim","Max","Min","Erf","Erfc","Erfinv","Erfcinv","Exp","Exp2","Expm1","Floor","Ceil","Trunc","Round","RoundToEven","FMA","Frexp","Gamma","Hypot","J0","Y0","J1","Y1","Jn","Yn","Ldexp","Lgamma","Log","Log10","Log2","Log1p","Logb","Ilogb","Mod","Modf","Nextafter32","Nextafter","Pow","Pow10","Remainder","Signbit","Cos","Sin","Sincos","Sinh","Cosh","Sqrt","Tan","Tanh","Float32bits","Float32frombits","Float64bits","Float64frombits","WordEncoder","BEncoding","QEncoding","WordDecoder","FormatMediaType","ErrInvalidMediaParameter","ParseMediaType","TypeByExtension","ExtensionsByType","AddExtensionType","Dialer","Dial","DialTimeout","ListenConfig","Listen","ListenPacket","SRV","MX","NS","FileConn","FileListener","FilePacketConn","Interface","Flags","FlagUp","FlagBroadcast","FlagLoopback","FlagPointToPoint","FlagMulticast","FlagRunning","Interfaces","InterfaceAddrs","InterfaceByIndex","InterfaceByName","IPv4len","IPv6len","IP","IPMask","IPNet","IPv4","IPv4Mask","CIDRMask","IPv4bcast","IPv4allsys","IPv4allrouter","IPv4zero","IPv6zero","IPv6unspecified","IPv6loopback","IPv6interfacelocalallnodes","IPv6linklocalallnodes","IPv6linklocalallrouters","ParseIP","ParseCIDR","IPAddr","ResolveIPAddr","IPConn","DialIP","ListenIP","SplitHostPort","JoinHostPort","DefaultResolver","Resolver","LookupHost","LookupIP","LookupPort","LookupCNAME","LookupSRV","LookupMX","LookupNS","LookupTXT","LookupAddr","HardwareAddr","ParseMAC","Addr","Conn","PacketConn","Listener","Error","ErrWriteToConnected","OpError","ParseError","AddrError","UnknownNetworkError","InvalidAddrError","DNSConfigError","DNSError","ErrClosed","Buffers","Pipe","TCPAddr","ResolveTCPAddr","TCPAddrFromAddrPort","TCPConn","KeepAliveConfig","DialTCP","TCPListener","ListenTCP","UDPAddr","ResolveUDPAddr","UDPAddrFromAddrPort","UDPConn","DialUDP","ListenUDP","ListenMulticastUDP","UnixAddr","ResolveUnixAddr","UnixConn","DialUnix","UnixListener","ListenUnix","ListenUnixgram","DirEntry","ReadDir","CopyFS","Expand","ExpandEnv","Getenv","LookupEnv","Setenv","Unsetenv","Clearenv","Environ","ErrInvalid","ErrPermission","ErrExist","ErrNotExist","ErrClosed","ErrNoDeadline","ErrDeadlineExceeded","PathError","SyscallError","NewSyscallError","IsExist","IsNotExist","IsPermission","IsTimeout","ErrProcessDone","Process","ProcAttr","Signal","Getpid","Getppid","FindProcess","StartProcess","Interrupt","Kill","ProcessState","Executable","Stdin","Stdout","Stderr","O_RDONLY","O_WRONLY","O_RDWR","O_APPEND","O_CREATE","O_EXCL","O_SYNC","O_TRUNC","SEEK_SET","SEEK_CUR","SEEK_END","LinkError","Mkdir","Chdir","Open","Create","OpenFile","Rename","Readlink","TempDir","UserCacheDir","UserConfigDir","UserHomeDir","Chmod","DirFS","ReadFile","WriteFile","Chown","Lchown","Chtimes","NewFile","DevNull","Truncate","Remove","Link","Symlink","Getwd","MkdirAll","RemoveAll","PathSeparator","PathListSeparator","IsPathSeparator","Pipe","Args","Getuid","Geteuid","Getgid","Getegid","Getgroups","Exit","Stat","Lstat","Hostname","CreateTemp","MkdirTemp","Getpagesize","File","FileInfo","FileMode","ModeDir","ModeAppend","ModeExclusive","ModeTemporary","ModeSymlink","ModeDevice","ModeNamedPipe","ModeSocket","ModeSetuid","ModeSetgid","ModeCharDevice","ModeSticky","ModeIrregular","ModeType","ModePerm","SameFile","ErrBadPattern","Match","Clean","Split","Join","Ext","Base","IsAbs","Dir","Plugin","Open","Symbol","DeepEqual","MakeFunc","Swapper","Type","Kind","Invalid","Bool","Int","Int8","Int16","Int32","Int64","Uint","Uint8","Uint16","Uint32","Uint64","Uintptr","Float32","Float64","Complex64","Complex128","Array","Chan","Func","Interface","Map","Pointer","Slice","String","Struct","UnsafePointer","Ptr","ChanDir","RecvDir","SendDir","BothDir","Method","StructField","StructTag","TypeOf","PtrTo","PointerTo","ChanOf","MapOf","FuncOf","SliceOf","StructOf","ArrayOf","TypeFor","Value","ValueError","MapIter","StringHeader","SliceHeader","Append","AppendSlice","Copy","SelectDir","SelectSend","SelectRecv","SelectDefault","SelectCase","Select","MakeSlice","SliceAt","MakeChan","MakeMap","MakeMapWithSize","Indirect","ValueOf","Zero","New","NewAt","VisibleFields","Regexp","Compile","CompilePOSIX","MustCompile","MustCompilePOSIX","MatchReader","MatchString","Match","QuoteMeta","Compiler","SetCPUProfileRate","CPUProfile","GOMAXPROCS","NumCPU","NumCgoCall","NumGoroutine","Error","TypeAssertionError","Caller","Callers","GOROOT","Version","GOOS","GOARCH","SetFinalizer","KeepAlive","GC","SetBlockProfileRate","SetMutexProfileFraction","StackRecord","MemProfileRate","MemProfileRecord","MemProfile","BlockProfileRecord","BlockProfile","MutexProfile","ThreadCreateProfile","GoroutineProfile","Stack","MemStats","ReadMemStats","Goexit","PanicNilError","Pinner","Gosched","Breakpoint","LockOSThread","UnlockOSThread","Frames","Frame","CallersFrames","Func","FuncForPC","StartTrace","StopTrace","ReadTrace","SetCgoTraceback","All","Backward","Values","AppendSeq","Collect","Sorted","SortedFunc","SortedStableFunc","Chunk","Equal","EqualFunc","Compare","CompareFunc","Index","IndexFunc","Contains","ContainsFunc","Insert","Delete","DeleteFunc","Replace","Clone","Compact","CompactFunc","Grow","Clip","Reverse","Concat","Repeat","Sort","SortFunc","SortStableFunc","IsSorted","IsSortedFunc","Min","MinFunc","Max","MaxFunc","BinarySearch","BinarySearchFunc","Search","Find","SearchInts","SearchFloat64s","SearchStrings","Slice","SliceStable","SliceIsSorted","Interface","Sort","Reverse","IsSorted","IntSlice","Float64Slice","StringSlice","Ints","Float64s","Strings","IntsAreSorted","Float64sAreSorted","StringsAreSorted","Stable","ParseBool","FormatBool","AppendBool","ParseComplex","ParseFloat","ErrRange","ErrSyntax","NumError","IntSize","ParseUint","ParseInt","Atoi","FormatComplex","FormatFloat","AppendFloat","FormatUint","FormatInt","Itoa","AppendInt","AppendUint","Quote","AppendQuote","QuoteToASCII","AppendQuoteToASCII","QuoteToGraphic","AppendQuoteToGraphic","QuoteRune","AppendQuoteRune","QuoteRuneToASCII","AppendQuoteRuneToASCII","QuoteRuneToGraphic","AppendQuoteRuneToGraphic","CanBackquote","UnquoteChar","QuotedPrefix","Unquote","IsPrint","IsGraphic","Builder","Clone","Compare","Reader","NewReader","Replacer","NewReplacer","Count","Contains","ContainsAny","ContainsRune","ContainsFunc","LastIndex","IndexByte","IndexRune","IndexAny","LastIndexAny","LastIndexByte","SplitN","SplitAfterN","Split","SplitAfter","Fields","FieldsFunc","Join","HasPrefix","HasSuffix","Map","Repeat","ToUpper","ToLower","ToTitle","ToUpperSpecial","ToLowerSpecial","ToTitleSpecial","ToValidUTF8","Title","TrimLeftFunc","TrimRightFunc","TrimFunc","IndexFunc","LastIndexFunc","Trim","TrimLeft","TrimRight","TrimSpace","TrimPrefix","TrimSuffix","Replace","ReplaceAll","EqualFold","Index","Cut","CutPrefix","CutSuffix","HostLayout","Cond","NewCond","Map","Mutex","Locker","Once","OnceFunc","OnceValue","OnceValues","Pool","RWMutex","WaitGroup","ParseDirent","Unsetenv","Getenv","Setenv","Clearenv","Environ","CLONE_VM","CLONE_FS","CLONE_FILES","CLONE_SIGHAND","CLONE_PIDFD","CLONE_PTRACE","CLONE_VFORK","CLONE_PARENT","CLONE_THREAD","CLONE_NEWNS","CLONE_SYSVSEM","CLONE_SETTLS","CLONE_PARENT_SETTID","CLONE_CHILD_CLEARTID","CLONE_DETACHED","CLONE_UNTRACED","CLONE_CHILD_SETTID","CLONE_NEWCGROUP","CLONE_NEWUTS","CLONE_NEWIPC","CLONE_NEWUSER","CLONE_NEWPID","CLONE_NEWNET","CLONE_IO","CLONE_CLEAR_SIGHAND","CLONE_INTO_CGROUP","CLONE_NEWTIME","SysProcIDMap","SysProcAttr","ForkLock","StringSlicePtr","SlicePtrFromStrings","CloseOnExec","SetNonblock","Credential","ProcAttr","ForkExec","StartProcess","Exec","FcntlFlock","LsfStmt","LsfJump","LsfSocket","SetLsfPromisc","AttachLsf","DetachLsf","RawConn","Conn","NetlinkRouteRequest","NetlinkRIB","NetlinkMessage","ParseNetlinkMessage","NetlinkRouteAttr","ParseNetlinkRouteAttr","Setrlimit","UnixCredentials","ParseUnixCredentials","CmsgLen","CmsgSpace","SocketControlMessage","ParseSocketControlMessage","UnixRights","ParseUnixRights","StringByteSlice","ByteSliceFromString","StringBytePtr","BytePtrFromString","Getpagesize","Exit","RawSyscall","RawSyscall6","Syscall","Syscall6","Access","Chmod","Chown","Creat","EpollCreate","Faccessat","Fchmodat","Link","Mkdir","Mknod","Open","Openat","Pipe","Pipe2","Readlink","Rename","Rmdir","Symlink","Unlink","Unlinkat","Utimes","UtimesNano","Futimesat","Futimes","ImplementsGetwd","Getwd","Getgroups","Setgroups","WaitStatus","Wait4","Mkfifo","SockaddrLinklayer","SockaddrNetlink","Accept4","Getsockname","GetsockoptInet4Addr","GetsockoptIPMreq","GetsockoptIPMreqn","GetsockoptIPv6Mreq","GetsockoptIPv6MTUInfo","GetsockoptICMPv6Filter","GetsockoptUcred","SetsockoptIPMreqn","BindToDevice","PtracePeekText","PtracePeekData","PtracePokeText","PtracePokeData","PtraceGetRegs","PtraceSetRegs","PtraceSetOptions","PtraceGetEventMsg","PtraceCont","PtraceSyscall","PtraceSingleStep","PtraceAttach","PtraceDetach","Reboot","ReadDirent","Mount","Getpgrp","AllThreadsSyscall","AllThreadsSyscall6","Setegid","Seteuid","Setgid","Setregid","Setresgid","Setresuid","Setreuid","Setuid","Mmap","Munmap","Accept","Stat","Lchown","Lstat","Gettimeofday","Time","Stdin","Stdout","Stderr","Errno","Signal","Read","Write","Pread","Pwrite","SocketDisableIPv6","Sockaddr","SockaddrInet4","SockaddrInet6","SockaddrUnix","Bind","Connect","Getpeername","GetsockoptInt","Recvfrom","Recvmsg","Sendmsg","SendmsgN","Sendto","SetsockoptByte","SetsockoptInt","SetsockoptInet4Addr","SetsockoptIPMreq","SetsockoptIPv6Mreq","SetsockoptICMPv6Filter","SetsockoptLinger","SetsockoptString","SetsockoptTimeval","Socket","Socketpair","Sendfile","TimespecToNsec","NsecToTimespec","TimevalToNsec","NsecToTimeval","AF_ALG","AF_APPLETALK","AF_ASH","AF_ATMPVC","AF_ATMSVC","AF_AX25","AF_BLUETOOTH","AF_BRIDGE","AF_CAIF","AF_CAN","AF_DECnet","AF_ECONET","AF_FILE","AF_IEEE802154","AF_INET","AF_INET6","AF_IPX","AF_IRDA","AF_ISDN","AF_IUCV","AF_KEY","AF_LLC","AF_LOCAL","AF_MAX","AF_NETBEUI","AF_NETLINK","AF_NETROM","AF_PACKET","AF_PHONET","AF_PPPOX","AF_RDS","AF_ROSE","AF_ROUTE","AF_RXRPC","AF_SECURITY","AF_SNA","AF_TIPC","AF_UNIX","AF_UNSPEC","AF_WANPIPE","AF_X25","ARPHRD_ADAPT","ARPHRD_APPLETLK","ARPHRD_ARCNET","ARPHRD_ASH","ARPHRD_ATM","ARPHRD_AX25","ARPHRD_BIF","ARPHRD_CHAOS","ARPHRD_CISCO","ARPHRD_CSLIP","ARPHRD_CSLIP6","ARPHRD_DDCMP","ARPHRD_DLCI","ARPHRD_ECONET","ARPHRD_EETHER","ARPHRD_ETHER","ARPHRD_EUI64","ARPHRD_FCAL","ARPHRD_FCFABRIC","ARPHRD_FCPL","ARPHRD_FCPP","ARPHRD_FDDI","ARPHRD_FRAD","ARPHRD_HDLC","ARPHRD_HIPPI","ARPHRD_HWX25","ARPHRD_IEEE1394","ARPHRD_IEEE802","ARPHRD_IEEE80211","ARPHRD_IEEE80211_PRISM","ARPHRD_IEEE80211_RADIOTAP","ARPHRD_IEEE802154","ARPHRD_IEEE802154_PHY","ARPHRD_IEEE802_TR","ARPHRD_INFINIBAND","ARPHRD_IPDDP","ARPHRD_IPGRE","ARPHRD_IRDA","ARPHRD_LAPB","ARPHRD_LOCALTLK","ARPHRD_LOOPBACK","ARPHRD_METRICOM","ARPHRD_NETROM","ARPHRD_NONE","ARPHRD_PIMREG","ARPHRD_PPP","ARPHRD_PRONET","ARPHRD_RAWHDLC","ARPHRD_ROSE","ARPHRD_RSRVD","ARPHRD_SIT","ARPHRD_SKIP","ARPHRD_SLIP","ARPHRD_SLIP6","ARPHRD_TUNNEL","ARPHRD_TUNNEL6","ARPHRD_VOID","ARPHRD_X25","BPF_A","BPF_ABS","BPF_ADD","BPF_ALU","BPF_AND","BPF_B","BPF_DIV","BPF_H","BPF_IMM","BPF_IND","BPF_JA","BPF_JEQ","BPF_JGE","BPF_JGT","BPF_JMP","BPF_JSET","BPF_K","BPF_LD","BPF_LDX","BPF_LEN","BPF_LSH","BPF_MAJOR_VERSION","BPF_MAXINSNS","BPF_MEM","BPF_MEMWORDS","BPF_MINOR_VERSION","BPF_MISC","BPF_MSH","BPF_MUL","BPF_NEG","BPF_OR","BPF_RET","BPF_RSH","BPF_ST","BPF_STX","BPF_SUB","BPF_TAX","BPF_TXA","BPF_W","BPF_X","DT_BLK","DT_CHR","DT_DIR","DT_FIFO","DT_LNK","DT_REG","DT_SOCK","DT_UNKNOWN","DT_WHT","EPOLLERR","EPOLLET","EPOLLHUP","EPOLLIN","EPOLLMSG","EPOLLONESHOT","EPOLLOUT","EPOLLPRI","EPOLLRDBAND","EPOLLRDHUP","EPOLLRDNORM","EPOLLWRBAND","EPOLLWRNORM","EPOLL_CLOEXEC","EPOLL_CTL_ADD","EPOLL_CTL_DEL","EPOLL_CTL_MOD","EPOLL_NONBLOCK","ETH_P_1588","ETH_P_8021Q","ETH_P_802_2","ETH_P_802_3","ETH_P_AARP","ETH_P_ALL","ETH_P_AOE","ETH_P_ARCNET","ETH_P_ARP","ETH_P_ATALK","ETH_P_ATMFATE","ETH_P_ATMMPOA","ETH_P_AX25","ETH_P_BPQ","ETH_P_CAIF","ETH_P_CAN","ETH_P_CONTROL","ETH_P_CUST","ETH_P_DDCMP","ETH_P_DEC","ETH_P_DIAG","ETH_P_DNA_DL","ETH_P_DNA_RC","ETH_P_DNA_RT","ETH_P_DSA","ETH_P_ECONET","ETH_P_EDSA","ETH_P_FCOE","ETH_P_FIP","ETH_P_HDLC","ETH_P_IEEE802154","ETH_P_IEEEPUP","ETH_P_IEEEPUPAT","ETH_P_IP","ETH_P_IPV6","ETH_P_IPX","ETH_P_IRDA","ETH_P_LAT","ETH_P_LINK_CTL","ETH_P_LOCALTALK","ETH_P_LOOP","ETH_P_MOBITEX","ETH_P_MPLS_MC","ETH_P_MPLS_UC","ETH_P_PAE","ETH_P_PAUSE","ETH_P_PHONET","ETH_P_PPPTALK","ETH_P_PPP_DISC","ETH_P_PPP_MP","ETH_P_PPP_SES","ETH_P_PUP","ETH_P_PUPAT","ETH_P_RARP","ETH_P_SCA","ETH_P_SLOW","ETH_P_SNAP","ETH_P_TEB","ETH_P_TIPC","ETH_P_TRAILER","ETH_P_TR_802_2","ETH_P_WAN_PPP","ETH_P_WCCP","ETH_P_X25","FD_CLOEXEC","FD_SETSIZE","F_DUPFD","F_DUPFD_CLOEXEC","F_EXLCK","F_GETFD","F_GETFL","F_GETLEASE","F_GETLK","F_GETLK64","F_GETOWN","F_GETOWN_EX","F_GETPIPE_SZ","F_GETSIG","F_LOCK","F_NOTIFY","F_OK","F_RDLCK","F_SETFD","F_SETFL","F_SETLEASE","F_SETLK","F_SETLK64","F_SETLKW","F_SETLKW64","F_SETOWN","F_SETOWN_EX","F_SETPIPE_SZ","F_SETSIG","F_SHLCK","F_TEST","F_TLOCK","F_ULOCK","F_UNLCK","F_WRLCK","ICMPV6_FILTER","IFA_F_DADFAILED","IFA_F_DEPRECATED","IFA_F_HOMEADDRESS","IFA_F_NODAD","IFA_F_OPTIMISTIC","IFA_F_PERMANENT","IFA_F_SECONDARY","IFA_F_TEMPORARY","IFA_F_TENTATIVE","IFA_MAX","IFF_ALLMULTI","IFF_AUTOMEDIA","IFF_BROADCAST","IFF_DEBUG","IFF_DYNAMIC","IFF_LOOPBACK","IFF_MASTER","IFF_MULTICAST","IFF_NOARP","IFF_NOTRAILERS","IFF_NO_PI","IFF_ONE_QUEUE","IFF_POINTOPOINT","IFF_PORTSEL","IFF_PROMISC","IFF_RUNNING","IFF_SLAVE","IFF_TAP","IFF_TUN","IFF_TUN_EXCL","IFF_UP","IFF_VNET_HDR","IFNAMSIZ","IN_ACCESS","IN_ALL_EVENTS","IN_ATTRIB","IN_CLASSA_HOST","IN_CLASSA_MAX","IN_CLASSA_NET","IN_CLASSA_NSHIFT","IN_CLASSB_HOST","IN_CLASSB_MAX","IN_CLASSB_NET","IN_CLASSB_NSHIFT","IN_CLASSC_HOST","IN_CLASSC_NET","IN_CLASSC_NSHIFT","IN_CLOEXEC","IN_CLOSE","IN_CLOSE_NOWRITE","IN_CLOSE_WRITE","IN_CREATE","IN_DELETE","IN_DELETE_SELF","IN_DONT_FOLLOW","IN_EXCL_UNLINK","IN_IGNORED","IN_ISDIR","IN_LOOPBACKNET","IN_MASK_ADD","IN_MODIFY","IN_MOVE","IN_MOVED_FROM","IN_MOVED_TO","IN_MOVE_SELF","IN_NONBLOCK","IN_ONESHOT","IN_ONLYDIR","IN_OPEN","IN_Q_OVERFLOW","IN_UNMOUNT","IPPROTO_AH","IPPROTO_COMP","IPPROTO_DCCP","IPPROTO_DSTOPTS","IPPROTO_EGP","IPPROTO_ENCAP","IPPROTO_ESP","IPPROTO_FRAGMENT","IPPROTO_GRE","IPPROTO_HOPOPTS","IPPROTO_ICMP","IPPROTO_ICMPV6","IPPROTO_IDP","IPPROTO_IGMP","IPPROTO_IP","IPPROTO_IPIP","IPPROTO_IPV6","IPPROTO_MTP","IPPROTO_NONE","IPPROTO_PIM","IPPROTO_PUP","IPPROTO_RAW","IPPROTO_ROUTING","IPPROTO_RSVP","IPPROTO_SCTP","IPPROTO_TCP","IPPROTO_TP","IPPROTO_UDP","IPPROTO_UDPLITE","IPV6_2292DSTOPTS","IPV6_2292HOPLIMIT","IPV6_2292HOPOPTS","IPV6_2292PKTINFO","IPV6_2292PKTOPTIONS","IPV6_2292RTHDR","IPV6_ADDRFORM","IPV6_ADD_MEMBERSHIP","IPV6_AUTHHDR","IPV6_CHECKSUM","IPV6_DROP_MEMBERSHIP","IPV6_DSTOPTS","IPV6_HOPLIMIT","IPV6_HOPOPTS","IPV6_IPSEC_POLICY","IPV6_JOIN_ANYCAST","IPV6_JOIN_GROUP","IPV6_LEAVE_ANYCAST","IPV6_LEAVE_GROUP","IPV6_MTU","IPV6_MTU_DISCOVER","IPV6_MULTICAST_HOPS","IPV6_MULTICAST_IF","IPV6_MULTICAST_LOOP","IPV6_NEXTHOP","IPV6_PKTINFO","IPV6_PMTUDISC_DO","IPV6_PMTUDISC_DONT","IPV6_PMTUDISC_PROBE","IPV6_PMTUDISC_WANT","IPV6_RECVDSTOPTS","IPV6_RECVERR","IPV6_RECVHOPLIMIT","IPV6_RECVHOPOPTS","IPV6_RECVPKTINFO","IPV6_RECVRTHDR","IPV6_RECVTCLASS","IPV6_ROUTER_ALERT","IPV6_RTHDR","IPV6_RTHDRDSTOPTS","IPV6_RTHDR_LOOSE","IPV6_RTHDR_STRICT","IPV6_RTHDR_TYPE_0","IPV6_RXDSTOPTS","IPV6_RXHOPOPTS","IPV6_TCLASS","IPV6_UNICAST_HOPS","IPV6_V6ONLY","IPV6_XFRM_POLICY","IP_ADD_MEMBERSHIP","IP_ADD_SOURCE_MEMBERSHIP","IP_BLOCK_SOURCE","IP_DEFAULT_MULTICAST_LOOP","IP_DEFAULT_MULTICAST_TTL","IP_DF","IP_DROP_MEMBERSHIP","IP_DROP_SOURCE_MEMBERSHIP","IP_FREEBIND","IP_HDRINCL","IP_IPSEC_POLICY","IP_MAXPACKET","IP_MAX_MEMBERSHIPS","IP_MF","IP_MINTTL","IP_MSFILTER","IP_MSS","IP_MTU","IP_MTU_DISCOVER","IP_MULTICAST_IF","IP_MULTICAST_LOOP","IP_MULTICAST_TTL","IP_OFFMASK","IP_OPTIONS","IP_ORIGDSTADDR","IP_PASSSEC","IP_PKTINFO","IP_PKTOPTIONS","IP_PMTUDISC","IP_PMTUDISC_DO","IP_PMTUDISC_DONT","IP_PMTUDISC_PROBE","IP_PMTUDISC_WANT","IP_RECVERR","IP_RECVOPTS","IP_RECVORIGDSTADDR","IP_RECVRETOPTS","IP_RECVTOS","IP_RECVTTL","IP_RETOPTS","IP_RF","IP_ROUTER_ALERT","IP_TOS","IP_TRANSPARENT","IP_TTL","IP_UNBLOCK_SOURCE","IP_XFRM_POLICY","LINUX_REBOOT_CMD_CAD_OFF","LINUX_REBOOT_CMD_CAD_ON","LINUX_REBOOT_CMD_HALT","LINUX_REBOOT_CMD_KEXEC","LINUX_REBOOT_CMD_POWER_OFF","LINUX_REBOOT_CMD_RESTART","LINUX_REBOOT_CMD_RESTART2","LINUX_REBOOT_CMD_SW_SUSPEND","LINUX_REBOOT_MAGIC1","LINUX_REBOOT_MAGIC2","LOCK_EX","LOCK_NB","LOCK_SH","LOCK_UN","MADV_DOFORK","MADV_DONTFORK","MADV_DONTNEED","MADV_HUGEPAGE","MADV_HWPOISON","MADV_MERGEABLE","MADV_NOHUGEPAGE","MADV_NORMAL","MADV_RANDOM","MADV_REMOVE","MADV_SEQUENTIAL","MADV_UNMERGEABLE","MADV_WILLNEED","MAP_32BIT","MAP_ANON","MAP_ANONYMOUS","MAP_DENYWRITE","MAP_EXECUTABLE","MAP_FILE","MAP_FIXED","MAP_GROWSDOWN","MAP_HUGETLB","MAP_LOCKED","MAP_NONBLOCK","MAP_NORESERVE","MAP_POPULATE","MAP_PRIVATE","MAP_SHARED","MAP_STACK","MAP_TYPE","MCL_CURRENT","MCL_FUTURE","MNT_DETACH","MNT_EXPIRE","MNT_FORCE","MSG_CMSG_CLOEXEC","MSG_CONFIRM","MSG_CTRUNC","MSG_DONTROUTE","MSG_DONTWAIT","MSG_EOR","MSG_ERRQUEUE","MSG_FASTOPEN","MSG_FIN","MSG_MORE","MSG_NOSIGNAL","MSG_OOB","MSG_PEEK","MSG_PROXY","MSG_RST","MSG_SYN","MSG_TRUNC","MSG_TRYHARD","MSG_WAITALL","MSG_WAITFORONE","MS_ACTIVE","MS_ASYNC","MS_BIND","MS_DIRSYNC","MS_INVALIDATE","MS_I_VERSION","MS_KERNMOUNT","MS_MANDLOCK","MS_MGC_MSK","MS_MGC_VAL","MS_MOVE","MS_NOATIME","MS_NODEV","MS_NODIRATIME","MS_NOEXEC","MS_NOSUID","MS_NOUSER","MS_POSIXACL","MS_PRIVATE","MS_RDONLY","MS_REC","MS_RELATIME","MS_REMOUNT","MS_RMT_MASK","MS_SHARED","MS_SILENT","MS_SLAVE","MS_STRICTATIME","MS_SYNC","MS_SYNCHRONOUS","MS_UNBINDABLE","NAME_MAX","NETLINK_ADD_MEMBERSHIP","NETLINK_AUDIT","NETLINK_BROADCAST_ERROR","NETLINK_CONNECTOR","NETLINK_DNRTMSG","NETLINK_DROP_MEMBERSHIP","NETLINK_ECRYPTFS","NETLINK_FIB_LOOKUP","NETLINK_FIREWALL","NETLINK_GENERIC","NETLINK_INET_DIAG","NETLINK_IP6_FW","NETLINK_ISCSI","NETLINK_KOBJECT_UEVENT","NETLINK_NETFILTER","NETLINK_NFLOG","NETLINK_NO_ENOBUFS","NETLINK_PKTINFO","NETLINK_ROUTE","NETLINK_SCSITRANSPORT","NETLINK_SELINUX","NETLINK_UNUSED","NETLINK_USERSOCK","NETLINK_XFRM","NLA_ALIGNTO","NLA_F_NESTED","NLA_F_NET_BYTEORDER","NLA_HDRLEN","NLMSG_ALIGNTO","NLMSG_DONE","NLMSG_ERROR","NLMSG_HDRLEN","NLMSG_MIN_TYPE","NLMSG_NOOP","NLMSG_OVERRUN","NLM_F_ACK","NLM_F_APPEND","NLM_F_ATOMIC","NLM_F_CREATE","NLM_F_DUMP","NLM_F_ECHO","NLM_F_EXCL","NLM_F_MATCH","NLM_F_MULTI","NLM_F_REPLACE","NLM_F_REQUEST","NLM_F_ROOT","O_ACCMODE","O_APPEND","O_ASYNC","O_CLOEXEC","O_CREAT","O_DIRECT","O_DIRECTORY","O_DSYNC","O_EXCL","O_FSYNC","O_LARGEFILE","O_NDELAY","O_NOATIME","O_NOCTTY","O_NOFOLLOW","O_NONBLOCK","O_RDONLY","O_RDWR","O_RSYNC","O_SYNC","O_TRUNC","O_WRONLY","PACKET_ADD_MEMBERSHIP","PACKET_BROADCAST","PACKET_DROP_MEMBERSHIP","PACKET_FASTROUTE","PACKET_HOST","PACKET_LOOPBACK","PACKET_MR_ALLMULTI","PACKET_MR_MULTICAST","PACKET_MR_PROMISC","PACKET_MULTICAST","PACKET_OTHERHOST","PACKET_OUTGOING","PACKET_RECV_OUTPUT","PACKET_RX_RING","PACKET_STATISTICS","PRIO_PGRP","PRIO_PROCESS","PRIO_USER","PROT_EXEC","PROT_GROWSDOWN","PROT_GROWSUP","PROT_NONE","PROT_READ","PROT_WRITE","PR_CAPBSET_DROP","PR_CAPBSET_READ","PR_ENDIAN_BIG","PR_ENDIAN_LITTLE","PR_ENDIAN_PPC_LITTLE","PR_FPEMU_NOPRINT","PR_FPEMU_SIGFPE","PR_FP_EXC_ASYNC","PR_FP_EXC_DISABLED","PR_FP_EXC_DIV","PR_FP_EXC_INV","PR_FP_EXC_NONRECOV","PR_FP_EXC_OVF","PR_FP_EXC_PRECISE","PR_FP_EXC_RES","PR_FP_EXC_SW_ENABLE","PR_FP_EXC_UND","PR_GET_DUMPABLE","PR_GET_ENDIAN","PR_GET_FPEMU","PR_GET_FPEXC","PR_GET_KEEPCAPS","PR_GET_NAME","PR_GET_PDEATHSIG","PR_GET_SECCOMP","PR_GET_SECUREBITS","PR_GET_TIMERSLACK","PR_GET_TIMING","PR_GET_TSC","PR_GET_UNALIGN","PR_MCE_KILL","PR_MCE_KILL_CLEAR","PR_MCE_KILL_DEFAULT","PR_MCE_KILL_EARLY","PR_MCE_KILL_GET","PR_MCE_KILL_LATE","PR_MCE_KILL_SET","PR_SET_DUMPABLE","PR_SET_ENDIAN","PR_SET_FPEMU","PR_SET_FPEXC","PR_SET_KEEPCAPS","PR_SET_NAME","PR_SET_PDEATHSIG","PR_SET_PTRACER","PR_SET_SECCOMP","PR_SET_SECUREBITS","PR_SET_TIMERSLACK","PR_SET_TIMING","PR_SET_TSC","PR_SET_UNALIGN","PR_TASK_PERF_EVENTS_DISABLE","PR_TASK_PERF_EVENTS_ENABLE","PR_TIMING_STATISTICAL","PR_TIMING_TIMESTAMP","PR_TSC_ENABLE","PR_TSC_SIGSEGV","PR_UNALIGN_NOPRINT","PR_UNALIGN_SIGBUS","PTRACE_ARCH_PRCTL","PTRACE_ATTACH","PTRACE_CONT","PTRACE_DETACH","PTRACE_EVENT_CLONE","PTRACE_EVENT_EXEC","PTRACE_EVENT_EXIT","PTRACE_EVENT_FORK","PTRACE_EVENT_VFORK","PTRACE_EVENT_VFORK_DONE","PTRACE_GETEVENTMSG","PTRACE_GETFPREGS","PTRACE_GETFPXREGS","PTRACE_GETREGS","PTRACE_GETREGSET","PTRACE_GETSIGINFO","PTRACE_GET_THREAD_AREA","PTRACE_KILL","PTRACE_OLDSETOPTIONS","PTRACE_O_MASK","PTRACE_O_TRACECLONE","PTRACE_O_TRACEEXEC","PTRACE_O_TRACEEXIT","PTRACE_O_TRACEFORK","PTRACE_O_TRACESYSGOOD","PTRACE_O_TRACEVFORK","PTRACE_O_TRACEVFORKDONE","PTRACE_PEEKDATA","PTRACE_PEEKTEXT","PTRACE_PEEKUSR","PTRACE_POKEDATA","PTRACE_POKETEXT","PTRACE_POKEUSR","PTRACE_SETFPREGS","PTRACE_SETFPXREGS","PTRACE_SETOPTIONS","PTRACE_SETREGS","PTRACE_SETREGSET","PTRACE_SETSIGINFO","PTRACE_SET_THREAD_AREA","PTRACE_SINGLEBLOCK","PTRACE_SINGLESTEP","PTRACE_SYSCALL","PTRACE_SYSEMU","PTRACE_SYSEMU_SINGLESTEP","PTRACE_TRACEME","RLIMIT_AS","RLIMIT_CORE","RLIMIT_CPU","RLIMIT_DATA","RLIMIT_FSIZE","RLIMIT_NOFILE","RLIMIT_STACK","RLIM_INFINITY","RTAX_ADVMSS","RTAX_CWND","RTAX_FEATURES","RTAX_FEATURE_ALLFRAG","RTAX_FEATURE_ECN","RTAX_FEATURE_SACK","RTAX_FEATURE_TIMESTAMP","RTAX_HOPLIMIT","RTAX_INITCWND","RTAX_INITRWND","RTAX_LOCK","RTAX_MAX","RTAX_MTU","RTAX_REORDERING","RTAX_RTO_MIN","RTAX_RTT","RTAX_RTTVAR","RTAX_SSTHRESH","RTAX_UNSPEC","RTAX_WINDOW","RTA_ALIGNTO","RTA_MAX","RTCF_DIRECTSRC","RTCF_DOREDIRECT","RTCF_LOG","RTCF_MASQ","RTCF_NAT","RTCF_VALVE","RTF_ADDRCLASSMASK","RTF_ADDRCONF","RTF_ALLONLINK","RTF_BROADCAST","RTF_CACHE","RTF_DEFAULT","RTF_DYNAMIC","RTF_FLOW","RTF_GATEWAY","RTF_HOST","RTF_INTERFACE","RTF_IRTT","RTF_LINKRT","RTF_LOCAL","RTF_MODIFIED","RTF_MSS","RTF_MTU","RTF_MULTICAST","RTF_NAT","RTF_NOFORWARD","RTF_NONEXTHOP","RTF_NOPMTUDISC","RTF_POLICY","RTF_REINSTATE","RTF_REJECT","RTF_STATIC","RTF_THROW","RTF_UP","RTF_WINDOW","RTF_XRESOLVE","RTM_BASE","RTM_DELACTION","RTM_DELADDR","RTM_DELADDRLABEL","RTM_DELLINK","RTM_DELNEIGH","RTM_DELQDISC","RTM_DELROUTE","RTM_DELRULE","RTM_DELTCLASS","RTM_DELTFILTER","RTM_F_CLONED","RTM_F_EQUALIZE","RTM_F_NOTIFY","RTM_F_PREFIX","RTM_GETACTION","RTM_GETADDR","RTM_GETADDRLABEL","RTM_GETANYCAST","RTM_GETDCB","RTM_GETLINK","RTM_GETMULTICAST","RTM_GETNEIGH","RTM_GETNEIGHTBL","RTM_GETQDISC","RTM_GETROUTE","RTM_GETRULE","RTM_GETTCLASS","RTM_GETTFILTER","RTM_MAX","RTM_NEWACTION","RTM_NEWADDR","RTM_NEWADDRLABEL","RTM_NEWLINK","RTM_NEWNDUSEROPT","RTM_NEWNEIGH","RTM_NEWNEIGHTBL","RTM_NEWPREFIX","RTM_NEWQDISC","RTM_NEWROUTE","RTM_NEWRULE","RTM_NEWTCLASS","RTM_NEWTFILTER","RTM_NR_FAMILIES","RTM_NR_MSGTYPES","RTM_SETDCB","RTM_SETLINK","RTM_SETNEIGHTBL","RTNH_ALIGNTO","RTNH_F_DEAD","RTNH_F_ONLINK","RTNH_F_PERVASIVE","RTN_MAX","RTPROT_BIRD","RTPROT_BOOT","RTPROT_DHCP","RTPROT_DNROUTED","RTPROT_GATED","RTPROT_KERNEL","RTPROT_MRT","RTPROT_NTK","RTPROT_RA","RTPROT_REDIRECT","RTPROT_STATIC","RTPROT_UNSPEC","RTPROT_XORP","RTPROT_ZEBRA","RT_CLASS_DEFAULT","RT_CLASS_LOCAL","RT_CLASS_MAIN","RT_CLASS_MAX","RT_CLASS_UNSPEC","RUSAGE_CHILDREN","RUSAGE_SELF","RUSAGE_THREAD","SCM_CREDENTIALS","SCM_RIGHTS","SCM_TIMESTAMP","SCM_TIMESTAMPING","SCM_TIMESTAMPNS","SHUT_RD","SHUT_RDWR","SHUT_WR","SIOCADDDLCI","SIOCADDMULTI","SIOCADDRT","SIOCATMARK","SIOCDARP","SIOCDELDLCI","SIOCDELMULTI","SIOCDELRT","SIOCDEVPRIVATE","SIOCDIFADDR","SIOCDRARP","SIOCGARP","SIOCGIFADDR","SIOCGIFBR","SIOCGIFBRDADDR","SIOCGIFCONF","SIOCGIFCOUNT","SIOCGIFDSTADDR","SIOCGIFENCAP","SIOCGIFFLAGS","SIOCGIFHWADDR","SIOCGIFINDEX","SIOCGIFMAP","SIOCGIFMEM","SIOCGIFMETRIC","SIOCGIFMTU","SIOCGIFNAME","SIOCGIFNETMASK","SIOCGIFPFLAGS","SIOCGIFSLAVE","SIOCGIFTXQLEN","SIOCGPGRP","SIOCGRARP","SIOCGSTAMP","SIOCGSTAMPNS","SIOCPROTOPRIVATE","SIOCRTMSG","SIOCSARP","SIOCSIFADDR","SIOCSIFBR","SIOCSIFBRDADDR","SIOCSIFDSTADDR","SIOCSIFENCAP","SIOCSIFFLAGS","SIOCSIFHWADDR","SIOCSIFHWBROADCAST","SIOCSIFLINK","SIOCSIFMAP","SIOCSIFMEM","SIOCSIFMETRIC","SIOCSIFMTU","SIOCSIFNAME","SIOCSIFNETMASK","SIOCSIFPFLAGS","SIOCSIFSLAVE","SIOCSIFTXQLEN","SIOCSPGRP","SIOCSRARP","SOCK_CLOEXEC","SOCK_DCCP","SOCK_DGRAM","SOCK_NONBLOCK","SOCK_PACKET","SOCK_RAW","SOCK_RDM","SOCK_SEQPACKET","SOCK_STREAM","SOL_AAL","SOL_ATM","SOL_DECNET","SOL_ICMPV6","SOL_IP","SOL_IPV6","SOL_IRDA","SOL_PACKET","SOL_RAW","SOL_SOCKET","SOL_TCP","SOL_X25","SOMAXCONN","SO_ACCEPTCONN","SO_ATTACH_FILTER","SO_BINDTODEVICE","SO_BROADCAST","SO_BSDCOMPAT","SO_DEBUG","SO_DETACH_FILTER","SO_DOMAIN","SO_DONTROUTE","SO_ERROR","SO_KEEPALIVE","SO_LINGER","SO_MARK","SO_NO_CHECK","SO_OOBINLINE","SO_PASSCRED","SO_PASSSEC","SO_PEERCRED","SO_PEERNAME","SO_PEERSEC","SO_PRIORITY","SO_PROTOCOL","SO_RCVBUF","SO_RCVBUFFORCE","SO_RCVLOWAT","SO_RCVTIMEO","SO_REUSEADDR","SO_RXQ_OVFL","SO_SECURITY_AUTHENTICATION","SO_SECURITY_ENCRYPTION_NETWORK","SO_SECURITY_ENCRYPTION_TRANSPORT","SO_SNDBUF","SO_SNDBUFFORCE","SO_SNDLOWAT","SO_SNDTIMEO","SO_TIMESTAMP","SO_TIMESTAMPING","SO_TIMESTAMPNS","SO_TYPE","S_BLKSIZE","S_IEXEC","S_IFBLK","S_IFCHR","S_IFDIR","S_IFIFO","S_IFLNK","S_IFMT","S_IFREG","S_IFSOCK","S_IREAD","S_IRGRP","S_IROTH","S_IRUSR","S_IRWXG","S_IRWXO","S_IRWXU","S_ISGID","S_ISUID","S_ISVTX","S_IWGRP","S_IWOTH","S_IWRITE","S_IWUSR","S_IXGRP","S_IXOTH","S_IXUSR","TCIFLUSH","TCIOFLUSH","TCOFLUSH","TCP_CONGESTION","TCP_CORK","TCP_DEFER_ACCEPT","TCP_INFO","TCP_KEEPCNT","TCP_KEEPIDLE","TCP_KEEPINTVL","TCP_LINGER2","TCP_MAXSEG","TCP_MAXWIN","TCP_MAX_WINSHIFT","TCP_MD5SIG","TCP_MD5SIG_MAXKEYLEN","TCP_MSS","TCP_NODELAY","TCP_QUICKACK","TCP_SYNCNT","TCP_WINDOW_CLAMP","TIOCCBRK","TIOCCONS","TIOCEXCL","TIOCGDEV","TIOCGETD","TIOCGICOUNT","TIOCGLCKTRMIOS","TIOCGPGRP","TIOCGPTN","TIOCGRS485","TIOCGSERIAL","TIOCGSID","TIOCGSOFTCAR","TIOCGWINSZ","TIOCINQ","TIOCLINUX","TIOCMBIC","TIOCMBIS","TIOCMGET","TIOCMIWAIT","TIOCMSET","TIOCM_CAR","TIOCM_CD","TIOCM_CTS","TIOCM_DSR","TIOCM_DTR","TIOCM_LE","TIOCM_RI","TIOCM_RNG","TIOCM_RTS","TIOCM_SR","TIOCM_ST","TIOCNOTTY","TIOCNXCL","TIOCOUTQ","TIOCPKT","TIOCPKT_DATA","TIOCPKT_DOSTOP","TIOCPKT_FLUSHREAD","TIOCPKT_FLUSHWRITE","TIOCPKT_IOCTL","TIOCPKT_NOSTOP","TIOCPKT_START","TIOCPKT_STOP","TIOCSBRK","TIOCSCTTY","TIOCSERCONFIG","TIOCSERGETLSR","TIOCSERGETMULTI","TIOCSERGSTRUCT","TIOCSERGWILD","TIOCSERSETMULTI","TIOCSERSWILD","TIOCSER_TEMT","TIOCSETD","TIOCSIG","TIOCSLCKTRMIOS","TIOCSPGRP","TIOCSPTLCK","TIOCSRS485","TIOCSSERIAL","TIOCSSOFTCAR","TIOCSTI","TIOCSWINSZ","TUNATTACHFILTER","TUNDETACHFILTER","TUNGETFEATURES","TUNGETIFF","TUNGETSNDBUF","TUNGETVNETHDRSZ","TUNSETDEBUG","TUNSETGROUP","TUNSETIFF","TUNSETLINK","TUNSETNOCSUM","TUNSETOFFLOAD","TUNSETOWNER","TUNSETPERSIST","TUNSETSNDBUF","TUNSETTXFILTER","TUNSETVNETHDRSZ","WALL","WCLONE","WCONTINUED","WEXITED","WNOHANG","WNOTHREAD","WNOWAIT","WORDSIZE","WSTOPPED","WUNTRACED","E2BIG","EACCES","EADDRINUSE","EADDRNOTAVAIL","EADV","EAFNOSUPPORT","EAGAIN","EALREADY","EBADE","EBADF","EBADFD","EBADMSG","EBADR","EBADRQC","EBADSLT","EBFONT","EBUSY","ECANCELED","ECHILD","ECHRNG","ECOMM","ECONNABORTED","ECONNREFUSED","ECONNRESET","EDEADLK","EDEADLOCK","EDESTADDRREQ","EDOM","EDOTDOT","EDQUOT","EEXIST","EFAULT","EFBIG","EHOSTDOWN","EHOSTUNREACH","EIDRM","EILSEQ","EINPROGRESS","EINTR","EINVAL","EIO","EISCONN","EISDIR","EISNAM","EKEYEXPIRED","EKEYREJECTED","EKEYREVOKED","EL2HLT","EL2NSYNC","EL3HLT","EL3RST","ELIBACC","ELIBBAD","ELIBEXEC","ELIBMAX","ELIBSCN","ELNRNG","ELOOP","EMEDIUMTYPE","EMFILE","EMLINK","EMSGSIZE","EMULTIHOP","ENAMETOOLONG","ENAVAIL","ENETDOWN","ENETRESET","ENETUNREACH","ENFILE","ENOANO","ENOBUFS","ENOCSI","ENODATA","ENODEV","ENOENT","ENOEXEC","ENOKEY","ENOLCK","ENOLINK","ENOMEDIUM","ENOMEM","ENOMSG","ENONET","ENOPKG","ENOPROTOOPT","ENOSPC","ENOSR","ENOSTR","ENOSYS","ENOTBLK","ENOTCONN","ENOTDIR","ENOTEMPTY","ENOTNAM","ENOTRECOVERABLE","ENOTSOCK","ENOTSUP","ENOTTY","ENOTUNIQ","ENXIO","EOPNOTSUPP","EOVERFLOW","EOWNERDEAD","EPERM","EPFNOSUPPORT","EPIPE","EPROTO","EPROTONOSUPPORT","EPROTOTYPE","ERANGE","EREMCHG","EREMOTE","EREMOTEIO","ERESTART","ERFKILL","EROFS","ESHUTDOWN","ESOCKTNOSUPPORT","ESPIPE","ESRCH","ESRMNT","ESTALE","ESTRPIPE","ETIME","ETIMEDOUT","ETOOMANYREFS","ETXTBSY","EUCLEAN","EUNATCH","EUSERS","EWOULDBLOCK","EXDEV","EXFULL","SIGABRT","SIGALRM","SIGBUS","SIGCHLD","SIGCLD","SIGCONT","SIGFPE","SIGHUP","SIGILL","SIGINT","SIGIO","SIGIOT","SIGKILL","SIGPIPE","SIGPOLL","SIGPROF","SIGPWR","SIGQUIT","SIGSEGV","SIGSTKFLT","SIGSTOP","SIGSYS","SIGTERM","SIGTRAP","SIGTSTP","SIGTTIN","SIGTTOU","SIGUNUSED","SIGURG","SIGUSR1","SIGUSR2","SIGVTALRM","SIGWINCH","SIGXCPU","SIGXFSZ","Getcwd","Acct","Adjtimex","Chdir","Chroot","Close","Dup","Dup3","EpollCreate1","EpollCtl","Fallocate","Fchdir","Fchmod","Fchownat","Fdatasync","Flock","Fsync","Getdents","Getpgid","Getpid","Getppid","Getpriority","Getrusage","Gettid","Getxattr","InotifyAddWatch","InotifyInit1","InotifyRmWatch","Kill","Klogctl","Listxattr","Mkdirat","Mknodat","Nanosleep","PivotRoot","Removexattr","Setdomainname","Sethostname","Setpgid","Setsid","Settimeofday","Setpriority","Setxattr","Sync","Sysinfo","Tee","Tgkill","Times","Umask","Uname","Unmount","Unshare","Madvise","Mprotect","Mlock","Munlock","Mlockall","Munlockall","Dup2","Fchown","Fstat","Fstatfs","Ftruncate","Getegid","Geteuid","Getgid","Getrlimit","Getuid","InotifyInit","Ioperm","Iopl","Listen","Pause","Renameat","Seek","Select","Setfsgid","Setfsuid","Shutdown","Splice","Statfs","SyncFileRange","Truncate","Ustat","EpollWait","Utime","SYS_READ","SYS_WRITE","SYS_OPEN","SYS_CLOSE","SYS_STAT","SYS_FSTAT","SYS_LSTAT","SYS_POLL","SYS_LSEEK","SYS_MMAP","SYS_MPROTECT","SYS_MUNMAP","SYS_BRK","SYS_RT_SIGACTION","SYS_RT_SIGPROCMASK","SYS_RT_SIGRETURN","SYS_IOCTL","SYS_PREAD64","SYS_PWRITE64","SYS_READV","SYS_WRITEV","SYS_ACCESS","SYS_PIPE","SYS_SELECT","SYS_SCHED_YIELD","SYS_MREMAP","SYS_MSYNC","SYS_MINCORE","SYS_MADVISE","SYS_SHMGET","SYS_SHMAT","SYS_SHMCTL","SYS_DUP","SYS_DUP2","SYS_PAUSE","SYS_NANOSLEEP","SYS_GETITIMER","SYS_ALARM","SYS_SETITIMER","SYS_GETPID","SYS_SENDFILE","SYS_SOCKET","SYS_CONNECT","SYS_ACCEPT","SYS_SENDTO","SYS_RECVFROM","SYS_SENDMSG","SYS_RECVMSG","SYS_SHUTDOWN","SYS_BIND","SYS_LISTEN","SYS_GETSOCKNAME","SYS_GETPEERNAME","SYS_SOCKETPAIR","SYS_SETSOCKOPT","SYS_GETSOCKOPT","SYS_CLONE","SYS_FORK","SYS_VFORK","SYS_EXECVE","SYS_EXIT","SYS_WAIT4","SYS_KILL","SYS_UNAME","SYS_SEMGET","SYS_SEMOP","SYS_SEMCTL","SYS_SHMDT","SYS_MSGGET","SYS_MSGSND","SYS_MSGRCV","SYS_MSGCTL","SYS_FCNTL","SYS_FLOCK","SYS_FSYNC","SYS_FDATASYNC","SYS_TRUNCATE","SYS_FTRUNCATE","SYS_GETDENTS","SYS_GETCWD","SYS_CHDIR","SYS_FCHDIR","SYS_RENAME","SYS_MKDIR","SYS_RMDIR","SYS_CREAT","SYS_LINK","SYS_UNLINK","SYS_SYMLINK","SYS_READLINK","SYS_CHMOD","SYS_FCHMOD","SYS_CHOWN","SYS_FCHOWN","SYS_LCHOWN","SYS_UMASK","SYS_GETTIMEOFDAY","SYS_GETRLIMIT","SYS_GETRUSAGE","SYS_SYSINFO","SYS_TIMES","SYS_PTRACE","SYS_GETUID","SYS_SYSLOG","SYS_GETGID","SYS_SETUID","SYS_SETGID","SYS_GETEUID","SYS_GETEGID","SYS_SETPGID","SYS_GETPPID","SYS_GETPGRP","SYS_SETSID","SYS_SETREUID","SYS_SETREGID","SYS_GETGROUPS","SYS_SETGROUPS","SYS_SETRESUID","SYS_GETRESUID","SYS_SETRESGID","SYS_GETRESGID","SYS_GETPGID","SYS_SETFSUID","SYS_SETFSGID","SYS_GETSID","SYS_CAPGET","SYS_CAPSET","SYS_RT_SIGPENDING","SYS_RT_SIGTIMEDWAIT","SYS_RT_SIGQUEUEINFO","SYS_RT_SIGSUSPEND","SYS_SIGALTSTACK","SYS_UTIME","SYS_MKNOD","SYS_USELIB","SYS_PERSONALITY","SYS_USTAT","SYS_STATFS","SYS_FSTATFS","SYS_SYSFS","SYS_GETPRIORITY","SYS_SETPRIORITY","SYS_SCHED_SETPARAM","SYS_SCHED_GETPARAM","SYS_SCHED_SETSCHEDULER","SYS_SCHED_GETSCHEDULER","SYS_SCHED_GET_PRIORITY_MAX","SYS_SCHED_GET_PRIORITY_MIN","SYS_SCHED_RR_GET_INTERVAL","SYS_MLOCK","SYS_MUNLOCK","SYS_MLOCKALL","SYS_MUNLOCKALL","SYS_VHANGUP","SYS_MODIFY_LDT","SYS_PIVOT_ROOT","SYS__SYSCTL","SYS_PRCTL","SYS_ARCH_PRCTL","SYS_ADJTIMEX","SYS_SETRLIMIT","SYS_CHROOT","SYS_SYNC","SYS_ACCT","SYS_SETTIMEOFDAY","SYS_MOUNT","SYS_UMOUNT2","SYS_SWAPON","SYS_SWAPOFF","SYS_REBOOT","SYS_SETHOSTNAME","SYS_SETDOMAINNAME","SYS_IOPL","SYS_IOPERM","SYS_CREATE_MODULE","SYS_INIT_MODULE","SYS_DELETE_MODULE","SYS_GET_KERNEL_SYMS","SYS_QUERY_MODULE","SYS_QUOTACTL","SYS_NFSSERVCTL","SYS_GETPMSG","SYS_PUTPMSG","SYS_AFS_SYSCALL","SYS_TUXCALL","SYS_SECURITY","SYS_GETTID","SYS_READAHEAD","SYS_SETXATTR","SYS_LSETXATTR","SYS_FSETXATTR","SYS_GETXATTR","SYS_LGETXATTR","SYS_FGETXATTR","SYS_LISTXATTR","SYS_LLISTXATTR","SYS_FLISTXATTR","SYS_REMOVEXATTR","SYS_LREMOVEXATTR","SYS_FREMOVEXATTR","SYS_TKILL","SYS_TIME","SYS_FUTEX","SYS_SCHED_SETAFFINITY","SYS_SCHED_GETAFFINITY","SYS_SET_THREAD_AREA","SYS_IO_SETUP","SYS_IO_DESTROY","SYS_IO_GETEVENTS","SYS_IO_SUBMIT","SYS_IO_CANCEL","SYS_GET_THREAD_AREA","SYS_LOOKUP_DCOOKIE","SYS_EPOLL_CREATE","SYS_EPOLL_CTL_OLD","SYS_EPOLL_WAIT_OLD","SYS_REMAP_FILE_PAGES","SYS_GETDENTS64","SYS_SET_TID_ADDRESS","SYS_RESTART_SYSCALL","SYS_SEMTIMEDOP","SYS_FADVISE64","SYS_TIMER_CREATE","SYS_TIMER_SETTIME","SYS_TIMER_GETTIME","SYS_TIMER_GETOVERRUN","SYS_TIMER_DELETE","SYS_CLOCK_SETTIME","SYS_CLOCK_GETTIME","SYS_CLOCK_GETRES","SYS_CLOCK_NANOSLEEP","SYS_EXIT_GROUP","SYS_EPOLL_WAIT","SYS_EPOLL_CTL","SYS_TGKILL","SYS_UTIMES","SYS_VSERVER","SYS_MBIND","SYS_SET_MEMPOLICY","SYS_GET_MEMPOLICY","SYS_MQ_OPEN","SYS_MQ_UNLINK","SYS_MQ_TIMEDSEND","SYS_MQ_TIMEDRECEIVE","SYS_MQ_NOTIFY","SYS_MQ_GETSETATTR","SYS_KEXEC_LOAD","SYS_WAITID","SYS_ADD_KEY","SYS_REQUEST_KEY","SYS_KEYCTL","SYS_IOPRIO_SET","SYS_IOPRIO_GET","SYS_INOTIFY_INIT","SYS_INOTIFY_ADD_WATCH","SYS_INOTIFY_RM_WATCH","SYS_MIGRATE_PAGES","SYS_OPENAT","SYS_MKDIRAT","SYS_MKNODAT","SYS_FCHOWNAT","SYS_FUTIMESAT","SYS_NEWFSTATAT","SYS_UNLINKAT","SYS_RENAMEAT","SYS_LINKAT","SYS_SYMLINKAT","SYS_READLINKAT","SYS_FCHMODAT","SYS_FACCESSAT","SYS_PSELECT6","SYS_PPOLL","SYS_UNSHARE","SYS_SET_ROBUST_LIST","SYS_GET_ROBUST_LIST","SYS_SPLICE","SYS_TEE","SYS_SYNC_FILE_RANGE","SYS_VMSPLICE","SYS_MOVE_PAGES","SYS_UTIMENSAT","SYS_EPOLL_PWAIT","SYS_SIGNALFD","SYS_TIMERFD_CREATE","SYS_EVENTFD","SYS_FALLOCATE","SYS_TIMERFD_SETTIME","SYS_TIMERFD_GETTIME","SYS_ACCEPT4","SYS_SIGNALFD4","SYS_EVENTFD2","SYS_EPOLL_CREATE1","SYS_DUP3","SYS_PIPE2","SYS_INOTIFY_INIT1","SYS_PREADV","SYS_PWRITEV","SYS_RT_TGSIGQUEUEINFO","SYS_PERF_EVENT_OPEN","SYS_RECVMMSG","SYS_FANOTIFY_INIT","SYS_FANOTIFY_MARK","SYS_PRLIMIT64","PathMax","Timespec","Timeval","Timex","Time_t","Tms","Utimbuf","Rusage","Rlimit","Stat_t","Statfs_t","Dirent","Fsid","Flock_t","RawSockaddrInet4","RawSockaddrInet6","RawSockaddrUnix","RawSockaddrLinklayer","RawSockaddrNetlink","RawSockaddr","RawSockaddrAny","Linger","Iovec","IPMreq","IPMreqn","IPv6Mreq","Msghdr","Cmsghdr","Inet4Pktinfo","Inet6Pktinfo","IPv6MTUInfo","ICMPv6Filter","Ucred","TCPInfo","SizeofSockaddrInet4","SizeofSockaddrInet6","SizeofSockaddrAny","SizeofSockaddrUnix","SizeofSockaddrLinklayer","SizeofSockaddrNetlink","SizeofLinger","SizeofIPMreq","SizeofIPMreqn","SizeofIPv6Mreq","SizeofMsghdr","SizeofCmsghdr","SizeofInet4Pktinfo","SizeofInet6Pktinfo","SizeofIPv6MTUInfo","SizeofICMPv6Filter","SizeofUcred","SizeofTCPInfo","IFA_UNSPEC","IFA_ADDRESS","IFA_LOCAL","IFA_LABEL","IFA_BROADCAST","IFA_ANYCAST","IFA_CACHEINFO","IFA_MULTICAST","IFLA_UNSPEC","IFLA_ADDRESS","IFLA_BROADCAST","IFLA_IFNAME","IFLA_MTU","IFLA_LINK","IFLA_QDISC","IFLA_STATS","IFLA_COST","IFLA_PRIORITY","IFLA_MASTER","IFLA_WIRELESS","IFLA_PROTINFO","IFLA_TXQLEN","IFLA_MAP","IFLA_WEIGHT","IFLA_OPERSTATE","IFLA_LINKMODE","IFLA_LINKINFO","IFLA_NET_NS_PID","IFLA_IFALIAS","IFLA_MAX","RT_SCOPE_UNIVERSE","RT_SCOPE_SITE","RT_SCOPE_LINK","RT_SCOPE_HOST","RT_SCOPE_NOWHERE","RT_TABLE_UNSPEC","RT_TABLE_COMPAT","RT_TABLE_DEFAULT","RT_TABLE_MAIN","RT_TABLE_LOCAL","RT_TABLE_MAX","RTA_UNSPEC","RTA_DST","RTA_SRC","RTA_IIF","RTA_OIF","RTA_GATEWAY","RTA_PRIORITY","RTA_PREFSRC","RTA_METRICS","RTA_MULTIPATH","RTA_FLOW","RTA_CACHEINFO","RTA_TABLE","RTN_UNSPEC","RTN_UNICAST","RTN_LOCAL","RTN_BROADCAST","RTN_ANYCAST","RTN_MULTICAST","RTN_BLACKHOLE","RTN_UNREACHABLE","RTN_PROHIBIT","RTN_THROW","RTN_NAT","RTN_XRESOLVE","RTNLGRP_NONE","RTNLGRP_LINK","RTNLGRP_NOTIFY","RTNLGRP_NEIGH","RTNLGRP_TC","RTNLGRP_IPV4_IFADDR","RTNLGRP_IPV4_MROUTE","RTNLGRP_IPV4_ROUTE","RTNLGRP_IPV4_RULE","RTNLGRP_IPV6_IFADDR","RTNLGRP_IPV6_MROUTE","RTNLGRP_IPV6_ROUTE","RTNLGRP_IPV6_IFINFO","RTNLGRP_IPV6_PREFIX","RTNLGRP_IPV6_RULE","RTNLGRP_ND_USEROPT","SizeofNlMsghdr","SizeofNlMsgerr","SizeofRtGenmsg","SizeofNlAttr","SizeofRtAttr","SizeofIfInfomsg","SizeofIfAddrmsg","SizeofRtMsg","SizeofRtNexthop","NlMsghdr","NlMsgerr","RtGenmsg","NlAttr","RtAttr","IfInfomsg","IfAddrmsg","RtMsg","RtNexthop","SizeofSockFilter","SizeofSockFprog","SockFilter","SockFprog","InotifyEvent","SizeofInotifyEvent","PtraceRegs","FdSet","Sysinfo_t","Utsname","Ustat_t","EpollEvent","Termios","VINTR","VQUIT","VERASE","VKILL","VEOF","VTIME","VMIN","VSWTC","VSTART","VSTOP","VSUSP","VEOL","VREPRINT","VDISCARD","VWERASE","VLNEXT","VEOL2","IGNBRK","BRKINT","IGNPAR","PARMRK","INPCK","ISTRIP","INLCR","IGNCR","ICRNL","IUCLC","IXON","IXANY","IXOFF","IMAXBEL","IUTF8","OPOST","OLCUC","ONLCR","OCRNL","ONOCR","ONLRET","OFILL","OFDEL","B0","B50","B75","B110","B134","B150","B200","B300","B600","B1200","B1800","B2400","B4800","B9600","B19200","B38400","CSIZE","CS5","CS6","CS7","CS8","CSTOPB","CREAD","PARENB","PARODD","HUPCL","CLOCAL","B57600","B115200","B230400","B460800","B500000","B576000","B921600","B1000000","B1152000","B1500000","B2000000","B2500000","B3000000","B3500000","B4000000","ISIG","ICANON","XCASE","ECHO","ECHOE","ECHOK","ECHONL","NOFLSH","TOSTOP","ECHOCTL","ECHOPRT","ECHOKE","FLUSHO","PENDIN","IEXTEN","TCGETS","TCSETS","AllocsPerRun","InternalBenchmark","B","BenchmarkResult","RunBenchmarks","PB","Benchmark","CoverBlock","Cover","Coverage","RegisterCover","InternalExample","RunExamples","InternalFuzzTarget","F","Init","Short","Testing","CoverMode","Verbose","TB","T","InternalTest","Main","M","MainStart","RunTests","Layout","ANSIC","UnixDate","RubyDate","RFC822","RFC822Z","RFC850","RFC1123","RFC1123Z","RFC3339","RFC3339Nano","Kitchen","Stamp","StampMilli","StampMicro","StampNano","DateTime","DateOnly","TimeOnly","ParseError","Parse","ParseInLocation","ParseDuration","Sleep","Timer","NewTimer","After","AfterFunc","Ticker","NewTicker","Tick","Time","Month","January","February","March","April","May","June","July","August","September","October","November","December","Weekday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Duration","Nanosecond","Microsecond","Millisecond","Second","Minute","Hour","Since","Until","Now","Unix","UnixMilli","UnixMicro","Date","Location","UTC","Local","FixedZone","LoadLocation","LoadLocationFromTZData","TurkishCase","AzeriCase","IsDigit","GraphicRanges","PrintRanges","IsGraphic","IsPrint","IsOneOf","In","IsControl","IsLetter","IsMark","IsNumber","IsPunct","IsSpace","IsSymbol","MaxRune","ReplacementChar","MaxASCII","MaxLatin1","RangeTable","Range16","Range32","CaseRange","SpecialCase","UpperCase","LowerCase","TitleCase","MaxCase","UpperLower","Is","IsUpper","IsLower","IsTitle","To","ToUpper","ToLower","ToTitle","SimpleFold","Version","Categories","Cc","Cf","Co","Cs","Digit","Nd","Letter","L","Lm","Lo","Lower","Ll","Mark","M","Mc","Me","Mn","Nl","No","Number","N","Other","C","Pc","Pd","Pe","Pf","Pi","Po","Ps","Punct","P","Sc","Sk","Sm","So","Space","Z","Symbol","S","Title","Lt","Upper","Lu","Zl","Zp","Zs","Scripts","Adlam","Ahom","Anatolian_Hieroglyphs","Arabic","Armenian","Avestan","Balinese","Bamum","Bassa_Vah","Batak","Bengali","Bhaiksuki","Bopomofo","Brahmi","Braille","Buginese","Buhid","Canadian_Aboriginal","Carian","Caucasian_Albanian","Chakma","Cham","Cherokee","Chorasmian","Common","Coptic","Cuneiform","Cypriot","Cypro_Minoan","Cyrillic","Deseret","Devanagari","Dives_Akuru","Dogra","Duployan","Egyptian_Hieroglyphs","Elbasan","Elymaic","Ethiopic","Georgian","Glagolitic","Gothic","Grantha","Greek","Gujarati","Gunjala_Gondi","Gurmukhi","Han","Hangul","Hanifi_Rohingya","Hanunoo","Hatran","Hebrew","Hiragana","Imperial_Aramaic","Inherited","Inscriptional_Pahlavi","Inscriptional_Parthian","Javanese","Kaithi","Kannada","Katakana","Kawi","Kayah_Li","Kharoshthi","Khitan_Small_Script","Khmer","Khojki","Khudawadi","Lao","Latin","Lepcha","Limbu","Linear_A","Linear_B","Lisu","Lycian","Lydian","Mahajani","Makasar","Malayalam","Mandaic","Manichaean","Marchen","Masaram_Gondi","Medefaidrin","Meetei_Mayek","Mende_Kikakui","Meroitic_Cursive","Meroitic_Hieroglyphs","Miao","Modi","Mongolian","Mro","Multani","Myanmar","Nabataean","Nag_Mundari","Nandinagari","New_Tai_Lue","Newa","Nko","Nushu","Nyiakeng_Puachue_Hmong","Ogham","Ol_Chiki","Old_Hungarian","Old_Italic","Old_North_Arabian","Old_Permic","Old_Persian","Old_Sogdian","Old_South_Arabian","Old_Turkic","Old_Uyghur","Oriya","Osage","Osmanya","Pahawh_Hmong","Palmyrene","Pau_Cin_Hau","Phags_Pa","Phoenician","Psalter_Pahlavi","Rejang","Runic","Samaritan","Saurashtra","Sharada","Shavian","Siddham","SignWriting","Sinhala","Sogdian","Sora_Sompeng","Soyombo","Sundanese","Syloti_Nagri","Syriac","Tagalog","Tagbanwa","Tai_Le","Tai_Tham","Tai_Viet","Takri","Tamil","Tangsa","Tangut","Telugu","Thaana","Thai","Tibetan","Tifinagh","Tirhuta","Toto","Ugaritic","Vai","Vithkuqi","Wancho","Warang_Citi","Yezidi","Yi","Zanabazar_Square","Properties","ASCII_Hex_Digit","Bidi_Control","Dash","Deprecated","Diacritic","Extender","Hex_Digit","Hyphen","IDS_Binary_Operator","IDS_Trinary_Operator","Ideographic","Join_Control","Logical_Order_Exception","Noncharacter_Code_Point","Other_Alphabetic","Other_Default_Ignorable_Code_Point","Other_Grapheme_Extend","Other_ID_Continue","Other_ID_Start","Other_Lowercase","Other_Math","Other_Uppercase","Pattern_Syntax","Pattern_White_Space","Prepended_Concatenation_Mark","Quotation_Mark","Radical","Regional_Indicator","STerm","Sentence_Terminal","Soft_Dotted","Terminal_Punctuation","Unified_Ideograph","Variation_Selector","White_Space","CaseRanges","FoldCategory","FoldScript","Handle","Make","ArbitraryType","IntegerType","Pointer","Sizeof","Offsetof","Alignof","Add","Slice","SliceData","String","StringData","ErrHeader","ErrWriteTooLong","ErrFieldTooLong","ErrWriteAfterClose","ErrInsecurePath","TypeReg","TypeRegA","TypeLink","TypeSymlink","TypeChar","TypeBlock","TypeDir","TypeFifo","TypeCont","TypeXHeader","TypeXGlobalHeader","TypeGNUSparse","TypeGNULongName","TypeGNULongLink","Header","FileInfoHeader","FileInfoNames","Format","FormatUnknown","FormatUSTAR","FormatPAX","FormatGNU","Reader","NewReader","Writer","NewWriter","ErrFormat","ErrAlgorithm","ErrChecksum","ErrInsecurePath","Reader","ReadCloser","File","OpenReader","NewReader","Compressor","Decompressor","RegisterDecompressor","RegisterCompressor","Store","Deflate","FileHeader","FileInfoHeader","Writer","NewWriter","StructuralError","NewReader","NoCompression","BestSpeed","BestCompression","DefaultCompression","HuffmanOnly","NewWriter","NewWriterDict","Writer","CorruptInputError","InternalError","ReadError","WriteError","Resetter","Reader","NewReader","NewReaderDict","ErrChecksum","ErrHeader","Header","Reader","NewReader","NoCompression","BestSpeed","BestCompression","DefaultCompression","HuffmanOnly","Writer","NewWriter","NewWriterLevel","Order","LSB","MSB","Reader","NewReader","Writer","NewWriter","ErrChecksum","ErrDictionary","ErrHeader","Resetter","NewReader","NewReaderDict","NoCompression","BestSpeed","BestCompression","DefaultCompression","HuffmanOnly","Writer","NewWriter","NewWriterLevel","NewWriterLevelDict","Interface","Init","Push","Pop","Remove","Fix","Element","List","New","Ring","New","BlockSize","KeySizeError","NewCipher","NewCBCEncrypter","NewCBCDecrypter","NewCFBEncrypter","NewCFBDecrypter","Block","Stream","BlockMode","NewCTR","AEAD","NewGCM","NewGCMWithNonceSize","NewGCMWithTagSize","StreamReader","StreamWriter","NewOFB","BlockSize","KeySizeError","NewCipher","NewTripleDESCipher","Parameters","PublicKey","PrivateKey","ErrInvalidPublicKey","ParameterSizes","L1024N160","L2048N224","L2048N256","L3072N256","GenerateParameters","GenerateKey","Sign","Verify","Curve","PublicKey","PrivateKey","P256","P384","P521","X25519","PublicKey","PrivateKey","GenerateKey","SignASN1","VerifyASN1","Sign","Verify","PublicKeySize","PrivateKeySize","SignatureSize","SeedSize","PublicKey","PrivateKey","Options","GenerateKey","NewKeyFromSeed","Sign","Verify","VerifyWithOptions","Curve","GenerateKey","Marshal","MarshalCompressed","Unmarshal","UnmarshalCompressed","P224","P256","P384","P521","CurveParams","New","Equal","Size","BlockSize","New","Sum","Reader","Read","Prime","Int","Cipher","KeySizeError","NewCipher","PKCS1v15DecryptOptions","EncryptPKCS1v15","DecryptPKCS1v15","DecryptPKCS1v15SessionKey","SignPKCS1v15","VerifyPKCS1v15","PSSSaltLengthAuto","PSSSaltLengthEqualsHash","PSSOptions","SignPSS","VerifyPSS","PublicKey","OAEPOptions","PrivateKey","PrecomputedValues","CRTValue","GenerateKey","GenerateMultiPrimeKey","ErrMessageTooLong","EncryptOAEP","ErrDecryption","ErrVerification","DecryptOAEP","Size","BlockSize","New","Sum","Size","Size224","BlockSize","New","New224","Sum256","Sum224","Size","Size224","Size256","Size384","BlockSize","New","New512_224","New512_256","New384","Sum512","Sum384","Sum512_224","Sum512_256","ConstantTimeCompare","ConstantTimeSelect","ConstantTimeByteEq","ConstantTimeEq","ConstantTimeCopy","ConstantTimeLessOrEq","XORBytes","AlertError","CipherSuite","CipherSuites","InsecureCipherSuites","CipherSuiteName","TLS_RSA_WITH_RC4_128_SHA","TLS_RSA_WITH_3DES_EDE_CBC_SHA","TLS_RSA_WITH_AES_128_CBC_SHA","TLS_RSA_WITH_AES_256_CBC_SHA","TLS_RSA_WITH_AES_128_CBC_SHA256","TLS_RSA_WITH_AES_128_GCM_SHA256","TLS_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_RC4_128_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_RSA_WITH_RC4_128_SHA","TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256","TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256","TLS_AES_128_GCM_SHA256","TLS_AES_256_GCM_SHA384","TLS_CHACHA20_POLY1305_SHA256","TLS_FALLBACK_SCSV","TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305","TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305","VersionTLS10","VersionTLS11","VersionTLS12","VersionTLS13","VersionSSL30","VersionName","CurveID","CurveP256","CurveP384","CurveP521","X25519","ConnectionState","ClientAuthType","NoClientCert","RequestClientCert","RequireAnyClientCert","VerifyClientCertIfGiven","RequireAndVerifyClientCert","ClientSessionCache","SignatureScheme","PKCS1WithSHA256","PKCS1WithSHA384","PKCS1WithSHA512","PSSWithSHA256","PSSWithSHA384","PSSWithSHA512","ECDSAWithP256AndSHA256","ECDSAWithP384AndSHA384","ECDSAWithP521AndSHA512","Ed25519","PKCS1WithSHA1","ECDSAWithSHA1","ClientHelloInfo","CertificateRequestInfo","RenegotiationSupport","RenegotiateNever","RenegotiateOnceAsClient","RenegotiateFreelyAsClient","Config","Certificate","NewLRUClientSessionCache","CertificateVerificationError","Conn","RecordHeaderError","ECHRejectionError","QUICEncryptionLevel","QUICEncryptionLevelInitial","QUICEncryptionLevelEarly","QUICEncryptionLevelHandshake","QUICEncryptionLevelApplication","QUICConn","QUICConfig","QUICEventKind","QUICNoEvent","QUICSetReadSecret","QUICSetWriteSecret","QUICWriteData","QUICTransportParameters","QUICTransportParametersRequired","QUICRejectedEarlyData","QUICHandshakeDone","QUICResumeSession","QUICStoreSession","QUICEvent","QUICClient","QUICServer","QUICSessionTicketOptions","SessionState","ParseSessionState","ClientSessionState","NewResumptionState","Server","Client","NewListener","Listen","DialWithDialer","Dial","Dialer","LoadX509KeyPair","X509KeyPair","CertPool","NewCertPool","SystemCertPool","OID","ParseOID","OIDFromInts","ParseCertificate","ParseCertificates","ParseRevocationList","PEMCipher","PEMCipherDES","PEMCipher3DES","PEMCipherAES128","PEMCipherAES192","PEMCipherAES256","IsEncryptedPEMBlock","IncorrectPasswordError","DecryptPEMBlock","EncryptPEMBlock","ParsePKCS1PrivateKey","MarshalPKCS1PrivateKey","ParsePKCS1PublicKey","MarshalPKCS1PublicKey","ParsePKCS8PrivateKey","MarshalPKCS8PrivateKey","SetFallbackRoots","ParseECPrivateKey","MarshalECPrivateKey","InvalidReason","NotAuthorizedToSign","Expired","CANotAuthorizedForThisName","TooManyIntermediates","IncompatibleUsage","NameMismatch","NameConstraintsWithoutSANs","UnconstrainedName","TooManyConstraints","CANotAuthorizedForExtKeyUsage","CertificateInvalidError","HostnameError","UnknownAuthorityError","SystemRootsError","VerifyOptions","ParsePKIXPublicKey","MarshalPKIXPublicKey","SignatureAlgorithm","UnknownSignatureAlgorithm","MD2WithRSA","MD5WithRSA","SHA1WithRSA","SHA256WithRSA","SHA384WithRSA","SHA512WithRSA","DSAWithSHA1","DSAWithSHA256","ECDSAWithSHA1","ECDSAWithSHA256","ECDSAWithSHA384","ECDSAWithSHA512","SHA256WithRSAPSS","SHA384WithRSAPSS","SHA512WithRSAPSS","PureEd25519","PublicKeyAlgorithm","UnknownPublicKeyAlgorithm","RSA","DSA","ECDSA","Ed25519","KeyUsage","KeyUsageDigitalSignature","KeyUsageContentCommitment","KeyUsageKeyEncipherment","KeyUsageDataEncipherment","KeyUsageKeyAgreement","KeyUsageCertSign","KeyUsageCRLSign","KeyUsageEncipherOnly","KeyUsageDecipherOnly","ExtKeyUsage","ExtKeyUsageAny","ExtKeyUsageServerAuth","ExtKeyUsageClientAuth","ExtKeyUsageCodeSigning","ExtKeyUsageEmailProtection","ExtKeyUsageIPSECEndSystem","ExtKeyUsageIPSECTunnel","ExtKeyUsageIPSECUser","ExtKeyUsageTimeStamping","ExtKeyUsageOCSPSigning","ExtKeyUsageMicrosoftServerGatedCrypto","ExtKeyUsageNetscapeServerGatedCrypto","ExtKeyUsageMicrosoftCommercialCodeSigning","ExtKeyUsageMicrosoftKernelCodeSigning","Certificate","ErrUnsupportedAlgorithm","InsecureAlgorithmError","ConstraintViolationError","UnhandledCriticalExtension","CreateCertificate","ParseCRL","ParseDERCRL","CertificateRequest","CreateCertificateRequest","ParseCertificateRequest","RevocationListEntry","RevocationList","CreateRevocationList","Register","Drivers","NamedArg","Named","IsolationLevel","LevelDefault","LevelReadUncommitted","LevelReadCommitted","LevelWriteCommitted","LevelRepeatableRead","LevelSnapshot","LevelSerializable","LevelLinearizable","TxOptions","RawBytes","NullString","NullInt64","NullInt32","NullInt16","NullByte","NullFloat64","NullBool","NullTime","Null","Scanner","Out","ErrNoRows","DB","OpenDB","Open","DBStats","ErrConnDone","Conn","Tx","ErrTxDone","Stmt","Rows","ColumnType","Row","Result","BuildInfo","ReadFile","Read","DecodeError","Attr","AttrSibling","AttrLocation","AttrName","AttrOrdering","AttrByteSize","AttrBitOffset","AttrBitSize","AttrStmtList","AttrLowpc","AttrHighpc","AttrLanguage","AttrDiscr","AttrDiscrValue","AttrVisibility","AttrImport","AttrStringLength","AttrCommonRef","AttrCompDir","AttrConstValue","AttrContainingType","AttrDefaultValue","AttrInline","AttrIsOptional","AttrLowerBound","AttrProducer","AttrPrototyped","AttrReturnAddr","AttrStartScope","AttrStrideSize","AttrUpperBound","AttrAbstractOrigin","AttrAccessibility","AttrAddrClass","AttrArtificial","AttrBaseTypes","AttrCalling","AttrCount","AttrDataMemberLoc","AttrDeclColumn","AttrDeclFile","AttrDeclLine","AttrDeclaration","AttrDiscrList","AttrEncoding","AttrExternal","AttrFrameBase","AttrFriend","AttrIdentifierCase","AttrMacroInfo","AttrNamelistItem","AttrPriority","AttrSegment","AttrSpecification","AttrStaticLink","AttrType","AttrUseLocation","AttrVarParam","AttrVirtuality","AttrVtableElemLoc","AttrAllocated","AttrAssociated","AttrDataLocation","AttrStride","AttrEntrypc","AttrUseUTF8","AttrExtension","AttrRanges","AttrTrampoline","AttrCallColumn","AttrCallFile","AttrCallLine","AttrDescription","AttrBinaryScale","AttrDecimalScale","AttrSmall","AttrDecimalSign","AttrDigitCount","AttrPictureString","AttrMutable","AttrThreadsScaled","AttrExplicit","AttrObjectPointer","AttrEndianity","AttrElemental","AttrPure","AttrRecursive","AttrSignature","AttrMainSubprogram","AttrDataBitOffset","AttrConstExpr","AttrEnumClass","AttrLinkageName","AttrStringLengthBitSize","AttrStringLengthByteSize","AttrRank","AttrStrOffsetsBase","AttrAddrBase","AttrRnglistsBase","AttrDwoName","AttrReference","AttrRvalueReference","AttrMacros","AttrCallAllCalls","AttrCallAllSourceCalls","AttrCallAllTailCalls","AttrCallReturnPC","AttrCallValue","AttrCallOrigin","AttrCallParameter","AttrCallPC","AttrCallTailCall","AttrCallTarget","AttrCallTargetClobbered","AttrCallDataLocation","AttrCallDataValue","AttrNoreturn","AttrAlignment","AttrExportSymbols","AttrDeleted","AttrDefaulted","AttrLoclistsBase","Tag","TagArrayType","TagClassType","TagEntryPoint","TagEnumerationType","TagFormalParameter","TagImportedDeclaration","TagLabel","TagLexDwarfBlock","TagMember","TagPointerType","TagReferenceType","TagCompileUnit","TagStringType","TagStructType","TagSubroutineType","TagTypedef","TagUnionType","TagUnspecifiedParameters","TagVariant","TagCommonDwarfBlock","TagCommonInclusion","TagInheritance","TagInlinedSubroutine","TagModule","TagPtrToMemberType","TagSetType","TagSubrangeType","TagWithStmt","TagAccessDeclaration","TagBaseType","TagCatchDwarfBlock","TagConstType","TagConstant","TagEnumerator","TagFileType","TagFriend","TagNamelist","TagNamelistItem","TagPackedType","TagSubprogram","TagTemplateTypeParameter","TagTemplateValueParameter","TagThrownType","TagTryDwarfBlock","TagVariantPart","TagVariable","TagVolatileType","TagDwarfProcedure","TagRestrictType","TagInterfaceType","TagNamespace","TagImportedModule","TagUnspecifiedType","TagPartialUnit","TagImportedUnit","TagMutableType","TagCondition","TagSharedType","TagTypeUnit","TagRvalueReferenceType","TagTemplateAlias","TagCoarrayType","TagGenericSubrange","TagDynamicType","TagAtomicType","TagCallSite","TagCallSiteParameter","TagSkeletonUnit","TagImmutableType","Entry","Field","Class","ClassUnknown","ClassAddress","ClassBlock","ClassConstant","ClassExprLoc","ClassFlag","ClassLinePtr","ClassLocListPtr","ClassMacPtr","ClassRangeListPtr","ClassReference","ClassReferenceSig","ClassString","ClassReferenceAlt","ClassStringAlt","ClassAddrPtr","ClassLocList","ClassRngList","ClassRngListsPtr","ClassStrOffsetsPtr","Offset","Reader","LineReader","LineEntry","LineFile","LineReaderPos","ErrUnknownPC","Data","New","Type","CommonType","BasicType","CharType","UcharType","IntType","UintType","FloatType","ComplexType","BoolType","AddrType","UnspecifiedType","QualType","ArrayType","VoidType","PtrType","StructType","StructField","EnumType","EnumValue","FuncType","DotDotDotType","TypedefType","UnsupportedType","EI_CLASS","EI_DATA","EI_VERSION","EI_OSABI","EI_ABIVERSION","EI_PAD","EI_NIDENT","ELFMAG","Version","EV_NONE","EV_CURRENT","Class","ELFCLASSNONE","ELFCLASS32","ELFCLASS64","Data","ELFDATANONE","ELFDATA2LSB","ELFDATA2MSB","OSABI","ELFOSABI_NONE","ELFOSABI_HPUX","ELFOSABI_NETBSD","ELFOSABI_LINUX","ELFOSABI_HURD","ELFOSABI_86OPEN","ELFOSABI_SOLARIS","ELFOSABI_AIX","ELFOSABI_IRIX","ELFOSABI_FREEBSD","ELFOSABI_TRU64","ELFOSABI_MODESTO","ELFOSABI_OPENBSD","ELFOSABI_OPENVMS","ELFOSABI_NSK","ELFOSABI_AROS","ELFOSABI_FENIXOS","ELFOSABI_CLOUDABI","ELFOSABI_ARM","ELFOSABI_STANDALONE","Type","ET_NONE","ET_REL","ET_EXEC","ET_DYN","ET_CORE","ET_LOOS","ET_HIOS","ET_LOPROC","ET_HIPROC","Machine","EM_NONE","EM_M32","EM_SPARC","EM_386","EM_68K","EM_88K","EM_860","EM_MIPS","EM_S370","EM_MIPS_RS3_LE","EM_PARISC","EM_VPP500","EM_SPARC32PLUS","EM_960","EM_PPC","EM_PPC64","EM_S390","EM_V800","EM_FR20","EM_RH32","EM_RCE","EM_ARM","EM_SH","EM_SPARCV9","EM_TRICORE","EM_ARC","EM_H8_300","EM_H8_300H","EM_H8S","EM_H8_500","EM_IA_64","EM_MIPS_X","EM_COLDFIRE","EM_68HC12","EM_MMA","EM_PCP","EM_NCPU","EM_NDR1","EM_STARCORE","EM_ME16","EM_ST100","EM_TINYJ","EM_X86_64","EM_PDSP","EM_PDP10","EM_PDP11","EM_FX66","EM_ST9PLUS","EM_ST7","EM_68HC16","EM_68HC11","EM_68HC08","EM_68HC05","EM_SVX","EM_ST19","EM_VAX","EM_CRIS","EM_JAVELIN","EM_FIREPATH","EM_ZSP","EM_MMIX","EM_HUANY","EM_PRISM","EM_AVR","EM_FR30","EM_D10V","EM_D30V","EM_V850","EM_M32R","EM_MN10300","EM_MN10200","EM_PJ","EM_OPENRISC","EM_ARC_COMPACT","EM_XTENSA","EM_VIDEOCORE","EM_TMM_GPP","EM_NS32K","EM_TPC","EM_SNP1K","EM_ST200","EM_IP2K","EM_MAX","EM_CR","EM_F2MC16","EM_MSP430","EM_BLACKFIN","EM_SE_C33","EM_SEP","EM_ARCA","EM_UNICORE","EM_EXCESS","EM_DXP","EM_ALTERA_NIOS2","EM_CRX","EM_XGATE","EM_C166","EM_M16C","EM_DSPIC30F","EM_CE","EM_M32C","EM_TSK3000","EM_RS08","EM_SHARC","EM_ECOG2","EM_SCORE7","EM_DSP24","EM_VIDEOCORE3","EM_LATTICEMICO32","EM_SE_C17","EM_TI_C6000","EM_TI_C2000","EM_TI_C5500","EM_TI_ARP32","EM_TI_PRU","EM_MMDSP_PLUS","EM_CYPRESS_M8C","EM_R32C","EM_TRIMEDIA","EM_QDSP6","EM_8051","EM_STXP7X","EM_NDS32","EM_ECOG1","EM_ECOG1X","EM_MAXQ30","EM_XIMO16","EM_MANIK","EM_CRAYNV2","EM_RX","EM_METAG","EM_MCST_ELBRUS","EM_ECOG16","EM_CR16","EM_ETPU","EM_SLE9X","EM_L10M","EM_K10M","EM_AARCH64","EM_AVR32","EM_STM8","EM_TILE64","EM_TILEPRO","EM_MICROBLAZE","EM_CUDA","EM_TILEGX","EM_CLOUDSHIELD","EM_COREA_1ST","EM_COREA_2ND","EM_ARC_COMPACT2","EM_OPEN8","EM_RL78","EM_VIDEOCORE5","EM_78KOR","EM_56800EX","EM_BA1","EM_BA2","EM_XCORE","EM_MCHP_PIC","EM_INTEL205","EM_INTEL206","EM_INTEL207","EM_INTEL208","EM_INTEL209","EM_KM32","EM_KMX32","EM_KMX16","EM_KMX8","EM_KVARC","EM_CDP","EM_COGE","EM_COOL","EM_NORC","EM_CSR_KALIMBA","EM_Z80","EM_VISIUM","EM_FT32","EM_MOXIE","EM_AMDGPU","EM_RISCV","EM_LANAI","EM_BPF","EM_LOONGARCH","EM_486","EM_MIPS_RS4_BE","EM_ALPHA_STD","EM_ALPHA","SectionIndex","SHN_UNDEF","SHN_LORESERVE","SHN_LOPROC","SHN_HIPROC","SHN_LOOS","SHN_HIOS","SHN_ABS","SHN_COMMON","SHN_XINDEX","SHN_HIRESERVE","SectionType","SHT_NULL","SHT_PROGBITS","SHT_SYMTAB","SHT_STRTAB","SHT_RELA","SHT_HASH","SHT_DYNAMIC","SHT_NOTE","SHT_NOBITS","SHT_REL","SHT_SHLIB","SHT_DYNSYM","SHT_INIT_ARRAY","SHT_FINI_ARRAY","SHT_PREINIT_ARRAY","SHT_GROUP","SHT_SYMTAB_SHNDX","SHT_LOOS","SHT_GNU_ATTRIBUTES","SHT_GNU_HASH","SHT_GNU_LIBLIST","SHT_GNU_VERDEF","SHT_GNU_VERNEED","SHT_GNU_VERSYM","SHT_HIOS","SHT_LOPROC","SHT_MIPS_ABIFLAGS","SHT_HIPROC","SHT_LOUSER","SHT_HIUSER","SectionFlag","SHF_WRITE","SHF_ALLOC","SHF_EXECINSTR","SHF_MERGE","SHF_STRINGS","SHF_INFO_LINK","SHF_LINK_ORDER","SHF_OS_NONCONFORMING","SHF_GROUP","SHF_TLS","SHF_COMPRESSED","SHF_MASKOS","SHF_MASKPROC","CompressionType","COMPRESS_ZLIB","COMPRESS_ZSTD","COMPRESS_LOOS","COMPRESS_HIOS","COMPRESS_LOPROC","COMPRESS_HIPROC","ProgType","PT_NULL","PT_LOAD","PT_DYNAMIC","PT_INTERP","PT_NOTE","PT_SHLIB","PT_PHDR","PT_TLS","PT_LOOS","PT_GNU_EH_FRAME","PT_GNU_STACK","PT_GNU_RELRO","PT_GNU_PROPERTY","PT_GNU_MBIND_LO","PT_GNU_MBIND_HI","PT_PAX_FLAGS","PT_OPENBSD_RANDOMIZE","PT_OPENBSD_WXNEEDED","PT_OPENBSD_NOBTCFI","PT_OPENBSD_BOOTDATA","PT_SUNW_EH_FRAME","PT_SUNWSTACK","PT_HIOS","PT_LOPROC","PT_ARM_ARCHEXT","PT_ARM_EXIDX","PT_AARCH64_ARCHEXT","PT_AARCH64_UNWIND","PT_MIPS_REGINFO","PT_MIPS_RTPROC","PT_MIPS_OPTIONS","PT_MIPS_ABIFLAGS","PT_S390_PGSTE","PT_HIPROC","ProgFlag","PF_X","PF_W","PF_R","PF_MASKOS","PF_MASKPROC","DynTag","DT_NULL","DT_NEEDED","DT_PLTRELSZ","DT_PLTGOT","DT_HASH","DT_STRTAB","DT_SYMTAB","DT_RELA","DT_RELASZ","DT_RELAENT","DT_STRSZ","DT_SYMENT","DT_INIT","DT_FINI","DT_SONAME","DT_RPATH","DT_SYMBOLIC","DT_REL","DT_RELSZ","DT_RELENT","DT_PLTREL","DT_DEBUG","DT_TEXTREL","DT_JMPREL","DT_BIND_NOW","DT_INIT_ARRAY","DT_FINI_ARRAY","DT_INIT_ARRAYSZ","DT_FINI_ARRAYSZ","DT_RUNPATH","DT_FLAGS","DT_ENCODING","DT_PREINIT_ARRAY","DT_PREINIT_ARRAYSZ","DT_SYMTAB_SHNDX","DT_LOOS","DT_HIOS","DT_VALRNGLO","DT_GNU_PRELINKED","DT_GNU_CONFLICTSZ","DT_GNU_LIBLISTSZ","DT_CHECKSUM","DT_PLTPADSZ","DT_MOVEENT","DT_MOVESZ","DT_FEATURE","DT_POSFLAG_1","DT_SYMINSZ","DT_SYMINENT","DT_VALRNGHI","DT_ADDRRNGLO","DT_GNU_HASH","DT_TLSDESC_PLT","DT_TLSDESC_GOT","DT_GNU_CONFLICT","DT_GNU_LIBLIST","DT_CONFIG","DT_DEPAUDIT","DT_AUDIT","DT_PLTPAD","DT_MOVETAB","DT_SYMINFO","DT_ADDRRNGHI","DT_VERSYM","DT_RELACOUNT","DT_RELCOUNT","DT_FLAGS_1","DT_VERDEF","DT_VERDEFNUM","DT_VERNEED","DT_VERNEEDNUM","DT_LOPROC","DT_MIPS_RLD_VERSION","DT_MIPS_TIME_STAMP","DT_MIPS_ICHECKSUM","DT_MIPS_IVERSION","DT_MIPS_FLAGS","DT_MIPS_BASE_ADDRESS","DT_MIPS_MSYM","DT_MIPS_CONFLICT","DT_MIPS_LIBLIST","DT_MIPS_LOCAL_GOTNO","DT_MIPS_CONFLICTNO","DT_MIPS_LIBLISTNO","DT_MIPS_SYMTABNO","DT_MIPS_UNREFEXTNO","DT_MIPS_GOTSYM","DT_MIPS_HIPAGENO","DT_MIPS_RLD_MAP","DT_MIPS_DELTA_CLASS","DT_MIPS_DELTA_CLASS_NO","DT_MIPS_DELTA_INSTANCE","DT_MIPS_DELTA_INSTANCE_NO","DT_MIPS_DELTA_RELOC","DT_MIPS_DELTA_RELOC_NO","DT_MIPS_DELTA_SYM","DT_MIPS_DELTA_SYM_NO","DT_MIPS_DELTA_CLASSSYM","DT_MIPS_DELTA_CLASSSYM_NO","DT_MIPS_CXX_FLAGS","DT_MIPS_PIXIE_INIT","DT_MIPS_SYMBOL_LIB","DT_MIPS_LOCALPAGE_GOTIDX","DT_MIPS_LOCAL_GOTIDX","DT_MIPS_HIDDEN_GOTIDX","DT_MIPS_PROTECTED_GOTIDX","DT_MIPS_OPTIONS","DT_MIPS_INTERFACE","DT_MIPS_DYNSTR_ALIGN","DT_MIPS_INTERFACE_SIZE","DT_MIPS_RLD_TEXT_RESOLVE_ADDR","DT_MIPS_PERF_SUFFIX","DT_MIPS_COMPACT_SIZE","DT_MIPS_GP_VALUE","DT_MIPS_AUX_DYNAMIC","DT_MIPS_PLTGOT","DT_MIPS_RWPLT","DT_MIPS_RLD_MAP_REL","DT_PPC_GOT","DT_PPC_OPT","DT_PPC64_GLINK","DT_PPC64_OPD","DT_PPC64_OPDSZ","DT_PPC64_OPT","DT_SPARC_REGISTER","DT_AUXILIARY","DT_USED","DT_FILTER","DT_HIPROC","DynFlag","DF_ORIGIN","DF_SYMBOLIC","DF_TEXTREL","DF_BIND_NOW","DF_STATIC_TLS","DynFlag1","DF_1_NOW","DF_1_GLOBAL","DF_1_GROUP","DF_1_NODELETE","DF_1_LOADFLTR","DF_1_INITFIRST","DF_1_NOOPEN","DF_1_ORIGIN","DF_1_DIRECT","DF_1_TRANS","DF_1_INTERPOSE","DF_1_NODEFLIB","DF_1_NODUMP","DF_1_CONFALT","DF_1_ENDFILTEE","DF_1_DISPRELDNE","DF_1_DISPRELPND","DF_1_NODIRECT","DF_1_IGNMULDEF","DF_1_NOKSYMS","DF_1_NOHDR","DF_1_EDITED","DF_1_NORELOC","DF_1_SYMINTPOSE","DF_1_GLOBAUDIT","DF_1_SINGLETON","DF_1_STUB","DF_1_PIE","DF_1_KMOD","DF_1_WEAKFILTER","DF_1_NOCOMMON","NType","NT_PRSTATUS","NT_FPREGSET","NT_PRPSINFO","SymBind","STB_LOCAL","STB_GLOBAL","STB_WEAK","STB_LOOS","STB_HIOS","STB_LOPROC","STB_HIPROC","SymType","STT_NOTYPE","STT_OBJECT","STT_FUNC","STT_SECTION","STT_FILE","STT_COMMON","STT_TLS","STT_LOOS","STT_HIOS","STT_LOPROC","STT_HIPROC","STT_RELC","STT_SRELC","STT_GNU_IFUNC","SymVis","STV_DEFAULT","STV_INTERNAL","STV_HIDDEN","STV_PROTECTED","R_X86_64","R_X86_64_NONE","R_X86_64_64","R_X86_64_PC32","R_X86_64_GOT32","R_X86_64_PLT32","R_X86_64_COPY","R_X86_64_GLOB_DAT","R_X86_64_JMP_SLOT","R_X86_64_RELATIVE","R_X86_64_GOTPCREL","R_X86_64_32","R_X86_64_32S","R_X86_64_16","R_X86_64_PC16","R_X86_64_8","R_X86_64_PC8","R_X86_64_DTPMOD64","R_X86_64_DTPOFF64","R_X86_64_TPOFF64","R_X86_64_TLSGD","R_X86_64_TLSLD","R_X86_64_DTPOFF32","R_X86_64_GOTTPOFF","R_X86_64_TPOFF32","R_X86_64_PC64","R_X86_64_GOTOFF64","R_X86_64_GOTPC32","R_X86_64_GOT64","R_X86_64_GOTPCREL64","R_X86_64_GOTPC64","R_X86_64_GOTPLT64","R_X86_64_PLTOFF64","R_X86_64_SIZE32","R_X86_64_SIZE64","R_X86_64_GOTPC32_TLSDESC","R_X86_64_TLSDESC_CALL","R_X86_64_TLSDESC","R_X86_64_IRELATIVE","R_X86_64_RELATIVE64","R_X86_64_PC32_BND","R_X86_64_PLT32_BND","R_X86_64_GOTPCRELX","R_X86_64_REX_GOTPCRELX","R_AARCH64","R_AARCH64_NONE","R_AARCH64_P32_ABS32","R_AARCH64_P32_ABS16","R_AARCH64_P32_PREL32","R_AARCH64_P32_PREL16","R_AARCH64_P32_MOVW_UABS_G0","R_AARCH64_P32_MOVW_UABS_G0_NC","R_AARCH64_P32_MOVW_UABS_G1","R_AARCH64_P32_MOVW_SABS_G0","R_AARCH64_P32_LD_PREL_LO19","R_AARCH64_P32_ADR_PREL_LO21","R_AARCH64_P32_ADR_PREL_PG_HI21","R_AARCH64_P32_ADD_ABS_LO12_NC","R_AARCH64_P32_LDST8_ABS_LO12_NC","R_AARCH64_P32_LDST16_ABS_LO12_NC","R_AARCH64_P32_LDST32_ABS_LO12_NC","R_AARCH64_P32_LDST64_ABS_LO12_NC","R_AARCH64_P32_LDST128_ABS_LO12_NC","R_AARCH64_P32_TSTBR14","R_AARCH64_P32_CONDBR19","R_AARCH64_P32_JUMP26","R_AARCH64_P32_CALL26","R_AARCH64_P32_GOT_LD_PREL19","R_AARCH64_P32_ADR_GOT_PAGE","R_AARCH64_P32_LD32_GOT_LO12_NC","R_AARCH64_P32_TLSGD_ADR_PAGE21","R_AARCH64_P32_TLSGD_ADD_LO12_NC","R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21","R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC","R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19","R_AARCH64_P32_TLSLE_MOVW_TPREL_G1","R_AARCH64_P32_TLSLE_MOVW_TPREL_G0","R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC","R_AARCH64_P32_TLSLE_ADD_TPREL_HI12","R_AARCH64_P32_TLSLE_ADD_TPREL_LO12","R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC","R_AARCH64_P32_TLSDESC_LD_PREL19","R_AARCH64_P32_TLSDESC_ADR_PREL21","R_AARCH64_P32_TLSDESC_ADR_PAGE21","R_AARCH64_P32_TLSDESC_LD32_LO12_NC","R_AARCH64_P32_TLSDESC_ADD_LO12_NC","R_AARCH64_P32_TLSDESC_CALL","R_AARCH64_P32_COPY","R_AARCH64_P32_GLOB_DAT","R_AARCH64_P32_JUMP_SLOT","R_AARCH64_P32_RELATIVE","R_AARCH64_P32_TLS_DTPMOD","R_AARCH64_P32_TLS_DTPREL","R_AARCH64_P32_TLS_TPREL","R_AARCH64_P32_TLSDESC","R_AARCH64_P32_IRELATIVE","R_AARCH64_NULL","R_AARCH64_ABS64","R_AARCH64_ABS32","R_AARCH64_ABS16","R_AARCH64_PREL64","R_AARCH64_PREL32","R_AARCH64_PREL16","R_AARCH64_MOVW_UABS_G0","R_AARCH64_MOVW_UABS_G0_NC","R_AARCH64_MOVW_UABS_G1","R_AARCH64_MOVW_UABS_G1_NC","R_AARCH64_MOVW_UABS_G2","R_AARCH64_MOVW_UABS_G2_NC","R_AARCH64_MOVW_UABS_G3","R_AARCH64_MOVW_SABS_G0","R_AARCH64_MOVW_SABS_G1","R_AARCH64_MOVW_SABS_G2","R_AARCH64_LD_PREL_LO19","R_AARCH64_ADR_PREL_LO21","R_AARCH64_ADR_PREL_PG_HI21","R_AARCH64_ADR_PREL_PG_HI21_NC","R_AARCH64_ADD_ABS_LO12_NC","R_AARCH64_LDST8_ABS_LO12_NC","R_AARCH64_TSTBR14","R_AARCH64_CONDBR19","R_AARCH64_JUMP26","R_AARCH64_CALL26","R_AARCH64_LDST16_ABS_LO12_NC","R_AARCH64_LDST32_ABS_LO12_NC","R_AARCH64_LDST64_ABS_LO12_NC","R_AARCH64_LDST128_ABS_LO12_NC","R_AARCH64_GOT_LD_PREL19","R_AARCH64_LD64_GOTOFF_LO15","R_AARCH64_ADR_GOT_PAGE","R_AARCH64_LD64_GOT_LO12_NC","R_AARCH64_LD64_GOTPAGE_LO15","R_AARCH64_TLSGD_ADR_PREL21","R_AARCH64_TLSGD_ADR_PAGE21","R_AARCH64_TLSGD_ADD_LO12_NC","R_AARCH64_TLSGD_MOVW_G1","R_AARCH64_TLSGD_MOVW_G0_NC","R_AARCH64_TLSLD_ADR_PREL21","R_AARCH64_TLSLD_ADR_PAGE21","R_AARCH64_TLSIE_MOVW_GOTTPREL_G1","R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC","R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21","R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC","R_AARCH64_TLSIE_LD_GOTTPREL_PREL19","R_AARCH64_TLSLE_MOVW_TPREL_G2","R_AARCH64_TLSLE_MOVW_TPREL_G1","R_AARCH64_TLSLE_MOVW_TPREL_G1_NC","R_AARCH64_TLSLE_MOVW_TPREL_G0","R_AARCH64_TLSLE_MOVW_TPREL_G0_NC","R_AARCH64_TLSLE_ADD_TPREL_HI12","R_AARCH64_TLSLE_ADD_TPREL_LO12","R_AARCH64_TLSLE_ADD_TPREL_LO12_NC","R_AARCH64_TLSDESC_LD_PREL19","R_AARCH64_TLSDESC_ADR_PREL21","R_AARCH64_TLSDESC_ADR_PAGE21","R_AARCH64_TLSDESC_LD64_LO12_NC","R_AARCH64_TLSDESC_ADD_LO12_NC","R_AARCH64_TLSDESC_OFF_G1","R_AARCH64_TLSDESC_OFF_G0_NC","R_AARCH64_TLSDESC_LDR","R_AARCH64_TLSDESC_ADD","R_AARCH64_TLSDESC_CALL","R_AARCH64_TLSLE_LDST128_TPREL_LO12","R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC","R_AARCH64_TLSLD_LDST128_DTPREL_LO12","R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC","R_AARCH64_COPY","R_AARCH64_GLOB_DAT","R_AARCH64_JUMP_SLOT","R_AARCH64_RELATIVE","R_AARCH64_TLS_DTPMOD64","R_AARCH64_TLS_DTPREL64","R_AARCH64_TLS_TPREL64","R_AARCH64_TLSDESC","R_AARCH64_IRELATIVE","R_ALPHA","R_ALPHA_NONE","R_ALPHA_REFLONG","R_ALPHA_REFQUAD","R_ALPHA_GPREL32","R_ALPHA_LITERAL","R_ALPHA_LITUSE","R_ALPHA_GPDISP","R_ALPHA_BRADDR","R_ALPHA_HINT","R_ALPHA_SREL16","R_ALPHA_SREL32","R_ALPHA_SREL64","R_ALPHA_OP_PUSH","R_ALPHA_OP_STORE","R_ALPHA_OP_PSUB","R_ALPHA_OP_PRSHIFT","R_ALPHA_GPVALUE","R_ALPHA_GPRELHIGH","R_ALPHA_GPRELLOW","R_ALPHA_IMMED_GP_16","R_ALPHA_IMMED_GP_HI32","R_ALPHA_IMMED_SCN_HI32","R_ALPHA_IMMED_BR_HI32","R_ALPHA_IMMED_LO32","R_ALPHA_COPY","R_ALPHA_GLOB_DAT","R_ALPHA_JMP_SLOT","R_ALPHA_RELATIVE","R_ARM","R_ARM_NONE","R_ARM_PC24","R_ARM_ABS32","R_ARM_REL32","R_ARM_PC13","R_ARM_ABS16","R_ARM_ABS12","R_ARM_THM_ABS5","R_ARM_ABS8","R_ARM_SBREL32","R_ARM_THM_PC22","R_ARM_THM_PC8","R_ARM_AMP_VCALL9","R_ARM_SWI24","R_ARM_THM_SWI8","R_ARM_XPC25","R_ARM_THM_XPC22","R_ARM_TLS_DTPMOD32","R_ARM_TLS_DTPOFF32","R_ARM_TLS_TPOFF32","R_ARM_COPY","R_ARM_GLOB_DAT","R_ARM_JUMP_SLOT","R_ARM_RELATIVE","R_ARM_GOTOFF","R_ARM_GOTPC","R_ARM_GOT32","R_ARM_PLT32","R_ARM_CALL","R_ARM_JUMP24","R_ARM_THM_JUMP24","R_ARM_BASE_ABS","R_ARM_ALU_PCREL_7_0","R_ARM_ALU_PCREL_15_8","R_ARM_ALU_PCREL_23_15","R_ARM_LDR_SBREL_11_10_NC","R_ARM_ALU_SBREL_19_12_NC","R_ARM_ALU_SBREL_27_20_CK","R_ARM_TARGET1","R_ARM_SBREL31","R_ARM_V4BX","R_ARM_TARGET2","R_ARM_PREL31","R_ARM_MOVW_ABS_NC","R_ARM_MOVT_ABS","R_ARM_MOVW_PREL_NC","R_ARM_MOVT_PREL","R_ARM_THM_MOVW_ABS_NC","R_ARM_THM_MOVT_ABS","R_ARM_THM_MOVW_PREL_NC","R_ARM_THM_MOVT_PREL","R_ARM_THM_JUMP19","R_ARM_THM_JUMP6","R_ARM_THM_ALU_PREL_11_0","R_ARM_THM_PC12","R_ARM_ABS32_NOI","R_ARM_REL32_NOI","R_ARM_ALU_PC_G0_NC","R_ARM_ALU_PC_G0","R_ARM_ALU_PC_G1_NC","R_ARM_ALU_PC_G1","R_ARM_ALU_PC_G2","R_ARM_LDR_PC_G1","R_ARM_LDR_PC_G2","R_ARM_LDRS_PC_G0","R_ARM_LDRS_PC_G1","R_ARM_LDRS_PC_G2","R_ARM_LDC_PC_G0","R_ARM_LDC_PC_G1","R_ARM_LDC_PC_G2","R_ARM_ALU_SB_G0_NC","R_ARM_ALU_SB_G0","R_ARM_ALU_SB_G1_NC","R_ARM_ALU_SB_G1","R_ARM_ALU_SB_G2","R_ARM_LDR_SB_G0","R_ARM_LDR_SB_G1","R_ARM_LDR_SB_G2","R_ARM_LDRS_SB_G0","R_ARM_LDRS_SB_G1","R_ARM_LDRS_SB_G2","R_ARM_LDC_SB_G0","R_ARM_LDC_SB_G1","R_ARM_LDC_SB_G2","R_ARM_MOVW_BREL_NC","R_ARM_MOVT_BREL","R_ARM_MOVW_BREL","R_ARM_THM_MOVW_BREL_NC","R_ARM_THM_MOVT_BREL","R_ARM_THM_MOVW_BREL","R_ARM_TLS_GOTDESC","R_ARM_TLS_CALL","R_ARM_TLS_DESCSEQ","R_ARM_THM_TLS_CALL","R_ARM_PLT32_ABS","R_ARM_GOT_ABS","R_ARM_GOT_PREL","R_ARM_GOT_BREL12","R_ARM_GOTOFF12","R_ARM_GOTRELAX","R_ARM_GNU_VTENTRY","R_ARM_GNU_VTINHERIT","R_ARM_THM_JUMP11","R_ARM_THM_JUMP8","R_ARM_TLS_GD32","R_ARM_TLS_LDM32","R_ARM_TLS_LDO32","R_ARM_TLS_IE32","R_ARM_TLS_LE32","R_ARM_TLS_LDO12","R_ARM_TLS_LE12","R_ARM_TLS_IE12GP","R_ARM_PRIVATE_0","R_ARM_PRIVATE_1","R_ARM_PRIVATE_2","R_ARM_PRIVATE_3","R_ARM_PRIVATE_4","R_ARM_PRIVATE_5","R_ARM_PRIVATE_6","R_ARM_PRIVATE_7","R_ARM_PRIVATE_8","R_ARM_PRIVATE_9","R_ARM_PRIVATE_10","R_ARM_PRIVATE_11","R_ARM_PRIVATE_12","R_ARM_PRIVATE_13","R_ARM_PRIVATE_14","R_ARM_PRIVATE_15","R_ARM_ME_TOO","R_ARM_THM_TLS_DESCSEQ16","R_ARM_THM_TLS_DESCSEQ32","R_ARM_THM_GOT_BREL12","R_ARM_THM_ALU_ABS_G0_NC","R_ARM_THM_ALU_ABS_G1_NC","R_ARM_THM_ALU_ABS_G2_NC","R_ARM_THM_ALU_ABS_G3","R_ARM_IRELATIVE","R_ARM_RXPC25","R_ARM_RSBREL32","R_ARM_THM_RPC22","R_ARM_RREL32","R_ARM_RABS32","R_ARM_RPC24","R_ARM_RBASE","R_386","R_386_NONE","R_386_32","R_386_PC32","R_386_GOT32","R_386_PLT32","R_386_COPY","R_386_GLOB_DAT","R_386_JMP_SLOT","R_386_RELATIVE","R_386_GOTOFF","R_386_GOTPC","R_386_32PLT","R_386_TLS_TPOFF","R_386_TLS_IE","R_386_TLS_GOTIE","R_386_TLS_LE","R_386_TLS_GD","R_386_TLS_LDM","R_386_16","R_386_PC16","R_386_8","R_386_PC8","R_386_TLS_GD_32","R_386_TLS_GD_PUSH","R_386_TLS_GD_CALL","R_386_TLS_GD_POP","R_386_TLS_LDM_32","R_386_TLS_LDM_PUSH","R_386_TLS_LDM_CALL","R_386_TLS_LDM_POP","R_386_TLS_LDO_32","R_386_TLS_IE_32","R_386_TLS_LE_32","R_386_TLS_DTPMOD32","R_386_TLS_DTPOFF32","R_386_TLS_TPOFF32","R_386_SIZE32","R_386_TLS_GOTDESC","R_386_TLS_DESC_CALL","R_386_TLS_DESC","R_386_IRELATIVE","R_386_GOT32X","R_MIPS","R_MIPS_NONE","R_MIPS_16","R_MIPS_32","R_MIPS_REL32","R_MIPS_26","R_MIPS_HI16","R_MIPS_LO16","R_MIPS_GPREL16","R_MIPS_LITERAL","R_MIPS_GOT16","R_MIPS_PC16","R_MIPS_CALL16","R_MIPS_GPREL32","R_MIPS_SHIFT5","R_MIPS_SHIFT6","R_MIPS_64","R_MIPS_GOT_DISP","R_MIPS_GOT_PAGE","R_MIPS_GOT_OFST","R_MIPS_GOT_HI16","R_MIPS_GOT_LO16","R_MIPS_SUB","R_MIPS_INSERT_A","R_MIPS_INSERT_B","R_MIPS_DELETE","R_MIPS_HIGHER","R_MIPS_HIGHEST","R_MIPS_CALL_HI16","R_MIPS_CALL_LO16","R_MIPS_SCN_DISP","R_MIPS_REL16","R_MIPS_ADD_IMMEDIATE","R_MIPS_PJUMP","R_MIPS_RELGOT","R_MIPS_JALR","R_MIPS_TLS_DTPMOD32","R_MIPS_TLS_DTPREL32","R_MIPS_TLS_DTPMOD64","R_MIPS_TLS_DTPREL64","R_MIPS_TLS_GD","R_MIPS_TLS_LDM","R_MIPS_TLS_DTPREL_HI16","R_MIPS_TLS_DTPREL_LO16","R_MIPS_TLS_GOTTPREL","R_MIPS_TLS_TPREL32","R_MIPS_TLS_TPREL64","R_MIPS_TLS_TPREL_HI16","R_MIPS_TLS_TPREL_LO16","R_MIPS_PC32","R_LARCH","R_LARCH_NONE","R_LARCH_32","R_LARCH_64","R_LARCH_RELATIVE","R_LARCH_COPY","R_LARCH_JUMP_SLOT","R_LARCH_TLS_DTPMOD32","R_LARCH_TLS_DTPMOD64","R_LARCH_TLS_DTPREL32","R_LARCH_TLS_DTPREL64","R_LARCH_TLS_TPREL32","R_LARCH_TLS_TPREL64","R_LARCH_IRELATIVE","R_LARCH_MARK_LA","R_LARCH_MARK_PCREL","R_LARCH_SOP_PUSH_PCREL","R_LARCH_SOP_PUSH_ABSOLUTE","R_LARCH_SOP_PUSH_DUP","R_LARCH_SOP_PUSH_GPREL","R_LARCH_SOP_PUSH_TLS_TPREL","R_LARCH_SOP_PUSH_TLS_GOT","R_LARCH_SOP_PUSH_TLS_GD","R_LARCH_SOP_PUSH_PLT_PCREL","R_LARCH_SOP_ASSERT","R_LARCH_SOP_NOT","R_LARCH_SOP_SUB","R_LARCH_SOP_SL","R_LARCH_SOP_SR","R_LARCH_SOP_ADD","R_LARCH_SOP_AND","R_LARCH_SOP_IF_ELSE","R_LARCH_SOP_POP_32_S_10_5","R_LARCH_SOP_POP_32_U_10_12","R_LARCH_SOP_POP_32_S_10_12","R_LARCH_SOP_POP_32_S_10_16","R_LARCH_SOP_POP_32_S_10_16_S2","R_LARCH_SOP_POP_32_S_5_20","R_LARCH_SOP_POP_32_S_0_5_10_16_S2","R_LARCH_SOP_POP_32_S_0_10_10_16_S2","R_LARCH_SOP_POP_32_U","R_LARCH_ADD8","R_LARCH_ADD16","R_LARCH_ADD24","R_LARCH_ADD32","R_LARCH_ADD64","R_LARCH_SUB8","R_LARCH_SUB16","R_LARCH_SUB24","R_LARCH_SUB32","R_LARCH_SUB64","R_LARCH_GNU_VTINHERIT","R_LARCH_GNU_VTENTRY","R_LARCH_B16","R_LARCH_B21","R_LARCH_B26","R_LARCH_ABS_HI20","R_LARCH_ABS_LO12","R_LARCH_ABS64_LO20","R_LARCH_ABS64_HI12","R_LARCH_PCALA_HI20","R_LARCH_PCALA_LO12","R_LARCH_PCALA64_LO20","R_LARCH_PCALA64_HI12","R_LARCH_GOT_PC_HI20","R_LARCH_GOT_PC_LO12","R_LARCH_GOT64_PC_LO20","R_LARCH_GOT64_PC_HI12","R_LARCH_GOT_HI20","R_LARCH_GOT_LO12","R_LARCH_GOT64_LO20","R_LARCH_GOT64_HI12","R_LARCH_TLS_LE_HI20","R_LARCH_TLS_LE_LO12","R_LARCH_TLS_LE64_LO20","R_LARCH_TLS_LE64_HI12","R_LARCH_TLS_IE_PC_HI20","R_LARCH_TLS_IE_PC_LO12","R_LARCH_TLS_IE64_PC_LO20","R_LARCH_TLS_IE64_PC_HI12","R_LARCH_TLS_IE_HI20","R_LARCH_TLS_IE_LO12","R_LARCH_TLS_IE64_LO20","R_LARCH_TLS_IE64_HI12","R_LARCH_TLS_LD_PC_HI20","R_LARCH_TLS_LD_HI20","R_LARCH_TLS_GD_PC_HI20","R_LARCH_TLS_GD_HI20","R_LARCH_32_PCREL","R_LARCH_RELAX","R_LARCH_DELETE","R_LARCH_ALIGN","R_LARCH_PCREL20_S2","R_LARCH_CFA","R_LARCH_ADD6","R_LARCH_SUB6","R_LARCH_ADD_ULEB128","R_LARCH_SUB_ULEB128","R_LARCH_64_PCREL","R_PPC","R_PPC_NONE","R_PPC_ADDR32","R_PPC_ADDR24","R_PPC_ADDR16","R_PPC_ADDR16_LO","R_PPC_ADDR16_HI","R_PPC_ADDR16_HA","R_PPC_ADDR14","R_PPC_ADDR14_BRTAKEN","R_PPC_ADDR14_BRNTAKEN","R_PPC_REL24","R_PPC_REL14","R_PPC_REL14_BRTAKEN","R_PPC_REL14_BRNTAKEN","R_PPC_GOT16","R_PPC_GOT16_LO","R_PPC_GOT16_HI","R_PPC_GOT16_HA","R_PPC_PLTREL24","R_PPC_COPY","R_PPC_GLOB_DAT","R_PPC_JMP_SLOT","R_PPC_RELATIVE","R_PPC_LOCAL24PC","R_PPC_UADDR32","R_PPC_UADDR16","R_PPC_REL32","R_PPC_PLT32","R_PPC_PLTREL32","R_PPC_PLT16_LO","R_PPC_PLT16_HI","R_PPC_PLT16_HA","R_PPC_SDAREL16","R_PPC_SECTOFF","R_PPC_SECTOFF_LO","R_PPC_SECTOFF_HI","R_PPC_SECTOFF_HA","R_PPC_TLS","R_PPC_DTPMOD32","R_PPC_TPREL16","R_PPC_TPREL16_LO","R_PPC_TPREL16_HI","R_PPC_TPREL16_HA","R_PPC_TPREL32","R_PPC_DTPREL16","R_PPC_DTPREL16_LO","R_PPC_DTPREL16_HI","R_PPC_DTPREL16_HA","R_PPC_DTPREL32","R_PPC_GOT_TLSGD16","R_PPC_GOT_TLSGD16_LO","R_PPC_GOT_TLSGD16_HI","R_PPC_GOT_TLSGD16_HA","R_PPC_GOT_TLSLD16","R_PPC_GOT_TLSLD16_LO","R_PPC_GOT_TLSLD16_HI","R_PPC_GOT_TLSLD16_HA","R_PPC_GOT_TPREL16","R_PPC_GOT_TPREL16_LO","R_PPC_GOT_TPREL16_HI","R_PPC_GOT_TPREL16_HA","R_PPC_EMB_NADDR32","R_PPC_EMB_NADDR16","R_PPC_EMB_NADDR16_LO","R_PPC_EMB_NADDR16_HI","R_PPC_EMB_NADDR16_HA","R_PPC_EMB_SDAI16","R_PPC_EMB_SDA2I16","R_PPC_EMB_SDA2REL","R_PPC_EMB_SDA21","R_PPC_EMB_MRKREF","R_PPC_EMB_RELSEC16","R_PPC_EMB_RELST_LO","R_PPC_EMB_RELST_HI","R_PPC_EMB_RELST_HA","R_PPC_EMB_BIT_FLD","R_PPC_EMB_RELSDA","R_PPC64","R_PPC64_NONE","R_PPC64_ADDR32","R_PPC64_ADDR24","R_PPC64_ADDR16","R_PPC64_ADDR16_LO","R_PPC64_ADDR16_HI","R_PPC64_ADDR16_HA","R_PPC64_ADDR14","R_PPC64_ADDR14_BRTAKEN","R_PPC64_ADDR14_BRNTAKEN","R_PPC64_REL24","R_PPC64_REL14","R_PPC64_REL14_BRTAKEN","R_PPC64_REL14_BRNTAKEN","R_PPC64_GOT16","R_PPC64_GOT16_LO","R_PPC64_GOT16_HI","R_PPC64_GOT16_HA","R_PPC64_COPY","R_PPC64_GLOB_DAT","R_PPC64_JMP_SLOT","R_PPC64_RELATIVE","R_PPC64_UADDR32","R_PPC64_UADDR16","R_PPC64_REL32","R_PPC64_PLT32","R_PPC64_PLTREL32","R_PPC64_PLT16_LO","R_PPC64_PLT16_HI","R_PPC64_PLT16_HA","R_PPC64_SECTOFF","R_PPC64_SECTOFF_LO","R_PPC64_SECTOFF_HI","R_PPC64_SECTOFF_HA","R_PPC64_REL30","R_PPC64_ADDR64","R_PPC64_ADDR16_HIGHER","R_PPC64_ADDR16_HIGHERA","R_PPC64_ADDR16_HIGHEST","R_PPC64_ADDR16_HIGHESTA","R_PPC64_UADDR64","R_PPC64_REL64","R_PPC64_PLT64","R_PPC64_PLTREL64","R_PPC64_TOC16","R_PPC64_TOC16_LO","R_PPC64_TOC16_HI","R_PPC64_TOC16_HA","R_PPC64_TOC","R_PPC64_PLTGOT16","R_PPC64_PLTGOT16_LO","R_PPC64_PLTGOT16_HI","R_PPC64_PLTGOT16_HA","R_PPC64_ADDR16_DS","R_PPC64_ADDR16_LO_DS","R_PPC64_GOT16_DS","R_PPC64_GOT16_LO_DS","R_PPC64_PLT16_LO_DS","R_PPC64_SECTOFF_DS","R_PPC64_SECTOFF_LO_DS","R_PPC64_TOC16_DS","R_PPC64_TOC16_LO_DS","R_PPC64_PLTGOT16_DS","R_PPC64_PLTGOT_LO_DS","R_PPC64_TLS","R_PPC64_DTPMOD64","R_PPC64_TPREL16","R_PPC64_TPREL16_LO","R_PPC64_TPREL16_HI","R_PPC64_TPREL16_HA","R_PPC64_TPREL64","R_PPC64_DTPREL16","R_PPC64_DTPREL16_LO","R_PPC64_DTPREL16_HI","R_PPC64_DTPREL16_HA","R_PPC64_DTPREL64","R_PPC64_GOT_TLSGD16","R_PPC64_GOT_TLSGD16_LO","R_PPC64_GOT_TLSGD16_HI","R_PPC64_GOT_TLSGD16_HA","R_PPC64_GOT_TLSLD16","R_PPC64_GOT_TLSLD16_LO","R_PPC64_GOT_TLSLD16_HI","R_PPC64_GOT_TLSLD16_HA","R_PPC64_GOT_TPREL16_DS","R_PPC64_GOT_TPREL16_LO_DS","R_PPC64_GOT_TPREL16_HI","R_PPC64_GOT_TPREL16_HA","R_PPC64_GOT_DTPREL16_DS","R_PPC64_GOT_DTPREL16_LO_DS","R_PPC64_GOT_DTPREL16_HI","R_PPC64_GOT_DTPREL16_HA","R_PPC64_TPREL16_DS","R_PPC64_TPREL16_LO_DS","R_PPC64_TPREL16_HIGHER","R_PPC64_TPREL16_HIGHERA","R_PPC64_TPREL16_HIGHEST","R_PPC64_TPREL16_HIGHESTA","R_PPC64_DTPREL16_DS","R_PPC64_DTPREL16_LO_DS","R_PPC64_DTPREL16_HIGHER","R_PPC64_DTPREL16_HIGHERA","R_PPC64_DTPREL16_HIGHEST","R_PPC64_DTPREL16_HIGHESTA","R_PPC64_TLSGD","R_PPC64_TLSLD","R_PPC64_TOCSAVE","R_PPC64_ADDR16_HIGH","R_PPC64_ADDR16_HIGHA","R_PPC64_TPREL16_HIGH","R_PPC64_TPREL16_HIGHA","R_PPC64_DTPREL16_HIGH","R_PPC64_DTPREL16_HIGHA","R_PPC64_REL24_NOTOC","R_PPC64_ADDR64_LOCAL","R_PPC64_ENTRY","R_PPC64_PLTSEQ","R_PPC64_PLTCALL","R_PPC64_PLTSEQ_NOTOC","R_PPC64_PLTCALL_NOTOC","R_PPC64_PCREL_OPT","R_PPC64_REL24_P9NOTOC","R_PPC64_D34","R_PPC64_D34_LO","R_PPC64_D34_HI30","R_PPC64_D34_HA30","R_PPC64_PCREL34","R_PPC64_GOT_PCREL34","R_PPC64_PLT_PCREL34","R_PPC64_PLT_PCREL34_NOTOC","R_PPC64_ADDR16_HIGHER34","R_PPC64_ADDR16_HIGHERA34","R_PPC64_ADDR16_HIGHEST34","R_PPC64_ADDR16_HIGHESTA34","R_PPC64_REL16_HIGHER34","R_PPC64_REL16_HIGHERA34","R_PPC64_REL16_HIGHEST34","R_PPC64_REL16_HIGHESTA34","R_PPC64_D28","R_PPC64_PCREL28","R_PPC64_TPREL34","R_PPC64_DTPREL34","R_PPC64_GOT_TLSGD_PCREL34","R_PPC64_GOT_TLSLD_PCREL34","R_PPC64_GOT_TPREL_PCREL34","R_PPC64_GOT_DTPREL_PCREL34","R_PPC64_REL16_HIGH","R_PPC64_REL16_HIGHA","R_PPC64_REL16_HIGHER","R_PPC64_REL16_HIGHERA","R_PPC64_REL16_HIGHEST","R_PPC64_REL16_HIGHESTA","R_PPC64_REL16DX_HA","R_PPC64_JMP_IREL","R_PPC64_IRELATIVE","R_PPC64_REL16","R_PPC64_REL16_LO","R_PPC64_REL16_HI","R_PPC64_REL16_HA","R_PPC64_GNU_VTINHERIT","R_PPC64_GNU_VTENTRY","R_RISCV","R_RISCV_NONE","R_RISCV_32","R_RISCV_64","R_RISCV_RELATIVE","R_RISCV_COPY","R_RISCV_JUMP_SLOT","R_RISCV_TLS_DTPMOD32","R_RISCV_TLS_DTPMOD64","R_RISCV_TLS_DTPREL32","R_RISCV_TLS_DTPREL64","R_RISCV_TLS_TPREL32","R_RISCV_TLS_TPREL64","R_RISCV_BRANCH","R_RISCV_JAL","R_RISCV_CALL","R_RISCV_CALL_PLT","R_RISCV_GOT_HI20","R_RISCV_TLS_GOT_HI20","R_RISCV_TLS_GD_HI20","R_RISCV_PCREL_HI20","R_RISCV_PCREL_LO12_I","R_RISCV_PCREL_LO12_S","R_RISCV_HI20","R_RISCV_LO12_I","R_RISCV_LO12_S","R_RISCV_TPREL_HI20","R_RISCV_TPREL_LO12_I","R_RISCV_TPREL_LO12_S","R_RISCV_TPREL_ADD","R_RISCV_ADD8","R_RISCV_ADD16","R_RISCV_ADD32","R_RISCV_ADD64","R_RISCV_SUB8","R_RISCV_SUB16","R_RISCV_SUB32","R_RISCV_SUB64","R_RISCV_GNU_VTINHERIT","R_RISCV_GNU_VTENTRY","R_RISCV_ALIGN","R_RISCV_RVC_BRANCH","R_RISCV_RVC_JUMP","R_RISCV_RVC_LUI","R_RISCV_GPREL_I","R_RISCV_GPREL_S","R_RISCV_TPREL_I","R_RISCV_TPREL_S","R_RISCV_RELAX","R_RISCV_SUB6","R_RISCV_SET6","R_RISCV_SET8","R_RISCV_SET16","R_RISCV_SET32","R_RISCV_32_PCREL","R_390","R_390_NONE","R_390_8","R_390_12","R_390_16","R_390_32","R_390_PC32","R_390_GOT12","R_390_GOT32","R_390_PLT32","R_390_COPY","R_390_GLOB_DAT","R_390_JMP_SLOT","R_390_RELATIVE","R_390_GOTOFF","R_390_GOTPC","R_390_GOT16","R_390_PC16","R_390_PC16DBL","R_390_PLT16DBL","R_390_PC32DBL","R_390_PLT32DBL","R_390_GOTPCDBL","R_390_64","R_390_PC64","R_390_GOT64","R_390_PLT64","R_390_GOTENT","R_390_GOTOFF16","R_390_GOTOFF64","R_390_GOTPLT12","R_390_GOTPLT16","R_390_GOTPLT32","R_390_GOTPLT64","R_390_GOTPLTENT","R_390_GOTPLTOFF16","R_390_GOTPLTOFF32","R_390_GOTPLTOFF64","R_390_TLS_LOAD","R_390_TLS_GDCALL","R_390_TLS_LDCALL","R_390_TLS_GD32","R_390_TLS_GD64","R_390_TLS_GOTIE12","R_390_TLS_GOTIE32","R_390_TLS_GOTIE64","R_390_TLS_LDM32","R_390_TLS_LDM64","R_390_TLS_IE32","R_390_TLS_IE64","R_390_TLS_IEENT","R_390_TLS_LE32","R_390_TLS_LE64","R_390_TLS_LDO32","R_390_TLS_LDO64","R_390_TLS_DTPMOD","R_390_TLS_DTPOFF","R_390_TLS_TPOFF","R_390_20","R_390_GOT20","R_390_GOTPLT20","R_390_TLS_GOTIE20","R_SPARC","R_SPARC_NONE","R_SPARC_8","R_SPARC_16","R_SPARC_32","R_SPARC_DISP8","R_SPARC_DISP16","R_SPARC_DISP32","R_SPARC_WDISP30","R_SPARC_WDISP22","R_SPARC_HI22","R_SPARC_22","R_SPARC_13","R_SPARC_LO10","R_SPARC_GOT10","R_SPARC_GOT13","R_SPARC_GOT22","R_SPARC_PC10","R_SPARC_PC22","R_SPARC_WPLT30","R_SPARC_COPY","R_SPARC_GLOB_DAT","R_SPARC_JMP_SLOT","R_SPARC_RELATIVE","R_SPARC_UA32","R_SPARC_PLT32","R_SPARC_HIPLT22","R_SPARC_LOPLT10","R_SPARC_PCPLT32","R_SPARC_PCPLT22","R_SPARC_PCPLT10","R_SPARC_10","R_SPARC_11","R_SPARC_64","R_SPARC_OLO10","R_SPARC_HH22","R_SPARC_HM10","R_SPARC_LM22","R_SPARC_PC_HH22","R_SPARC_PC_HM10","R_SPARC_PC_LM22","R_SPARC_WDISP16","R_SPARC_WDISP19","R_SPARC_GLOB_JMP","R_SPARC_7","R_SPARC_5","R_SPARC_6","R_SPARC_DISP64","R_SPARC_PLT64","R_SPARC_HIX22","R_SPARC_LOX10","R_SPARC_H44","R_SPARC_M44","R_SPARC_L44","R_SPARC_REGISTER","R_SPARC_UA64","R_SPARC_UA16","ARM_MAGIC_TRAMP_NUMBER","Header32","Section32","Prog32","Dyn32","Chdr32","Rel32","Rela32","R_SYM32","R_TYPE32","R_INFO32","Sym32","Sym32Size","ST_BIND","ST_TYPE","ST_INFO","ST_VISIBILITY","Header64","Section64","Prog64","Dyn64","Chdr64","Rel64","Rela64","R_SYM64","R_TYPE64","R_INFO","Sym64","Sym64Size","FileHeader","File","SectionHeader","Section","ProgHeader","Prog","Symbol","FormatError","Open","NewFile","ErrNoSymbols","ImportedSymbol","LineTable","NewLineTable","Sym","Func","Obj","Table","NewTable","UnknownFileError","UnknownLineError","DecodingError","FatFile","FatArchHeader","FatArch","ErrNotFat","NewFatFile","OpenFat","File","Load","LoadBytes","SegmentHeader","Segment","SectionHeader","Reloc","Section","Dylib","Symtab","Dysymtab","Rpath","Symbol","FormatError","Open","NewFile","FileHeader","Magic32","Magic64","MagicFat","Type","TypeObj","TypeExec","TypeDylib","TypeBundle","Cpu","Cpu386","CpuAmd64","CpuArm","CpuArm64","CpuPpc","CpuPpc64","LoadCmd","LoadCmdSegment","LoadCmdSymtab","LoadCmdThread","LoadCmdUnixThread","LoadCmdDysymtab","LoadCmdDylib","LoadCmdDylinker","LoadCmdSegment64","LoadCmdRpath","Segment32","Segment64","SymtabCmd","DysymtabCmd","DylibCmd","RpathCmd","Thread","FlagNoUndefs","FlagIncrLink","FlagDyldLink","FlagBindAtLoad","FlagPrebound","FlagSplitSegs","FlagLazyInit","FlagTwoLevel","FlagForceFlat","FlagNoMultiDefs","FlagNoFixPrebinding","FlagPrebindable","FlagAllModsBound","FlagSubsectionsViaSymbols","FlagCanonical","FlagWeakDefines","FlagBindsToWeak","FlagAllowStackExecution","FlagRootSafe","FlagSetuidSafe","FlagNoReexportedDylibs","FlagPIE","FlagDeadStrippableDylib","FlagHasTLVDescriptors","FlagNoHeapExecution","FlagAppExtensionSafe","Section32","Section64","Nlist32","Nlist64","Regs386","RegsAMD64","RelocTypeGeneric","GENERIC_RELOC_VANILLA","GENERIC_RELOC_PAIR","GENERIC_RELOC_SECTDIFF","GENERIC_RELOC_PB_LA_PTR","GENERIC_RELOC_LOCAL_SECTDIFF","GENERIC_RELOC_TLV","RelocTypeX86_64","X86_64_RELOC_UNSIGNED","X86_64_RELOC_SIGNED","X86_64_RELOC_BRANCH","X86_64_RELOC_GOT_LOAD","X86_64_RELOC_GOT","X86_64_RELOC_SUBTRACTOR","X86_64_RELOC_SIGNED_1","X86_64_RELOC_SIGNED_2","X86_64_RELOC_SIGNED_4","X86_64_RELOC_TLV","RelocTypeARM","ARM_RELOC_VANILLA","ARM_RELOC_PAIR","ARM_RELOC_SECTDIFF","ARM_RELOC_LOCAL_SECTDIFF","ARM_RELOC_PB_LA_PTR","ARM_RELOC_BR24","ARM_THUMB_RELOC_BR22","ARM_THUMB_32BIT_BRANCH","ARM_RELOC_HALF","ARM_RELOC_HALF_SECTDIFF","RelocTypeARM64","ARM64_RELOC_UNSIGNED","ARM64_RELOC_SUBTRACTOR","ARM64_RELOC_BRANCH26","ARM64_RELOC_PAGE21","ARM64_RELOC_PAGEOFF12","ARM64_RELOC_GOT_LOAD_PAGE21","ARM64_RELOC_GOT_LOAD_PAGEOFF12","ARM64_RELOC_POINTER_TO_GOT","ARM64_RELOC_TLVP_LOAD_PAGE21","ARM64_RELOC_TLVP_LOAD_PAGEOFF12","ARM64_RELOC_ADDEND","File","Open","NewFile","ImportDirectory","FormatError","FileHeader","DataDirectory","OptionalHeader32","OptionalHeader64","IMAGE_FILE_MACHINE_UNKNOWN","IMAGE_FILE_MACHINE_AM33","IMAGE_FILE_MACHINE_AMD64","IMAGE_FILE_MACHINE_ARM","IMAGE_FILE_MACHINE_ARMNT","IMAGE_FILE_MACHINE_ARM64","IMAGE_FILE_MACHINE_EBC","IMAGE_FILE_MACHINE_I386","IMAGE_FILE_MACHINE_IA64","IMAGE_FILE_MACHINE_LOONGARCH32","IMAGE_FILE_MACHINE_LOONGARCH64","IMAGE_FILE_MACHINE_M32R","IMAGE_FILE_MACHINE_MIPS16","IMAGE_FILE_MACHINE_MIPSFPU","IMAGE_FILE_MACHINE_MIPSFPU16","IMAGE_FILE_MACHINE_POWERPC","IMAGE_FILE_MACHINE_POWERPCFP","IMAGE_FILE_MACHINE_R4000","IMAGE_FILE_MACHINE_SH3","IMAGE_FILE_MACHINE_SH3DSP","IMAGE_FILE_MACHINE_SH4","IMAGE_FILE_MACHINE_SH5","IMAGE_FILE_MACHINE_THUMB","IMAGE_FILE_MACHINE_WCEMIPSV2","IMAGE_FILE_MACHINE_RISCV32","IMAGE_FILE_MACHINE_RISCV64","IMAGE_FILE_MACHINE_RISCV128","IMAGE_DIRECTORY_ENTRY_EXPORT","IMAGE_DIRECTORY_ENTRY_IMPORT","IMAGE_DIRECTORY_ENTRY_RESOURCE","IMAGE_DIRECTORY_ENTRY_EXCEPTION","IMAGE_DIRECTORY_ENTRY_SECURITY","IMAGE_DIRECTORY_ENTRY_BASERELOC","IMAGE_DIRECTORY_ENTRY_DEBUG","IMAGE_DIRECTORY_ENTRY_ARCHITECTURE","IMAGE_DIRECTORY_ENTRY_GLOBALPTR","IMAGE_DIRECTORY_ENTRY_TLS","IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG","IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT","IMAGE_DIRECTORY_ENTRY_IAT","IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT","IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR","IMAGE_FILE_RELOCS_STRIPPED","IMAGE_FILE_EXECUTABLE_IMAGE","IMAGE_FILE_LINE_NUMS_STRIPPED","IMAGE_FILE_LOCAL_SYMS_STRIPPED","IMAGE_FILE_AGGRESIVE_WS_TRIM","IMAGE_FILE_LARGE_ADDRESS_AWARE","IMAGE_FILE_BYTES_REVERSED_LO","IMAGE_FILE_32BIT_MACHINE","IMAGE_FILE_DEBUG_STRIPPED","IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP","IMAGE_FILE_NET_RUN_FROM_SWAP","IMAGE_FILE_SYSTEM","IMAGE_FILE_DLL","IMAGE_FILE_UP_SYSTEM_ONLY","IMAGE_FILE_BYTES_REVERSED_HI","IMAGE_SUBSYSTEM_UNKNOWN","IMAGE_SUBSYSTEM_NATIVE","IMAGE_SUBSYSTEM_WINDOWS_GUI","IMAGE_SUBSYSTEM_WINDOWS_CUI","IMAGE_SUBSYSTEM_OS2_CUI","IMAGE_SUBSYSTEM_POSIX_CUI","IMAGE_SUBSYSTEM_NATIVE_WINDOWS","IMAGE_SUBSYSTEM_WINDOWS_CE_GUI","IMAGE_SUBSYSTEM_EFI_APPLICATION","IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER","IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER","IMAGE_SUBSYSTEM_EFI_ROM","IMAGE_SUBSYSTEM_XBOX","IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION","IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA","IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE","IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY","IMAGE_DLLCHARACTERISTICS_NX_COMPAT","IMAGE_DLLCHARACTERISTICS_NO_ISOLATION","IMAGE_DLLCHARACTERISTICS_NO_SEH","IMAGE_DLLCHARACTERISTICS_NO_BIND","IMAGE_DLLCHARACTERISTICS_APPCONTAINER","IMAGE_DLLCHARACTERISTICS_WDM_DRIVER","IMAGE_DLLCHARACTERISTICS_GUARD_CF","IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE","SectionHeader32","Reloc","SectionHeader","Section","IMAGE_SCN_CNT_CODE","IMAGE_SCN_CNT_INITIALIZED_DATA","IMAGE_SCN_CNT_UNINITIALIZED_DATA","IMAGE_SCN_LNK_COMDAT","IMAGE_SCN_MEM_DISCARDABLE","IMAGE_SCN_MEM_EXECUTE","IMAGE_SCN_MEM_READ","IMAGE_SCN_MEM_WRITE","StringTable","COFFSymbolSize","COFFSymbol","Symbol","COFFSymbolAuxFormat5","IMAGE_COMDAT_SELECT_NODUPLICATES","IMAGE_COMDAT_SELECT_ANY","IMAGE_COMDAT_SELECT_SAME_SIZE","IMAGE_COMDAT_SELECT_EXACT_MATCH","IMAGE_COMDAT_SELECT_ASSOCIATIVE","IMAGE_COMDAT_SELECT_LARGEST","FileHeader","File","SectionHeader","Section","Sym","Open","NewFile","ErrNoSymbols","Magic64","Magic386","MagicAMD64","MagicARM","Encode","MaxEncodedLen","NewEncoder","CorruptInputError","Decode","NewDecoder","StructuralError","SyntaxError","BitString","NullRawValue","NullBytes","ObjectIdentifier","Enumerated","Flag","RawValue","RawContent","Unmarshal","UnmarshalWithParams","TagBoolean","TagInteger","TagBitString","TagOctetString","TagNull","TagOID","TagEnum","TagUTF8String","TagSequence","TagSet","TagNumericString","TagPrintableString","TagT61String","TagIA5String","TagUTCTime","TagGeneralizedTime","TagGeneralString","TagBMPString","ClassUniversal","ClassApplication","ClassContextSpecific","ClassPrivate","Marshal","MarshalWithParams","Encoding","StdPadding","NoPadding","NewEncoding","StdEncoding","HexEncoding","NewEncoder","CorruptInputError","NewDecoder","Encoding","StdPadding","NoPadding","NewEncoding","StdEncoding","URLEncoding","RawStdEncoding","RawURLEncoding","NewEncoder","CorruptInputError","NewDecoder","ByteOrder","AppendByteOrder","LittleEndian","BigEndian","Read","Decode","Write","Encode","Append","Size","NativeEndian","MaxVarintLen16","MaxVarintLen32","MaxVarintLen64","AppendUvarint","PutUvarint","Uvarint","AppendVarint","PutVarint","Varint","ReadUvarint","ReadVarint","ParseError","ErrBareQuote","ErrQuote","ErrFieldCount","ErrTrailingComma","Reader","NewReader","Writer","NewWriter","Decoder","NewDecoder","Encoder","NewEncoder","CommonType","GobEncoder","GobDecoder","RegisterName","Register","EncodedLen","Encode","AppendEncode","ErrLength","InvalidByteError","DecodedLen","Decode","AppendDecode","EncodeToString","DecodeString","Dump","NewEncoder","NewDecoder","Dumper","Unmarshal","Unmarshaler","UnmarshalTypeError","UnmarshalFieldError","InvalidUnmarshalError","Number","Marshal","MarshalIndent","Marshaler","UnsupportedTypeError","UnsupportedValueError","InvalidUTF8Error","MarshalerError","HTMLEscape","Compact","Indent","Valid","SyntaxError","Decoder","NewDecoder","Encoder","NewEncoder","RawMessage","Token","Delim","Block","Decode","Encode","EncodeToMemory","Header","Marshal","Marshaler","MarshalerAttr","MarshalIndent","Encoder","NewEncoder","UnsupportedTypeError","Unmarshal","UnmarshalError","Unmarshaler","UnmarshalerAttr","TagPathError","SyntaxError","Name","Attr","Token","StartElement","EndElement","CharData","Comment","ProcInst","Directive","CopyToken","TokenReader","Decoder","NewDecoder","NewTokenDecoder","HTMLEntity","HTMLAutoClose","EscapeText","Escape","Node","Expr","Stmt","Decl","Comment","CommentGroup","Field","FieldList","BadExpr","Ident","Ellipsis","BasicLit","FuncLit","CompositeLit","ParenExpr","SelectorExpr","IndexExpr","IndexListExpr","SliceExpr","TypeAssertExpr","CallExpr","StarExpr","UnaryExpr","BinaryExpr","KeyValueExpr","ChanDir","SEND","RECV","ArrayType","StructType","FuncType","InterfaceType","MapType","ChanType","NewIdent","IsExported","BadStmt","DeclStmt","EmptyStmt","LabeledStmt","ExprStmt","SendStmt","IncDecStmt","AssignStmt","GoStmt","DeferStmt","ReturnStmt","BranchStmt","BlockStmt","IfStmt","CaseClause","SwitchStmt","TypeSwitchStmt","CommClause","SelectStmt","ForStmt","RangeStmt","Spec","ImportSpec","ValueSpec","TypeSpec","BadDecl","GenDecl","FuncDecl","File","Package","IsGenerated","Unparen","CommentMap","NewCommentMap","FileExports","PackageExports","Filter","FilterDecl","FilterFile","FilterPackage","MergeMode","FilterFuncDuplicates","FilterUnassociatedComments","FilterImportDuplicates","MergePackageFiles","SortImports","FieldFilter","NotNilFilter","Fprint","Print","Importer","NewPackage","Scope","NewScope","Object","NewObj","ObjKind","Bad","Pkg","Con","Typ","Var","Fun","Lbl","Visitor","Walk","Inspect","Preorder","Context","Default","ImportMode","FindOnly","AllowBinary","ImportComment","IgnoreVendor","Package","Directive","NoGoError","MultiplePackageError","Import","ImportDir","ToolDir","IsLocalImport","ArchChar","Kind","Unknown","Bool","String","Int","Float","Complex","Value","MakeUnknown","MakeBool","MakeString","MakeInt64","MakeUint64","MakeFloat64","MakeFromLiteral","BoolVal","StringVal","Int64Val","Uint64Val","Float32Val","Float64Val","Val","Make","BitLen","Sign","Bytes","MakeFromBytes","Num","Denom","MakeImag","Real","Imag","ToInt","ToFloat","ToComplex","UnaryOp","BinaryOp","Shift","Compare","ToHTML","ToText","Package","Value","Type","Func","Note","Mode","AllDecls","AllMethods","PreserveAST","New","NewFromFiles","Example","Examples","Filter","IsPredeclared","Synopsis","IllegalPrefixes","Node","Source","Lookup","ForCompiler","For","Default","Mode","PackageClauseOnly","ImportsOnly","ParseComments","Trace","DeclarationErrors","SpuriousErrors","SkipObjectResolution","AllErrors","ParseFile","ParseDir","ParseExprFrom","ParseExpr","Mode","RawFormat","TabIndent","UseSpaces","SourcePos","Config","CommentedNode","Fprint","Error","ErrorList","PrintError","ErrorHandler","Scanner","Mode","ScanComments","Position","Pos","NoPos","File","FileSet","NewFileSet","Token","ILLEGAL","EOF","COMMENT","IDENT","INT","FLOAT","IMAG","CHAR","STRING","ADD","SUB","MUL","QUO","REM","AND","OR","XOR","SHL","SHR","AND_NOT","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","QUO_ASSIGN","REM_ASSIGN","AND_ASSIGN","OR_ASSIGN","XOR_ASSIGN","SHL_ASSIGN","SHR_ASSIGN","AND_NOT_ASSIGN","LAND","LOR","ARROW","INC","DEC","EQL","LSS","GTR","ASSIGN","NOT","NEQ","LEQ","GEQ","DEFINE","ELLIPSIS","LPAREN","LBRACK","LBRACE","COMMA","PERIOD","RPAREN","RBRACK","RBRACE","SEMICOLON","COLON","BREAK","CASE","CHAN","CONST","CONTINUE","DEFAULT","DEFER","ELSE","FALLTHROUGH","FOR","FUNC","GO","GOTO","IF","IMPORT","INTERFACE","MAP","PACKAGE","RANGE","RETURN","SELECT","STRUCT","SWITCH","TYPE","VAR","TILDE","LowestPrec","UnaryPrec","HighestPrec","Lookup","IsExported","IsKeyword","IsIdentifier","Alias","NewAlias","Unalias","Error","ArgumentError","Importer","ImportMode","ImporterFrom","Config","Info","TypeAndValue","Instance","Initializer","AssertableTo","AssignableTo","ConvertibleTo","Implements","Satisfies","Identical","IdenticalIgnoreTags","Array","NewArray","BasicKind","Invalid","Bool","Int","Int8","Int16","Int32","Int64","Uint","Uint8","Uint16","Uint32","Uint64","Uintptr","Float32","Float64","Complex64","Complex128","String","UnsafePointer","UntypedBool","UntypedInt","UntypedRune","UntypedFloat","UntypedComplex","UntypedString","UntypedNil","Byte","Rune","BasicInfo","IsBoolean","IsInteger","IsUnsigned","IsFloat","IsComplex","IsString","IsUntyped","IsOrdered","IsNumeric","IsConstType","Basic","Chan","ChanDir","SendRecv","SendOnly","RecvOnly","NewChan","Checker","NewChecker","Context","NewContext","Eval","CheckExpr","ExprString","WriteExpr","Instantiate","Interface","NewInterface","NewInterfaceType","LookupFieldOrMethod","MissingMethod","Map","NewMap","MethodSet","NewMethodSet","Named","NewNamed","Object","Id","PkgName","NewPkgName","Const","NewConst","TypeName","NewTypeName","Var","NewVar","NewParam","NewField","Func","NewFunc","Label","NewLabel","Builtin","Nil","ObjectString","Package","NewPackage","Pointer","NewPointer","IsInterface","Comparable","Default","Scope","NewScope","SelectionKind","FieldVal","MethodVal","MethodExpr","Selection","SelectionString","Signature","NewSignature","NewSignatureType","Sizes","StdSizes","SizesFor","Slice","NewSlice","Struct","NewStruct","Tuple","NewTuple","Type","TypeParamList","TypeList","TypeParam","NewTypeParam","Qualifier","RelativeTo","TypeString","WriteType","WriteSignature","Union","NewUnion","Term","NewTerm","Universe","Unsafe","Typ","DefPredeclaredTestFuncs","Lang","Compare","IsValid","Size","New","Checksum","Size","IEEE","Castagnoli","Koopman","Table","IEEETable","MakeTable","New","NewIEEE","Update","Checksum","ChecksumIEEE","Size","ISO","ECMA","Table","MakeTable","New","Update","Checksum","New32","New32a","New64","New64a","New128","New128a","Seed","Bytes","String","Hash","MakeSeed","CSS","HTML","HTMLAttr","JS","JSStr","URL","Srcset","Error","ErrorCode","OK","ErrAmbigContext","ErrBadHTML","ErrBranchEnd","ErrEndContext","ErrNoSuchTemplate","ErrOutputContext","ErrPartialCharset","ErrPartialEscape","ErrRangeLoopReentry","ErrSlashAmbig","ErrPredefinedEscaper","ErrJSTemplate","HTMLEscape","HTMLEscapeString","HTMLEscaper","JSEscape","JSEscapeString","JSEscaper","URLQueryEscaper","Template","New","FuncMap","Must","ParseFiles","ParseGlob","IsTrue","ParseFS","Color","RGBA","RGBA64","NRGBA","NRGBA64","Alpha","Alpha16","Gray","Gray16","Model","ModelFunc","RGBAModel","RGBA64Model","NRGBAModel","NRGBA64Model","AlphaModel","Alpha16Model","GrayModel","Gray16Model","Palette","Black","White","Transparent","Opaque","RGBToYCbCr","YCbCrToRGB","YCbCr","YCbCrModel","NYCbCrA","NYCbCrAModel","RGBToCMYK","CMYKToRGB","CMYK","CMYKModel","Image","RGBA64Image","Quantizer","Op","Over","Src","Drawer","FloydSteinberg","Draw","DrawMask","DisposalNone","DisposalBackground","DisposalPrevious","Decode","GIF","DecodeAll","DecodeConfig","Options","EncodeAll","Encode","FormatError","UnsupportedError","Reader","Decode","DecodeConfig","DefaultQuality","Options","Encode","FormatError","UnsupportedError","Decode","DecodeConfig","Encoder","EncoderBufferPool","EncoderBuffer","CompressionLevel","DefaultCompression","NoCompression","BestSpeed","BestCompression","Encode","Index","New","FormatFileInfo","FormatDirEntry","FS","ValidPath","File","DirEntry","ReadDirFile","ErrInvalid","ErrPermission","ErrExist","ErrNotExist","ErrClosed","FileInfo","FileMode","ModeDir","ModeAppend","ModeExclusive","ModeTemporary","ModeSymlink","ModeDevice","ModeNamedPipe","ModeSocket","ModeSetuid","ModeSetgid","ModeCharDevice","ModeSticky","ModeIrregular","ModeType","ModePerm","PathError","GlobFS","Glob","ReadDirFS","ReadDir","FileInfoToDirEntry","ReadFileFS","ReadFile","StatFS","Stat","SubFS","Sub","SkipDir","SkipAll","WalkDirFunc","WalkDir","ReadAll","ReadFile","WriteFile","ReadDir","NopCloser","Discard","TempFile","TempDir","Attr","String","Int64","Int","Uint64","Float64","Bool","Time","Duration","Group","Any","Handler","HandlerOptions","TimeKey","LevelKey","MessageKey","SourceKey","JSONHandler","NewJSONHandler","Level","LevelDebug","LevelInfo","LevelWarn","LevelError","LevelVar","Leveler","SetLogLoggerLevel","Default","SetDefault","Logger","New","With","NewLogLogger","Debug","DebugContext","Info","InfoContext","Warn","WarnContext","Error","ErrorContext","Log","LogAttrs","Record","NewRecord","Source","TextHandler","NewTextHandler","Value","Kind","KindAny","KindBool","KindDuration","KindFloat64","KindInt64","KindString","KindTime","KindUint64","KindGroup","KindLogValuer","StringValue","IntValue","Int64Value","Uint64Value","Float64Value","BoolValue","TimeValue","DurationValue","GroupValue","AnyValue","LogValuer","Priority","LOG_EMERG","LOG_ALERT","LOG_CRIT","LOG_ERR","LOG_WARNING","LOG_NOTICE","LOG_INFO","LOG_DEBUG","LOG_KERN","LOG_USER","LOG_MAIL","LOG_DAEMON","LOG_AUTH","LOG_SYSLOG","LOG_LPR","LOG_NEWS","LOG_UUCP","LOG_CRON","LOG_AUTHPRIV","LOG_FTP","LOG_LOCAL0","LOG_LOCAL1","LOG_LOCAL2","LOG_LOCAL3","LOG_LOCAL4","LOG_LOCAL5","LOG_LOCAL6","LOG_LOCAL7","Writer","New","Dial","NewLogger","Word","Float","ErrNaN","NewFloat","MaxExp","MinExp","MaxPrec","RoundingMode","ToNearestEven","ToNearestAway","ToZero","AwayFromZero","ToNegativeInf","ToPositiveInf","Accuracy","Below","Exact","Above","ParseFloat","Int","NewInt","Jacobi","MaxBase","Rat","NewRat","UintSize","LeadingZeros","LeadingZeros8","LeadingZeros16","LeadingZeros32","LeadingZeros64","TrailingZeros","TrailingZeros8","TrailingZeros16","TrailingZeros32","TrailingZeros64","OnesCount","OnesCount8","OnesCount16","OnesCount32","OnesCount64","RotateLeft","RotateLeft8","RotateLeft16","RotateLeft32","RotateLeft64","Reverse","Reverse8","Reverse16","Reverse32","Reverse64","ReverseBytes","ReverseBytes16","ReverseBytes32","ReverseBytes64","Len","Len8","Len16","Len32","Len64","Add","Add32","Add64","Sub","Sub32","Sub64","Mul","Mul32","Mul64","Div","Div32","Div64","Rem","Rem32","Rem64","Abs","Asin","Asinh","Acos","Acosh","Atan","Atanh","Conj","Exp","IsInf","Inf","IsNaN","NaN","Log","Log10","Phase","Polar","Pow","Rect","Sin","Sinh","Cos","Cosh","Sqrt","Tan","Tanh","Cot","Source","Source64","NewSource","Rand","New","Seed","Int63","Uint32","Uint64","Int31","Int","Int63n","Int31n","Intn","Float64","Float32","Perm","Shuffle","Read","NormFloat64","ExpFloat64","Zipf","NewZipf","ErrMessageTooLarge","Form","FileHeader","File","Part","NewReader","Reader","Writer","NewWriter","Reader","NewReader","Writer","NewWriter","Client","DefaultClient","RoundTripper","ErrSchemeMismatch","Get","ErrUseLastResponse","Post","PostForm","Head","Cookie","SameSite","SameSiteDefaultMode","SameSiteLaxMode","SameSiteStrictMode","SameSiteNoneMode","ParseCookie","ParseSetCookie","SetCookie","NewFileTransport","NewFileTransportFS","Dir","FileSystem","File","ServeContent","ServeFile","ServeFileFS","FS","FileServer","FileServerFS","Header","ParseTime","CanonicalHeaderKey","NoBody","PushOptions","Pusher","CookieJar","MethodGet","MethodHead","MethodPost","MethodPut","MethodPatch","MethodDelete","MethodConnect","MethodOptions","MethodTrace","ErrMissingFile","ProtocolError","ErrNotSupported","ErrUnexpectedTrailer","ErrMissingBoundary","ErrNotMultipart","ErrHeaderTooLong","ErrShortBody","ErrMissingContentLength","Request","ErrNoCookie","ParseHTTPVersion","NewRequest","NewRequestWithContext","ReadRequest","MaxBytesReader","MaxBytesError","Response","ErrNoLocation","ReadResponse","ResponseController","NewResponseController","ErrBodyNotAllowed","ErrHijacked","ErrContentLength","ErrWriteAfterFlush","Handler","ResponseWriter","Flusher","Hijacker","CloseNotifier","ServerContextKey","LocalAddrContextKey","TrailerPrefix","DefaultMaxHeaderBytes","TimeFormat","ErrAbortHandler","HandlerFunc","Error","NotFound","NotFoundHandler","StripPrefix","Redirect","RedirectHandler","ServeMux","NewServeMux","DefaultServeMux","Handle","HandleFunc","Serve","ServeTLS","Server","ConnState","StateNew","StateActive","StateIdle","StateHijacked","StateClosed","AllowQuerySemicolons","ErrServerClosed","ListenAndServe","ListenAndServeTLS","TimeoutHandler","ErrHandlerTimeout","MaxBytesHandler","DetectContentType","StatusContinue","StatusSwitchingProtocols","StatusProcessing","StatusEarlyHints","StatusOK","StatusCreated","StatusAccepted","StatusNonAuthoritativeInfo","StatusNoContent","StatusResetContent","StatusPartialContent","StatusMultiStatus","StatusAlreadyReported","StatusIMUsed","StatusMultipleChoices","StatusMovedPermanently","StatusFound","StatusSeeOther","StatusNotModified","StatusUseProxy","StatusTemporaryRedirect","StatusPermanentRedirect","StatusBadRequest","StatusUnauthorized","StatusPaymentRequired","StatusForbidden","StatusNotFound","StatusMethodNotAllowed","StatusNotAcceptable","StatusProxyAuthRequired","StatusRequestTimeout","StatusConflict","StatusGone","StatusLengthRequired","StatusPreconditionFailed","StatusRequestEntityTooLarge","StatusRequestURITooLong","StatusUnsupportedMediaType","StatusRequestedRangeNotSatisfiable","StatusExpectationFailed","StatusTeapot","StatusMisdirectedRequest","StatusUnprocessableEntity","StatusLocked","StatusFailedDependency","StatusTooEarly","StatusUpgradeRequired","StatusPreconditionRequired","StatusTooManyRequests","StatusRequestHeaderFieldsTooLarge","StatusUnavailableForLegalReasons","StatusInternalServerError","StatusNotImplemented","StatusBadGateway","StatusServiceUnavailable","StatusGatewayTimeout","StatusHTTPVersionNotSupported","StatusVariantAlsoNegotiates","StatusInsufficientStorage","StatusLoopDetected","StatusNotExtended","StatusNetworkAuthenticationRequired","StatusText","ErrLineTooLong","ErrBodyReadAfterClose","DefaultTransport","DefaultMaxIdleConnsPerHost","Transport","ProxyFromEnvironment","ProxyURL","ErrSkipAltProtocol","Message","ReadMessage","ParseDate","Header","ErrHeaderNotPresent","Address","ParseAddress","ParseAddressList","AddressParser","Addr","IPv6LinkLocalAllNodes","IPv6LinkLocalAllRouters","IPv6Loopback","IPv6Unspecified","IPv4Unspecified","AddrFrom4","AddrFrom16","ParseAddr","MustParseAddr","AddrFromSlice","AddrPort","AddrPortFrom","ParseAddrPort","MustParseAddrPort","Prefix","PrefixFrom","ParsePrefix","MustParsePrefix","ServerError","ErrShutdown","Call","Client","ClientCodec","NewClient","NewClientWithCodec","DialHTTP","DialHTTPPath","Dial","DefaultRPCPath","DefaultDebugPath","Request","Response","Server","NewServer","DefaultServer","Register","RegisterName","ServerCodec","ServeConn","ServeCodec","ServeRequest","Accept","HandleHTTP","Auth","ServerInfo","PlainAuth","CRAMMD5Auth","Client","Dial","NewClient","SendMail","MIMEHeader","Pipeline","Reader","NewReader","CanonicalMIMEHeaderKey","Error","ProtocolError","Conn","NewConn","Dial","TrimString","TrimBytes","Writer","NewWriter","Error","EscapeError","InvalidHostError","QueryUnescape","PathUnescape","QueryEscape","PathEscape","URL","User","UserPassword","Userinfo","Parse","ParseRequestURI","Values","ParseQuery","JoinPath","Error","ErrWaitDelay","Cmd","Command","CommandContext","ExitError","ErrDot","ErrNotFound","LookPath","Ignore","Ignored","Notify","Reset","Stop","NotifyContext","Current","Lookup","LookupId","LookupGroup","LookupGroupId","User","Group","UnknownUserIdError","UnknownUserError","UnknownGroupIdError","UnknownGroupError","ErrBadPattern","Match","Glob","Separator","ListSeparator","Clean","IsLocal","Localize","ToSlash","FromSlash","SplitList","Split","Join","Ext","EvalSymlinks","IsAbs","Abs","Rel","SkipDir","SkipAll","WalkFunc","WalkDir","Walk","Base","Dir","VolumeName","HasPrefix","Compile","Error","ErrorCode","ErrInternalError","ErrInvalidCharClass","ErrInvalidCharRange","ErrInvalidEscape","ErrInvalidNamedCapture","ErrInvalidPerlOp","ErrInvalidRepeatOp","ErrInvalidRepeatSize","ErrInvalidUTF8","ErrMissingBracket","ErrMissingParen","ErrMissingRepeatArgument","ErrTrailingBackslash","ErrUnexpectedParen","ErrNestingDepth","ErrLarge","Flags","FoldCase","Literal","ClassNL","DotNL","OneLine","NonGreedy","PerlX","UnicodeGroups","WasDollar","Simple","MatchNL","Perl","POSIX","Parse","Prog","InstOp","InstAlt","InstAltMatch","InstCapture","InstEmptyWidth","InstMatch","InstFail","InstNop","InstRune","InstRune1","InstRuneAny","InstRuneAnyNotNL","EmptyOp","EmptyBeginLine","EmptyEndLine","EmptyBeginText","EmptyEndText","EmptyWordBoundary","EmptyNoWordBoundary","EmptyOpContext","IsWordChar","Inst","Regexp","Op","OpNoMatch","OpEmptyMatch","OpLiteral","OpCharClass","OpAnyCharNotNL","OpAnyChar","OpBeginLine","OpEndLine","OpBeginText","OpEndText","OpWordBoundary","OpNoWordBoundary","OpCapture","OpStar","OpPlus","OpQuest","OpRepeat","OpConcat","OpAlternate","Incomplete","Handle","NewHandle","WriteMetaDir","WriteMeta","WriteCountersDir","WriteCounters","ClearCounters","GCStats","ReadGCStats","SetGCPercent","FreeOSMemory","SetMaxStack","SetMaxThreads","SetPanicOnFault","WriteHeapDump","SetTraceback","SetMemoryLimit","ReadBuildInfo","BuildInfo","Module","BuildSetting","ParseBuildInfo","PrintStack","Stack","CrashOptions","SetCrashOutput","Description","All","Float64Histogram","Sample","Read","ValueKind","KindBad","KindUint64","KindFloat64","KindFloat64Histogram","Value","LabelSet","WithLabels","Labels","Label","ForLabels","Profile","NewProfile","Lookup","Profiles","WriteHeapProfile","StartCPUProfile","StopCPUProfile","SetGoroutineLabels","Do","NewTask","Task","Log","Logf","WithRegion","StartRegion","Region","IsEnabled","Start","Stop","SwapInt32","SwapInt64","SwapUint32","SwapUint64","SwapUintptr","SwapPointer","CompareAndSwapInt32","CompareAndSwapInt64","CompareAndSwapUint32","CompareAndSwapUint64","CompareAndSwapUintptr","CompareAndSwapPointer","AddInt32","AddUint32","AddInt64","AddUint64","AddUintptr","AndInt32","AndUint32","AndInt64","AndUint64","AndUintptr","OrInt32","OrUint32","OrInt64","OrUint64","OrUintptr","LoadInt32","LoadInt64","LoadUint32","LoadUint64","LoadUintptr","LoadPointer","StoreInt32","StoreInt64","StoreUint32","StoreUint64","StoreUintptr","StorePointer","Bool","Pointer","Int32","Int64","Uint32","Uint64","Uintptr","Value","Func","FuncOf","Value","Error","Undefined","Null","Global","ValueOf","Type","TypeUndefined","TypeNull","TypeBoolean","TypeNumber","TypeString","TypeSymbol","TypeObject","TypeFunction","ValueError","CopyBytesToGo","CopyBytesToJS","MapFS","MapFile","TestFS","NewWriteLogger","NewReadLogger","OneByteReader","HalfReader","DataErrReader","ErrTimeout","TimeoutReader","ErrReader","TestReader","TruncateWriter","Generator","Value","Config","SetupError","CheckError","CheckEqualError","Check","CheckEqual","TestHandler","Run","Position","ScanIdents","ScanInts","ScanFloats","ScanChars","ScanStrings","ScanRawStrings","ScanComments","SkipComments","GoTokens","EOF","Ident","Int","Float","Char","String","RawString","Comment","TokenString","GoWhitespace","Scanner","Writer","FilterHTML","StripEscape","AlignRight","DiscardEmptyColumns","TabIndent","Debug","Escape","NewWriter","ExecError","IsTrue","FuncMap","HTMLEscape","HTMLEscapeString","HTMLEscaper","JSEscape","JSEscapeString","JSEscaper","URLQueryEscaper","Must","ParseFiles","ParseGlob","ParseFS","Template","New","IsSurrogate","DecodeRune","EncodeRune","RuneLen","Encode","AppendRune","Decode","RuneError","RuneSelf","MaxRune","UTFMax","FullRune","FullRuneInString","DecodeRune","DecodeRuneInString","DecodeLastRune","DecodeLastRuneInString","RuneLen","EncodeRune","AppendRune","RuneCount","RuneCountInString","RuneStart","Valid","ValidString","ValidRune","AlgorithmIdentifier","RDNSequence","RelativeDistinguishedNameSET","AttributeTypeAndValue","AttributeTypeAndValueSET","Extension","Name","CertificateList","TBSCertificateList","RevokedCertificate","Value","NamedValue","Driver","DriverContext","Connector","ErrSkip","ErrBadConn","Pinger","Execer","ExecerContext","Queryer","QueryerContext","Conn","ConnPrepareContext","IsolationLevel","TxOptions","ConnBeginTx","SessionResetter","Validator","Result","Stmt","StmtExecContext","StmtQueryContext","ErrRemoveArgument","NamedValueChecker","ColumnConverter","Rows","RowsNextResultSet","RowsColumnTypeScanType","RowsColumnTypeDatabaseTypeName","RowsColumnTypeLength","RowsColumnTypeNullable","RowsColumnTypePrecisionScale","Tx","RowsAffected","ResultNoRows","ValueConverter","Valuer","Bool","Int32","String","Null","NotNull","IsValue","IsScanValue","DefaultParameterConverter","Expr","TagExpr","NotExpr","AndExpr","OrExpr","SyntaxError","Parse","IsGoBuild","IsPlusBuild","PlusBuildLines","GoVersion","Doc","LinkDef","Block","Heading","List","ListItem","Paragraph","Code","Text","Plain","Italic","Link","DocLink","Parser","DefaultLookupPackage","Printer","Plan9","WebSafe","ChaCha8","NewChaCha8","PCG","NewPCG","Source","Rand","New","Int64","Uint32","Uint64N","Uint32N","Uint64","Int32","Int","Uint","Int64N","Int32N","IntN","UintN","N","Float64","Float32","Perm","Shuffle","NormFloat64","ExpFloat64","Zipf","NewZipf","Request","RequestFromMap","Serve","Handler","PublicSuffixList","Options","Jar","New","ErrRequestAborted","ErrConnClosed","Serve","ProcessEnv","NewRequest","NewRequestWithContext","ResponseRecorder","NewRecorder","DefaultRemoteAddr","Server","NewServer","NewUnstartedServer","NewTLSServer","ContextClientTrace","WithClientTrace","ClientTrace","WroteRequestInfo","DNSStartInfo","DNSDoneInfo","GotConnInfo","DumpRequestOut","DumpRequest","DumpResponse","NewChunkedReader","NewChunkedWriter","ErrLineTooLong","ErrPersistEOF","ErrClosed","ErrPipeline","ServerConn","NewServerConn","ClientConn","NewClientConn","NewProxyClientConn","ProxyRequest","ReverseProxy","BufferPool","NewSingleHostReverseProxy","Cmdline","Profile","Trace","Symbol","Handler","Index","NewClientCodec","NewClient","Dial","NewServerCodec","ServeConn","Node","NodeType","Pos","NodeText","NodeAction","NodeBool","NodeChain","NodeCommand","NodeDot","NodeField","NodeIdentifier","NodeIf","NodeList","NodeNil","NodeNumber","NodePipe","NodeRange","NodeString","NodeTemplate","NodeVariable","NodeWith","NodeComment","NodeBreak","NodeContinue","ListNode","TextNode","CommentNode","PipeNode","ActionNode","CommandNode","IdentifierNode","NewIdentifier","VariableNode","DotNode","NilNode","FieldNode","ChainNode","BoolNode","NumberNode","StringNode","BranchNode","IfNode","BreakNode","ContinueNode","RangeNode","WithNode","TemplateNode","Tree","Mode","ParseComments","SkipFuncCheck","Parse","New","IsEmptyTree","KeySize","NonceSize","NonceSizeX","Cipher","NewUnauthenticatedCipher","HChaCha20","KeySize","NonceSize","NonceSizeX","Overhead","New","NewX","Builder","NewBuilder","NewFixedBuilder","BuilderContinuation","BuildError","MarshalingValue","String","Extract","Expand","New","New224","New256","New384","New512","NewLegacyKeccak256","NewLegacyKeccak512","Sum224","Sum256","Sum384","Sum512","ShakeHash","NewShake128","NewShake256","NewCShake128","NewCShake256","ShakeSum128","ShakeSum256","ToASCII","ToUnicode","Option","Transitional","VerifyDNSLength","RemoveLeadingDots","ValidateLabels","CheckHyphens","CheckJoiners","StrictDomainName","BidiRule","ValidateForRegistration","MapForLookup","Profile","New","Punycode","Lookup","Display","Registration","UnicodeVersion","MakePipe","TestConn","SupportsIPv4","SupportsIPv6","SupportsRawSocket","TestableNetwork","TestableAddress","NewLocalListener","NewLocalPacketListener","LocalPath","MulticastSource","LoopbackInterface","RoutedInterface","Initialized","CacheLinePad","X86","ARM64","ARM","MIPS64X","PPC64","S390X","IsBigEndian","ErrShortDst","ErrShortSrc","ErrEndOfSpan","Transformer","SpanningTransformer","NopResetter","Reader","NewReader","Writer","NewWriter","Discard","Nop","Chain","RemoveFunc","String","Bytes","Append","Tag","BOOLEAN","INTEGER","BIT_STRING","OCTET_STRING","NULL","OBJECT_IDENTIFIER","ENUM","UTF8String","SEQUENCE","SET","PrintableString","T61String","IA5String","UTCTime","GeneralizedTime","GeneralString","Type","TypeA","TypeNS","TypeCNAME","TypeSOA","TypePTR","TypeMX","TypeTXT","TypeAAAA","TypeSRV","TypeOPT","TypeWKS","TypeHINFO","TypeMINFO","TypeAXFR","TypeALL","Class","ClassINET","ClassCSNET","ClassCHAOS","ClassHESIOD","ClassANY","OpCode","RCode","RCodeSuccess","RCodeFormatError","RCodeServerFailure","RCodeNameError","RCodeNotImplemented","RCodeRefused","ErrNotStarted","ErrSectionDone","Header","Message","Resource","ResourceBody","Parser","Builder","NewBuilder","ResourceHeader","Name","NewName","MustNewName","Question","CNAMEResource","MXResource","NSResource","PTRResource","SOAResource","TXTResource","SRVResource","AResource","AAAAResource","OPTResource","Option","UnknownResource","ValidTrailerHeader","IsTokenRune","HeaderValuesContainsToken","ValidHeaderFieldName","ValidHostHeader","ValidHeaderFieldValue","PunycodeHostPort","Config","FromEnvironment","Encoder","NewEncoder","DecodingError","InvalidIndexError","HeaderField","Decoder","NewDecoder","ErrStringLength","HuffmanDecode","HuffmanDecodeToString","ErrInvalidHuffman","AppendHuffmanString","HuffmanEncodeLength","ErrInvalid","Direction","DirectionString","Valid","ValidString","New","Transformer","Direction","LeftToRight","RightToLeft","Mixed","Neutral","Option","DefaultDirection","Paragraph","Ordering","Run","AppendReverse","ReverseString","Properties","LookupRune","Lookup","LookupString","UnicodeVersion","Class","L","R","EN","ES","ET","AN","CS","B","S","WS","ON","BN","NSM","AL","Control","LRO","RLO","LRE","RLE","PDF","LRI","RLI","FSI","PDI","GraphemeJoiner","Properties","MaxSegmentSize","Iter","Form","NFC","NFD","NFKC","NFKD","Version","MaxTransformChunkSize"],"docs":["","","","","Reader implements buffering for an io.Reader object.","NewReaderSize returns a new \\[Reader] whose buffer has at least the specified size. If the argument io.Reader is already a \\[Reader] with large enough size, it returns the underlying \\[Reader].","NewReader returns a new \\[Reader] whose buffer has the default size.","Writer implements buffering for an [io.Writer](https://pkg.go.dev/io/#Writer) object. If an error occurs writing to a \\[Writer], no more data will be accepted and all subsequent writes, and \\[Writer.Flush], will return the error. After all data has been written, the client should call the \\[Writer.Flush] method to guarantee all data has been forwarded to the underlying [io.Writer](https://pkg.go.dev/io/#Writer).","NewWriterSize returns a new \\[Writer] whose buffer has at least the specified size. If the argument io.Writer is already a \\[Writer] with large enough size, it returns the underlying \\[Writer].","NewWriter returns a new \\[Writer] whose buffer has the default size. If the argument io.Writer is already a \\[Writer] with large enough buffer size, it returns the underlying \\[Writer].","ReadWriter stores pointers to a \\[Reader] and a \\[Writer]. It implements [io.ReadWriter](https://pkg.go.dev/io/#ReadWriter).","NewReadWriter allocates a new \\[ReadWriter] that dispatches to r and w.","Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the \\[Scanner.Scan] method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type \\[SplitFunc]; the default split function breaks the input into lines with line termination stripped. \\[Scanner.Split] functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.\n\nScanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the \\[Scanner.Buffer]. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use [bufio.Reader](https://pkg.go.dev/bufio/#Reader) instead.","SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the \\[Reader] has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.\n\nScanning stops if the function returns an error, in which case some of the input may be discarded. If that error is \\[ErrFinalToken], scanning stops with no error. A non-nil token delivered with \\[ErrFinalToken] will be the last token, and a nil token with \\[ErrFinalToken] immediately stops the scanning.\n\nOtherwise, the \\[Scanner] advances the input. If the token is not nil, the \\[Scanner] returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the \\[Scanner] returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a \\[SplitFunc] can return (0, nil, nil) to signal the \\[Scanner] to read more data into the slice and try again with a longer slice starting at the same point in the input.\n\nThe function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.","","","","","MaxScanTokenSize is the maximum size used to buffer a token unless the user provides an explicit buffer with \\[Scanner.Buffer]. The actual maximum token size may be smaller as the buffer may need to include, for instance, a newline.","NewScanner returns a new \\[Scanner] to read from r. The split function defaults to \\[ScanLines].","ErrFinalToken is a special sentinel error value. It is intended to be returned by a Split function to indicate that the scanning should stop with no error. If the token being delivered with this error is not nil, the token is the last token.\n\nThe value is useful to stop processing early or when it is necessary to deliver a final empty token (which is different from a nil token). One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.","ScanBytes is a split function for a \\[Scanner] that returns each byte as a token.","ScanRunes is a split function for a \\[Scanner] that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = \"\\\\xef\\\\xbf\\\\xbd\". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.","ScanLines is a split function for a \\[Scanner] that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is \\`\\\\r?\\\\n\\`. The last non-empty line of input will be returned even if it has no newline.","ScanWords is a split function for a \\[Scanner] that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.","bool is the set of boolean values, true and false.","","","uint8 is the set of all unsigned 8-bit integers. Range: 0 through 255.","uint16 is the set of all unsigned 16-bit integers. Range: 0 through 65535.","uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295.","uint64 is the set of all unsigned 64-bit integers. Range: 0 through 18446744073709551615.","int8 is the set of all signed 8-bit integers. Range: -128 through 127.","int16 is the set of all signed 16-bit integers. Range: -32768 through 32767.","int32 is the set of all signed 32-bit integers. Range: -2147483648 through 2147483647.","int64 is the set of all signed 64-bit integers. Range: -9223372036854775808 through 9223372036854775807.","float32 is the set of all IEEE 754 32-bit floating-point numbers.","float64 is the set of all IEEE 754 64-bit floating-point numbers.","complex64 is the set of all complex numbers with float32 real and imaginary parts.","complex128 is the set of all complex numbers with float64 real and imaginary parts.","string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable.","int is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32.","uint is an unsigned integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, uint32.","uintptr is an integer type that is large enough to hold the bit pattern of any pointer.","byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values.","rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values.","any is an alias for interface{} and is equivalent to interface{} in all ways.","comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable.","iota is a predeclared identifier representing the untyped integer ordinal number of the current const specification in a (usually parenthesized) const declaration. It is zero-indexed.","nil is a predeclared identifier representing the zero value for a pointer, channel, func, interface, map, or slice type.","The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:\n\n\tslice = append(slice, elem1, elem2)\n\tslice = append(slice, anotherSlice...)\n\nAs a special case, it is legal to append a string to a byte slice, like this:\n\n\tslice = append([]byte(\"hello \"), \"world\"...)","The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).","The delete built-in function deletes the element with the specified key (m\\[key]) from the map. If m is nil or there is no such element, delete is a no-op.","The len built-in function returns the length of v, according to its type:\n\n\tArray: the number of elements in v.\n\tPointer to array: the number of elements in *v (even if v is nil).\n\tSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\n\tString: the number of bytes in v.\n\tChannel: the number of elements queued (unread) in the channel buffer;\n\t         if v is nil, len(v) is zero.\n\nFor some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's \"Length and capacity\" section for details.","The cap built-in function returns the capacity of v, according to its type:\n\n\tArray: the number of elements in v (same as len(v)).\n\tPointer to array: the number of elements in *v (same as len(v)).\n\tSlice: the maximum length the slice can reach when resliced;\n\tif v is nil, cap(v) is zero.\n\tChannel: the channel buffer capacity, in units of elements;\n\tif v is nil, cap(v) is zero.\n\nFor some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's \"Length and capacity\" section for details.","The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:\n\n\tSlice: The size specifies the length. The capacity of the slice is\n\tequal to its length. A second integer argument may be provided to\n\tspecify a different capacity; it must be no smaller than the\n\tlength. For example, make([]int, 0, 10) allocates an underlying array\n\tof size 10 and returns a slice of length 0 and capacity 10 that is\n\tbacked by this underlying array.\n\tMap: An empty map is allocated with enough space to hold the\n\tspecified number of elements. The size may be omitted, in which case\n\ta small starting size is allocated.\n\tChannel: The channel's buffer is initialized with the specified\n\tbuffer capacity. If zero, or the size is omitted, the channel is\n\tunbuffered.","The max built-in function returns the largest value of a fixed number of arguments of [cmp.Ordered](https://pkg.go.dev/cmp/#Ordered) types. There must be at least one argument. If T is a floating-point type and any of the arguments are NaNs, max will return NaN.","The min built-in function returns the smallest value of a fixed number of arguments of [cmp.Ordered](https://pkg.go.dev/cmp/#Ordered) types. There must be at least one argument. If T is a floating-point type and any of the arguments are NaNs, min will return NaN.","The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.","The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).","The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.","The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.","The clear built-in function clears maps and slices. For maps, clear deletes all entries, resulting in an empty map. For slices, clear sets all elements up to the length of the slice to the zero value of the respective element type. If the argument type is a type parameter, the type parameter's type set must contain only map or slice types, and clear performs the operation implied by the type argument.","The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form\n\n\tx, ok := \u003c-c\n\nwill also set ok to false for a closed and empty channel.","The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.\n\nStarting in Go 1.21, calling panic with a nil interface value or an untyped nil causes a run-time error (a different panic). The GODEBUG setting panicnil=1 disables the run-time error.","The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, recover returns nil.\n\nPrior to Go 1.21, recover would also return nil if panic is called with a nil argument. See \\[panic] for details.","The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.","The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.","The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.","A Buffer is a variable-sized buffer of bytes with \\[Buffer.Read] and \\[Buffer.Write] methods. The zero value for Buffer is an empty buffer ready to use.","ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.","MinRead is the minimum slice size passed to a \\[Buffer.Read] call by \\[Buffer.ReadFrom]. As long as the \\[Buffer] has at least MinRead bytes beyond what is required to hold the contents of r, \\[Buffer.ReadFrom] will not grow the underlying buffer.","NewBuffer creates and initializes a new \\[Buffer] using buf as its initial contents. The new \\[Buffer] takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a \\[Buffer] to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.\n\nIn most cases, new(\\[Buffer]) (or just declaring a \\[Buffer] variable) is sufficient to initialize a \\[Buffer].","NewBufferString creates and initializes a new \\[Buffer] using string s as its initial contents. It is intended to prepare a buffer to read an existing string.\n\nIn most cases, new(\\[Buffer]) (or just declaring a \\[Buffer] variable) is sufficient to initialize a \\[Buffer].","Equal reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice.","Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a == b, -1 if a \\\u003c b, and +1 if a \u003e b. A nil argument is equivalent to an empty slice.","Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.","Contains reports whether subslice is within b.","ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.","ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.","ContainsFunc reports whether any of the UTF-8-encoded code points r within b satisfy f(r).","IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.","LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.","LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.","IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is \\[utf8.RuneError], it returns the first instance of any invalid UTF-8 byte sequence.","IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.","LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.","SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:\n\n  - n \u003e 0: at most n subslices; the last subslice will be the unsplit remainder;\n  - n == 0: the result is nil (zero subslices);\n  - n \\\u003c 0: all subslices.\n\nTo split around the first instance of a separator, see \\[Cut].","SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:\n\n  - n \u003e 0: at most n subslices; the last subslice will be the unsplit remainder;\n  - n == 0: the result is nil (zero subslices);\n  - n \\\u003c 0: all subslices.","Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.\n\nTo split around the first instance of a separator, see \\[Cut].","SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.","Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by [unicode.IsSpace](https://pkg.go.dev/unicode/#IsSpace), returning a slice of subslices of s or an empty slice if s contains only white space.","FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned.\n\nFieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c.","Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.","HasPrefix reports whether the byte slice s begins with prefix.","HasSuffix reports whether the byte slice s ends with suffix.","Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points.","Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if the result of (len(b) \\* count) overflows.","ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.","ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.","ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.","ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.","ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.","ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.","ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.","Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.\n\nDeprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead.","TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).","TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).","TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).","TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.","TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.","IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.","LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.","Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.","TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.","TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.","TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.","Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.","Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n \\\u003c 0, there is no limit on the number of replacements.","ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice.","EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity.","Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.","Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, nil, false.\n\nCut returns slices of the original slice s, not copies.","Clone returns a copy of b\\[:len(b)]. The result may have additional unused capacity. Clone(nil) returns nil.","CutPrefix returns s without the provided leading prefix byte slice and reports whether it found the prefix. If s doesn't start with prefix, CutPrefix returns s, false. If prefix is the empty byte slice, CutPrefix returns s, true.\n\nCutPrefix returns slices of the original slice s, not copies.","CutSuffix returns s without the provided ending suffix byte slice and reports whether it found the suffix. If s doesn't end with suffix, CutSuffix returns s, false. If suffix is the empty byte slice, CutSuffix returns s, true.\n\nCutSuffix returns slices of the original slice s, not copies.","A Reader implements the [io.Reader](https://pkg.go.dev/io/#Reader), [io.ReaderAt](https://pkg.go.dev/io/#ReaderAt), [io.WriterTo](https://pkg.go.dev/io/#WriterTo), [io.Seeker](https://pkg.go.dev/io/#Seeker), [io.ByteScanner](https://pkg.go.dev/io/#ByteScanner), and [io.RuneScanner](https://pkg.go.dev/io/#RuneScanner) interfaces by reading from a byte slice. Unlike a \\[Buffer], a Reader is read-only and supports seeking. The zero value for Reader operates like a Reader of an empty slice.","NewReader returns a new \\[Reader] reading from b.","Ordered is a constraint that permits any ordered type: any type that supports the operators \\\u003c \\\u003c= \u003e= \u003e. If future releases of Go add new ordered types, this constraint will be modified to include them.\n\nNote that floating-point types may contain NaN (\"not-a-number\") values. An operator such as == or \\\u003c will always report false when comparing a NaN value with any other value, NaN or not. See the \\[Compare] function for a consistent way to compare NaN values.","Less reports whether x is less than y. For floating-point types, a NaN is considered less than any non-NaN, and -0.0 is not less than (is equal to) 0.0.","Compare returns\n\n\t-1 if x is less than y,\n\t 0 if x equals y,\n\t+1 if x is greater than y.\n\nFor floating-point types, a NaN is considered less than any non-NaN, a NaN is considered equal to a NaN, and -0.0 is equal to 0.0.","Or returns the first of its arguments that is not equal to the zero value. If no argument is non-zero, it returns the zero value.","A Context carries a deadline, a cancellation signal, and other values across API boundaries.\n\nContext's methods may be called by multiple goroutines simultaneously.","Canceled is the error returned by \\[Context.Err] when the context is canceled.","DeadlineExceeded is the error returned by \\[Context.Err] when the context's deadline passes.","Background returns a non-nil, empty \\[Context]. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests.","TODO returns a non-nil, empty \\[Context]. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter).","A CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. A CancelFunc may be called by multiple goroutines simultaneously. After the first call, subsequent calls to a CancelFunc do nothing.","WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this \\[Context] complete.","A CancelCauseFunc behaves like a \\[CancelFunc] but additionally sets the cancellation cause. This cause can be retrieved by calling \\[Cause] on the canceled Context or on any of its derived Contexts.\n\nIf the context has already been canceled, CancelCauseFunc does not set the cause. For example, if childContext is derived from parentContext:\n\n  - if parentContext is canceled with cause1 before childContext is canceled with cause2, then Cause(parentContext) == Cause(childContext) == cause1\n  - if childContext is canceled with cause2 before parentContext is canceled with cause1, then Cause(parentContext) == cause1 and Cause(childContext) == cause2","WithCancelCause behaves like \\[WithCancel] but returns a \\[CancelCauseFunc] instead of a \\[CancelFunc]. Calling cancel with a non-nil error (the \"cause\") records that error in ctx; it can then be retrieved using Cause(ctx). Calling cancel with nil sets the cause to Canceled.\n\nExample use:\n\n\tctx, cancel := context.WithCancelCause(parent)\n\tcancel(myError)\n\tctx.Err() // returns context.Canceled\n\tcontext.Cause(ctx) // returns myError","Cause returns a non-nil error explaining why c was canceled. The first cancellation of c or one of its parents sets the cause. If that cancellation happened via a call to CancelCauseFunc(err), then \\[Cause] returns err. Otherwise Cause(c) returns the same value as c.Err(). Cause returns nil if c has not been canceled yet.","AfterFunc arranges to call f in its own goroutine after ctx is done (canceled or timed out). If ctx is already done, AfterFunc calls f immediately in its own goroutine.\n\nMultiple calls to AfterFunc on a context operate independently; one does not replace another.\n\nCalling the returned stop function stops the association of ctx with f. It returns true if the call stopped f from being run. If stop returns false, either the context is done and f has been started in its own goroutine; or f was already stopped. The stop function does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.\n\nIf ctx has a \"AfterFunc(func()) func() bool\" method, AfterFunc will use it to schedule the call.","WithoutCancel returns a copy of parent that is not canceled when parent is canceled. The returned context returns no Deadline or Err, and its Done channel is nil. Calling \\[Cause] on the returned context returns nil.","WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned \\[Context.Done] channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this \\[Context] complete.","WithDeadlineCause behaves like \\[WithDeadline] but also sets the cause of the returned Context when the deadline is exceeded. The returned \\[CancelFunc] does not set the cause.","WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this \\[Context] complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}","WithTimeoutCause behaves like \\[WithTimeout] but also sets the cause of the returned Context when the timeout expires. The returned \\[CancelFunc] does not set the cause.","WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.","Hash identifies a cryptographic hash function that is implemented in another package.","","","","","","","","","","","","","","","","","","","","RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.","PublicKey represents a public key using an unspecified algorithm.\n\nAlthough this type is an empty interface for backwards compatibility reasons, all public key types in the standard library implement the following interface\n\n\tinterface{\n\t    Equal(x crypto.PublicKey) bool\n\t}\n\nwhich can be used for increased type safety within applications.","PrivateKey represents a private key using an unspecified algorithm.\n\nAlthough this type is an empty interface for backwards compatibility reasons, all private key types in the standard library implement the following interface\n\n\tinterface{\n\t    Public() crypto.PublicKey\n\t    Equal(x crypto.PrivateKey) bool\n\t}\n\nas well as purpose-specific interfaces such as \\[Signer] and \\[Decrypter], which can be used for increased type safety within applications.","Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.","SignerOpts contains options for signing with a \\[Signer].","Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module.","","An FS is a read-only collection of files, usually initialized with a //go:embed directive. When declared without a //go:embed directive, an FS is an empty file system.\n\nAn FS is a read-only value, so it is safe to use from multiple goroutines simultaneously and also safe to assign values of type FS to each other.\n\nFS implements fs.FS, so it can be used with any package that understands file system interfaces, including net/http, text/template, and html/template.\n\nSee the package documentation for more details about initializing an FS.","BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form.\n\nMarshalBinary encodes the receiver into a binary form and returns the result.","BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself.\n\nUnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.","TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.\n\nMarshalText encodes the receiver into UTF-8-encoded text and returns the result.","TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.\n\nUnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.","New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical.","ErrUnsupported indicates that a requested operation cannot be performed, because it is unsupported. For example, a call to [os.Link](https://pkg.go.dev/os/#Link) when using a file system that does not support hard links.\n\nFunctions and methods should not return this error but should instead return an error including appropriate context that satisfies\n\n\terrors.Is(err, errors.ErrUnsupported)\n\neither by directly wrapping ErrUnsupported or by implementing an \\[Is] method.\n\nFunctions and methods should document the cases in which an error wrapping this will be returned.","Join returns an error that wraps the given errors. Any nil error values are discarded. Join returns nil if every value in errs is nil. The error formats as the concatenation of the strings obtained by calling the Error method of each element of errs, with a newline between each string.\n\nA non-nil error returned by Join implements the Unwrap() \\[]error method.","Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.\n\nUnwrap only calls a method of the form \"Unwrap() error\". In particular Unwrap does not unwrap errors returned by \\[Join].","Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling its Unwrap() error or Unwrap() \\[]error method. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall/#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call \\[Unwrap] on either.","As finds the first error in err's tree that matches target, and if one is found, sets target to that error value and returns true. Otherwise, it returns false.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling its Unwrap() error or Unwrap() \\[]error method. When err wraps multiple errors, As examines err followed by a depth-first traversal of its children.\n\nAn error matches target if the error's concrete value is assignable to the value pointed to by target, or if the error has a method As(any) bool such that As(target) returns true. In the latter case, the As method is responsible for setting target.\n\nAn error type might provide an As method so it can be treated as if it were a different error type.\n\nAs panics if target is not a non-nil pointer to either a type that implements error, or to any interface type.","Var is an abstract type for all exported variables.","Int is a 64-bit integer variable that satisfies the \\[Var] interface.","Float is a 64-bit float variable that satisfies the \\[Var] interface.","Map is a string-to-Var map variable that satisfies the \\[Var] interface.","KeyValue represents a single entry in a \\[Map].","String is a string variable, and satisfies the \\[Var] interface.","Func implements \\[Var] by calling the function and formatting the returned value using JSON.","Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.","Get retrieves a named exported variable. It returns nil if the name has not been registered.","","","","","Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated.","Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.","ErrHelp is the error returned if the -help or -h flag is invoked but no such flag is defined.","Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)\n\nIf a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.\n\nSet is called once, in command line order, for each flag present. The flag package may call the \\[String] method with a zero-valued receiver, such as a nil pointer.","Getter is an interface that allows the contents of a \\[Value] to be retrieved. It wraps the \\[Value] interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All \\[Value] types provided by this package satisfy the \\[Getter] interface, except the type used by \\[Func].","ErrorHandling defines how \\[FlagSet.Parse] behaves if the parse fails.","","","","A FlagSet represents a set of defined flags. The zero value of a FlagSet has no name and has \\[ContinueOnError] error handling.\n\n\\[Flag] names must be unique within a FlagSet. An attempt to define a flag whose name is already in use will cause a panic.","A Flag represents the state of a flag.","VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.","Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.","Lookup returns the \\[Flag] structure of the named command-line flag, returning nil if none exists.","Set sets the value of the named command-line flag.","UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given \"a \\`name\\` to show\" it returns (\"name\", \"a name to show\"). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.","PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form\n\n\t-x int\n\t\tusage-message-for-x (default 7)\n\nThe usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given\n\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\n\nthe output will be\n\n\t-I directory\n\t\tsearch directory for include files.\n\nTo change the destination for flag messages, call \\[CommandLine].SetOutput.","Usage prints a usage message documenting all defined command-line flags to \\[CommandLine]'s output, which by default is [os.Stderr](https://pkg.go.dev/os/#Stderr). It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls \\[PrintDefaults]; for details about the format of the output and how to control it, see the documentation for \\[PrintDefaults]. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to \\[ExitOnError].","NFlag returns the number of command-line flags that have been set.","Arg returns the i'th command-line argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.","NArg is the number of arguments remaining after flags have been processed.","Args returns the non-flag command-line arguments.","BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.","Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.","IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.","Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.","Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.","Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.","UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.","Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.","Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.","Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.","StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.","String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.","Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.","Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.","DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.","Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration.","TextVar defines a flag with a specified name, default value, and usage string. The argument p must be a pointer to a variable that will hold the value of the flag, and p must implement encoding.TextUnmarshaler. If the flag is used, the flag value will be passed to p's UnmarshalText method. The type of the default value must be the same as the type of p.","Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error.","BoolFunc defines a flag with the specified name and usage string without requiring values. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error.","Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type \\[Value], which typically holds a user-defined implementation of \\[Value]. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of \\[Value]; in particular, \\[Set] would decompose the comma-separated string into the slice.","Parse parses the command-line flags from [os.Args](https://pkg.go.dev/os/#Args)\\[1:]. Must be called after all flags are defined and before flags are accessed by the program.","Parsed reports whether the command-line flags have been parsed.","CommandLine is the default set of command-line flags, parsed from [os.Args](https://pkg.go.dev/os/#Args). The top-level functions such as \\[BoolVar], \\[Arg], and so on are wrappers for the methods of CommandLine.","NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.","Errorf formats according to a format specifier and returns the string as a value that satisfies error.\n\nIf the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. If there is more than one %w verb, the returned error will implement an Unwrap method returning a \\[]error containing all the %w operands in the order they appear in the arguments. It is invalid to supply the %w verb with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v.","State represents the printer state passed to custom formatters. It provides access to the [io.Writer](https://pkg.go.dev/io/#Writer) interface plus information about the flags and options for the operand's format specifier.","Formatter is implemented by any value that has a Format method. The implementation controls how \\[State] and rune are interpreted, and may call \\[Sprint] or \\[Fprint](f) etc. to generate its output.","Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as \\[Print].","GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.","FormatString returns a string representing the fully qualified formatting directive captured by the \\[State], followed by the argument verb. (\\[State] does not itself contain the verb.) The result has a leading percent sign followed by any flags, the width, and the precision. Missing flags, width, and precision are omitted. This function allows a \\[Formatter] to reconstruct the original directive triggering the call to Format.","Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.","Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.","Sprintf formats according to a format specifier and returns the resulting string.","Appendf formats according to a format specifier, appends the result to the byte slice, and returns the updated slice.","Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.","Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.","Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.","Append formats using the default formats for its operands, appends the result to the byte slice, and returns the updated slice.","Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.","Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.","Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.","Appendln formats using the default formats for its operands, appends the result to the byte slice, and returns the updated slice. Spaces are always added between operands and a newline is appended.","ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.","Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to \\[Scan], \\[Scanf], or \\[Scanln] that implements it.","Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.","Scanln is similar to \\[Scan], but stops scanning at a newline and after the final item there must be a newline or EOF.","Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.","Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.","Sscanln is similar to \\[Sscan], but stops scanning at a newline and after the final item there must be a newline or EOF.","Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.","Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.","Fscanln is similar to \\[Fscan], but stops scanning at a newline and after the final item there must be a newline or EOF.","Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.","Hash is the common interface implemented by all hash functions.\n\nHash implementations in the standard library (e.g. [hash/crc32](https://pkg.go.dev/hash/crc32/) and [crypto/sha256](https://pkg.go.dev/crypto/sha256/)) implement the [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) interfaces. Marshaling a hash implementation allows its internal state to be saved and used for additional processing later, without having to re-write the data previously written to the hash. The hash state may contain portions of the input in its original form, which users are expected to handle for any possible security implications.\n\nCompatibility: Any future changes to hash or crypto packages will endeavor to maintain compatibility with state encoded using previous versions. That is, any released versions of the packages should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: [https://golang.org/doc/go1compat](https://golang.org/doc/go1compat)","Hash32 is the common interface implemented by all 32-bit hash functions.","Hash64 is the common interface implemented by all 64-bit hash functions.","EscapeString escapes special characters like \"\\\u003c\" to become \"\u0026lt;\". It escapes only five such characters: \\\u003c, \u003e, \u0026, ' and \". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.","UnescapeString unescapes entities like \"\u0026lt;\" to become \"\\\u003c\". It unescapes a larger range of entities than EscapeString escapes. For example, \"\u0026aacute;\" unescapes to \"á\", as does \"\u0026#225;\" and \"\u0026#xE1;\". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.","ErrFormat indicates that decoding encountered an unknown format.","RegisterFormat registers an image format for use by \\[Decode]. Name is the name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix that identifies the format's encoding. The magic string can contain \"?\" wildcards that each match any one byte. \\[Decode] is the function that decodes the encoded image. \\[DecodeConfig] is the function that decodes just its configuration.","Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package.","DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package.","A Point is an X, Y coordinate pair. The axes increase right and down.","ZP is the zero \\[Point].\n\nDeprecated: Use a literal [image.Point](https://pkg.go.dev/image/#Point) instead.","Pt is shorthand for \\[Point]{X, Y}.","A Rectangle contains the points with Min.X \\\u003c= X \\\u003c Max.X, Min.Y \\\u003c= Y \\\u003c Max.Y. It is well-formed if Min.X \\\u003c= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs.\n\nA Rectangle is also an \\[Image] whose bounds are the rectangle itself. At returns color.Opaque for points in the rectangle and color.Transparent otherwise.","ZR is the zero \\[Rectangle].\n\nDeprecated: Use a literal [image.Rectangle](https://pkg.go.dev/image/#Rectangle) instead.","Rect is shorthand for \\[Rectangle]{Pt(x0, y0), \\[Pt](x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.","Config holds an image's color model and dimensions.","Image is a finite rectangular grid of \\[color.Color] values taken from a color model.","RGBA64Image is an \\[Image] whose pixels can be converted directly to a color.RGBA64.","PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a \\[color.Palette] p, then m.At(x, y) should be equivalent to p\\[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.","RGBA is an in-memory image whose At method returns \\[color.RGBA] values.","NewRGBA returns a new \\[RGBA] image with the given bounds.","RGBA64 is an in-memory image whose At method returns \\[color.RGBA64] values.","NewRGBA64 returns a new \\[RGBA64] image with the given bounds.","NRGBA is an in-memory image whose At method returns \\[color.NRGBA] values.","NewNRGBA returns a new \\[NRGBA] image with the given bounds.","NRGBA64 is an in-memory image whose At method returns \\[color.NRGBA64] values.","NewNRGBA64 returns a new \\[NRGBA64] image with the given bounds.","Alpha is an in-memory image whose At method returns \\[color.Alpha] values.","NewAlpha returns a new \\[Alpha] image with the given bounds.","Alpha16 is an in-memory image whose At method returns \\[color.Alpha16] values.","NewAlpha16 returns a new \\[Alpha16] image with the given bounds.","Gray is an in-memory image whose At method returns \\[color.Gray] values.","NewGray returns a new \\[Gray] image with the given bounds.","Gray16 is an in-memory image whose At method returns \\[color.Gray16] values.","NewGray16 returns a new \\[Gray16] image with the given bounds.","CMYK is an in-memory image whose At method returns \\[color.CMYK] values.","NewCMYK returns a new CMYK image with the given bounds.","Paletted is an in-memory image of uint8 indices into a given palette.","NewPaletted returns a new \\[Paletted] image with the given width, height and palette.","Black is an opaque black uniform image.","White is an opaque white uniform image.","Transparent is a fully transparent uniform image.","Opaque is a fully opaque uniform image.","Uniform is an infinite-sized \\[Image] of uniform color. It implements the \\[color.Color], \\[color.Model], and \\[Image] interfaces.","NewUniform returns a new \\[Uniform] image of the given color.","YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.","","","","","","","YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and:\n\n\tFor 4:4:4, CStride == YStride/1 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/1.\n\tFor 4:2:2, CStride == YStride/2 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/2.\n\tFor 4:2:0, CStride == YStride/2 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/4.\n\tFor 4:4:0, CStride == YStride/1 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/2.\n\tFor 4:1:1, CStride == YStride/4 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/4.\n\tFor 4:1:0, CStride == YStride/4 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/8.","NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.","NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.","NewNYCbCrA returns a new \\[NYCbCrA] image with the given bounds and subsample ratio.","","","","ErrShortWrite means that a write accepted fewer bytes than requested but failed to return an explicit error.","ErrShortBuffer means that a read required a longer buffer than was provided.","EOF is the error returned by Read when no more input is available. (Read must return EOF itself, not an error wrapping EOF, because callers will test for EOF using ==.) Functions should return EOF only to signal a graceful end of input. If the EOF occurs unexpectedly in a structured data stream, the appropriate error is either \\[ErrUnexpectedEOF] or some other error giving more detail.","ErrUnexpectedEOF means that EOF was encountered in the middle of reading a fixed-size block or data structure.","ErrNoProgress is returned by some clients of a \\[Reader] when many calls to Read have failed to return any data or error, usually the sign of a broken \\[Reader] implementation.","Reader is the interface that wraps the basic Read method.\n\nRead reads up to len(p) bytes into p. It returns the number of bytes read (0 \\\u003c= n \\\u003c= len(p)) and any error encountered. Even if Read returns n \\\u003c len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.\n\nWhen Read encounters an error or end-of-file condition after successfully reading n \u003e 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.\n\nCallers should always process the n \u003e 0 bytes returned before considering the error err. Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors.\n\nIf len(p) == 0, Read should always return n == 0. It may return a non-nil error if some error condition is known, such as EOF.\n\nImplementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.\n\nImplementations must not retain p.","Writer is the interface that wraps the basic Write method.\n\nWrite writes len(p) bytes from p to the underlying data stream. It returns the number of bytes written from p (0 \\\u003c= n \\\u003c= len(p)) and any error encountered that caused the write to stop early. Write must return a non-nil error if it returns n \\\u003c len(p). Write must not modify the slice data, even temporarily.\n\nImplementations must not retain p.","Closer is the interface that wraps the basic Close method.\n\nThe behavior of Close after the first call is undefined. Specific implementations may document their own behavior.","Seeker is the interface that wraps the basic Seek method.\n\nSeek sets the offset for the next Read or Write to offset, interpreted according to whence: \\[SeekStart] means relative to the start of the file, \\[SeekCurrent] means relative to the current offset, and \\[SeekEnd] means relative to the end (for example, offset = -2 specifies the penultimate byte of the file). Seek returns the new offset relative to the start of the file or an error, if any.\n\nSeeking to an offset before the start of the file is an error. Seeking to any positive offset may be allowed, but if the new offset exceeds the size of the underlying object the behavior of subsequent I/O operations is implementation-dependent.","ReadWriter is the interface that groups the basic Read and Write methods.","ReadCloser is the interface that groups the basic Read and Close methods.","WriteCloser is the interface that groups the basic Write and Close methods.","ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.","ReadSeeker is the interface that groups the basic Read and Seek methods.","ReadSeekCloser is the interface that groups the basic Read, Seek and Close methods.","WriteSeeker is the interface that groups the basic Write and Seek methods.","ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.","ReaderFrom is the interface that wraps the ReadFrom method.\n\nReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except EOF encountered during the read is also returned.\n\nThe \\[Copy] function uses \\[ReaderFrom] if available.","WriterTo is the interface that wraps the WriteTo method.\n\nWriteTo writes data to w until there's no more data to write or when an error occurs. The return value n is the number of bytes written. Any error encountered during the write is also returned.\n\nThe Copy function uses WriterTo if available.","ReaderAt is the interface that wraps the basic ReadAt method.\n\nReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 \\\u003c= n \\\u003c= len(p)) and any error encountered.\n\nWhen ReadAt returns n \\\u003c len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.\n\nEven if ReadAt returns n \\\u003c len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, ReadAt blocks until either all the data is available or an error occurs. In this respect ReadAt is different from Read.\n\nIf the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.\n\nIf ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.\n\nClients of ReadAt can execute parallel ReadAt calls on the same input source.\n\nImplementations must not retain p.","WriterAt is the interface that wraps the basic WriteAt method.\n\nWriteAt writes len(p) bytes from p to the underlying data stream at offset off. It returns the number of bytes written from p (0 \\\u003c= n \\\u003c= len(p)) and any error encountered that caused the write to stop early. WriteAt must return a non-nil error if it returns n \\\u003c len(p).\n\nIf WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.\n\nClients of WriteAt can execute parallel WriteAt calls on the same destination if the ranges do not overlap.\n\nImplementations must not retain p.","ByteReader is the interface that wraps the ReadByte method.\n\nReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.\n\nReadByte provides an efficient interface for byte-at-time processing. A \\[Reader] that does not implement  ByteReader can be wrapped using bufio.NewReader to add this method.","ByteScanner is the interface that adds the UnreadByte method to the basic ReadByte method.\n\nUnreadByte causes the next call to ReadByte to return the last byte read. If the last operation was not a successful call to ReadByte, UnreadByte may return an error, unread the last byte read (or the byte prior to the last-unread byte), or (in implementations that support the \\[Seeker] interface) seek to one byte before the current offset.","ByteWriter is the interface that wraps the WriteByte method.","RuneReader is the interface that wraps the ReadRune method.\n\nReadRune reads a single encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.","RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.\n\nUnreadRune causes the next call to ReadRune to return the last rune read. If the last operation was not a successful call to ReadRune, UnreadRune may return an error, unread the last rune read (or the rune prior to the last-unread rune), or (in implementations that support the \\[Seeker] interface) seek to the start of the rune before the current offset.","StringWriter is the interface that wraps the WriteString method.","WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements \\[StringWriter], \\[StringWriter.WriteString] is invoked directly. Otherwise, \\[Writer.Write] is called exactly once.","ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns \\[ErrUnexpectedEOF]. If min is greater than the length of buf, ReadAtLeast returns \\[ErrShortBuffer]. On return, n \u003e= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.","ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns \\[ErrUnexpectedEOF]. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.","CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil.\n\nIf dst implements \\[ReaderFrom], the copy is implemented using it.","Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF. Because Copy is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nIf src implements \\[WriterTo], the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements \\[ReaderFrom], the copy is implemented by calling dst.ReadFrom(src).","CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics.\n\nIf either src implements \\[WriterTo] or dst implements \\[ReaderFrom], buf will not be used to perform the copy.","LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a \\*LimitedReader.","A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining. Read returns EOF when N \\\u003c= 0 or when the underlying R returns EOF.","NewSectionReader returns a \\[SectionReader] that reads from r starting at offset off and stops with EOF after n bytes.","SectionReader implements Read, Seek, and ReadAt on a section of an underlying \\[ReaderAt].","An OffsetWriter maps writes at offset base to offset base+off in the underlying writer.","NewOffsetWriter returns an \\[OffsetWriter] that writes to w starting at offset off.","TeeReader returns a \\[Reader] that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.","Discard is a \\[Writer] on which all Write calls succeed without doing anything.","NopCloser returns a \\[ReadCloser] with a no-op Close method wrapping the provided \\[Reader] r. If r implements \\[WriterTo], the returned \\[ReadCloser] will implement \\[WriterTo] by forwarding calls to r.","ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.","MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF.  If any of the readers return a non-nil, non-EOF error, Read will return that error.","MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time. If a listed writer returns an error, that overall write operation stops and returns the error; it does not continue down the list.","ErrClosedPipe is the error used for read or write operations on a closed pipe.","A PipeReader is the read half of a pipe.","A PipeWriter is the write half of a pipe.","Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an [io.Reader](https://pkg.go.dev/io/#Reader) with code expecting an [io.Writer](https://pkg.go.dev/io/#Writer).\n\nReads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the \\[PipeWriter] blocks until it has satisfied one or more Reads from the \\[PipeReader] that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially.","Seq is an iterator over sequences of individual values. When called as seq(yield), seq calls yield(v) for each value v in the sequence, stopping early if yield returns false. See the [iter](https://pkg.go.dev/iter/) package documentation for more details.","Seq2 is an iterator over sequences of pairs of values, most commonly key-value pairs. When called as seq(yield), seq calls yield(k, v) for each pair (k, v) in the sequence, stopping early if yield returns false. See the [iter](https://pkg.go.dev/iter/) package documentation for more details.","Pull converts the “push-style” iterator sequence seq into a “pull-style” iterator accessed by the two functions next and stop.\n\nNext returns the next value in the sequence and a boolean indicating whether the value is valid. When the sequence is over, next returns the zero V and false. It is valid to call next after reaching the end of the sequence or after calling stop. These calls will continue to return the zero V and false.\n\nStop ends the iteration. It must be called when the caller is no longer interested in next values and next has not yet signaled that the sequence is over (with a false boolean return). It is valid to call stop multiple times and when next has already returned false. Typically, callers should “defer stop()”.\n\nIt is an error to call next or stop from multiple goroutines simultaneously.\n\nIf the iterator panics during a call to next (or stop), then next (or stop) itself panics with the same value.","Pull2 converts the “push-style” iterator sequence seq into a “pull-style” iterator accessed by the two functions next and stop.\n\nNext returns the next pair in the sequence and a boolean indicating whether the pair is valid. When the sequence is over, next returns a pair of zero values and false. It is valid to call next after reaching the end of the sequence or after calling stop. These calls will continue to return a pair of zero values and false.\n\nStop ends the iteration. It must be called when the caller is no longer interested in next values and next has not yet signaled that the sequence is over (with a false boolean return). It is valid to call stop multiple times and when next has already returned false. Typically, callers should “defer stop()”.\n\nIt is an error to call next or stop from multiple goroutines simultaneously.\n\nIf the iterator panics during a call to next (or stop), then next (or stop) itself panics with the same value.","","","","","","","","","A Logger represents an active logging object that generates lines of output to an [io.Writer](https://pkg.go.dev/io/#Writer). Each logging operation makes a single call to the Writer's Write method. A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer.","New creates a new \\[Logger]. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the \\[Lmsgprefix] flag is provided. The flag argument defines the logging properties.","Default returns the standard logger used by the package-level output functions.","SetOutput sets the output destination for the standard logger.","Flags returns the output flags for the standard logger. The flag bits are \\[Ldate], \\[Ltime], and so on.","SetFlags sets the output flags for the standard logger. The flag bits are \\[Ldate], \\[Ltime], and so on.","Prefix returns the output prefix for the standard logger.","SetPrefix sets the output prefix for the standard logger.","Writer returns the output destination for the standard logger.","Print calls Output to print to the standard logger. Arguments are handled in the manner of [fmt.Print](https://pkg.go.dev/fmt/#Print).","Printf calls Output to print to the standard logger. Arguments are handled in the manner of [fmt.Printf](https://pkg.go.dev/fmt/#Printf).","Println calls Output to print to the standard logger. Arguments are handled in the manner of [fmt.Println](https://pkg.go.dev/fmt/#Println).","Fatal is equivalent to \\[Print] followed by a call to [os.Exit](https://pkg.go.dev/os/#Exit)(1).","Fatalf is equivalent to \\[Printf] followed by a call to [os.Exit](https://pkg.go.dev/os/#Exit)(1).","Fatalln is equivalent to \\[Println] followed by a call to [os.Exit](https://pkg.go.dev/os/#Exit)(1).","Panic is equivalent to \\[Print] followed by a call to panic().","Panicf is equivalent to \\[Printf] followed by a call to panic().","Panicln is equivalent to \\[Println] followed by a call to panic().","Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if \\[Llongfile] or \\[Lshortfile] is set; a value of 1 will print the details for the caller of Output.","All returns an iterator over key-value pairs from m. The iteration order is not specified and is not guaranteed to be the same from one call to the next.","Keys returns an iterator over keys in m. The iteration order is not specified and is not guaranteed to be the same from one call to the next.","Values returns an iterator over values in m. The iteration order is not specified and is not guaranteed to be the same from one call to the next.","Insert adds the key-value pairs from seq to m. If a key in seq already exists in m, its value will be overwritten.","Collect collects key-value pairs from seq into a new map and returns it.","Equal reports whether two maps contain the same key/value pairs. Values are compared using ==.","EqualFunc is like Equal, but compares values using eq. Keys are still compared with ==.","Clone returns a copy of m.  This is a shallow clone: the new keys and values are set using ordinary assignment.","Copy copies all key/value pairs in src adding them to dst. When a key in src is already present in dst, the value in dst will be overwritten by the value associated with the key in src.","DeleteFunc deletes any key/value pairs from m for which del returns true.","Abs returns the absolute value of x.\n\nSpecial cases are:\n\n\tAbs(±Inf) = +Inf\n\tAbs(NaN) = NaN","Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x \u003c 1\n\tAcosh(NaN) = NaN","Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\n\tAsin(±0) = ±0\n\tAsin(x) = NaN if x \u003c -1 or x \u003e 1","Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\n\tAcos(x) = NaN if x \u003c -1 or x \u003e 1","Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\n\tAsinh(±0) = ±0\n\tAsinh(±Inf) = ±Inf\n\tAsinh(NaN) = NaN","Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n\n\tAtan(±0) = ±0\n\tAtan(±Inf) = ±Pi/2","Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value.\n\nSpecial cases are (in order):\n\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x\u003e=0) = +0\n\tAtan2(-0, x\u003e=0) = -0\n\tAtan2(+0, x\u003c=-0) = +Pi\n\tAtan2(-0, x\u003c=-0) = -Pi\n\tAtan2(y\u003e0, 0) = +Pi/2\n\tAtan2(y\u003c0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y\u003e0, -Inf) = +Pi\n\tAtan2(y\u003c0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2","Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\n\tAtanh(1) = +Inf\n\tAtanh(±0) = ±0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x \u003c -1 or x \u003e 1\n\tAtanh(NaN) = NaN","Inf returns positive infinity if sign \u003e= 0, negative infinity if sign \\\u003c 0.","NaN returns an IEEE 754 “not-a-number” value.","IsNaN reports whether f is an IEEE 754 “not-a-number” value.","IsInf reports whether f is an infinity, according to sign. If sign \u003e 0, IsInf reports whether f is positive infinity. If sign \\\u003c 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.","Cbrt returns the cube root of x.\n\nSpecial cases are:\n\n\tCbrt(±0) = ±0\n\tCbrt(±Inf) = ±Inf\n\tCbrt(NaN) = NaN","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Copysign returns a value with the magnitude of f and the sign of sign.","Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN","Max returns the larger of x or y.\n\nSpecial cases are:\n\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, ±0) = Max(±0, +0) = +0\n\tMax(-0, -0) = -0\n\nNote that this differs from the built-in function max when called with NaN and +Inf.","Min returns the smaller of x or y.\n\nSpecial cases are:\n\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, ±0) = Min(±0, -0) = -0\n\nNote that this differs from the built-in function min when called with NaN and -Inf.","Erf returns the error function of x.\n\nSpecial cases are:\n\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN","Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN","Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x \u003c -1 or x \u003e 1\n\tErfinv(NaN) = NaN","Erfcinv returns the inverse of \\[Erfc](x).\n\nSpecial cases are:\n\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x \u003c 0 or x \u003e 2\n\tErfcinv(NaN) = NaN","Exp returns e\\*\\*x, the base-e exponential of x.\n\nSpecial cases are:\n\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\n\nVery large values overflow to 0 or +Inf. Very small values underflow to 1.","Exp2 returns 2\\*\\*x, the base-2 exponential of x.\n\nSpecial cases are the same as \\[Exp].","Expm1 returns e\\*\\*x - 1, the base-e exponential of x minus 1. It is more accurate than \\[Exp](x) - 1 when x is near zero.\n\nSpecial cases are:\n\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\n\nVery large values overflow to -1 or +Inf.","Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\n\tFloor(±0) = ±0\n\tFloor(±Inf) = ±Inf\n\tFloor(NaN) = NaN","Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\n\tCeil(±0) = ±0\n\tCeil(±Inf) = ±Inf\n\tCeil(NaN) = NaN","Trunc returns the integer value of x.\n\nSpecial cases are:\n\n\tTrunc(±0) = ±0\n\tTrunc(±Inf) = ±Inf\n\tTrunc(NaN) = NaN","Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\n\tRound(±0) = ±0\n\tRound(±Inf) = ±Inf\n\tRound(NaN) = NaN","RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\n\tRoundToEven(±0) = ±0\n\tRoundToEven(±Inf) = ±Inf\n\tRoundToEven(NaN) = NaN","FMA returns x \\* y + z, computed with only one rounding. (That is, FMA returns the fused multiply-add of x, y, and z.)","Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac × 2\\*\\*exp, with the absolute value of frac in the interval \\[½, 1).\n\nSpecial cases are:\n\n\tFrexp(±0) = ±0, 0\n\tFrexp(±Inf) = ±Inf, 0\n\tFrexp(NaN) = NaN, 0","Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x \u003c 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN","Hypot returns \\[Sqrt](p\\*p + q\\*q), taking care to avoid unnecessary overflow and underflow.\n\nSpecial cases are:\n\n\tHypot(±Inf, q) = +Inf\n\tHypot(p, ±Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN","J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\n\tJ0(±Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN","Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x \u003c 0) = NaN\n\tY0(NaN) = NaN","J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\n\tJ1(±Inf) = 0\n\tJ1(NaN) = NaN","Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x \u003c 0) = NaN\n\tY1(NaN) = NaN","Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\n\tJn(n, ±Inf) = 0\n\tJn(n, NaN) = NaN","Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\n\tYn(n, +Inf) = 0\n\tYn(n ≥ 0, 0) = -Inf\n\tYn(n \u003c 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x \u003c 0) = NaN\n\tYn(n, NaN) = NaN","Ldexp is the inverse of \\[Frexp]. It returns frac × 2\\*\\*exp.\n\nSpecial cases are:\n\n\tLdexp(±0, exp) = ±0\n\tLdexp(±Inf, exp) = ±Inf\n\tLdexp(NaN, exp) = NaN","Lgamma returns the natural logarithm and sign (-1 or +1) of \\[Gamma](x).\n\nSpecial cases are:\n\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN","Log returns the natural logarithm of x.\n\nSpecial cases are:\n\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x \u003c 0) = NaN\n\tLog(NaN) = NaN","Log10 returns the decimal logarithm of x. The special cases are the same as for \\[Log].","Log2 returns the binary logarithm of x. The special cases are the same as for \\[Log].","Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than \\[Log](1 + x) when x is near zero.\n\nSpecial cases are:\n\n\tLog1p(+Inf) = +Inf\n\tLog1p(±0) = ±0\n\tLog1p(-1) = -Inf\n\tLog1p(x \u003c -1) = NaN\n\tLog1p(NaN) = NaN","Logb returns the binary exponent of x.\n\nSpecial cases are:\n\n\tLogb(±Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN","Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\n\tIlogb(±Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32","Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.\n\nSpecial cases are:\n\n\tMod(±Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, ±Inf) = x\n\tMod(x, NaN) = NaN","Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\n\tModf(±Inf) = ±Inf, NaN\n\tModf(NaN) = NaN, NaN","Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN","Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN","Pow returns x\\*\\*y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\n\tPow(x, ±0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(±0, y) = ±Inf for y an odd integer \u003c 0\n\tPow(±0, -Inf) = +Inf\n\tPow(±0, +Inf) = +0\n\tPow(±0, y) = +Inf for finite y \u003c 0 and not an odd integer\n\tPow(±0, y) = ±0 for y an odd integer \u003e 0\n\tPow(±0, y) = +0 for finite y \u003e 0 and not an odd integer\n\tPow(-1, ±Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| \u003e 1\n\tPow(x, -Inf) = +0 for |x| \u003e 1\n\tPow(x, +Inf) = +0 for |x| \u003c 1\n\tPow(x, -Inf) = +Inf for |x| \u003c 1\n\tPow(+Inf, y) = +Inf for y \u003e 0\n\tPow(+Inf, y) = +0 for y \u003c 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x \u003c 0 and finite non-integer y","Pow10 returns 10\\*\\*n, the base-10 exponential of n.\n\nSpecial cases are:\n\n\tPow10(n) =    0 for n \u003c -323\n\tPow10(n) = +Inf for n \u003e 308","Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\n\tRemainder(±Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, ±Inf) = x\n\tRemainder(x, NaN) = NaN","Signbit reports whether x is negative or negative zero.","Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\n\tCos(±Inf) = NaN\n\tCos(NaN) = NaN","Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\n\tSin(±0) = ±0\n\tSin(±Inf) = NaN\n\tSin(NaN) = NaN","Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\n\tSincos(±0) = ±0, 1\n\tSincos(±Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN","Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\n\tSinh(±0) = ±0\n\tSinh(±Inf) = ±Inf\n\tSinh(NaN) = NaN","Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\n\tCosh(±0) = 1\n\tCosh(±Inf) = +Inf\n\tCosh(NaN) = NaN","Sqrt returns the square root of x.\n\nSpecial cases are:\n\n\tSqrt(+Inf) = +Inf\n\tSqrt(±0) = ±0\n\tSqrt(x \u003c 0) = NaN\n\tSqrt(NaN) = NaN","Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\n\tTan(±0) = ±0\n\tTan(±Inf) = NaN\n\tTan(NaN) = NaN","Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\n\tTanh(±0) = ±0\n\tTanh(±Inf) = ±1\n\tTanh(NaN) = NaN","Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) == x.","Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) == x.","Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) == x.","Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) == x.","A WordEncoder is an RFC 2047 encoded-word encoder.","BEncoding represents Base64 encoding scheme as defined by RFC 2045.","QEncoding represents the Q-encoding scheme as defined by RFC 2047.","A WordDecoder decodes MIME headers containing RFC 2047 encoded-words.","FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.","ErrInvalidMediaParameter is returned by \\[ParseMediaType] if the media type value was found but there was an error parsing the optional parameters","ParseMediaType parses a media type value and any optional parameters, per RFC 1521.  Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error \\[ErrInvalidMediaParameter]. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.","TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in \".html\". When ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local system's MIME-info database or mime.types file(s) if available under one or more of these names:\n\n\t/usr/local/share/mime/globs2\n\t/usr/share/mime/globs2\n\t/etc/mime.types\n\t/etc/apache2/mime.types\n\t/etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.","ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in \".html\". When typ has no associated extensions, ExtensionsByType returns an nil slice.","AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in \".html\".","A Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the \\[Dial] function.\n\nIt is safe to call Dialer's methods concurrently.","Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\". The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in \"\\[2001:db8::1]:80\" or \"\\[fe80::1%zone]:80\". The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions \\[JoinHostPort] and \\[SplitHostPort] manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds.\n\nExamples:\n\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a colon and a literal protocol number or a protocol name, and the address has the form \"host\". The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"\\[::]:80\" for TCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is assumed.\n\nFor Unix networks, the address must be a file system path.","DialTimeout acts like \\[Dial] but takes a timeout.\n\nThe timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.\n\nSee func Dial for a description of the network and address parameters.","ListenConfig contains options for listening to an address.","Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network \"tcp4\". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"\\[::1]:0\", a port number is automatically chosen. The \\[Addr] method of \\[Listener] can be used to discover the chosen port.\n\nSee func \\[Dial] for a description of the network and address parameters.\n\nListen uses context.Background internally; to specify the context, use \\[ListenConfig.Listen].","ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP transport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by a colon and a literal protocol number or a protocol name, as in \"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network \"udp4\" or \"ip4:proto\". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"\\[::1]:0\", a port number is automatically chosen. The LocalAddr method of \\[PacketConn] can be used to discover the chosen port.\n\nSee func \\[Dial] for a description of the network and address parameters.\n\nListenPacket uses context.Background internally; to specify the context, use \\[ListenConfig.ListenPacket].","An SRV represents a single DNS SRV record.","An MX represents a single DNS MX record.","An NS represents a single DNS NS record.","FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.","FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.","FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.","Interface represents a mapping between network interface name and index. It also represents network interface facility information.","","","","","","","","Interfaces returns a list of the system's network interfaces.","InterfaceAddrs returns a list of the system's unicast interface addresses.\n\nThe returned list does not identify the associated interface; use Interfaces and \\[Interface.Addrs] for more detail.","InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use \\[InterfaceByName].","InterfaceByName returns the interface specified by name.","","","An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address.","An IPMask is a bitmask that can be used to manipulate IP addresses for IP addressing and routing.\n\nSee type \\[IPNet] and func \\[ParseCIDR] for details.","An IPNet represents an IP network.","IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.","IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.","CIDRMask returns an \\[IPMask] consisting of 'ones' 1 bits followed by 0s up to a total length of 'bits' bits. For a mask of this form, CIDRMask is the inverse of \\[IPMask.Size].","","","","","","","","","","","ParseIP parses s as an IP address, returning the result. The string s can be in IPv4 dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv4-mapped IPv6 (\"::ffff:192.0.2.1\") form. If s is not a valid textual representation of an IP address, ParseIP returns nil. The returned address is always 16 bytes, IPv4 addresses are returned in IPv4-mapped IPv6 form.","ParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(\"192.0.2.1/24\") returns the IP address 192.0.2.1 and the network 192.0.2.0/24.","IPAddr represents the address of an IP end point.","ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.\n\nSee func \\[Dial] for a description of the network and address parameters.","IPConn is the implementation of the \\[Conn] and \\[PacketConn] interfaces for IP network connections.","DialIP acts like \\[Dial] for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.","ListenIP acts like \\[ListenPacket] for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.","SplitHostPort splits a network address of the form \"host:port\", \"host%zone:port\", \"\\[host]:port\" or \"\\[host%zone]:port\" into host or host%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square brackets, as in \"\\[::1]:80\", \"\\[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host and port results.","JoinHostPort combines host and port into a network address of the form \"host:port\". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns \"\\[host]:port\".\n\nSee func Dial for a description of the host and port parameters.","DefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver.","A Resolver looks up names and numbers.\n\nA nil \\*Resolver is equivalent to a zero Resolver.","LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.\n\nLookupHost uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupHost].","LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.","LookupPort looks up the port for the given network and service.\n\nLookupPort uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupPort].","LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call \\[LookupHost] or \\[LookupIP] directly; both take care of resolving the canonical name as part of the lookup.\n\nA canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records.\n\nThe returned canonical name is validated to be a properly formatted presentation-format domain name.\n\nLookupCNAME uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupCNAME].","LookupSRV tries to resolve an \\[SRV] query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up \\_service.\\_proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.\n\nThe returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.","LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nThe returned mail server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.\n\nLookupMX uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupMX].","LookupNS returns the DNS NS records for the given domain name.\n\nThe returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.\n\nLookupNS uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupNS].","LookupTXT returns the DNS TXT records for the given domain name.\n\nLookupTXT uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupTXT].","LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.\n\nThe returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.\n\nWhen using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom \\[Resolver].\n\nLookupAddr uses [context.Background](https://pkg.go.dev/context/#Background) internally; to specify the context, use \\[Resolver.LookupAddr].","A HardwareAddr represents a physical hardware address.","ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:\n\n\t00:00:5e:00:53:01\n\t02:00:5e:10:00:00:00:01\n\t00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01\n\t00-00-5e-00-53-01\n\t02-00-5e-10-00-00-00-01\n\t00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01\n\t0000.5e00.5301\n\t0200.5e10.0000.0001\n\t0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001","Addr represents a network end point address.\n\nThe two methods \\[Addr.Network] and \\[Addr.String] conventionally return strings that can be passed as the arguments to \\[Dial], but the exact form and meaning of the strings is up to the implementation.","Conn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.","PacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.","A Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.","An Error represents a network error.","","OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.","A ParseError is the error type of literal network address parsers.","","","","DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.)","DNSError represents a DNS lookup error.","ErrClosed is the error returned by an I/O call on a network connection that has already been closed, or that is closed by another goroutine before the I/O is completed. This may be wrapped in another error, and should normally be tested using errors.Is(err, net.ErrClosed).","Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as \"writev\").","Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the \\[Conn] interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.","TCPAddr represents the address of a TCP end point.","ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.\n\nSee func \\[Dial] for a description of the network and address parameters.","TCPAddrFromAddrPort returns addr as a \\[TCPAddr]. If addr.IsValid() is false, then the returned TCPAddr will contain a nil IP field, indicating an address family-agnostic unspecified address.","TCPConn is an implementation of the \\[Conn] interface for TCP network connections.","KeepAliveConfig contains TCP keep-alive options.\n\nIf the Idle, Interval, or Count fields are zero, a default value is chosen. If a field is negative, the corresponding socket-level option will be left unchanged.\n\nNote that prior to Windows 10 version 1709, neither setting Idle and Interval separately nor changing Count (which is usually 10) is supported. Therefore, it's recommended to set both Idle and Interval to non-negative values in conjunction with a -1 for Count on those old Windows if you intend to customize the TCP keep-alive settings. By contrast, if only one of Idle and Interval is set to a non-negative value, the other will be set to the system default value, and ultimately, set both Idle and Interval to negative values if you want to leave them unchanged.\n\nNote that Solaris and its derivatives do not support setting Interval to a non-negative value and Count to a negative value, or vice-versa.","DialTCP acts like \\[Dial] for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.","TCPListener is a TCP network listener. Clients should typically use variables of type \\[Listener] instead of assuming TCP.","ListenTCP acts like \\[Listen] for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen.","UDPAddr represents the address of a UDP end point.","ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.\n\nSee func Dial for a description of the network and address parameters.","UDPAddrFromAddrPort returns addr as a UDPAddr. If addr.IsValid() is false, then the returned UDPAddr will contain a nil IP field, indicating an address family-agnostic unspecified address.","UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.","DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.","ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen.","ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.\n\nListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses.\n\nNote that ListenMulticastUDP will set the IP\\_MULTICAST\\_LOOP socket option to 0 under IPPROTO\\_IP, to disable loopback of multicast packets.","UnixAddr represents the address of a Unix domain socket end point.","ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func \\[Dial] for a description of the network and address parameters.","UnixConn is an implementation of the \\[Conn] interface for connections to Unix domain sockets.","DialUnix acts like \\[Dial] for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the connection.","UnixListener is a Unix domain socket listener. Clients should typically use variables of type \\[Listener] instead of assuming Unix domain sockets.","ListenUnix acts like \\[Listen] for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".","ListenUnixgram acts like \\[ListenPacket] for Unix networks.\n\nThe network must be \"unixgram\".","A DirEntry is an entry read from a directory (using the \\[ReadDir] function or a \\[File.ReadDir] method).","ReadDir reads the named directory, returning all its directory entries sorted by filename. If an error occurs reading the directory, ReadDir returns the entries it was able to read before the error, along with the error.","CopyFS copies the file system fsys into the directory dir, creating dir if necessary.\n\nFiles are created with mode 0o666 plus any execute permissions from the source, and directories are created with mode 0o777 (before umask).\n\nCopyFS will not overwrite existing files. If a file name in fsys already exists in the destination, CopyFS will return an error such that errors.Is(err, fs.ErrExist) will be true.\n\nSymbolic links in fsys are not supported. A \\*PathError with Err set to ErrInvalid is returned when copying from a symbolic link.\n\nSymbolic links in dir are followed.\n\nCopying stops at and returns the first error encountered.","Expand replaces ${var} or $var in the string based on the mapping function. For example, [os.ExpandEnv](https://pkg.go.dev/os/#ExpandEnv)(s) is equivalent to [os.Expand](https://pkg.go.dev/os/#Expand)(s, [os.Getenv](https://pkg.go.dev/os/#Getenv)).","ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.","Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use \\[LookupEnv].","LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.","Setenv sets the value of the environment variable named by the key. It returns an error, if any.","Unsetenv unsets a single environment variable.","Clearenv deletes all environment variables.","Environ returns a copy of strings representing the environment, in the form \"key=value\".","ErrInvalid indicates an invalid argument. Methods on File will return this error when the receiver is nil.","","","","","","","PathError records an error and the operation and file path that caused it.","SyscallError records an error from a specific system call.","NewSyscallError returns, as an error, a new \\[SyscallError] with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.","IsExist returns a boolean indicating whether its argument is known to report that a file or directory already exists. It is satisfied by \\[ErrExist] as well as some syscall errors.\n\nThis function predates [errors.Is](https://pkg.go.dev/errors/#Is). It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrExist).","IsNotExist returns a boolean indicating whether its argument is known to report that a file or directory does not exist. It is satisfied by \\[ErrNotExist] as well as some syscall errors.\n\nThis function predates [errors.Is](https://pkg.go.dev/errors/#Is). It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrNotExist).","IsPermission returns a boolean indicating whether its argument is known to report that permission is denied. It is satisfied by \\[ErrPermission] as well as some syscall errors.\n\nThis function predates [errors.Is](https://pkg.go.dev/errors/#Is). It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrPermission).","IsTimeout returns a boolean indicating whether its argument is known to report that a timeout occurred.\n\nThis function predates [errors.Is](https://pkg.go.dev/errors/#Is), and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as [os.ErrDeadlineExceeded](https://pkg.go.dev/os/#ErrDeadlineExceeded).","ErrProcessDone indicates a \\[Process] has finished.","Process stores the information about a process created by \\[StartProcess].","ProcAttr holds the attributes that will be applied to a new process started by StartProcess.","A Signal represents an operating system signal. The usual underlying implementation is operating system-dependent: on Unix it is syscall.Signal.","Getpid returns the process id of the caller.","Getppid returns the process id of the caller's parent.","FindProcess looks for a running process by its pid.\n\nThe \\[Process] it returns can be used to obtain information about the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists. To test whether the process actually exists, see whether p.Signal(syscall.Signal(0)) reports an error.","StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become [os.Args](https://pkg.go.dev/os/#Args) in the new process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread with [runtime.LockOSThread](https://pkg.go.dev/runtime/#LockOSThread) and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The [os/exec](https://pkg.go.dev/os/exec/) package provides higher-level interfaces.\n\nIf there is an error, it will be of type \\[\\*PathError].","","","ProcessState stores information about a process, as reported by Wait.","Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, [path/filepath.EvalSymlinks](https://pkg.go.dev/path/filepath/#EvalSymlinks) might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an executable.","","","","Exactly one of O\\_RDONLY, O\\_WRONLY, or O\\_RDWR must be specified.","","","The remaining values may be or'ed in to control behavior.","","","","","","","","LinkError records an error during a link or symlink or rename system call and the paths that caused it.","Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type \\*PathError.","Chdir changes the current working directory to the named directory. If there is an error, it will be of type \\*PathError.","Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O\\_RDONLY. If there is an error, it will be of type \\*PathError.","Create creates or truncates the named file. If the file already exists, it is truncated. If the file does not exist, it is created with mode 0o666 (before umask). If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O\\_RDWR. If there is an error, it will be of type \\*PathError.","OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O\\_RDONLY etc.). If the file does not exist, and the O\\_CREATE flag is passed, it is created with mode perm (before umask). If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type \\*PathError.","Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. Even within the same directory, on non-Unix platforms Rename is not an atomic operation. If there is an error, it will be of type \\*LinkError.","Readlink returns the destination of the named symbolic link. If there is an error, it will be of type \\*PathError.\n\nIf the link destination is relative, Readlink returns the relative path without resolving it to an absolute one.","TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible permissions.","UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.\n\nOn Unix systems, it returns $XDG\\_CACHE\\_HOME as specified by [https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html) if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined), then it will return an error.","UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.\n\nOn Unix systems, it returns $XDG\\_CONFIG\\_HOME as specified by [https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html) if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.\n\nIf the location cannot be determined (for example, $HOME is not defined), then it will return an error.","UserHomeDir returns the current user's home directory.\n\nOn Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable.\n\nIf the expected variable is not set in the environment, UserHomeDir returns either a platform-specific default value or a non-nil error.","Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type \\*PathError.\n\nA different subset of the mode bits are used, depending on the operating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.\n\nOn Windows, only the 0o200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0o400 for a read-only file and 0o600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.","DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.\n\nNote that DirFS(\"/prefix\") only guarantees that the Open calls it makes to the operating system will begin with \"/prefix\": DirFS(\"/prefix\").Open(\"file\") is the same as os.Open(\"/prefix/file\"). So if /prefix/file is a symbolic link pointing outside the /prefix tree, then using DirFS does not stop the access any more than using os.Open does. Additionally, the root of the fs.FS returned for a relative path, DirFS(\"prefix\"), will be affected by later calls to Chdir. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content.\n\nThe directory dir must not be \"\".\n\nThe result implements [io/fs.StatFS](https://pkg.go.dev/io/fs/#StatFS), [io/fs.ReadFileFS](https://pkg.go.dev/io/fs/#ReadFileFS) and [io/fs.ReadDirFS](https://pkg.go.dev/io/fs/#ReadDirFS).","ReadFile reads the named file and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.","WriteFile writes data to the named file, creating it if necessary. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions. Since WriteFile requires multiple system calls to complete, a failure mid-operation can leave the file in a partially written state.","Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type \\[\\*PathError].\n\nOn Windows or Plan 9, Chown always returns the [syscall.EWINDOWS](https://pkg.go.dev/syscall/#EWINDOWS) or EPLAN9 error, wrapped in \\*PathError.","Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type \\[\\*PathError].\n\nOn Windows, it always returns the [syscall.EWINDOWS](https://pkg.go.dev/syscall/#EWINDOWS) error, wrapped in \\*PathError.","Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions. A zero [time.Time](https://pkg.go.dev/time/#Time) value will leave the corresponding file time unchanged.\n\nThe underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type \\[\\*PathError].","NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).\n\nAfter passing it to NewFile, fd may become invalid under the same conditions described in the comments of the Fd method, and the same constraints apply.","DevNull is the name of the operating system's “null device.” On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\".","Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type \\*PathError.","Remove removes the named file or (empty) directory. If there is an error, it will be of type \\*PathError.","Link creates newname as a hard link to the oldname file. If there is an error, it will be of type \\*LinkError.","Symlink creates newname as a symbolic link to oldname. On Windows, a symlink to a non-existent oldname creates a file symlink; if oldname is later created as a directory the symlink will not work. If there is an error, it will be of type \\*LinkError.","Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.","MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.","RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type \\[\\*PathError].","","","IsPathSeparator reports whether c is a directory separator character.","Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.","Args hold the command-line arguments, starting with the program name.","Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.","Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.","Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.","Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.","Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns [syscall.EWINDOWS](https://pkg.go.dev/syscall/#EWINDOWS). See the [os/user](https://pkg.go.dev/os/user/) package for a possible alternative.","Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run.\n\nFor portability, the status code should be in the range \\[0, 125].","Stat returns a \\[FileInfo] describing the named file. If there is an error, it will be of type \\[\\*PathError].","Lstat returns a \\[FileInfo] describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type \\[\\*PathError].\n\nOn Windows, if the file is a reparse point that is a surrogate for another named entity (such as a symbolic link or mounted folder), the returned FileInfo describes the reparse point, and makes no attempt to resolve it.","Hostname returns the host name reported by the kernel.","CreateTemp creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting file. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a \"\\*\", the random string replaces the last \"\\*\". The file is created with mode 0o600 (before umask). If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by \\[TempDir]. Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file. The caller can use the file's Name method to find the pathname of the file. It is the caller's responsibility to remove the file when it is no longer needed.","MkdirTemp creates a new temporary directory in the directory dir and returns the pathname of the new directory. The new directory's name is generated by adding a random string to the end of pattern. If pattern includes a \"\\*\", the random string replaces the last \"\\*\" instead. The directory is created with mode 0o700 (before umask). If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when it is no longer needed.","Getpagesize returns the underlying system's memory page size.","File represents an open file descriptor.\n\nThe methods of File are safe for concurrent use.","A FileInfo describes a file and is returned by \\[Stat] and \\[Lstat].","A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is \\[ModeDir] for directories.","The single letters are the abbreviations used by the String method's formatting.","","","","","","","","","","","","","Mask for the type bits. For regular files, none will be set.","","SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's \\[Stat]. It returns false in other cases.","ErrBadPattern indicates a pattern was malformed.","Match reports whether name matches the shell pattern. The pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo \u003c= c \u003c= hi\n\nMatch requires pattern to match all of name, not just a substring. The only possible returned error is \\[ErrBadPattern], when pattern is malformed.","Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:\n\n 1. Replace multiple slashes with a single slash.\n 2. Eliminate each . path name element (the current directory).\n 3. Eliminate each inner .. path name element (the parent directory) along with the non-.. element that precedes it.\n 4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean returns the string \".\".\n\nSee also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,” [https://9p.io/sys/doc/lexnames.html](https://9p.io/sys/doc/lexnames.html)","Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.","Join joins any number of path elements into a single path, separating them with slashes. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string.","Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot.","Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of slashes, Base returns \"/\".","IsAbs reports whether the path is absolute.","Dir returns all but the last element of path, typically the path's directory. After dropping the final element using \\[Split], the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash.","Plugin is a loaded Go plugin.","Open opens a Go plugin. If a path has already been opened, then the existing \\*\\[Plugin] is returned. It is safe for concurrent use by multiple goroutines.","A Symbol is a pointer to a variable or function.\n\nFor example, a plugin defined as\n\n\tpackage main\n\n\timport \"fmt\"\n\n\tvar V int\n\n\tfunc F() { fmt.Printf(\"Hello, number %d\\n\", V) }\n\nmay be loaded with the \\[Open] function and then the exported package symbols V and F can be accessed\n\n\tp, err := plugin.Open(\"plugin_name.so\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tv, err := p.Lookup(\"V\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tf, err := p.Lookup(\"F\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*v.(*int) = 7\n\tf.(func())() // prints \"Hello, number 7\"","DeepEqual reports whether x and y are “deeply equal,” defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, \u0026x\\[0] == \u0026y\\[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, \\[]byte{} and \\[]byte(nil)) are not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The second and subsequent times that DeepEqual compares two pointer values that have been compared before, it treats the values as equal rather than examining the values to which they point. This ensures that DeepEqual terminates.","MakeFunc returns a new function of the given \\[Type] that wraps the function fn. When called, that new function does the following:\n\n  - converts its arguments to a slice of Values.\n  - runs results := fn(args).\n  - returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument \\[Value] slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.\n\nThe \\[Value.Call] method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types.","Swapper returns a function that swaps the elements in the provided slice.\n\nSwapper panics if the provided interface is not a slice.","Type is the representation of a Go type.\n\nNot all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic.\n\nType values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.","A Kind represents the specific kind of type that a \\[Type] represents. The zero Kind is not a valid kind.","","","","","","","","","","","","","","","","","","","","","","","","","","","","Ptr is the old name for the \\[Pointer] kind.","ChanDir represents a channel type's direction.","","","","Method represents a single method.","A StructField describes a single field in a struct.","A StructTag is the tag string in a struct field.\n\nBy convention, tag strings are a concatenation of optionally space-separated key:\"value\" pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' '), quote (U+0022 '\"'), and colon (U+003A ':').  Each value is quoted using U+0022 '\"' characters and Go string literal syntax.","TypeOf returns the reflection \\[Type] that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.","PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents \\*Foo.\n\nPtrTo is the old spelling of \\[PointerTo]. The two functions behave identically.\n\nDeprecated: Superseded by \\[PointerTo].","PointerTo returns the pointer type with element t. For example, if t represents type Foo, PointerTo(t) represents \\*Foo.","ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents \\\u003c-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.","MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map\\[int]string.\n\nIf the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics.","FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf(\\[]Type{k}, \\[]Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf panics if the in\\[len(in)-1] does not represent a slice and variadic is true.","SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents \\[]int.","StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.\n\nStructOf currently does not support promoted methods of embedded fields and panics if passed unexported StructFields.","ArrayOf returns the array type with the given length and element type. For example, if t represents int, ArrayOf(5, t) represents \\[5]int.\n\nIf the resulting type would be larger than the available address space, ArrayOf panics.","TypeFor returns the \\[Type] that represents the type argument T.","Value is the reflection interface to a Go value.\n\nNot all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.\n\nThe zero Value represents no value. Its \\[Value.IsValid] method returns false, its Kind method returns \\[Invalid], its String method returns \"\\\u003cinvalid Value\u003e\", and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.\n\nA Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations.\n\nTo compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.","A ValueError occurs when a Value method is invoked on a \\[Value] that does not support it. Such cases are documented in the description of each method.","A MapIter is an iterator for ranging over a map. See \\[Value.MapRange].","StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.\n\nDeprecated: Use unsafe.String or unsafe.StringData instead.","SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.\n\nDeprecated: Use unsafe.Slice or unsafe.SliceData instead.","Append appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type.","AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type.","Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind \\[Slice] or \\[Array], and dst and src must have the same element type.\n\nAs a special case, src can have kind \\[String] if the element type of dst is kind \\[Uint8].","A SelectDir describes the communication direction of a select case.","","","","A SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction.\n\nIf Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.\n\nIf Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.\n\nIf Dir is \\[SelectRecv], the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select.","Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). Select supports a maximum of 65536 cases.","MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.","SliceAt returns a \\[Value] representing a slice whose underlying data starts at p, with length and capacity equal to n.\n\nThis is like [unsafe.Slice](https://pkg.go.dev/unsafe/#Slice).","MakeChan creates a new channel with the specified type and buffer size.","MakeMap creates a new map with the specified type.","MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.","Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.","ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.","Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind \\[Int] and value 0. The returned value is neither addressable nor settable.","New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is \\[PointerTo](typ).","NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.","VisibleFields returns all the visible fields in t, which must be a struct type. A field is defined as visible if it's accessible directly with a FieldByName call. The returned fields include fields inside anonymous struct members and unexported fields. They follow the same order found in the struct, with anonymous fields followed immediately by their promoted fields.\n\nFor each element e of the returned slice, the corresponding field can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index).","Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as \\[Regexp.Longest].","Compile parses a regular expression and returns, if successful, a \\[Regexp] object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see \\[CompilePOSIX].","CompilePOSIX is like \\[Compile] but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies.\n\nHowever, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See [https://swtch.com/~rsc/regexp/regexp2.html#posix](https://swtch.com/~rsc/regexp/regexp2.html#posix) for details.","MustCompile is like \\[Compile] but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.","MustCompilePOSIX is like \\[CompilePOSIX] but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.","MatchReader reports whether the text returned by the [io.RuneReader](https://pkg.go.dev/io/#RuneReader) contains any match of the regular expression pattern. More complicated queries need to use \\[Compile] and the full \\[Regexp] interface.","MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use \\[Compile] and the full \\[Regexp] interface.","Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use \\[Compile] and the full \\[Regexp] interface.","QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.","Compiler is the name of the compiler toolchain that built the running binary. Known toolchains are:\n\n\tgc      Also known as cmd/compile.\n\tgccgo   The gccgo front end, part of the GCC compiler suite.","SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz \\\u003c= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the [runtime/pprof](https://pkg.go.dev/runtime/pprof/) package or the [testing](https://pkg.go.dev/testing/) package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly.","CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed.\n\nDeprecated: Use the [runtime/pprof](https://pkg.go.dev/runtime/pprof/) package, or the handlers in the [net/http/pprof](https://pkg.go.dev/net/http/pprof/) package, or the [testing](https://pkg.go.dev/testing/) package's -test.cpuprofile flag instead.","GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. It defaults to the value of [runtime.NumCPU](https://pkg.go.dev/runtime/#NumCPU). If n \\\u003c 1, it does not change the current setting. This call will go away when the scheduler improves.","NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.","NumCgoCall returns the number of cgo calls made by the current process.","NumGoroutine returns the number of goroutines that currently exist.","The Error interface identifies a run time error.","A TypeAssertionError explains a failed type assertion.","Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller.  (For historical reasons the meaning of skip differs between Caller and \\[Callers].) The return values report the program counter, file name, and line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information.","Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function names and line numbers, use \\[CallersFrames]. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using \\[FuncForPC] on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.","GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.","Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\".","GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run \"go tool dist list\".","GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on.","SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program.\n\nFinalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an [os.File](https://pkg.go.dev/os/#File) object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a [bufio.Writer](https://pkg.go.dev/bufio/#Writer), because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of \\*obj is zero bytes, because it may share same address with other zero-size objects in memory. See [https://go.dev/ref/spec#Size\\_and\\_alignment\\_guarantees](https://go.dev/ref/spec#Size_and_alignment_guarantees).\n\nIt is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.\n\nNote that because finalizers may execute arbitrarily far into the future after an object is no longer referenced, the runtime is allowed to perform a space-saving optimization that batches objects together in a single allocation slot. The finalizer for an unreferenced object in such an allocation may never run if it always exists in the same batch as a referenced object. Typically, this batching only happens for tiny (on the order of 16 bytes or less) and pointer-free objects.\n\nA finalizer may run as soon as an object becomes unreachable. In order to use finalizers correctly, the program must ensure that the object is reachable until it is no longer required. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. A function argument or receiver may become unreachable at the last point where the function mentions it. To make an unreachable object reachable, pass the object to a call of the \\[KeepAlive] function to mark the last point in the function where the object must be reachable.\n\nFor example, if p points to a struct, such as os.File, that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters [syscall.Write](https://pkg.go.dev/syscall/#Write). The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call KeepAlive(p) after the call to syscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially. If a finalizer must run for a long time, it should do so by starting a new goroutine.\n\nIn the terminology of the Go memory model, a call SetFinalizer(x, f) “synchronizes before” the finalization call f(x). However, there is no guarantee that KeepAlive(x) or any other use of x “synchronizes before” f(x), so in general a finalizer should use a mutex or other synchronization mechanism if it needs to access mutable state in x. For example, consider a finalizer that inspects a mutable field in x that is modified from time to time in the main program before x becomes unreachable and the finalizer is invoked. The modifications in the main program and the inspection in the finalizer need to use appropriate synchronization, such as mutexes or atomic updates, to avoid read-write races.","KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := \u0026File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of [syscall.Read](https://pkg.go.dev/syscall/#Read), closing the file descriptor before syscall.Read makes the actual system call.\n\nNote: KeepAlive should only be used to prevent finalizers from running prematurely. In particular, when used with [unsafe.Pointer](https://pkg.go.dev/unsafe/#Pointer), the rules for valid uses of unsafe.Pointer still apply.","GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.","SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate \\\u003c= 0.","SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0. To just read the current rate, pass rate \\\u003c 0. (For n\u003e1 the details of sampling may change.)","A StackRecord describes a single execution stack.","MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated.\n\nTo include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.\n\nThe tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).","A MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace).","MemProfile returns a profile of memory allocated and freed per allocation site.\n\nMemProfile returns n, the number of records in the current memory profile. If len(p) \u003e= n, MemProfile copies the profile into p and returns n, true. If len(p) \\\u003c n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records where r.AllocBytes \u003e 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly.","BlockProfileRecord describes blocking events originated at a particular call sequence (stack trace).","BlockProfile returns n, the number of records in the current blocking profile. If len(p) \u003e= n, BlockProfile copies the profile into p and returns n, true. If len(p) \\\u003c n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the [runtime/pprof](https://pkg.go.dev/runtime/pprof/) package or the [testing](https://pkg.go.dev/testing/) package's -test.blockprofile flag instead of calling BlockProfile directly.","MutexProfile returns n, the number of records in the current mutex profile. If len(p) \u003e= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the [runtime/pprof](https://pkg.go.dev/runtime/pprof/) package instead of calling MutexProfile directly.","ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) \u003e= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) \\\u003c n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly.","GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) \u003e= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) \\\u003c n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the [runtime/pprof](https://pkg.go.dev/runtime/pprof/) package instead of calling GoroutineProfile directly.","Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.","A MemStats records statistics about the memory allocator.","ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.","Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutines. If all other goroutines exit, the program crashes.","A PanicNilError happens when code calls panic(nil).\n\nBefore Go 1.21, programs that called panic(nil) observed recover returning nil. Starting in Go 1.21, programs that call panic(nil) observe recover returning a \\*PanicNilError. Programs can change back to the old behavior by setting GODEBUG=panicnil=1.","A Pinner is a set of Go objects each pinned to a fixed location in memory. The \\[Pinner.Pin] method pins one object, while \\[Pinner.Unpin] unpins all pinned objects. See their comments for more information.","Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.","Breakpoint executes a breakpoint trap.","LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to \\[UnlockOSThread] as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread from an init function will cause the main function to be invoked on that thread.\n\nA goroutine should call LockOSThread before calling OS services or non-Go library functions that depend on per-thread state.","UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS thread is suitable for running other goroutines. If the caller made any permanent changes to the state of the thread that would affect other goroutines, it should not call this function and thus leave the goroutine locked to the OS thread until the goroutine (and hence the thread) exits.","Frames may be used to get function/file/line information for a slice of PC values returned by \\[Callers].","Frame is the information returned by \\[Frames] for each call frame.","CallersFrames takes a slice of PC values returned by \\[Callers] and prepares to return function/file/line information. Do not change the slice until you are done with the \\[Frames].","A Func represents a Go function in the running binary.","FuncForPC returns a \\*\\[Func] describing the function that contains the given program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns the \\*Func describing the innermost function, but with an entry of the outermost function.\n\nFor completely unclear reasons, even though they can import runtime, some widely used packages access this using linkname. Notable members of the hall of shame include:\n\n  - gitee.com/quant1x/gox\n\nDo not remove or change the type signature. See go.dev/issue/67401.","StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via \\[ReadTrace]. StartTrace returns an error if tracing is already enabled. Most clients should use the [runtime/trace](https://pkg.go.dev/runtime/trace/) package or the [testing](https://pkg.go.dev/testing/) package's -test.trace flag instead of calling StartTrace directly.","StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.","ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.","SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory.  None of the functions may call back into Go.\n\nThe context function will be called with a single argument, a pointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.\n\nIf the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.\n\nWhile it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a pointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value.\n\nIf the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext\\_t\\* cast to uintptr\\_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.\n\nBuf is where the traceback information should be stored. It should be PC values, such that Buf\\[0] is the PC of the caller, Buf\\[1] is the PC of that function's caller, and so on.  Max is the maximum number of entries to store.  The function should store a zero to indicate the top of the stack, or that the caller is on a different stack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, linux/arm64, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a pointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback function.\n\nThe first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero.  If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.","All returns an iterator over index-value pairs in the slice in the usual order.","Backward returns an iterator over index-value pairs in the slice, traversing it backward with descending indices.","Values returns an iterator that yields the slice elements in order.","AppendSeq appends the values from seq to the slice and returns the extended slice.","Collect collects values from seq into a new slice and returns it.","Sorted collects values from seq into a new slice, sorts the slice, and returns it.","SortedFunc collects values from seq into a new slice, sorts the slice using the comparison function, and returns it.","SortedStableFunc collects values from seq into a new slice. It then sorts the slice while keeping the original order of equal elements, using the comparison function to compare elements. It returns the new slice.","Chunk returns an iterator over consecutive sub-slices of up to n elements of s. All but the last sub-slice will have size n. All sub-slices are clipped to have no capacity beyond the length. If s is empty, the sequence is empty: there is no empty slice in the sequence. Chunk panics if n is less than 1.","Equal reports whether two slices are equal: the same length and all elements equal. If the lengths are different, Equal returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first unequal pair. Empty and nil slices are considered equal. Floating point NaNs are not considered equal.","EqualFunc reports whether two slices are equal using an equality function on each pair of elements. If the lengths are different, EqualFunc returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first index for which eq returns false.","Compare compares the elements of s1 and s2, using [cmp.Compare](https://pkg.go.dev/cmp/#Compare) on each pair of elements. The elements are compared sequentially, starting at index 0, until one element is not equal to the other. The result of comparing the first non-matching elements is returned. If both slices are equal until one of them ends, the shorter slice is considered less than the longer one. The result is 0 if s1 == s2, -1 if s1 \\\u003c s2, and +1 if s1 \u003e s2.","CompareFunc is like \\[Compare] but uses a custom comparison function on each pair of elements. The result is the first non-zero result of cmp; if cmp always returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) \\\u003c len(s2), and +1 if len(s1) \u003e len(s2).","Index returns the index of the first occurrence of v in s, or -1 if not present.","IndexFunc returns the first index i satisfying f(s\\[i]), or -1 if none do.","Contains reports whether v is present in s.","ContainsFunc reports whether at least one element e of s satisfies f(e).","Insert inserts the values v... into s at index i, returning the modified slice. The elements at s\\[i:] are shifted up to make room. In the returned slice r, r\\[i] == v\\[0], and r\\[i+len(v)] == value originally at r\\[i]. Insert panics if i is out of range. This function is O(len(s) + len(v)).","Delete removes the elements s\\[i:j] from s, returning the modified slice. Delete panics if j \u003e len(s) or s\\[i:j] is not a valid slice of s. Delete is O(len(s)-i), so if many items must be deleted, it is better to make a single call deleting them all together than to delete one at a time. Delete zeroes the elements s\\[len(s)-(j-i):len(s)].","DeleteFunc removes any elements from s for which del returns true, returning the modified slice. DeleteFunc zeroes the elements between the new length and the original length.","Replace replaces the elements s\\[i:j] by the given v, and returns the modified slice. Replace panics if j \u003e len(s) or s\\[i:j] is not a valid slice of s. When len(v) \\\u003c (j-i), Replace zeroes the elements between the new length and the original length.","Clone returns a copy of the slice. The elements are copied using assignment, so this is a shallow clone. The result may have additional unused capacity.","Compact replaces consecutive runs of equal elements with a single copy. This is like the uniq command found on Unix. Compact modifies the contents of the slice s and returns the modified slice, which may have a smaller length. Compact zeroes the elements between the new length and the original length.","CompactFunc is like \\[Compact] but uses an equality function to compare elements. For runs of elements that compare equal, CompactFunc keeps the first one. CompactFunc zeroes the elements between the new length and the original length.","Grow increases the slice's capacity, if necessary, to guarantee space for another n elements. After Grow(n), at least n elements can be appended to the slice without another allocation. If n is negative or too large to allocate the memory, Grow panics.","Clip removes unused capacity from the slice, returning s\\[:len(s):len(s)].","Reverse reverses the elements of the slice in place.","Concat returns a new slice concatenating the passed in slices.","Repeat returns a new slice that repeats the provided slice the given number of times. The result has length and capacity (len(x) \\* count). The result is never nil. Repeat panics if count is negative or if the result of (len(x) \\* count) overflows.","Sort sorts a slice of any ordered type in ascending order. When sorting floating-point numbers, NaNs are ordered before other values.","SortFunc sorts the slice x in ascending order as determined by the cmp function. This sort is not guaranteed to be stable. cmp(a, b) should return a negative number when a \\\u003c b, a positive number when a \u003e b and zero when a == b or a and b are incomparable in the sense of a strict weak ordering.\n\nSortFunc requires that cmp is a strict weak ordering. See [https://en.wikipedia.org/wiki/Weak\\_ordering#Strict\\_weak\\_orderings](https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings). The function should return 0 for incomparable items.","SortStableFunc sorts the slice x while keeping the original order of equal elements, using cmp to compare elements in the same way as \\[SortFunc].","IsSorted reports whether x is sorted in ascending order.","IsSortedFunc reports whether x is sorted in ascending order, with cmp as the comparison function as defined by \\[SortFunc].","Min returns the minimal value in x. It panics if x is empty. For floating-point numbers, Min propagates NaNs (any NaN value in x forces the output to be NaN).","MinFunc returns the minimal value in x, using cmp to compare elements. It panics if x is empty. If there is more than one minimal element according to the cmp function, MinFunc returns the first one.","Max returns the maximal value in x. It panics if x is empty. For floating-point E, Max propagates NaNs (any NaN value in x forces the output to be NaN).","MaxFunc returns the maximal value in x, using cmp to compare elements. It panics if x is empty. If there is more than one maximal element according to the cmp function, MaxFunc returns the first one.","BinarySearch searches for target in a sorted slice and returns the earliest position where target is found, or the position where target would appear in the sort order; it also returns a bool saying whether the target is really found in the slice. The slice must be sorted in increasing order.","BinarySearchFunc works like \\[BinarySearch], but uses a custom comparison function. The slice must be sorted in increasing order, where \"increasing\" is defined by cmp. cmp should return 0 if the slice element matches the target, a negative number if the slice element precedes the target, or a positive number if the slice element follows the target. cmp must implement the same ordering as the slice, such that if cmp(a, t) \\\u003c 0 and cmp(b, t) \u003e= 0, then a must precede b in the slice.","Search uses binary search to find and return the smallest index i in \\[0, n) at which f(i) is true, assuming that on the range \\[0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range \\[0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range \\[0, n).\n\nA common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered.\n\nFor instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data\\[i] \u003e= 23 }) returns the smallest index i such that data\\[i] \u003e= 23. If the caller wants to find whether 23 is in the slice, it must test data\\[i] == 23 separately.\n\nSearching data sorted in descending order would use the \\\u003c= operator instead of the \u003e= operator.\n\nTo complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] \u003e= x })\n\tif i \u003c len(data) \u0026\u0026 data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number \u003c= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", \u0026s)\n\t\t\treturn s != \"\" \u0026\u0026 s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}","Find uses binary search to find and return the smallest index i in \\[0, n) at which cmp(i) \\\u003c= 0. If there is no such index i, Find returns i = n. The found result is true if i \\\u003c n and cmp(i) == 0. Find calls cmp(i) only for i in the range \\[0, n).\n\nTo permit binary search, Find requires that cmp(i) \u003e 0 for a leading prefix of the range, cmp(i) == 0 in the middle, and cmp(i) \\\u003c 0 for the final suffix of the range. (Each subrange could be empty.) The usual way to establish this condition is to interpret cmp(i) as a comparison of a desired target value t against entry i in an underlying indexed data structure x, returning \\\u003c0, 0, and \u003e0 when t \\\u003c x\\[i], t == x\\[i], and t \u003e x\\[i], respectively.\n\nFor example, to look for a particular string in a sorted, random-access list of strings:\n\n\ti, found := sort.Find(x.Len(), func(i int) int {\n\t    return strings.Compare(target, x.At(i))\n\t})\n\tif found {\n\t    fmt.Printf(\"found %s at entry %d\\n\", target, i)\n\t} else {\n\t    fmt.Printf(\"%s not found, would insert at %d\", target, i)\n\t}","SearchInts searches for x in a sorted slice of ints and returns the index as specified by \\[Search]. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.","SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by \\[Search]. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.","SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.","Slice sorts the slice x given the provided less function. It panics if x is not a slice.\n\nThe sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use \\[SliceStable].\n\nThe less function must satisfy the same requirements as the Interface type's Less method.\n\nNote: in many situations, the newer [slices.SortFunc](https://pkg.go.dev/slices/#SortFunc) function is more ergonomic and runs faster.","SliceStable sorts the slice x using the provided less function, keeping equal elements in their original order. It panics if x is not a slice.\n\nThe less function must satisfy the same requirements as the Interface type's Less method.\n\nNote: in many situations, the newer [slices.SortStableFunc](https://pkg.go.dev/slices/#SortStableFunc) function is more ergonomic and runs faster.","SliceIsSorted reports whether the slice x is sorted according to the provided less function. It panics if x is not a slice.\n\nNote: in many situations, the newer [slices.IsSortedFunc](https://pkg.go.dev/slices/#IsSortedFunc) function is more ergonomic and runs faster.","An implementation of Interface can be sorted by the routines in this package. The methods refer to elements of the underlying collection by integer index.","Sort sorts data in ascending order as determined by the Less method. It makes one call to data.Len to determine n and O(n\\*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.\n\nNote: in many situations, the newer [slices.SortFunc](https://pkg.go.dev/slices/#SortFunc) function is more ergonomic and runs faster.","Reverse returns the reverse order for data.","IsSorted reports whether data is sorted.\n\nNote: in many situations, the newer [slices.IsSortedFunc](https://pkg.go.dev/slices/#IsSortedFunc) function is more ergonomic and runs faster.","IntSlice attaches the methods of Interface to \\[]int, sorting in increasing order.","Float64Slice implements Interface for a \\[]float64, sorting in increasing order, with not-a-number (NaN) values ordered before other values.","StringSlice attaches the methods of Interface to \\[]string, sorting in increasing order.","Ints sorts a slice of ints in increasing order.\n\nNote: as of Go 1.22, this function simply calls [slices.Sort](https://pkg.go.dev/slices/#Sort).","Float64s sorts a slice of float64s in increasing order. Not-a-number (NaN) values are ordered before other values.\n\nNote: as of Go 1.22, this function simply calls [slices.Sort](https://pkg.go.dev/slices/#Sort).","Strings sorts a slice of strings in increasing order.\n\nNote: as of Go 1.22, this function simply calls [slices.Sort](https://pkg.go.dev/slices/#Sort).","IntsAreSorted reports whether the slice x is sorted in increasing order.\n\nNote: as of Go 1.22, this function simply calls [slices.IsSorted](https://pkg.go.dev/slices/#IsSorted).","Float64sAreSorted reports whether the slice x is sorted in increasing order, with not-a-number (NaN) values before any other values.\n\nNote: as of Go 1.22, this function simply calls [slices.IsSorted](https://pkg.go.dev/slices/#IsSorted).","StringsAreSorted reports whether the slice x is sorted in increasing order.\n\nNote: as of Go 1.22, this function simply calls [slices.IsSorted](https://pkg.go.dev/slices/#IsSorted).","Stable sorts data in ascending order as determined by the Less method, while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n\\*log(n)) calls to data.Less and O(n\\*log(n)\\*log(n)) calls to data.Swap.\n\nNote: in many situations, the newer slices.SortStableFunc function is more ergonomic and runs faster.","ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.","FormatBool returns \"true\" or \"false\" according to the value of b.","AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer.","ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value.\n\nThe number represented by s must be of the form N, Ni, or N±Ni, where N stands for a floating-point number as recognized by \\[ParseFloat], and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the ±. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.\n\nThe errors that ParseComplex returns have concrete type \\[\\*NumError] and include err.Num = s.\n\nIf s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = ±Inf for the respective component.","ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.\n\nParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for [floating-point literals](https://go.dev/ref/spec#Floating-point_literals). If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)\n\nThe errors that ParseFloat returns have concrete type \\*NumError and include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = ±Inf, err.Err = ErrRange.\n\nParseFloat recognizes the string \"NaN\", and the (possibly signed) strings \"Inf\" and \"Infinity\" as their respective special floating point values. It ignores case when matching.","ErrRange indicates that a value is out of range for the target type.","ErrSyntax indicates that a value does not have the right syntax for the target type.","A NumError records a failed conversion.","IntSize is the size in bits of an int or uint value.","ParseUint is like \\[ParseInt] but for unsigned numbers.\n\nA sign prefix is not permitted.","ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.\n\nThe string may begin with a leading sign: \"+\" or \"-\".\n\nIf the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for [integer literals](https://go.dev/ref/spec#Integer_literals).\n\nThe bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.\n\nThe errors that ParseInt returns have concrete type \\[\\*NumError] and include err.Num = s. If s is empty or contains invalid digits, err.Err = \\[ErrSyntax] and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = \\[ErrRange] and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.","Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.","FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.\n\nThe format fmt and precision prec have the same meaning as in \\[FormatFloat]. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.","FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of 'b' (-ddddp±ddd, a binary exponent), 'e' (-d.dddde±dd, a decimal exponent), 'E' (-d.ddddE±dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).\n\nThe precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.","AppendFloat appends the string form of the floating-point number f, as generated by \\[FormatFloat], to dst and returns the extended buffer.","FormatUint returns the string representation of i in the given base, for 2 \\\u003c= base \\\u003c= 36. The result uses the lower-case letters 'a' to 'z' for digit values \u003e= 10.","FormatInt returns the string representation of i in the given base, for 2 \\\u003c= base \\\u003c= 36. The result uses the lower-case letters 'a' to 'z' for digit values \u003e= 10.","Itoa is equivalent to \\[FormatInt](int64(i), 10).","AppendInt appends the string form of the integer i, as generated by \\[FormatInt], to dst and returns the extended buffer.","AppendUint appends the string form of the unsigned integer i, as generated by \\[FormatUint], to dst and returns the extended buffer.","Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\\\t, \\\\n, \\\\xFF, \\\\u0100) for control characters and non-printable characters as defined by \\[IsPrint].","AppendQuote appends a double-quoted Go string literal representing s, as generated by \\[Quote], to dst and returns the extended buffer.","QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\\\t, \\\\n, \\\\xFF, \\\\u0100) for non-ASCII characters and non-printable characters as defined by \\[IsPrint].","AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by \\[QuoteToASCII], to dst and returns the extended buffer.","QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by \\[IsGraphic], unchanged and uses Go escape sequences (\\\\t, \\\\n, \\\\xFF, \\\\u0100) for non-graphic characters.","AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by \\[QuoteToGraphic], to dst and returns the extended buffer.","QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\\\t, \\\\n, \\\\xFF, \\\\u0100) for control characters and non-printable characters as defined by \\[IsPrint]. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.","AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by \\[QuoteRune], to dst and returns the extended buffer.","QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\\\t, \\\\n, \\\\xFF, \\\\u0100) for non-ASCII characters and non-printable characters as defined by \\[IsPrint]. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.","AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by \\[QuoteRuneToASCII], to dst and returns the extended buffer.","QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by \\[IsGraphic], the returned string will use a Go escape sequence (\\\\t, \\\\n, \\\\xFF, \\\\u0100). If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.","AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by \\[QuoteRuneToGraphic], to dst and returns the extended buffer.","CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.","UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:\n\n 1. value, the decoded Unicode code point or byte value;\n 2. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n 3. tail, the remainder of the string after the character; and\n 4. an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \\\\' and disallows unescaped '. If set to a double quote, it permits \\\\\" and disallows unescaped \". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.","QuotedPrefix returns the quoted string (as understood by \\[Unquote]) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error.","Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes.  (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)","IsPrint reports whether the rune is defined as printable by Go, with the same definition as [unicode.IsPrint](https://pkg.go.dev/unicode/#IsPrint): letters, numbers, punctuation, symbols and ASCII space.","IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.","A Builder is used to efficiently build a string using \\[Builder.Write] methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.","Clone returns a fresh copy of s. It guarantees to make a copy of s into a new allocation, which can be important when retaining only a small substring of a much larger string. Using Clone can help such programs use less memory. Of course, since using Clone makes a copy, overuse of Clone can make programs use more memory. Clone should typically be used only rarely, and only when profiling indicates that it is needed. For strings of length zero the string \"\" will be returned and no allocation is made.","Compare returns an integer comparing two strings lexicographically. The result will be 0 if a == b, -1 if a \\\u003c b, and +1 if a \u003e b.\n\nUse Compare when you need to perform a three-way comparison (with [slices.SortFunc](https://pkg.go.dev/slices/#SortFunc), for example). It is usually clearer and always faster to use the built-in string comparison operators ==, \\\u003c, \u003e, and so on.","A Reader implements the [io.Reader](https://pkg.go.dev/io/#Reader), [io.ReaderAt](https://pkg.go.dev/io/#ReaderAt), [io.ByteReader](https://pkg.go.dev/io/#ByteReader), [io.ByteScanner](https://pkg.go.dev/io/#ByteScanner), [io.RuneReader](https://pkg.go.dev/io/#RuneReader), [io.RuneScanner](https://pkg.go.dev/io/#RuneScanner), [io.Seeker](https://pkg.go.dev/io/#Seeker), and [io.WriterTo](https://pkg.go.dev/io/#WriterTo) interfaces by reading from a string. The zero value for Reader operates like a Reader of an empty string.","NewReader returns a new \\[Reader] reading from s. It is similar to [bytes.NewBufferString](https://pkg.go.dev/bytes/#NewBufferString) but more efficient and non-writable.","Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.","NewReplacer returns a new \\[Replacer] from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order.\n\nNewReplacer panics if given an odd number of arguments.","Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.","Contains reports whether substr is within s.","ContainsAny reports whether any Unicode code points in chars are within s.","ContainsRune reports whether the Unicode code point r is within s.","ContainsFunc reports whether any Unicode code points r within s satisfy f(r).","LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.","IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.","IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is \\[utf8.RuneError], it returns the first instance of any invalid UTF-8 byte sequence.","IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.","LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.","LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.","SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.\n\nThe count determines the number of substrings to return:\n\n  - n \u003e 0: at most n substrings; the last substring will be the unsplit remainder;\n  - n == 0: the result is nil (zero substrings);\n  - n \\\u003c 0: all substrings.\n\nEdge cases for s and sep (for example, empty strings) are handled as described in the documentation for \\[Split].\n\nTo split around the first instance of a separator, see \\[Cut].","SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n\n  - n \u003e 0: at most n substrings; the last substring will be the unsplit remainder;\n  - n == 0: the result is nil (zero substrings);\n  - n \\\u003c 0: all substrings.\n\nEdge cases for s and sep (for example, empty strings) are handled as described in the documentation for \\[SplitAfter].","Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.\n\nIt is equivalent to \\[SplitN] with a count of -1.\n\nTo split around the first instance of a separator, see \\[Cut].","SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to \\[SplitAfterN] with a count of -1.","Fields splits the string s around each instance of one or more consecutive white space characters, as defined by [unicode.IsSpace](https://pkg.go.dev/unicode/#IsSpace), returning a slice of substrings of s or an empty slice if s contains only white space.","FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned.\n\nFieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c.","Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string.","HasPrefix reports whether the string s begins with prefix.","HasSuffix reports whether the string s ends with suffix.","Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.","Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if the result of (len(s) \\* count) overflows.","ToUpper returns s with all Unicode letters mapped to their upper case.","ToLower returns s with all Unicode letters mapped to their lower case.","ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.","ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.","ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.","ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.","ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.","Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.\n\nDeprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead.","TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.","TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.","TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.","IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.","LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.","Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.","TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.\n\nTo remove a prefix, use \\[TrimPrefix] instead.","TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.\n\nTo remove a suffix, use \\[TrimSuffix] instead.","TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.","TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.","TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.","Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n \\\u003c 0, there is no limit on the number of replacements.","ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.","EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity.","Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.","Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, \"\", false.","CutPrefix returns s without the provided leading prefix string and reports whether it found the prefix. If s doesn't start with prefix, CutPrefix returns s, false. If prefix is the empty string, CutPrefix returns s, true.","CutSuffix returns s without the provided ending suffix string and reports whether it found the suffix. If s doesn't end with suffix, CutSuffix returns s, false. If suffix is the empty string, CutSuffix returns s, true.","HostLayout marks a struct as using host memory layout. A struct with a field of type HostLayout will be laid out in memory according to host expectations, generally following the host's C ABI.\n\nHostLayout does not affect layout within any other struct-typed fields of the containing struct, nor does it affect layout of structs containing the struct marked as host layout.\n\nBy convention, HostLayout should be used as the type of a field named \"\\_\", placed at the beginning of the struct type definition.","Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event.\n\nEach Cond has an associated Locker L (often a \\[\\*Mutex] or \\[\\*RWMutex]), which must be held when changing the condition and when calling the \\[Cond.Wait] method.\n\nA Cond must not be copied after first use.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), Cond arranges that a call to \\[Cond.Broadcast] or \\[Cond.Signal] “synchronizes before” any Wait call that it unblocks.\n\nFor many simple use cases, users will be better off using channels than a Cond (Broadcast corresponds to closing a channel, and Signal corresponds to sending on a channel).\n\nFor more on replacements for [sync.Cond](https://pkg.go.dev/sync/#Cond), see [Roberto Clapis's series on advanced concurrency patterns](https://blogtitle.github.io/categories/concurrency/), as well as [Bryan Mills's talk on concurrency patterns](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view).","NewCond returns a new Cond with Locker l.","Map is like a Go map\\[any]any but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.\n\nThe Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.\n\nThe Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate \\[Mutex] or \\[RWMutex].\n\nThe zero Map is empty and ready for use. A Map must not be copied after first use.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), Map arranges that a write operation “synchronizes before” any read operation that observes the effect of the write, where read and write operations are defined as follows. \\[Map.Load], \\[Map.LoadAndDelete], \\[Map.LoadOrStore], \\[Map.Swap], \\[Map.CompareAndSwap], and \\[Map.CompareAndDelete] are read operations; \\[Map.Delete], \\[Map.LoadAndDelete], \\[Map.Store], and \\[Map.Swap] are write operations; \\[Map.LoadOrStore] is a write operation when it returns loaded set to false; \\[Map.CompareAndSwap] is a write operation when it returns swapped set to true; and \\[Map.CompareAndDelete] is a write operation when it returns deleted set to true.","A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.\n\nA Mutex must not be copied after first use.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), the n'th call to \\[Mutex.Unlock] “synchronizes before” the m'th call to \\[Mutex.Lock] for any n \\\u003c m. A successful call to \\[Mutex.TryLock] is equivalent to a call to Lock. A failed call to TryLock does not establish any “synchronizes before” relation at all.","A Locker represents an object that can be locked and unlocked.","Once is an object that will perform exactly one action.\n\nA Once must not be copied after first use.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), the return from f “synchronizes before” the return from any call of once.Do(f).","OnceFunc returns a function that invokes f only once. The returned function may be called concurrently.\n\nIf f panics, the returned function will panic with the same value on every call.","OnceValue returns a function that invokes f only once and returns the value returned by f. The returned function may be called concurrently.\n\nIf f panics, the returned function will panic with the same value on every call.","OnceValues returns a function that invokes f only once and returns the values returned by f. The returned function may be called concurrently.\n\nIf f panics, the returned function will panic with the same value on every call.","A Pool is a set of temporary objects that may be individually saved and retrieved.\n\nAny item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated.\n\nA Pool is safe for use by multiple goroutines simultaneously.\n\nPool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.\n\nAn appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients.\n\nAn example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. The store scales under load (when many goroutines are actively printing) and shrinks when quiescent.\n\nOn the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.\n\nA Pool must not be copied after first use.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), a call to Put(x) “synchronizes before” a call to \\[Pool.Get] returning that same value x. Similarly, a call to New returning x “synchronizes before” a call to Get returning that same value x.","A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.\n\nA RWMutex must not be copied after first use.\n\nIf any goroutine calls \\[RWMutex.Lock] while the lock is already held by one or more readers, concurrent calls to \\[RWMutex.RLock] will block until the writer has acquired (and released) the lock, to ensure that the lock eventually becomes available to the writer. Note that this prohibits recursive read-locking.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), the n'th call to \\[RWMutex.Unlock] “synchronizes before” the m'th call to Lock for any n \\\u003c m, just as for \\[Mutex]. For any call to RLock, there exists an n such that the n'th call to Unlock “synchronizes before” that call to RLock, and the corresponding call to \\[RWMutex.RUnlock] “synchronizes before” the n+1'th call to Lock.","A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls \\[WaitGroup.Add] to set the number of goroutines to wait for. Then each of the goroutines runs and calls \\[WaitGroup.Done] when finished. At the same time, \\[WaitGroup.Wait] can be used to block until all goroutines have finished.\n\nA WaitGroup must not be copied after first use.\n\nIn the terminology of [the Go memory model](https://go.dev/ref/mem), a call to \\[WaitGroup.Done] “synchronizes before” the return of any Wait call that it unblocks.","ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user\\_namespaces(7).\n\nNote that User Namespaces are not available on a number of popular Linux versions (due to security issues), or are available but subject to AppArmor restrictions like in Ubuntu 24.04.","","ForkLock is used to synchronize creation of new file descriptors with fork.\n\nWe want the child in a fork/exec sequence to inherit only the file descriptors we intend. To do that, we mark all file descriptors close-on-exec and then, in the child, explicitly unmark the ones we want the exec'ed program to keep. Unix doesn't make this easy: there is, in general, no way to allocate a new file descriptor close-on-exec. Instead you have to allocate the descriptor and then mark it close-on-exec. If a fork happens between those two events, the child's exec will inherit an unwanted file descriptor.\n\nThis lock solves that race: the create new fd/mark close-on-exec operation is done holding ForkLock for reading, and the fork itself is done holding ForkLock for writing. At least, that's the idea. There are some complications.\n\nSome system calls that create new file descriptors can block for arbitrarily long times: open on a hung NFS server or named pipe, accept on a socket, and so on. We can't reasonably grab the lock across those operations.\n\nIt is worse to inherit some file descriptors than others. If a non-malicious child accidentally inherits an open ordinary file, that's not a big deal. On the other hand, if a long-lived child accidentally inherits the write end of a pipe, then the reader of that pipe will not see EOF until that child exits, potentially causing the parent program to hang. This is a common problem in threaded C programs that use popen.\n\nLuckily, the file descriptors that are most important not to inherit are not the ones that can take an arbitrarily long time to create: pipe returns instantly, and the net package uses non-blocking I/O to accept on a listening socket. The rules for which file descriptor-creating operations use the ForkLock are as follows:\n\n  - \\[Pipe]. Use pipe2 if available. Otherwise, does not block, so use ForkLock.\n  - \\[Socket]. Use SOCK\\_CLOEXEC if available. Otherwise, does not block, so use ForkLock.\n  - \\[Open]. Use \\[O\\_CLOEXEC] if available. Otherwise, may block, so live with the race.\n  - \\[Dup]. Use \\[F\\_DUPFD\\_CLOEXEC] or dup3 if available. Otherwise, does not block, so use ForkLock.","StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.\n\nDeprecated: Use \\[SlicePtrFromStrings] instead.","SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, \\[EINVAL]).","","","Credential holds user and group identities to be assumed by a child process started by \\[StartProcess].","ProcAttr holds attributes that will be applied to a new process started by \\[StartProcess].","Combination of fork and exec, careful to be thread safe.","StartProcess wraps \\[ForkExec] for package os.","Exec invokes the execve(2) system call.","FcntlFlock performs a fcntl syscall for the \\[F\\_GETLK], \\[F\\_SETLK] or \\[F\\_SETLKW] command.","Deprecated: Use golang.org/x/net/bpf instead.","Deprecated: Use golang.org/x/net/bpf instead.","Deprecated: Use golang.org/x/net/bpf instead.","Deprecated: Use golang.org/x/net/bpf instead.","Deprecated: Use golang.org/x/net/bpf instead.","Deprecated: Use golang.org/x/net/bpf instead.","A RawConn is a raw network connection.","Conn is implemented by some types in the net and os packages to provide access to the underlying file descriptor or handle.","NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.","NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.","NetlinkMessage represents a netlink message.","ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.","NetlinkRouteAttr represents a netlink route attribute.","ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.","","UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.","ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO\\_PASSCRED option must be enabled on the socket.","CmsgLen returns the value to store in the Len field of the \\[Cmsghdr] structure, taking into account any necessary alignment.","CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies.","SocketControlMessage represents a socket control message.","ParseSocketControlMessage parses b as an array of socket control messages.","UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.","ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.","StringByteSlice converts a string to a NUL-terminated \\[]byte, If s contains a NUL byte this function panics instead of returning an error.\n\nDeprecated: Use ByteSliceFromString instead.","ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, \\[EINVAL]).","StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.\n\nDeprecated: Use \\[BytePtrFromString] instead.","BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, \\[EINVAL]).","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","BindToDevice binds the socket associated with fd to device.","","","","","","","","","","","","","","","","","","AllThreadsSyscall performs a syscall on each OS thread of the Go runtime. It first invokes the syscall on one thread. Should that invocation fail, it returns immediately with the error status. Otherwise, it invokes the syscall on all of the remaining threads in parallel. It will terminate the program if it observes any invoked syscall's return value differs from that of the first invocation.\n\nAllThreadsSyscall is intended for emulating simultaneous process-wide state changes that require consistently modifying per-thread state of the Go runtime.\n\nAllThreadsSyscall is unaware of any threads that are launched explicitly by cgo linked code, so the function always returns \\[ENOTSUP] in binaries that use cgo.","AllThreadsSyscall6 is like \\[AllThreadsSyscall], but extended to six arguments.","","","","","","","","","","","","","","","","","","","","An Errno is an unsigned number describing an error condition. It implements the error interface. The zero Errno is by convention a non-error, so code to convert from Errno to error should use:\n\n\terr = nil\n\tif errno != 0 {\n\t\terr = errno\n\t}\n\nErrno values can be tested against error values using [errors.Is](https://pkg.go.dev/errors/#Is). For example:\n\n\t_, _, err := syscall.Syscall(...)\n\tif errors.Is(err, fs.ErrNotExist) ...","A Signal is a number describing a process signal. It implements the [os.Signal](https://pkg.go.dev/os/#Signal) interface.","","","","","For testing: clients can set this flag to force creation of IPv6 sockets to return \\[EAFNOSUPPORT].","","","","","","","","","","","","","","","","","","","","","","","","","","TimespecToNsec returns the time stored in ts as nanoseconds.","NsecToTimespec converts a number of nanoseconds into a \\[Timespec].","TimevalToNsec returns the time stored in tv as nanoseconds.","NsecToTimeval converts a number of nanoseconds into a \\[Timeval].","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore it before returning.","InternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command.","B is a type passed to \\[Benchmark] functions to manage benchmark timing and to specify the number of iterations to run.\n\nA benchmark ends when its Benchmark function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called only from the goroutine running the Benchmark function. The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.\n\nLike in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.","BenchmarkResult contains the results of a benchmark run.","RunBenchmarks is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command.","A PB is used by RunParallel for running parallel benchmarks.","Benchmark benchmarks a single function. It is useful for creating custom benchmarks that do not use the \"go test\" command.\n\nIf f depends on testing flags, then \\[Init] must be used to register those flags before calling Benchmark and before calling [flag.Parse](https://pkg.go.dev/flag/#Parse).\n\nIf f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark.","CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.","Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.","Coverage reports the current code coverage as a fraction in the range \\[0, 1]. If coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.","RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.","","RunExamples is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command.","InternalFuzzTarget is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command.","F is a type passed to fuzz tests.\n\nFuzz tests run generated inputs against a provided fuzz target, which can find and report potential bugs in the code being tested.\n\nA fuzz test runs the seed corpus by default, which includes entries provided by (\\*F).Add and entries in the testdata/fuzz/\\\u003cFuzzTestName\u003e directory. After any necessary setup and calls to (\\*F).Add, the fuzz test must then call (\\*F).Fuzz to provide the fuzz target. See the testing package documentation for an example, and see the \\[F.Fuzz] and \\[F.Add] method documentation for details.\n\n\\*F methods can only be called before (\\*F).Fuzz. Once the test is executing the fuzz target, only (\\*T) methods can be used. The only \\*F methods that are allowed in the (\\*F).Fuzz function are (\\*F).Failed and (\\*F).Name.","Init registers testing flags. These flags are automatically registered by the \"go test\" command before running test functions, so Init is only needed when calling functions such as Benchmark without using \"go test\".\n\nInit is not safe to call concurrently. It has no effect if it was already called.","Short reports whether the -test.short flag is set.","Testing reports whether the current code is being run in a test. This will report true in programs created by \"go test\", false in programs created by \"go build\".","CoverMode reports what the test coverage mode is set to. The values are \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage is not enabled.","Verbose reports whether the -test.v flag is set.","TB is the interface common to T, B, and F.","T is a type passed to Test functions to manage test state and support formatted test logs.\n\nA test ends when its Test function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as the Parallel method, must be called only from the goroutine running the Test function.\n\nThe other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.","InternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command.","Main is an internal function, part of the implementation of the \"go test\" command. It was exported because it is cross-package and predates \"internal\" packages. It is no longer used by \"go test\" but preserved, as much as possible, for other systems that simulate \"go test\" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating \"go test\" should be updated to use MainStart.","M is a type passed to a TestMain function to run the actual tests.","MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.","RunTests is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command.","","","","","","","","","","","","","Handy time stamps.","","","","","","","ParseError describes a problem parsing a time string.","Parse parses a formatted string and returns the time value it represents. See the documentation for the constant called \\[Layout] to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument.\n\nThe example for \\[Time.Format] demonstrates the working of the layout string in detail and is a good reference.\n\nWhen parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. Fractional seconds are truncated to nanosecond precision.\n\nElements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored.\n\nFor layouts specifying the two-digit year 06, a value NN \u003e= 69 will be treated as 19NN and a value NN \\\u003c 69 will be treated as 20NN.\n\nThe remainder of this comment describes the handling of time zones.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (\\[Local]), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use \\[ParseInLocation].","ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.","ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".","Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.","The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by \\[AfterFunc]. A Timer must be created with \\[NewTimer] or AfterFunc.","NewTimer creates a new Timer that will send the current time on its channel after at least duration d.\n\nBefore Go 1.23, the garbage collector did not recover timers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTimer, to make the timer recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced timers, even if they haven't expired or been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the timer for other reasons.)\n\nBefore Go 1.23, the channel associated with a Timer was asynchronous (buffered, capacity 1), which meant that stale time values could be received even after \\[Timer.Stop] or \\[Timer.Reset] returned. As of Go 1.23, the channel is synchronous (unbuffered, capacity 0), eliminating the possibility of those stale values.\n\nThe GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23 behaviors: when set, unexpired timers won't be garbage collected, and channels will have buffered capacity. This setting may be removed in Go 1.27 or later.","After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to \\[NewTimer](d).C.\n\nBefore Go 1.23, this documentation warned that the underlying \\[Timer] would not be recovered by the garbage collector until the timer fired, and that if efficiency was a concern, code should use NewTimer instead and call \\[Timer.Stop] if the timer is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced, unstopped timers. There is no reason to prefer NewTimer when After will do.","AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a \\[Timer] that can be used to cancel the call using its Stop method. The returned Timer's C field is not used and will be nil.","A Ticker holds a channel that delivers “ticks” of a clock at intervals.","NewTicker returns a new \\[Ticker] containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic.\n\nBefore Go 1.23, the garbage collector did not recover tickers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTicker, to make the ticker recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the ticker for other reasons.)","Tick is a convenience wrapper for \\[NewTicker] providing access to the ticking channel only. Unlike NewTicker, Tick will return nil if d \\\u003c= 0.\n\nBefore Go 1.23, this documentation warned that the underlying \\[Ticker] would never be recovered by the garbage collector, and that if efficiency was a concern, code should use NewTicker instead and call \\[Ticker.Stop] when the ticker is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. There is no longer any reason to prefer NewTicker when Tick will do.","A Time represents an instant in time with nanosecond precision.\n\nPrograms using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type [time.Time](https://pkg.go.dev/time/#Time), not \\*time.Time.\n\nA Time value can be used by multiple goroutines simultaneously except that the methods \\[Time.GobDecode], \\[Time.UnmarshalBinary], \\[Time.UnmarshalJSON] and \\[Time.UnmarshalText] are not concurrency-safe.\n\nTime instants can be compared using the \\[Time.Before], \\[Time.After], and \\[Time.Equal] methods. The \\[Time.Sub] method subtracts two instants, producing a \\[Duration]. The \\[Time.Add] method adds a Time and a Duration, producing a Time.\n\nThe zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the \\[Time.IsZero] method gives a simple way of detecting a time that has not been initialized explicitly.\n\nEach time has an associated \\[Location]. The methods \\[Time.Local], \\[Time.UTC], and Time.In return a Time with a specific Location. Changing the Location of a Time value with these methods does not change the actual instant it represents, only the time zone in which to interpret it.\n\nRepresentations of a Time value saved by the \\[Time.GobEncode], \\[Time.MarshalBinary], \\[Time.MarshalJSON], and \\[Time.MarshalText] methods store the \\[Time.Location]'s offset, but not the location name. They therefore lose information about Daylight Saving Time.\n\nIn addition to the required “wall clock” reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the “Monotonic Clocks” section in the package documentation for details.\n\nNote that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.","A Month specifies a month of the year (January = 1, ...).","","","","","","","","","","","","","A Weekday specifies a day of the week (Sunday = 0, ...).","","","","","","","","A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.","","","","","","","Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).","Until returns the duration until t. It is shorthand for t.Sub(time.Now()).","Now returns the current local time.","Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range \\[0, 999999999]. Not all sec values have a corresponding time value. One such value is 1\\\u003c\\\u003c63-1 (the largest int64 value).","UnixMilli returns the local Time corresponding to the given Unix time, msec milliseconds since January 1, 1970 UTC.","UnixMicro returns the local Time corresponding to the given Unix time, usec microseconds since January 1, 1970 UTC.","Date returns the Time corresponding to\n\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\n\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which.\n\nDate panics if loc is nil.","A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant.\n\nLocation is used to provide a time zone in a printed Time value and for calculations involving intervals that may cross daylight savings time boundaries.","UTC represents Universal Coordinated Time (UTC).","Local represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=\"\" means use UTC. TZ=\"foo\" means use file foo in the system timezone directory.","FixedZone returns a \\[Location] that always uses the given zone name and offset (seconds east of UTC).","LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New\\_York\".\n\nLoadLocation looks for the IANA Time Zone database in the following locations in order:\n\n  - the directory or uncompressed zip file named by the ZONEINFO environment variable\n  - on a Unix system, the system standard installation location\n  - $GOROOT/lib/time/zoneinfo.zip\n  - the time/tzdata package, if it was imported","LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).","","","IsDigit reports whether the rune is a decimal digit.","GraphicRanges defines the set of graphic characters according to Unicode.","PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately.","IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories \\[L], \\[M], \\[N], \\[P], \\[S], \\[Zs].","IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories \\[L], \\[M], \\[N], \\[P], \\[S] and the ASCII space character. This categorization is the same as \\[IsGraphic] except that the only spacing character is ASCII space, U+0020.","IsOneOf reports whether the rune is a member of one of the ranges. The function \"In\" provides a nicer signature and should be used in preference to IsOneOf.","In reports whether the rune is a member of one of the ranges.","IsControl reports whether the rune is a control character. The \\[C] (\\[Other]) Unicode category includes more code points such as surrogates; use \\[Is](C, r) to test for them.","IsLetter reports whether the rune is a letter (category \\[L]).","IsMark reports whether the rune is a mark character (category \\[M]).","IsNumber reports whether the rune is a number (category \\[N]).","IsPunct reports whether the rune is a Unicode punctuation character (category \\[P]).","IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is\n\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\n\nOther definitions of spacing characters are set by category Z and property \\[Pattern\\_White\\_Space].","IsSymbol reports whether the rune is a symbolic character.","","","","","RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values \u003e= 0x10000 (1\\\u003c\\\u003c16).","Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.","Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be \u003e= 1\\\u003c\\\u003c16.","CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas are the number to add to the code point to reach the code point for a different case for that character. They may be negative. If zero, it means the character is in the corresponding case. There is a special case representing sequences of alternating corresponding Upper and Lower pairs. It appears with a fixed Delta of\n\n\t{UpperLower, UpperLower, UpperLower}\n\nThe constant UpperLower has an otherwise impossible delta value.","SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.","","","","","If the Delta field of a \\[CaseRange] is UpperLower, it means this CaseRange represents a sequence of the form (say) \\[Upper] \\[Lower] \\[Upper] \\[Lower].","Is reports whether the rune is in the specified table of ranges.","IsUpper reports whether the rune is an upper case letter.","IsLower reports whether the rune is a lower case letter.","IsTitle reports whether the rune is a title case letter.","To maps the rune to the specified case: \\[UpperCase], \\[LowerCase], or \\[TitleCase].","ToUpper maps the rune to upper case.","ToLower maps the rune to lower case.","ToTitle maps the rune to title case.","SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune \u003e r if one exists, or else the smallest rune \u003e= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, K)\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2","Version is the Unicode edition from which the tables are derived.","Categories is the set of Unicode category tables.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Scripts is the set of Unicode script tables.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Properties is the set of Unicode property tables.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","CaseRanges is the table describing case mappings for all letters with non-self mappings.","FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points.","FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points.","Handle is a globally unique identity for some value of type T.\n\nTwo handles compare equal exactly if the two values used to create the handles would have also compared equal. The comparison of two handles is trivial and typically much more efficient than comparing the values used to create them.","Make returns a globally unique handle for a value of type T. Handles are equal if and only if the values used to produce them are equal.","ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression.","IntegerType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents any arbitrary integer type.","Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:\n\n  - A pointer value of any type can be converted to a Pointer.\n  - A Pointer can be converted to a pointer value of any type.\n  - A uintptr can be converted to a Pointer.\n  - A Pointer can be converted to a uintptr.\n\nPointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.\n\nThe following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.\n\nRunning \"go vet\" can help find uses of Pointer that do not conform to these patterns, but silence from \"go vet\" is not a guarantee that the code is valid.\n\n(1) Conversion of a \\*T1 to Pointer to \\*T2.\n\nProvided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:\n\n\tfunc Float64bits(f float64) uint64 {\n\t\treturn *(*uint64)(unsafe.Pointer(\u0026f))\n\t}\n\n(2) Conversion of a Pointer to a uintptr (but not back to Pointer).\n\nConverting a Pointer to a uintptr produces the memory address of the value pointed at, as an integer. The usual use for such a uintptr is to print it.\n\nConversion of a uintptr back to Pointer is not valid in general.\n\nA uintptr is an integer, not a reference. Converting a Pointer to a uintptr creates an integer value with no pointer semantics. Even if a uintptr holds the address of some object, the garbage collector will not update that uintptr's value if the object moves, nor will that uintptr keep the object from being reclaimed.\n\nThe remaining patterns enumerate the only valid conversions from uintptr to Pointer.\n\n(3) Conversion of a Pointer to a uintptr and back, with arithmetic.\n\nIf p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.\n\n\tp = unsafe.Pointer(uintptr(p) + offset)\n\nThe most common use of this pattern is to access fields in a struct or elements of an array:\n\n\t// equivalent to f := unsafe.Pointer(\u0026s.f)\n\tf := unsafe.Pointer(uintptr(unsafe.Pointer(\u0026s)) + unsafe.Offsetof(s.f))\n\n\t// equivalent to e := unsafe.Pointer(\u0026x[i])\n\te := unsafe.Pointer(uintptr(unsafe.Pointer(\u0026x[0])) + i*unsafe.Sizeof(x[0]))\n\nIt is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use \u0026^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.\n\nUnlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:\n\n\t// INVALID: end points outside allocated space.\n\tvar s thing\n\tend = unsafe.Pointer(uintptr(unsafe.Pointer(\u0026s)) + unsafe.Sizeof(s))\n\n\t// INVALID: end points outside allocated space.\n\tb := make([]byte, n)\n\tend = unsafe.Pointer(uintptr(unsafe.Pointer(\u0026b[0])) + uintptr(n))\n\nNote that both conversions must appear in the same expression, with only the intervening arithmetic between them:\n\n\t// INVALID: uintptr cannot be stored in variable\n\t// before conversion back to Pointer.\n\tu := uintptr(p)\n\tp = unsafe.Pointer(u + offset)\n\nNote that the pointer must point into an allocated object, so it may not be nil.\n\n\t// INVALID: conversion of nil pointer\n\tu := unsafe.Pointer(nil)\n\tp := unsafe.Pointer(uintptr(u) + offset)\n\n(4) Conversion of a Pointer to a uintptr when calling functions like [syscall.Syscall](https://pkg.go.dev/syscall/#Syscall).\n\nThe Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer.\n\nIf a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:\n\n\tsyscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))\n\nThe compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.\n\nFor the compiler to recognize this pattern, the conversion must appear in the argument list:\n\n\t// INVALID: uintptr cannot be stored in variable\n\t// before implicit conversion back to Pointer during system call.\n\tu := uintptr(unsafe.Pointer(p))\n\tsyscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))\n\n(5) Conversion of the result of [reflect.Value.Pointer](https://pkg.go.dev/reflect/#Value.Pointer) or [reflect.Value.UnsafeAddr](https://pkg.go.dev/reflect/#Value.UnsafeAddr) from uintptr to Pointer.\n\nPackage reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing \"unsafe\". However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression:\n\n\tp := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))\n\nAs in the cases above, it is invalid to store the result before the conversion:\n\n\t// INVALID: uintptr cannot be stored in variable\n\t// before conversion back to Pointer.\n\tu := reflect.ValueOf(new(int)).Pointer()\n\tp := (*int)(unsafe.Pointer(u))\n\n(6) Conversion of a [reflect.SliceHeader](https://pkg.go.dev/reflect/#SliceHeader) or [reflect.StringHeader](https://pkg.go.dev/reflect/#StringHeader) Data field to or from Pointer.\n\nAs in the previous case, the reflect data structures SliceHeader and StringHeader declare the field Data as a uintptr to keep callers from changing the result to an arbitrary type without first importing \"unsafe\". However, this means that SliceHeader and StringHeader are only valid when interpreting the content of an actual slice or string value.\n\n\tvar s string\n\thdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) // case 1\n\thdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)\n\thdr.Len = n\n\nIn this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.\n\nIn general, [reflect.SliceHeader](https://pkg.go.dev/reflect/#SliceHeader) and [reflect.StringHeader](https://pkg.go.dev/reflect/#StringHeader) should be used only as \\*reflect.SliceHeader and \\*reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.\n\n\t// INVALID: a directly-declared header will not hold Data as a reference.\n\tvar hdr reflect.StringHeader\n\thdr.Data = uintptr(unsafe.Pointer(p))\n\thdr.Len = n\n\ts := *(*string)(unsafe.Pointer(\u0026hdr)) // p possibly already lost","Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice; if x is an interface, Sizeof returns the size of the interface value itself, not the size of the value stored in the interface. For a struct, the size includes any padding introduced by field alignment. The return value of Sizeof is a Go constant if the type of the argument x does not have variable size. (A type has variable size if it is a type parameter or if it is an array or struct type with elements of variable size).","Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. The return value of Offsetof is a Go constant if the type of the argument x does not have variable size. (See the description of \\[Sizeof] for a definition of variable sized types.)","Alignof takes an expression x of any type and returns the required alignment of a hypothetical variable v as if v was declared via var v = x. It is the largest value m such that the address of v is always zero mod m. It is the same as the value returned by [reflect.TypeOf](https://pkg.go.dev/reflect/#TypeOf)(x).Align(). As a special case, if a variable s is of struct type and f is a field within that struct, then Alignof(s.f) will return the required alignment of a field of that type within a struct. This case is the same as the value returned by [reflect.TypeOf](https://pkg.go.dev/reflect/#TypeOf)(s.f).FieldAlign(). The return value of Alignof is a Go constant if the type of the argument does not have variable size. (See the description of \\[Sizeof] for a definition of variable sized types.)","The function Add adds len to ptr and returns the updated pointer \\[Pointer](uintptr(ptr) + uintptr(len)). The len argument must be of integer type or an untyped constant. A constant len argument must be representable by a value of type int; if it is an untyped constant it is given type int. The rules for valid uses of Pointer still apply.","The function Slice returns a slice whose underlying array starts at ptr and whose length and capacity are len. Slice(ptr, len) is equivalent to\n\n\t(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\n\nexcept that, as a special case, if ptr is nil and len is zero, Slice returns nil.\n\nThe len argument must be of integer type or an untyped constant. A constant len argument must be non-negative and representable by a value of type int; if it is an untyped constant it is given type int. At run time, if len is negative, or if ptr is nil and len is not zero, a run-time panic occurs.","SliceData returns a pointer to the underlying array of the argument slice.\n\n  - If cap(slice) \u003e 0, SliceData returns \u0026slice\\[:1]\\[0].\n  - If slice == nil, SliceData returns nil.\n  - Otherwise, SliceData returns a non-nil pointer to an unspecified memory address.","String returns a string value whose underlying bytes start at ptr and whose length is len.\n\nThe len argument must be of integer type or an untyped constant. A constant len argument must be non-negative and representable by a value of type int; if it is an untyped constant it is given type int. At run time, if len is negative, or if ptr is nil and len is not zero, a run-time panic occurs.\n\nSince Go strings are immutable, the bytes passed to String must not be modified as long as the returned string value exists.","StringData returns a pointer to the underlying bytes of str. For an empty string the return value is unspecified, and may be nil.\n\nSince Go strings are immutable, the bytes returned by StringData must not be modified.","","","","","","Type '0' indicates a regular file.","Deprecated: Use TypeReg instead.","Type '1' to '6' are header-only flags and may not have a data body.","","","","","","Type '7' is reserved.","Type 'x' is used by the PAX format to store key-value records that are only relevant to the next file. This package transparently handles these types.","Type 'g' is used by the PAX format to store key-value records that are relevant to all subsequent files. This package only supports parsing and composing such headers, but does not currently support persisting the global state across files.","Type 'S' indicates a sparse file in the GNU format.","Types 'L' and 'K' are used by the GNU format for a meta file used to store the path or link name for the next file. This package transparently handles these types.","","A Header represents a single header in a tar archive. Some fields may not be populated.\n\nFor forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving.","FileInfoHeader creates a partially-populated \\[Header] from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name.\n\nSince fs.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.\n\nIf fi implements \\[FileInfoNames] Header.Gname and Header.Uname are provided by the methods of the interface.","FileInfoNames extends \\[fs.FileInfo]. Passing an instance of this to \\[FileInfoHeader] permits the caller to avoid a system-dependent name lookup by specifying the Uname and Gname directly.","Format represents the tar archive format.\n\nThe original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.\n\nThe following table captures the capabilities of each format:\n\n\t                  |  USTAR |       PAX |       GNU\n\t------------------+--------+-----------+----------\n\tName              |   256B | unlimited | unlimited\n\tLinkname          |   100B | unlimited | unlimited\n\tSize              | uint33 | unlimited |    uint89\n\tMode              | uint21 |    uint21 |    uint57\n\tUid/Gid           | uint21 | unlimited |    uint57\n\tUname/Gname       |    32B | unlimited |       32B\n\tModTime           | uint33 | unlimited |     int89\n\tAccessTime        |    n/a | unlimited |     int89\n\tChangeTime        |    n/a | unlimited |     int89\n\tDevmajor/Devminor | uint21 |    uint21 |    uint57\n\t------------------+--------+-----------+----------\n\tstring encoding   |  ASCII |     UTF-8 |    binary\n\tsub-second times  |     no |       yes |        no\n\tsparse files      |     no |       yes |       yes\n\nThe table's upper portion shows the \\[Header] fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).\n\nThe table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.\n\nThe Writer currently provides no support for sparse files.","FormatUnknown indicates that the format is unknown.","FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.\n\nWhile this format is compatible with most tar readers, the format has several limitations making it unsuitable for some usages. Most notably, it cannot support sparse files, files larger than 8GiB, filenames larger than 256 characters, and non-ASCII filenames.\n\nReference:\n\n\thttp://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06","FormatPAX represents the PAX header format defined in POSIX.1-2001.\n\nPAX extends USTAR by writing a special file with Typeflag TypeXHeader preceding the original header. This file contains a set of key-value records, which are used to overcome USTAR's shortcomings, in addition to providing the ability to have sub-second resolution for timestamps.\n\nSome newer formats add their own extensions to PAX by defining their own keys and assigning certain semantic meaning to the associated values. For example, sparse file support in PAX is implemented using keys defined by the GNU manual (e.g., \"GNU.sparse.map\").\n\nReference:\n\n\thttp://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html","FormatGNU represents the GNU header format.\n\nThe GNU header format is older than the USTAR and PAX standards and is not compatible with them. The GNU format supports arbitrary file sizes, filenames of arbitrary encoding and length, sparse files, and other features.\n\nIt is recommended that PAX be chosen over GNU unless the target application can only parse GNU formatted archives.\n\nReference:\n\n\thttps://www.gnu.org/software/tar/manual/html_node/Standard.html","Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.","NewReader creates a new \\[Reader] reading from r.","Writer provides sequential writing of a tar archive. \\[Writer.WriteHeader] begins a new file with the provided \\[Header], and then Writer can be treated as an io.Writer to supply that file's data.","NewWriter creates a new Writer writing to w.","","","","","A Reader serves content from a ZIP archive.","A ReadCloser is a \\[Reader] that must be closed when no longer needed.","A File is a single file in a ZIP archive. The file information is in the embedded \\[FileHeader]. The file content can be accessed by calling \\[File.Open].","OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nIf any file inside the archive uses a non-local name (as defined by \\[filepath.IsLocal]) or a name containing backslashes and the GODEBUG environment variable contains \\`zipinsecurepath=0\\`, OpenReader returns the reader with an ErrInsecurePath error. A future version of Go may introduce this behavior by default. Programs that want to accept non-local names can ignore the ErrInsecurePath error and use the returned reader.","NewReader returns a new \\[Reader] reading from r, which is assumed to have the given size in bytes.\n\nIf any file inside the archive uses a non-local name (as defined by \\[filepath.IsLocal]) or a name containing backslashes and the GODEBUG environment variable contains \\`zipinsecurepath=0\\`, NewReader returns the reader with an \\[ErrInsecurePath] error. A future version of Go may introduce this behavior by default. Programs that want to accept non-local names can ignore the \\[ErrInsecurePath] error and use the returned reader.","A Compressor returns a new compressing writer, writing to w. The WriteCloser's Close method must be used to flush pending data to w. The Compressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned writer will be used only by one goroutine at a time.","A Decompressor returns a new decompressing reader, reading from r. The [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser)'s Close method must be used to release associated resources. The Decompressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned reader will be used only by one goroutine at a time.","RegisterDecompressor allows custom decompressors for a specified method ID. The common methods \\[Store] and \\[Deflate] are built in.","RegisterCompressor registers custom compressors for a specified method ID. The common methods \\[Store] and \\[Deflate] are built in.","","","FileHeader describes a file within a ZIP file. See the [ZIP specification](https://support.pkware.com/pkzip/appnote) for details.","FileInfoHeader creates a partially-populated \\[FileHeader] from an fs.FileInfo. Because fs.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. If compression is desired, callers should set the FileHeader.Method field; it is unset by default.","Writer implements a zip file writer.","NewWriter returns a new \\[Writer] writing a zip file to w.","A StructuralError is returned when the bzip2 data is found to be syntactically invalid.","NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), the decompressor may read more data than necessary from r.","","","","","HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman entropy encoding. This mode is useful in compressing data that has already been compressed with an LZ style algorithm (e.g. Snappy or LZ4) that lacks an entropy encoder. Compression gains are achieved when certain bytes in the input stream occur more frequently than others.\n\nNote that HuffmanOnly produces a compressed output that is RFC 1951 compliant. That is, any valid DEFLATE decompressor will continue to be able to decompress this output.","NewWriter returns a new \\[Writer] compressing data at the given level. Following zlib, levels range from 1 (\\[BestSpeed]) to 9 (\\[BestCompression]); higher levels typically run slower but compress more. Level 0 (\\[NoCompression]) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (\\[DefaultCompression]) uses the default compression level. Level -2 (\\[HuffmanOnly]) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency.\n\nIf level is in the range \\[-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil.","NewWriterDict is like \\[NewWriter] but initializes the new \\[Writer] with a preset dictionary. The returned \\[Writer] behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a \\[Reader] initialized with the same dictionary.","A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see \\[NewWriter]).","A CorruptInputError reports the presence of corrupt input at a given offset.","An InternalError reports an error in the flate code itself.","A ReadError reports an error encountered while reading input.\n\nDeprecated: No longer returned.","A WriteError reports an error encountered while writing output.\n\nDeprecated: No longer returned.","Resetter resets a ReadCloser returned by \\[NewReader] or \\[NewReaderDict] to switch to a new underlying \\[Reader]. This permits reusing a ReadCloser instead of allocating a new one.","The actual read interface needed by \\[NewReader]. If the passed in io.Reader does not also have ReadByte, the \\[NewReader] will introduce its own buffering.","NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), the decompressor may read more data than necessary from r. The reader returns [io.EOF](https://pkg.go.dev/io/#EOF) after the final block in the DEFLATE stream has been encountered. Any trailing data after the final block is ignored.\n\nThe [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser) returned by NewReader also implements \\[Resetter].","NewReaderDict is like \\[NewReader] but initializes the reader with a preset dictionary. The returned \\[Reader] behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReaderDict also implements \\[Resetter].","ErrChecksum is returned when reading GZIP data that has an invalid checksum.","ErrHeader is returned when reading GZIP data that has an invalid header.","The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the \\[Writer] and \\[Reader] structs.\n\nStrings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format.","A Reader is an [io.Reader](https://pkg.go.dev/io/#Reader) that can be read to retrieve uncompressed data from a gzip-format compressed file.\n\nIn general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields.\n\nGzip files store a length and checksum of the uncompressed data. The Reader will return an \\[ErrChecksum] when \\[Reader.Read] reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by \\[Reader.Read] as tentative until they receive the [io.EOF](https://pkg.go.dev/io/#EOF) marking the end of the data.","NewReader creates a new \\[Reader] reading the given reader. If r does not also implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), the decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the \\[Reader] when done.\n\nThe \\[Reader.Header] fields will be valid in the \\[Reader] returned.","","","","","","A Writer is an io.WriteCloser. Writes to a Writer are compressed and written to w.","NewWriter returns a new \\[Writer]. Writes to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the \\[Writer] when done. Writes may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before the first call to Write, Flush, or Close.","NewWriterLevel is like \\[NewWriter] but specifies the compression level instead of assuming \\[DefaultCompression].\n\nThe compression level can be \\[DefaultCompression], \\[NoCompression], \\[HuffmanOnly] or any integer value between \\[BestSpeed] and \\[BestCompression] inclusive. The error returned will be nil if the level is valid.","Order specifies the bit ordering in an LZW data stream.","LSB means Least Significant Bits first, as used in the GIF file format.","MSB means Most Significant Bits first, as used in the TIFF and PDF file formats.","Reader is an io.Reader which can be used to read compressed data in the LZW format.","NewReader creates a new [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser). Reads from the returned [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser) read and decompress data from r. If r does not also implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range \\[2,8] and is typically 8. It must equal the litWidth used during compression.\n\nIt is guaranteed that the underlying type of the returned [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser) is a \\*\\[Reader].","Writer is an LZW compressor. It writes the compressed form of the data to an underlying writer (see \\[NewWriter]).","NewWriter creates a new [io.WriteCloser](https://pkg.go.dev/io/#WriteCloser). Writes to the returned [io.WriteCloser](https://pkg.go.dev/io/#WriteCloser) are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range \\[2,8] and is typically 8. Input bytes must be less than 1\\\u003c\\\u003clitWidth.\n\nIt is guaranteed that the underlying type of the returned [io.WriteCloser](https://pkg.go.dev/io/#WriteCloser) is a \\*\\[Writer].","ErrChecksum is returned when reading ZLIB data that has an invalid checksum.","ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.","ErrHeader is returned when reading ZLIB data that has an invalid header.","Resetter resets a ReadCloser returned by \\[NewReader] or \\[NewReaderDict] to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.","NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser) returned by NewReader also implements \\[Resetter].","NewReaderDict is like \\[NewReader] but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns \\[ErrDictionary].\n\nThe ReadCloser returned by NewReaderDict also implements \\[Resetter].","","","","","","A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter).","NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close.","NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.","NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until the Writer is closed.","The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after \\[Init] has been called or if the data is empty or sorted):\n\n\t!h.Less(j, i) for 0 \u003c= i \u003c h.Len() and 2*i+1 \u003c= j \u003c= 2*i+2 and j \u003c h.Len()\n\nNote that \\[Push] and \\[Pop] in this interface are for package heap's implementation to call. To add and remove things from the heap, use \\[heap.Push] and \\[heap.Pop].","Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().","Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().","Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to \\[Remove](h, 0).","Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len().","Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling \\[Remove](h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len().","Element is an element of a linked list.","List represents a doubly linked list. The zero value for List is an empty list ready to use.","New returns an initialized list.","A Ring is an element of a circular list, or ring. Rings do not have a beginning or end; a pointer to any ring element serves as reference to the entire ring. Empty rings are represented as nil Ring pointers. The zero value for a Ring is a one-element ring with a nil Value.","New creates a ring of n elements.","The AES block size in bytes.","","NewCipher creates and returns a new \\[cipher.Block]. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.","NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size.","NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data.","NewCFBEncrypter returns a \\[Stream] which encrypts with cipher feedback mode, using the given \\[Block]. The iv must be the same length as the \\[Block]'s block size.","NewCFBDecrypter returns a \\[Stream] which decrypts with cipher feedback mode, using the given \\[Block]. The iv must be the same length as the \\[Block]'s block size.","A Block represents an implementation of block cipher using a given key. It provides the capability to encrypt or decrypt individual blocks. The mode implementations extend that capability to streams of blocks.","A Stream represents a stream cipher.","A BlockMode represents a block cipher running in a block-based mode (CBC, ECB etc).","NewCTR returns a \\[Stream] which encrypts/decrypts using the given \\[Block] in counter mode. The length of iv must be the same as the \\[Block]'s block size.","AEAD is a cipher mode providing authenticated encryption with associated data. For a description of the methodology, see [https://en.wikipedia.org/wiki/Authenticated\\_encryption](https://en.wikipedia.org/wiki/Authenticated_encryption).","NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying \\[Block] was created by aes.NewCipher on systems with hardware support for AES. See the [crypto/aes](https://pkg.go.dev/crypto/aes/) package documentation for details.","NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length. The length must not be zero.\n\nOnly use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use \\[NewGCM], which is faster and more resistant to misuse.","NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing cryptosystem that uses non-standard tag lengths. All other users should use \\[NewGCM], which is more resistant to misuse.","StreamReader wraps a \\[Stream] into an [io.Reader](https://pkg.go.dev/io/#Reader). It calls XORKeyStream to process each slice of data which passes through.","StreamWriter wraps a \\[Stream] into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any \\[StreamWriter.Write] call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; \\[StreamWriter.Close] does not need to be called to flush write data.","NewOFB returns a \\[Stream] that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size.","The DES block size in bytes.","","NewCipher creates and returns a new \\[cipher.Block].","NewTripleDESCipher creates and returns a new \\[cipher.Block].","Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8.","PublicKey represents a DSA public key.","PrivateKey represents a DSA private key.","ErrInvalidPublicKey results when a public key is not usable by this code. FIPS is quite strict about the format of DSA keys, but other code may be less so. Thus, when using keys which may have been generated by other code, this error must be handled.","ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2.","","","","","GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.","GenerateKey generates a public\u0026private key pair. The Parameters of the \\[PrivateKey] must already be valid (see \\[GenerateParameters]).","Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.\n\nBe aware that calling Sign with an attacker-controlled \\[PrivateKey] may require an arbitrary amount of CPU.","Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.","","PublicKey is an ECDH public key, usually a peer's ECDH share sent over the wire.\n\nThese keys can be parsed with [crypto/x509.ParsePKIXPublicKey](https://pkg.go.dev/crypto/x509/#ParsePKIXPublicKey) and encoded with [crypto/x509.MarshalPKIXPublicKey](https://pkg.go.dev/crypto/x509/#MarshalPKIXPublicKey). For NIST curves, they then need to be converted with [crypto/ecdsa.PublicKey.ECDH](https://pkg.go.dev/crypto/ecdsa/#PublicKey.ECDH) after parsing.","PrivateKey is an ECDH private key, usually kept secret.\n\nThese keys can be parsed with [crypto/x509.ParsePKCS8PrivateKey](https://pkg.go.dev/crypto/x509/#ParsePKCS8PrivateKey) and encoded with [crypto/x509.MarshalPKCS8PrivateKey](https://pkg.go.dev/crypto/x509/#MarshalPKCS8PrivateKey). For NIST curves, they then need to be converted with [crypto/ecdsa.PrivateKey.ECDH](https://pkg.go.dev/crypto/ecdsa/#PrivateKey.ECDH) after parsing.","P256 returns a \\[Curve] which implements NIST P-256 (FIPS 186-3, section D.2.3), also known as secp256r1 or prime256v1.\n\nMultiple invocations of this function will return the same value, which can be used for equality checks and switch statements.","P384 returns a \\[Curve] which implements NIST P-384 (FIPS 186-3, section D.2.4), also known as secp384r1.\n\nMultiple invocations of this function will return the same value, which can be used for equality checks and switch statements.","P521 returns a \\[Curve] which implements NIST P-521 (FIPS 186-3, section D.2.5), also known as secp521r1.\n\nMultiple invocations of this function will return the same value, which can be used for equality checks and switch statements.","X25519 returns a \\[Curve] which implements the X25519 function over Curve25519 (RFC 7748, Section 5).\n\nMultiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.","PublicKey represents an ECDSA public key.","PrivateKey represents an ECDSA private key.","GenerateKey generates a new ECDSA private key for the specified curve.\n\nMost applications should use [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) as rand. Note that the returned key does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions.","SignASN1 signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature.\n\nThe signature is randomized. Most applications should use [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) as rand. Note that the returned signature does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions.","VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.\n\nThe inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs.","Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. Most applications should use \\[SignASN1] instead of dealing directly with r, s.","Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid. Most applications should use VerifyASN1 instead of dealing directly with r, s.\n\nThe inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs.","PublicKeySize is the size, in bytes, of public keys as used in this package.","PrivateKeySize is the size, in bytes, of private keys as used in this package.","SignatureSize is the size, in bytes, of signatures generated and verified by this package.","SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.","PublicKey is the type of Ed25519 public keys.","PrivateKey is the type of Ed25519 private keys. It implements [crypto.Signer](https://pkg.go.dev/crypto/#Signer).","Options can be used with \\[PrivateKey.Sign] or \\[VerifyWithOptions] to select Ed25519 variants.","GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) will be used.\n\nThe output of this function is deterministic, and equivalent to reading \\[SeedSize] bytes from rand, and passing them to \\[NewKeyFromSeed].","NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not \\[SeedSize]. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.","Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not \\[PrivateKeySize].","Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not \\[PublicKeySize].\n\nThe inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs.","VerifyWithOptions reports whether sig is a valid signature of message by publicKey. A valid signature is indicated by returning a nil error. It will panic if len(publicKey) is not \\[PublicKeySize].\n\nIf opts.Hash is [crypto.SHA512](https://pkg.go.dev/crypto/#SHA512), the pre-hashed variant Ed25519ph is used and message is expected to be a SHA-512 hash, otherwise opts.Hash must be [crypto.Hash](https://pkg.go.dev/crypto/#Hash)(0) and the message must not be hashed, as Ed25519 performs two passes over messages to be signed.\n\nThe inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs.","A Curve represents a short-form Weierstrass curve with a=-3.\n\nThe behavior of Add, Double, and ScalarMult when the input is not a point on the curve is undefined.\n\nNote that the conventional point at infinity (0, 0) is not considered on the curve, although it can be returned by Add, Double, ScalarMult, or ScalarBaseMult (but not the \\[Unmarshal] or \\[UnmarshalCompressed] functions).\n\nUsing Curve implementations besides those returned by \\[P224], \\[P256], \\[P384], and \\[P521] is deprecated.","GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.\n\nDeprecated: for ECDH, use the GenerateKey methods of the [crypto/ecdh](https://pkg.go.dev/crypto/ecdh/) package; for ECDSA, use the GenerateKey function of the crypto/ecdsa package.","Marshal converts a point on the curve into the uncompressed form specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is the conventional point at infinity), the behavior is undefined.\n\nDeprecated: for ECDH, use the crypto/ecdh package. This function returns an encoding equivalent to that of PublicKey.Bytes in crypto/ecdh.","MarshalCompressed converts a point on the curve into the compressed form specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is the conventional point at infinity), the behavior is undefined.","Unmarshal converts a point, serialized by \\[Marshal], into an x, y pair. It is an error if the point is not in uncompressed form, is not on the curve, or is the point at infinity. On error, x = nil.\n\nDeprecated: for ECDH, use the crypto/ecdh package. This function accepts an encoding equivalent to that of the NewPublicKey methods in crypto/ecdh.","UnmarshalCompressed converts a point, serialized by \\[MarshalCompressed], into an x, y pair. It is an error if the point is not in compressed form, is not on the curve, or is the point at infinity. On error, x = nil.","P224 returns a \\[Curve] which implements NIST P-224 (FIPS 186-3, section D.2.2), also known as secp224r1. The CurveParams.Name of this \\[Curve] is \"P-224\".\n\nMultiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.\n\nThe cryptographic operations are implemented using constant-time algorithms.","P256 returns a \\[Curve] which implements NIST P-256 (FIPS 186-3, section D.2.3), also known as secp256r1 or prime256v1. The CurveParams.Name of this \\[Curve] is \"P-256\".\n\nMultiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.\n\nThe cryptographic operations are implemented using constant-time algorithms.","P384 returns a \\[Curve] which implements NIST P-384 (FIPS 186-3, section D.2.4), also known as secp384r1. The CurveParams.Name of this \\[Curve] is \"P-384\".\n\nMultiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.\n\nThe cryptographic operations are implemented using constant-time algorithms.","P521 returns a \\[Curve] which implements NIST P-521 (FIPS 186-3, section D.2.5), also known as secp521r1. The CurveParams.Name of this \\[Curve] is \"P-521\".\n\nMultiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.\n\nThe cryptographic operations are implemented using constant-time algorithms.","CurveParams contains the parameters of an elliptic curve and also provides a generic, non-constant time implementation of \\[Curve].\n\nThe generic Curve implementation is deprecated, and using custom curves (those not returned by \\[P224], \\[P256], \\[P384], and \\[P521]) is not guaranteed to provide any security property.","New returns a new HMAC hash using the given [hash.Hash](https://pkg.go.dev/hash/#Hash) type and key. New functions like sha256.New from [crypto/sha256](https://pkg.go.dev/crypto/sha256/) can be used as h. h must return a new Hash every time it is called. Note that unlike other hash implementations in the standard library, the returned Hash does not implement [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) or [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler).","Equal compares two MACs for equality without leaking timing information.","The size of an MD5 checksum in bytes.","The blocksize of MD5 in bytes.","New returns a new hash.Hash computing the MD5 checksum. The Hash also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","Sum returns the MD5 checksum of the data.","Reader is a global, shared instance of a cryptographically secure random number generator.\n\n  - On Linux, FreeBSD, Dragonfly, and Solaris, Reader uses getrandom(2) if available, and /dev/urandom otherwise.\n  - On macOS and iOS, Reader uses arc4random\\_buf(3).\n  - On OpenBSD and NetBSD, Reader uses getentropy(2).\n  - On other Unix-like systems, Reader reads from /dev/urandom.\n  - On Windows, Reader uses the ProcessPrng API.\n  - On js/wasm, Reader uses the Web Crypto API.\n  - On wasip1/wasm, Reader uses random\\_get from wasi\\_snapshot\\_preview1.","Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil.","Prime returns a number of the given bit length that is prime with high probability. Prime will return error for any error returned by \\[rand.Read] or if bits \\\u003c 2.","Int returns a uniform random value in \\[0, max). It panics if max \\\u003c= 0.","A Cipher is an instance of RC4 using a particular key.","","NewCipher creates and returns a new \\[Cipher]. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.","PKCS1v15DecryptOptions is for passing options to PKCS #1 v1.5 decryption using the [crypto.Decrypter](https://pkg.go.dev/crypto/#Decrypter) interface.","EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS #1 v1.5.  The message must be no longer than the length of the public modulus minus 11 bytes.\n\nThe random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. Most applications should use [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) as random. Note that the returned ciphertext does not depend deterministically on the bytes read from random, and may change between calls and/or between versions.\n\nWARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.","DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil.\n\nNote that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem.","DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil.\n\nDecryptPKCS1v15SessionKey returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value.\n\nNote that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This also defeats the point of this function. Using at least a 16-byte key will protect against this attack.\n\nThis method implements protections against Bleichenbacher chosen ciphertext attacks \\[0] described in RFC 3218 Section 2.3.2 \\[1]. While these protections make a Bleichenbacher attack significantly more difficult, the protections are only effective if the rest of the protocol which uses DecryptPKCS1v15SessionKey is designed with these considerations in mind. In particular, if any subsequent operations which use the decrypted session key leak any information about the key (e.g. whether it is a static or random key) then the mitigations are defeated. This method must be used extremely carefully, and typically should only be used when absolutely necessary for compatibility with an existing protocol (such as TLS) that is designed with these properties in mind.\n\n  - \\[0] “Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1”, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98)\n  - \\[1] RFC 3218, Preventing the Million Message Attack on CMS, [https://www.rfc-editor.org/rfc/rfc3218.html](https://www.rfc-editor.org/rfc/rfc3218.html)","SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1\\_5-SIGN from RSA PKCS #1 v1.5.  Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.\n\nThe random parameter is legacy and ignored, and it can be nil.\n\nThis function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.","VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.\n\nThe inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs.","PSSSaltLengthAuto causes the salt in a PSS signature to be as large as possible when signing, and to be auto-detected when verifying.","PSSSaltLengthEqualsHash causes the salt length to equal the length of the hash used in the signature.","PSSOptions contains options for creating and verifying PSS signatures.","SignPSS calculates the signature of digest using PSS.\n\ndigest must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. If opts.Hash is set, it overrides hash.\n\nThe signature is randomized depending on the message, key, and salt size, using bytes from rand. Most applications should use [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) as rand.","VerifyPSS verifies a PSS signature.\n\nA valid signature is indicated by returning a nil error. digest must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. opts.Hash is ignored.\n\nThe inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs.","A PublicKey represents the public part of an RSA key.\n\nThe value of the modulus N is considered secret by this library and protected from leaking through timing side-channels. However, neither the value of the exponent E nor the precise bit size of N are similarly protected.","OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface.","A PrivateKey represents an RSA key","","CRTValue contains the precomputed Chinese remainder theorem values.","GenerateKey generates a random RSA private key of the given bit size.\n\nMost applications should use [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) as rand. Note that the returned key does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions.","GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source.\n\nTable 1 in \"[On the Security of Multi-prime RSA](http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)\" suggests maximum numbers of primes for a given bit size.\n\nAlthough the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.\n\nThis package does not implement CRT optimizations for multi-prime RSA, so the keys with more than two primes will have worse performance.\n\nDeprecated: The use of this function with a number of primes different from two is not recommended for the above security, compatibility, and performance reasons. Use \\[GenerateKey] instead.","ErrMessageTooLong is returned when attempting to encrypt or sign a message which is too large for the size of the key. When using \\[SignPSS], this can also be returned if the size of the salt is too large.","EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. Most applications should use [crypto/rand.Reader](https://pkg.go.dev/crypto/rand/#Reader) as random.\n\nThe label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to encrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.","ErrDecryption represents a failure to decrypt a message. It is deliberately vague to avoid adaptive attacks.","ErrVerification represents a failure to verify a signature. It is deliberately vague to avoid adaptive attacks.","DecryptOAEP decrypts ciphertext using RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.\n\nThe random parameter is legacy and ignored, and it can be nil.\n\nThe label parameter must match the value given when encrypting. See \\[EncryptOAEP] for details.","The size of a SHA-1 checksum in bytes.","The blocksize of SHA-1 in bytes.","New returns a new hash.Hash computing the SHA1 checksum. The Hash also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","Sum returns the SHA-1 checksum of the data.","The size of a SHA256 checksum in bytes.","The size of a SHA224 checksum in bytes.","The blocksize of SHA256 and SHA224 in bytes.","New returns a new hash.Hash computing the SHA256 checksum. The Hash also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","New224 returns a new hash.Hash computing the SHA224 checksum.","Sum256 returns the SHA256 checksum of the data.","Sum224 returns the SHA224 checksum of the data.","Size is the size, in bytes, of a SHA-512 checksum.","Size224 is the size, in bytes, of a SHA-512/224 checksum.","Size256 is the size, in bytes, of a SHA-512/256 checksum.","Size384 is the size, in bytes, of a SHA-384 checksum.","BlockSize is the block size, in bytes, of the SHA-512/224, SHA-512/256, SHA-384 and SHA-512 hash functions.","New returns a new hash.Hash computing the SHA-512 checksum.","New512\\_224 returns a new hash.Hash computing the SHA-512/224 checksum.","New512\\_256 returns a new hash.Hash computing the SHA-512/256 checksum.","New384 returns a new hash.Hash computing the SHA-384 checksum.","Sum512 returns the SHA512 checksum of the data.","Sum384 returns the SHA384 checksum of the data.","Sum512\\_224 returns the Sum512/224 checksum of the data.","Sum512\\_256 returns the Sum512/256 checksum of the data.","ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents. If the lengths of x and y do not match it returns 0 immediately.","ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value.","ConstantTimeByteEq returns 1 if x == y and 0 otherwise.","ConstantTimeEq returns 1 if x == y and 0 otherwise.","ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value.","ConstantTimeLessOrEq returns 1 if x \\\u003c= y and 0 otherwise. Its behavior is undefined if x or y are negative or \u003e 2\\*\\*31 - 1.","XORBytes sets dst\\[i] = x\\[i] ^ y\\[i] for all i \\\u003c n = min(len(x), len(y)), returning n, the number of bytes written to dst. If dst does not have length at least n, XORBytes panics without writing anything to dst.","An AlertError is a TLS alert.\n\nWhen using a QUIC transport, QUICConn methods will return an error which wraps AlertError rather than sending a TLS alert.","CipherSuite is a TLS cipher suite. Note that most functions in this package accept and expose cipher suite IDs instead of this type.","CipherSuites returns a list of cipher suites currently implemented by this package, excluding those with security issues, which are returned by \\[InsecureCipherSuites].\n\nThe list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list, and might not match those returned by this function.","InsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues.\n\nMost applications should not use the cipher suites in this list, and should only use those returned by \\[CipherSuites].","CipherSuiteName returns the standard name for the passed cipher suite ID (e.g. \"TLS\\_ECDHE\\_ECDSA\\_WITH\\_AES\\_128\\_GCM\\_SHA256\"), or a fallback representation of the ID value if the cipher suite is not implemented by this package.","TLS 1.0 - 1.2 cipher suites.","","","","","","","","","","","","","","","","","","","","","","TLS 1.3 cipher suites.","","","TLS\\_FALLBACK\\_SCSV isn't a standard cipher suite but an indicator that the client is doing version fallback. See RFC 7507.","Legacy names for the corresponding cipher suites with the correct \\_SHA256 suffix, retained for backward compatibility.","","","","","","Deprecated: SSLv3 is cryptographically broken, and is no longer supported by this package. See golang.org/issue/32716.","VersionName returns the name for the provided TLS version number (e.g. \"TLS 1.3\"), or a fallback representation of the value if the version is not implemented by this package.","CurveID is the type of a TLS identifier for a key exchange mechanism. See [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8).\n\nIn TLS 1.2, this registry used to support only elliptic curves. In TLS 1.3, it was extended to other groups and renamed NamedGroup. See RFC 8446, Section 4.2.7. It was then also extended to other mechanisms, such as hybrid post-quantum KEMs.","","","","","ConnectionState records basic TLS details about the connection.","ClientAuthType declares the policy the server will follow for TLS Client Authentication.","NoClientCert indicates that no client certificate should be requested during the handshake, and if any certificates are sent they will not be verified.","RequestClientCert indicates that a client certificate should be requested during the handshake, but does not require that the client send any certificates.","RequireAnyClientCert indicates that a client certificate should be requested during the handshake, and that at least one certificate is required to be sent by the client, but that certificate is not required to be valid.","VerifyClientCertIfGiven indicates that a client certificate should be requested during the handshake, but does not require that the client sends a certificate. If the client does send a certificate it is required to be valid.","RequireAndVerifyClientCert indicates that a client certificate should be requested during the handshake, and that at least one valid certificate is required to be sent by the client.","ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which are supported via this interface.","SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3.","RSASSA-PKCS1-v1\\_5 algorithms.","","","RSASSA-PSS algorithms with public key OID rsaEncryption.","","","ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.","","","EdDSA algorithms.","Legacy signature and hash algorithms for TLS 1.2.","","ClientHelloInfo contains information from a ClientHello message in order to guide application logic in the GetCertificate and GetConfigForClient callbacks.","CertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client.","RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.\n\nEven when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS.\n\nRenegotiation is not defined in TLS 1.3.","RenegotiateNever disables renegotiation.","RenegotiateOnceAsClient allows a remote server to request renegotiation once per connection.","RenegotiateFreelyAsClient allows a remote server to repeatedly request renegotiation.","A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it.","A Certificate is a chain of one or more certificates, leaf first.","NewLRUClientSessionCache returns a \\[ClientSessionCache] with the given capacity that uses an LRU strategy. If capacity is \\\u003c 1, a default capacity is used instead.","CertificateVerificationError is returned when certificate verification fails during the handshake.","A Conn represents a secured connection. It implements the net.Conn interface.","RecordHeaderError is returned when a TLS record header is invalid.","ECHRejectionError is the error type returned when ECH is rejected by a remote server. If the server offered a ECHConfigList to use for retries, the RetryConfigList field will contain this list.\n\nThe client may treat an ECHRejectionError with an empty set of RetryConfigs as a secure signal from the server.","QUICEncryptionLevel represents a QUIC encryption level used to transmit handshake messages.","","","","","A QUICConn represents a connection which uses a QUIC implementation as the underlying transport as described in RFC 9001.\n\nMethods of QUICConn are not safe for concurrent use.","A QUICConfig configures a \\[QUICConn].","A QUICEventKind is a type of operation on a QUIC connection.","QUICNoEvent indicates that there are no events available.","QUICSetReadSecret and QUICSetWriteSecret provide the read and write secrets for a given encryption level. QUICEvent.Level, QUICEvent.Data, and QUICEvent.Suite are set.\n\nSecrets for the Initial encryption level are derived from the initial destination connection ID, and are not provided by the QUICConn.","","QUICWriteData provides data to send to the peer in CRYPTO frames. QUICEvent.Data is set.","QUICTransportParameters provides the peer's QUIC transport parameters. QUICEvent.Data is set.","QUICTransportParametersRequired indicates that the caller must provide QUIC transport parameters to send to the peer. The caller should set the transport parameters with QUICConn.SetTransportParameters and call QUICConn.NextEvent again.\n\nIf transport parameters are set before calling QUICConn.Start, the connection will never generate a QUICTransportParametersRequired event.","QUICRejectedEarlyData indicates that the server rejected 0-RTT data even if we offered it. It's returned before QUICEncryptionLevelApplication keys are returned. This event only occurs on client connections.","QUICHandshakeDone indicates that the TLS handshake has completed.","QUICResumeSession indicates that a client is attempting to resume a previous session. \\[QUICEvent.SessionState] is set.\n\nFor client connections, this event occurs when the session ticket is selected. For server connections, this event occurs when receiving the client's session ticket.\n\nThe application may set \\[QUICEvent.SessionState.EarlyData] to false before the next call to \\[QUICConn.NextEvent] to decline 0-RTT even if the session supports it.","QUICStoreSession indicates that the server has provided state permitting the client to resume the session. \\[QUICEvent.SessionState] is set. The application should use \\[QUICConn.StoreSession] session to store the \\[SessionState]. The application may modify the \\[SessionState] before storing it. This event only occurs on client connections.","A QUICEvent is an event occurring on a QUIC connection.\n\nThe type of event is specified by the Kind field. The contents of the other fields are kind-specific.","QUICClient returns a new TLS client side connection using QUICTransport as the underlying transport. The config cannot be nil.\n\nThe config's MinVersion must be at least TLS 1.3.","QUICServer returns a new TLS server side connection using QUICTransport as the underlying transport. The config cannot be nil.\n\nThe config's MinVersion must be at least TLS 1.3.","","A SessionState is a resumable session.","ParseSessionState parses a \\[SessionState] encoded by \\[SessionState.Bytes].","ClientSessionState contains the state needed by a client to resume a previous TLS session.","NewResumptionState returns a state value that can be returned by \\[ClientSessionCache.Get] to resume a previous session.\n\nstate needs to be returned by \\[ParseSessionState], and the ticket and session state must have been returned by \\[ClientSessionState.ResumptionState].","Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.","Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config.","NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with \\[Server]. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.","Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.","DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of \\[Config] for the defaults.\n\nDialWithDialer uses context.Background internally; to specify the context, use \\[Dialer.DialContext] with NetDialer set to the desired dialer.","Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.","Dialer dials TLS connections given a configuration and a Dialer for the underlying connection.","LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be populated.\n\nBefore Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\" in the GODEBUG environment variable.","X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be populated.\n\nBefore Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\" in the GODEBUG environment variable.","CertPool is a set of certificates.","NewCertPool returns a new, empty CertPool.","SystemCertPool returns a copy of the system cert pool.\n\nOn Unix systems other than macOS the environment variables SSL\\_CERT\\_FILE and SSL\\_CERT\\_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively. The latter can be a colon-separated list.\n\nAny mutations to the returned pool are not written to disk and do not affect any other pool returned by SystemCertPool.\n\nNew changes in the system cert pool might not be reflected in subsequent calls.","An OID represents an ASN.1 OBJECT IDENTIFIER.","ParseOID parses a Object Identifier string, represented by ASCII numbers separated by dots.","OIDFromInts creates a new OID using ints, each integer is a separate component.","ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nBefore Go 1.23, ParseCertificate accepted certificates with negative serial numbers. This behavior can be restored by including \"x509negativeserial=1\" in the GODEBUG environment variable.","ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.","ParseRevocationList parses a X509 v2 \\[Certificate] Revocation List from the given ASN.1 DER data.","","","","","","","IsEncryptedPEMBlock returns whether the PEM block is password encrypted according to RFC 1423.\n\nDeprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.","IncorrectPasswordError is returned when an incorrect password is detected.","DecryptPEMBlock takes a PEM block encrypted according to RFC 1423 and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an \\[IncorrectPasswordError] is returned. Because of deficiencies in the format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise.\n\nDeprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.","EncryptPEMBlock returns a PEM block of the specified type holding the given DER encoded data encrypted with the specified algorithm and password according to RFC 1423.\n\nDeprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.","ParsePKCS1PrivateKey parses an \\[RSA] private key in PKCS #1, ASN.1 DER form.\n\nThis kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE KEY\".","MarshalPKCS1PrivateKey converts an \\[RSA] private key to PKCS #1, ASN.1 DER form.\n\nThis kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE KEY\". For a more flexible key format which is not \\[RSA] specific, use \\[MarshalPKCS8PrivateKey].","ParsePKCS1PublicKey parses an \\[RSA] public key in PKCS #1, ASN.1 DER form.\n\nThis kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\".","MarshalPKCS1PublicKey converts an \\[RSA] public key to PKCS #1, ASN.1 DER form.\n\nThis kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\".","ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER form.\n\nIt returns a \\*\\[rsa.PrivateKey], an \\*\\[ecdsa.PrivateKey], an \\[ed25519.PrivateKey] (not a pointer), or an \\*\\[ecdh.PrivateKey] (for X25519). More types might be supported in the future.\n\nThis kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\".","MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form.\n\nThe following key types are currently supported: \\*\\[rsa.PrivateKey], \\*\\[ecdsa.PrivateKey], \\[ed25519.PrivateKey] (not a pointer), and \\*\\[ecdh.PrivateKey]. Unsupported key types result in an error.\n\nThis kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\".","SetFallbackRoots sets the roots to use during certificate verification, if no custom roots are specified and a platform verifier or a system certificate pool is not available (for instance in a container which does not have a root certificate bundle). SetFallbackRoots will panic if roots is nil.\n\nSetFallbackRoots may only be called once, if called multiple times it will panic.\n\nThe fallback behavior can be forced on all platforms, even when there is a system certificate pool, by setting GODEBUG=x509usefallbackroots=1 (note that on Windows and macOS this will disable usage of the platform verification APIs and cause the pure Go verifier to be used). Setting x509usefallbackroots=1 without calling SetFallbackRoots has no effect.","ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form.\n\nThis kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\".","MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.\n\nThis kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\". For a more flexible key format which is not EC specific, use \\[MarshalPKCS8PrivateKey].","","NotAuthorizedToSign results when a certificate is signed by another which isn't marked as a CA certificate.","Expired results when a certificate has expired, based on the time given in the VerifyOptions.","CANotAuthorizedForThisName results when an intermediate or root certificate has a name constraint which doesn't permit a DNS or other name (including IP address) in the leaf certificate.","TooManyIntermediates results when a path length constraint is violated.","IncompatibleUsage results when the certificate's key usage indicates that it may only be used for a different purpose.","NameMismatch results when the subject name of a parent certificate does not match the issuer name in the child.","NameConstraintsWithoutSANs is a legacy error and is no longer returned.","UnconstrainedName results when a CA certificate contains permitted name constraints, but leaf certificate contains a name of an unsupported or unconstrained type.","TooManyConstraints results when the number of comparison operations needed to check a certificate exceeds the limit set by VerifyOptions.MaxConstraintComparisions. This limit exists to prevent pathological certificates can consuming excessive amounts of CPU time to verify.","CANotAuthorizedForExtKeyUsage results when an intermediate or root certificate does not permit a requested extended key usage.","CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly.","HostnameError results when the set of authorized names doesn't match the requested name.","UnknownAuthorityError results when the certificate issuer is unknown","SystemRootsError results when we fail to load the system root certificates.","VerifyOptions contains parameters for Certificate.Verify.","ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).\n\nIt returns a \\*\\[rsa.PublicKey], \\*\\[dsa.PublicKey], \\*\\[ecdsa.PublicKey], \\[ed25519.PublicKey] (not a pointer), or \\*\\[ecdh.PublicKey] (for X25519). More types might be supported in the future.\n\nThis kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\".","MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).\n\nThe following key types are currently supported: \\*\\[rsa.PublicKey], \\*\\[ecdsa.PublicKey], \\[ed25519.PublicKey] (not a pointer), and \\*\\[ecdh.PublicKey]. Unsupported key types result in an error.\n\nThis kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\".","","","","","","","","","","","","","","","","","","","","","","","","","KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage\\* constants.","","","","","","","","","","ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage\\* constants define a unique action.","","","","","","","","","","","","","","","A Certificate represents an X.509 certificate.","ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented.","An InsecureAlgorithmError indicates that the \\[SignatureAlgorithm] used to generate the signature is not secure, and the signature has been rejected.\n\nTo temporarily restore support for SHA-1 signatures, include the value \"x509sha1=1\" in the GODEBUG environment variable. Note that this option will be removed in a future release.","ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key.","","CreateCertificate creates a new X.509 v3 certificate based on a template. The following members of template are currently used:\n\n  - AuthorityKeyId\n  - BasicConstraintsValid\n  - CRLDistributionPoints\n  - DNSNames\n  - EmailAddresses\n  - ExcludedDNSDomains\n  - ExcludedEmailAddresses\n  - ExcludedIPRanges\n  - ExcludedURIDomains\n  - ExtKeyUsage\n  - ExtraExtensions\n  - IPAddresses\n  - IsCA\n  - IssuingCertificateURL\n  - KeyUsage\n  - MaxPathLen\n  - MaxPathLenZero\n  - NotAfter\n  - NotBefore\n  - OCSPServer\n  - PermittedDNSDomains\n  - PermittedDNSDomainsCritical\n  - PermittedEmailAddresses\n  - PermittedIPRanges\n  - PermittedURIDomains\n  - PolicyIdentifiers (see note below)\n  - Policies (see note below)\n  - SerialNumber\n  - SignatureAlgorithm\n  - Subject\n  - SubjectKeyId\n  - URIs\n  - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the certificate to be generated and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nThe currently supported key types are \\*rsa.PublicKey, \\*ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.\n\nIf SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key.\n\nThe PolicyIdentifier and Policies fields are both used to marshal certificate policy OIDs. By default, only the PolicyIdentifier is marshaled, but if the GODEBUG setting \"x509usepolicies\" has the value \"1\", the Policies field will be marshaled instead of the PolicyIdentifier field. The Policies field can be used to marshal policy OIDs which have components that are larger than 31 bits.","ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.\n\nDeprecated: Use \\[ParseRevocationList] instead.","ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nDeprecated: Use \\[ParseRevocationList] instead.","CertificateRequest represents a PKCS #10, certificate signature request.","CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used:\n\n  - SignatureAlgorithm\n  - Subject\n  - DNSNames\n  - EmailAddresses\n  - IPAddresses\n  - URIs\n  - ExtraExtensions\n  - Attributes (deprecated)\n\npriv is the private key to sign the CSR with, and the corresponding public key will be included in the CSR. It must implement crypto.Signer and its Public() method must return a \\*rsa.PublicKey or a \\*ecdsa.PublicKey or a ed25519.PublicKey. (A \\*rsa.PrivateKey, \\*ecdsa.PrivateKey or ed25519.PrivateKey satisfies this.)\n\nThe returned slice is the certificate request in DER encoding.","ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.","RevocationListEntry represents an entry in the revokedCertificates sequence of a CRL.","RevocationList represents a \\[Certificate] Revocation List (CRL) as specified by RFC 5280.","CreateRevocationList creates a new X.509 v2 \\[Certificate] Revocation List, according to RFC 5280, based on template.\n\nThe CRL is signed by priv which should be the private key associated with the public key in the issuer certificate.\n\nThe issuer may not be nil, and the crlSign bit must be set in \\[KeyUsage] in order to use it as a CRL issuer.\n\nThe issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.","Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.","Drivers returns a sorted list of the names of the registered drivers.","A NamedArg is a named argument. NamedArg values may be used as arguments to \\[DB.Query] or \\[DB.Exec] and bind to the corresponding named parameter in the SQL statement.\n\nFor a more concise way to create NamedArg values, see the \\[Named] function.","Named provides a more concise way to create \\[NamedArg] values.\n\nExample usage:\n\n\tdb.ExecContext(ctx, `\n\t    delete from Invoice\n\t    where\n\t        TimeCreated \u003c @end\n\t        and TimeCreated \u003e= @start;`,\n\t    sql.Named(\"start\", startTime),\n\t    sql.Named(\"end\", endTime),\n\t)","IsolationLevel is the transaction isolation level used in \\[TxOptions].","","","","","","","","","TxOptions holds the transaction options to be used in \\[DB.BeginTx].","RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a \\[Rows.Scan] into a RawBytes, the slice is only valid until the next call to \\[Rows.Next], \\[Rows.Scan], or \\[Rows.Close].","NullString represents a string that may be null. NullString implements the \\[Scanner] interface so it can be used as a scan destination:\n\n\tvar s NullString\n\terr := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(\u0026s)\n\t...\n\tif s.Valid {\n\t   // use s.String\n\t} else {\n\t   // NULL value\n\t}","NullInt64 represents an int64 that may be null. NullInt64 implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","NullInt32 represents an int32 that may be null. NullInt32 implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","NullInt16 represents an int16 that may be null. NullInt16 implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","NullByte represents a byte that may be null. NullByte implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","NullFloat64 represents a float64 that may be null. NullFloat64 implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","NullBool represents a bool that may be null. NullBool implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","NullTime represents a [time.Time](https://pkg.go.dev/time/#Time) that may be null. NullTime implements the \\[Scanner] interface so it can be used as a scan destination, similar to \\[NullString].","Null represents a value that may be null. Null implements the \\[Scanner] interface so it can be used as a scan destination:\n\n\tvar s Null[string]\n\terr := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(\u0026s)\n\t...\n\tif s.Valid {\n\t   // use s.V\n\t} else {\n\t   // NULL value\n\t}","Scanner is an interface used by \\[Rows.Scan].","Out may be used to retrieve OUTPUT value parameters from stored procedures.\n\nNot all drivers and databases support OUTPUT value parameters.\n\nExample usage:\n\n\tvar outArg string\n\t_, err := db.ExecContext(ctx, \"ProcName\", sql.Named(\"Arg1\", sql.Out{Dest: \u0026outArg}))","ErrNoRows is returned by \\[Row.Scan] when \\[DB.QueryRow] doesn't return a row. In such a case, QueryRow returns a placeholder \\[\\*Row] value that defers this error until a Scan.","DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines.\n\nThe sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (\\[Tx]) or connection (\\[Conn]). Once \\[DB.Begin] is called, the returned \\[Tx] is bound to a single connection. Once \\[Tx.Commit] or \\[Tx.Rollback] is called on the transaction, that transaction's connection is returned to \\[DB]'s idle connection pool. The pool size can be controlled with \\[DB.SetMaxIdleConns].","OpenDB opens a database using a \\[driver.Connector], allowing drivers to bypass a string based data source name.\n\nMost users will open a database via a driver-specific connection helper function that returns a \\[\\*DB]. No database drivers are included in the Go standard library. See [https://golang.org/s/sqldrivers](https://golang.org/s/sqldrivers) for a list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call \\[DB.Ping].\n\nThe returned \\[DB] is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a \\[DB].","Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information.\n\nMost users will open a database via a driver-specific connection helper function that returns a \\[\\*DB]. No database drivers are included in the Go standard library. See [https://golang.org/s/sqldrivers](https://golang.org/s/sqldrivers) for a list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call \\[DB.Ping].\n\nThe returned \\[DB] is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a \\[DB].","DBStats contains database statistics.","ErrConnDone is returned by any operation that is performed on a connection that has already been returned to the connection pool.","Conn represents a single database connection rather than a pool of database connections. Prefer running queries from \\[DB] unless there is a specific need for a continuous single database connection.\n\nA Conn must call \\[Conn.Close] to return the connection to the database pool and may do so concurrently with a running query.\n\nAfter a call to \\[Conn.Close], all operations on the connection fail with \\[ErrConnDone].","Tx is an in-progress database transaction.\n\nA transaction must end with a call to \\[Tx.Commit] or \\[Tx.Rollback].\n\nAfter a call to \\[Tx.Commit] or \\[Tx.Rollback], all operations on the transaction fail with \\[ErrTxDone].\n\nThe statements prepared for a transaction by calling the transaction's \\[Tx.Prepare] or \\[Tx.Stmt] methods are closed by the call to \\[Tx.Commit] or \\[Tx.Rollback].","ErrTxDone is returned by any operation that is performed on a transaction that has already been committed or rolled back.","Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.\n\nIf a Stmt is prepared on a \\[Tx] or \\[Conn], it will be bound to a single underlying connection forever. If the \\[Tx] or \\[Conn] closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a \\[DB], it will remain usable for the lifetime of the \\[DB]. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.","Rows is the result of a query. Its cursor starts before the first row of the result set. Use \\[Rows.Next] to advance from row to row.","ColumnType contains the name and type of a column.","Row is the result of calling \\[DB.QueryRow] to select a single row.","A Result summarizes an executed SQL command.","Type alias for build info. We cannot move the types here, since runtime/debug would need to import this package, which would make it a much larger dependency.","ReadFile returns build information embedded in a Go binary file at the given path. Most information is only available for binaries built with module support.","Read returns build information embedded in a Go binary file accessed through the given ReaderAt. Most information is only available for binaries built with module support.","","An Attr identifies the attribute type in a DWARF \\[Entry.Field].","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The following are new in DWARF 3.","","","","","","","","","","","","","","","","","","","","","","","","","","","The following are new in DWARF 4.","","","","","","The following are new in DWARF 5.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A Tag is the classification (the type) of an \\[Entry].","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The following are new in DWARF 3.","","","","","","","","","","","The following are new in DWARF 4.","","","The following are new in DWARF 5.","","","","","","","","An entry is a sequence of attribute/value pairs.","A Field is a single attribute/value pair in an \\[Entry].\n\nA value can be one of several \"attribute classes\" defined by DWARF. The Go types corresponding to each class are:\n\n\tDWARF class       Go type        Class\n\t-----------       -------        -----\n\taddress           uint64         ClassAddress\n\tblock             []byte         ClassBlock\n\tconstant          int64          ClassConstant\n\tflag              bool           ClassFlag\n\treference\n\t  to info         dwarf.Offset   ClassReference\n\t  to type unit    uint64         ClassReferenceSig\n\tstring            string         ClassString\n\texprloc           []byte         ClassExprLoc\n\tlineptr           int64          ClassLinePtr\n\tloclistptr        int64          ClassLocListPtr\n\tmacptr            int64          ClassMacPtr\n\trangelistptr      int64          ClassRangeListPtr\n\nFor unrecognized or vendor-defined attributes, \\[Class] may be \\[ClassUnknown].","A Class is the DWARF 4 class of an attribute value.\n\nIn general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute.\n\nDWARF version 4 distinguishes attribute value classes more finely than previous versions of DWARF. The reader will disambiguate coarser classes from earlier versions of DWARF into the appropriate DWARF 4 class. For example, DWARF 2 uses \"constant\" for constants as well as all types of section offsets, but the reader will canonicalize attributes in DWARF 2 files that refer to section offsets to one of the Class\\*Ptr classes, even though these classes were only defined in DWARF 3.","ClassUnknown represents values of unknown DWARF class.","ClassAddress represents values of type uint64 that are addresses on the target machine.","ClassBlock represents values of type \\[]byte whose interpretation depends on the attribute.","ClassConstant represents values of type int64 that are constants. The interpretation of this constant depends on the attribute.","ClassExprLoc represents values of type \\[]byte that contain an encoded DWARF expression or location description.","ClassFlag represents values of type bool.","ClassLinePtr represents values that are an int64 offset into the \"line\" section.","ClassLocListPtr represents values that are an int64 offset into the \"loclist\" section.","ClassMacPtr represents values that are an int64 offset into the \"mac\" section.","ClassRangeListPtr represents values that are an int64 offset into the \"rangelist\" section.","ClassReference represents values that are an Offset offset of an Entry in the info section (for use with Reader.Seek). The DWARF specification combines ClassReference and ClassReferenceSig into class \"reference\".","ClassReferenceSig represents values that are a uint64 type signature referencing a type Entry.","ClassString represents values that are strings. If the compilation unit specifies the AttrUseUTF8 flag (strongly recommended), the string value will be encoded in UTF-8. Otherwise, the encoding is unspecified.","ClassReferenceAlt represents values of type int64 that are an offset into the DWARF \"info\" section of an alternate object file.","ClassStringAlt represents values of type int64 that are an offset into the DWARF string section of an alternate object file.","ClassAddrPtr represents values that are an int64 offset into the \"addr\" section.","ClassLocList represents values that are an int64 offset into the \"loclists\" section.","ClassRngList represents values that are a uint64 offset from the base of the \"rnglists\" section.","ClassRngListsPtr represents values that are an int64 offset into the \"rnglists\" section. These are used as the base for ClassRngList values.","ClassStrOffsetsPtr represents values that are an int64 offset into the \"str\\_offsets\" section.","An Offset represents the location of an \\[Entry] within the DWARF info. (See \\[Reader.Seek].)","A Reader allows reading \\[Entry] structures from a DWARF “info” section. The \\[Entry] structures are arranged in a tree. The \\[Reader.Next] function return successive entries from a pre-order traversal of the tree. If an entry has children, its Children field will be true, and the children follow, terminated by an \\[Entry] with \\[Tag] 0.","A LineReader reads a sequence of \\[LineEntry] structures from a DWARF \"line\" section for a single compilation unit. LineEntries occur in order of increasing PC and each \\[LineEntry] gives metadata for the instructions from that \\[LineEntry]'s PC to just before the next \\[LineEntry]'s PC. The last entry will have the \\[LineEntry.EndSequence] field set.","A LineEntry is a row in a DWARF line table.","A LineFile is a source file referenced by a DWARF line table entry.","A LineReaderPos represents a position in a line table.","ErrUnknownPC is the error returned by LineReader.ScanPC when the seek PC is not covered by any entry in the line table.","Data represents the DWARF debugging information loaded from an executable file (for example, an ELF or Mach-O executable).","New returns a new \\[Data] object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package [debug/elf](https://pkg.go.dev/debug/elf/), [debug/macho](https://pkg.go.dev/debug/macho/), or [debug/pe](https://pkg.go.dev/debug/pe/).\n\nThe \\[]byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the \".debug\\_abbrev\" section.","A Type conventionally represents a pointer to any of the specific Type structures (\\[CharType], \\[StructType], etc.).","A CommonType holds fields common to multiple types. If a field is not known or not applicable for a given type, the zero value is used.","A BasicType holds fields common to all basic types.\n\nSee the documentation for \\[StructField] for more info on the interpretation of the BitSize/BitOffset/DataBitOffset fields.","A CharType represents a signed character type.","A UcharType represents an unsigned character type.","An IntType represents a signed integer type.","A UintType represents an unsigned integer type.","A FloatType represents a floating point type.","A ComplexType represents a complex floating point type.","A BoolType represents a boolean type.","An AddrType represents a machine address type.","An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent type.","A QualType represents a type that has the C/C++ \"const\", \"restrict\", or \"volatile\" qualifier.","An ArrayType represents a fixed size array type.","A VoidType represents the C void type.","A PtrType represents a pointer type.","A StructType represents a struct, union, or C++ class type.","A StructField represents a field in a struct, union, or C++ class type.\n\n### Bit Fields {#hdr-Bit_Fields}\n\nThe BitSize, BitOffset, and DataBitOffset fields describe the bit size and offset of data members declared as bit fields in C/C++ struct/union/class types.\n\nBitSize is the number of bits in the bit field.\n\nDataBitOffset, if non-zero, is the number of bits from the start of the enclosing entity (e.g. containing struct/class/union) to the start of the bit field. This corresponds to the DW\\_AT\\_data\\_bit\\_offset DWARF attribute that was introduced in DWARF 4.\n\nBitOffset, if non-zero, is the number of bits between the most significant bit of the storage unit holding the bit field to the most significant bit of the bit field. Here \"storage unit\" is the type name before the bit field (for a field \"unsigned x:17\", the storage unit is \"unsigned\"). BitOffset values can vary depending on the endianness of the system. BitOffset corresponds to the DW\\_AT\\_bit\\_offset DWARF attribute that was deprecated in DWARF 4 and removed in DWARF 5.\n\nAt most one of DataBitOffset and BitOffset will be non-zero; DataBitOffset/BitOffset will only be non-zero if BitSize is non-zero. Whether a C compiler uses one or the other will depend on compiler vintage and command line options.\n\nHere is an example of C/C++ bit field use, along with what to expect in terms of DWARF bit offset info. Consider this code:\n\n\tstruct S {\n\t\tint q;\n\t\tint j:5;\n\t\tint k:6;\n\t\tint m:5;\n\t\tint n:8;\n\t} s;\n\nFor the code above, one would expect to see the following for DW\\_AT\\_bit\\_offset values (using GCC 8):\n\n\t       Little   |     Big\n\t       Endian   |    Endian\n\t                |\n\t\"j\":     27     |     0\n\t\"k\":     21     |     5\n\t\"m\":     16     |     11\n\t\"n\":     8      |     16\n\nNote that in the above the offsets are purely with respect to the containing storage unit for j/k/m/n -- these values won't vary based on the size of prior data members in the containing struct.\n\nIf the compiler emits DW\\_AT\\_data\\_bit\\_offset, the expected values would be:\n\n\t\"j\":     32\n\t\"k\":     37\n\t\"m\":     43\n\t\"n\":     48\n\nHere the value 32 for \"j\" reflects the fact that the bit field is preceded by other data members (recall that DW\\_AT\\_data\\_bit\\_offset values are relative to the start of the containing struct). Hence DW\\_AT\\_data\\_bit\\_offset values can be quite large for structs with many fields.\n\nDWARF also allow for the possibility of base types that have non-zero bit size and bit offset, so this information is also captured for base types, but it is worth noting that it is not possible to trigger this behavior using mainstream languages.","An EnumType represents an enumerated type. The only indication of its native integer type is its ByteSize (inside \\[CommonType]).","An EnumValue represents a single enumeration value.","A FuncType represents a function type.","A DotDotDotType represents the variadic ... function parameter.","A TypedefType represents a named type.","An UnsupportedType is a placeholder returned in situations where we encounter a type that isn't supported.","","","","","","","","Initial magic number for ELF files.","Version is found in Header.Ident\\[EI\\_VERSION] and Header.Version.","","","Class is found in Header.Ident\\[EI\\_CLASS] and Header.Class.","","","","Data is found in Header.Ident\\[EI\\_DATA] and Header.Data.","","","","OSABI is found in Header.Ident\\[EI\\_OSABI] and Header.OSABI.","","","","","","","","","","","","","","","","","","","","","Type is found in Header.Type.","","","","","","","","","","Machine is found in Header.Machine.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Non-standard or deprecated.","","","","Special section indices.","","","","","","","","","","","Section type.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Section flags.","","","","","","","","","","","","","","Section compression type.","","","","","","","Prog.Type","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Prog.Flag","","","","","","Dyn.Tag","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","DT\\_FLAGS values.","","","","","","DT\\_FLAGS\\_1 values.","Indicates that all relocations for this object must be processed before returning control to the program.","Unused.","Indicates that the object is a member of a group.","Indicates that the object cannot be deleted from a process.","Meaningful only for filters. Indicates that all associated filtees be processed immediately.","Indicates that this object's initialization section be run before any other objects loaded.","Indicates that the object cannot be added to a running process with dlopen.","Indicates the object requires $ORIGIN processing.","Indicates that the object should use direct binding information.","Unused.","Indicates that the objects symbol table is to interpose before all symbols except the primary load object, which is typically the executable.","Indicates that the search for dependencies of this object ignores any default library search paths.","Indicates that this object is not dumped by dldump. Candidates are objects with no relocations that might get included when generating alternative objects using.","Identifies this object as a configuration alternative object generated by crle. Triggers the runtime linker to search for a configuration file $ORIGIN/ld.config.app-name.","Meaningful only for filtees. Terminates a filters search for any further filtees.","Indicates that this object has displacement relocations applied.","Indicates that this object has displacement relocations pending.","Indicates that this object contains symbols that cannot be directly bound to.","Reserved for internal use by the kernel runtime-linker.","Reserved for internal use by the kernel runtime-linker.","Reserved for internal use by the kernel runtime-linker.","Indicates that this object has been edited or has been modified since the objects original construction by the link-editor.","Reserved for internal use by the kernel runtime-linker.","Indicates that the object contains individual symbols that should interpose before all symbols except the primary load object, which is typically the executable.","Indicates that the executable requires global auditing.","Indicates that the object defines, or makes reference to singleton symbols.","Indicates that the object is a stub.","Indicates that the object is a position-independent executable.","Indicates that the object is a kernel module.","Indicates that the object is a weak standard filter.","Unused.","NType values; used in core files.","","","","Symbol Binding - ELFNN\\_ST\\_BIND - st\\_info","","","","","","","","Symbol type - ELFNN\\_ST\\_TYPE - st\\_info","","","","","","","","","","","","Non-standard symbol types.","","","Symbol visibility - ELFNN\\_ST\\_VISIBILITY - st\\_other","","","","","Relocation types for x86-64.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for AArch64 (aka arm64)","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for Alpha.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for ARM.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for 386.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for MIPS.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for LoongArch.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for PowerPC.\n\nValues that are shared by both R\\_PPC and R\\_PPC64 are prefixed with R\\_POWERPC\\_ in the ELF standard. For the R\\_PPC type, the relevant shared relocations have been renamed with the prefix R\\_PPC\\_. The original name follows the value in a comment.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for 64-bit PowerPC or Power Architecture processors.\n\nValues that are shared by both R\\_PPC and R\\_PPC64 are prefixed with R\\_POWERPC\\_ in the ELF standard. For the R\\_PPC64 type, the relevant shared relocations have been renamed with the prefix R\\_PPC64\\_. The original name follows the value in a comment.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for RISC-V processors.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for s390x processors.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Relocation types for SPARC.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Magic number for the elf trampoline, chosen wisely to be an immediate value.","ELF32 File header.","ELF32 Section header.","ELF32 Program header.","ELF32 Dynamic structure. The \".dynamic\" section contains an array of them.","ELF32 Compression header.","ELF32 Relocations that don't need an addend field.","ELF32 Relocations that need an addend field.","","","","ELF32 Symbol.","","","","","","ELF64 file header.","ELF64 Section header.","ELF64 Program header.","ELF64 Dynamic structure. The \".dynamic\" section contains an array of them.","ELF64 Compression header.","ELF64 relocations that don't need an addend field.","ELF64 relocations that need an addend field.","","","","ELF64 symbol table entries.","","A FileHeader represents an ELF file header.","A File represents an open ELF file.","A SectionHeader represents a single ELF section header.","A Section represents a single section in an ELF file.","A ProgHeader represents a single ELF program header.","A Prog represents a single ELF program header in an ELF binary.","A Symbol represents an entry in an ELF symbol table section.","","Open opens the named file using [os.Open](https://pkg.go.dev/os/#Open) and prepares it for use as an ELF binary.","NewFile creates a new \\[File] for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt.","ErrNoSymbols is returned by \\[File.Symbols] and \\[File.DynamicSymbols] if there is no such section in the File.","","A LineTable is a data structure mapping program counters to line numbers.\n\nIn Go 1.1 and earlier, each function (represented by a \\[Func]) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.\n\nIn Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.\n\nFor the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on \\[Table] instead.","NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment, with the exact value stored in the 'runtime.text' symbol. This value may differ from the start address of the text segment if binary was built with cgo enabled.","A Sym represents a single symbol table entry.","A Func collects information about a single function.","An Obj represents a collection of functions in a symbol table.\n\nThe exact method of division of a binary into separate Objs is an internal detail of the symbol table format.\n\nIn early versions of Go each source file became a different Obj.\n\nIn Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.\n\nIn Go 1.2, there is a single Obj for the entire program.","Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses.","NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data.","UnknownFileError represents a failure to find the specific file in the symbol table.","UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.","DecodingError represents an error during the decoding of the symbol table.","A FatFile is a Mach-O universal binary that contains at least one architecture.","A FatArchHeader represents a fat header for a specific image architecture.","A FatArch is a Mach-O File inside a FatFile.","ErrNotFat is returned from \\[NewFatFile] or \\[OpenFat] when the file is not a universal binary but may be a thin binary, based on its magic number.","NewFatFile creates a new \\[FatFile] for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt.","OpenFat opens the named file using [os.Open](https://pkg.go.dev/os/#Open) and prepares it for use as a Mach-O universal binary.","A File represents an open Mach-O file.","A Load represents any Mach-O load command.","A LoadBytes is the uninterpreted bytes of a Mach-O load command.","A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command.","A Segment represents a Mach-O 32-bit or 64-bit load segment command.","","A Reloc represents a Mach-O relocation.","","A Dylib represents a Mach-O load dynamic library command.","A Symtab represents a Mach-O symbol table command.","A Dysymtab represents a Mach-O dynamic symbol table command.","A Rpath represents a Mach-O rpath command.","A Symbol is a Mach-O 32-bit or 64-bit symbol table entry.","FormatError is returned by some operations if the data does not have the correct format for an object file.","Open opens the named file using [os.Open](https://pkg.go.dev/os/#Open) and prepares it for use as a Mach-O binary.","NewFile creates a new \\[File] for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt.","A FileHeader represents a Mach-O file header.","","","","A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library.","","","","","A Cpu is a Mach-O cpu type.","","","","","","","A LoadCmd is a Mach-O load command.","","","","","","","","","","A Segment32 is a 32-bit Mach-O segment load command.","A Segment64 is a 64-bit Mach-O segment load command.","A SymtabCmd is a Mach-O symbol table command.","A DysymtabCmd is a Mach-O dynamic symbol table command.","A DylibCmd is a Mach-O load dynamic library command.","A RpathCmd is a Mach-O rpath command.","A Thread is a Mach-O thread state command.","","","","","","","","","","","","","","","","","","","","","","","","","","","A Section32 is a 32-bit Mach-O section header.","A Section64 is a 64-bit Mach-O section header.","An Nlist32 is a Mach-O 32-bit symbol table entry.","An Nlist64 is a Mach-O 64-bit symbol table entry.","Regs386 is the Mach-O 386 register structure.","RegsAMD64 is the Mach-O AMD64 register structure.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A File represents an open PE file.","Open opens the named file using [os.Open](https://pkg.go.dev/os/#Open) and prepares it for use as a PE binary.","NewFile creates a new \\[File] for accessing a PE binary in an underlying reader.","","FormatError is unused. The type is retained for compatibility.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","SectionHeader32 represents real PE COFF section header.","Reloc represents a PE COFF relocation. Each section contains its own relocation list.","SectionHeader is similar to \\[SectionHeader32] with Name field replaced by Go string.","Section provides access to PE COFF section.","","","","","","","","","StringTable is a COFF string table.","","COFFSymbol represents single COFF symbol table record.","Symbol is similar to \\[COFFSymbol] with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols.","COFFSymbolAuxFormat5 describes the expected form of an aux symbol attached to a section definition symbol. The PE format defines a number of different aux symbol formats: format 1 for function definitions, format 2 for .be and .ef symbols, and so on. Format 5 holds extra info associated with a section definition, including number of relocations + line numbers, as well as COMDAT info. See [https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions) for more on what's going on here.","","","","","","","A FileHeader represents a Plan 9 a.out file header.","A File represents an open Plan 9 a.out file.","A SectionHeader represents a single Plan 9 a.out section header. This structure doesn't exist on-disk, but eases navigation through the object file.","A Section represents a single section in a Plan 9 a.out file.","A Symbol represents an entry in a Plan 9 a.out symbol table section.","Open opens the named file using [os.Open](https://pkg.go.dev/os/#Open) and prepares it for use as a Plan 9 a.out binary.","NewFile creates a new \\[File] for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt.","ErrNoSymbols is returned by \\[File.Symbols] if there is no such section in the File.","","","","","Encode encodes src into at most \\[MaxEncodedLen](len(src)) bytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use \\[NewEncoder] instead.\n\nOften, ascii85-encoded data is wrapped in \\\u003c~ and ~\u003e symbols. Encode does not add these.","MaxEncodedLen returns the maximum length of an encoding of n source bytes.","NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block.","","Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a \\[CorruptInputError]. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in \\\u003c~ and ~\u003e symbols. Decode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.\n\n\\[NewDecoder] wraps an [io.Reader](https://pkg.go.dev/io/#Reader) interface around Decode.","NewDecoder constructs a new ascii85 stream decoder.","A StructuralError suggests that the ASN.1 data is valid, but the Go type which is receiving it doesn't match.","A SyntaxError suggests that the ASN.1 data is invalid.","BitString is the structure to use when you want an ASN.1 BIT STRING type. A bit string is padded up to the nearest byte in memory and the number of valid bits is recorded. Padding bits will be zero.","NullRawValue is a \\[RawValue] with its Tag set to the ASN.1 NULL type tag (5).","NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.","An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.","An Enumerated is represented as a plain int.","A Flag accepts any data and is set to true if present.","A RawValue represents an undecoded ASN.1 object.","RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.","Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error.\n\nAfter parsing b, any bytes that were leftover and not used to fill val will be returned in rest. When parsing a SEQUENCE into a struct, any trailing elements of the SEQUENCE that do not have matching fields in val will not be included in rest, as these are considered valid elements of the SEQUENCE and not trailing data.\n\n  - An ASN.1 INTEGER can be written to an int, int32, int64, or \\*\\[big.Int]. If the encoded value does not fit in the Go type, Unmarshal returns a parse error.\n\n  - An ASN.1 BIT STRING can be written to a \\[BitString].\n\n  - An ASN.1 OCTET STRING can be written to a \\[]byte.\n\n  - An ASN.1 OBJECT IDENTIFIER can be written to an \\[ObjectIdentifier].\n\n  - An ASN.1 ENUMERATED can be written to an \\[Enumerated].\n\n  - An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a [time.Time](https://pkg.go.dev/time/#Time).\n\n  - An ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\n  - Any of the above ASN.1 values can be written to an interface{}. The value stored in the interface has the corresponding Go type. For integers, that type is int64.\n\n  - An ASN.1 SEQUENCE OF x or SET OF x can be written to a slice if an x can be written to the slice's element type.\n\n  - An ASN.1 SEQUENCE or SET can be written to a struct if each of the elements in the sequence can be written to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nWhen decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '\u0026'. To force other encodings, use the following tags:\n\n\tia5     causes strings to be unmarshaled as ASN.1 IA5String values\n\tnumeric causes strings to be unmarshaled as ASN.1 NumericString values\n\tutf8    causes strings to be unmarshaled as ASN.1 UTF8String values\n\nIf the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.\n\nIf the name of a slice type ends with \"SET\" then it's treated as if the \"set\" tag was set on it. This results in interpreting the type as a SET OF x rather than a SEQUENCE OF x. This can be used with nested slices where a struct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error.","UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.","","","","","","","","","","","","","","","","","","","","","","","Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognized by Unmarshal, the following can be used:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values","MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.","An Encoding is a radix 32 encoding/decoding scheme, defined by a 32-character alphabet. The most common is the \"base32\" encoding introduced for SASL GSSAPI and standardized in RFC 4648. The alternate \"base32hex\" encoding is used in DNSSEC.","","","NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 32-byte string that contains unique byte values and does not contain the padding character or CR / LF ('\\\\r', '\\\\n'). The alphabet is treated as a sequence of byte values without any special treatment for multi-byte UTF-8. The resulting Encoding uses the default padding character ('='), which may be changed or disabled via \\[Encoding.WithPadding].","StdEncoding is the standard base32 encoding, as defined in RFC 4648.","HexEncoding is the “Extended Hex Alphabet” defined in RFC 4648. It is typically used in DNS.","NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.","","NewDecoder constructs a new base32 stream decoder.","An Encoding is a radix 64 encoding/decoding scheme, defined by a 64-character alphabet. The most common encoding is the \"base64\" encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421).  RFC 4648 also defines an alternate encoding, which is the standard encoding with - and \\_ substituted for + and /.","","","NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that contains unique byte values and does not contain the padding character or CR / LF ('\\\\r', '\\\\n'). The alphabet is treated as a sequence of byte values without any special treatment for multi-byte UTF-8. The resulting Encoding uses the default padding character ('='), which may be changed or disabled via \\[Encoding.WithPadding].","StdEncoding is the standard base64 encoding, as defined in RFC 4648.","URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.","RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as \\[StdEncoding] but omits padding characters.","RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as \\[URLEncoding] but omits padding characters.","NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.","","NewDecoder constructs a new base64 stream decoder.","A ByteOrder specifies how to convert byte slices into 16-, 32-, or 64-bit unsigned integers.\n\nIt is implemented by \\[LittleEndian], \\[BigEndian], and \\[NativeEndian].","AppendByteOrder specifies how to append 16-, 32-, or 64-bit unsigned integers into a byte slice.\n\nIt is implemented by \\[LittleEndian], \\[BigEndian], and \\[NativeEndian].","LittleEndian is the little-endian implementation of \\[ByteOrder] and \\[AppendByteOrder].","BigEndian is the big-endian implementation of \\[ByteOrder] and \\[AppendByteOrder].","Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (\\_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.\n\nThe error is [io.EOF](https://pkg.go.dev/io/#EOF) only if no bytes were read. If an [io.EOF](https://pkg.go.dev/io/#EOF) happens after reading some but not all the bytes, Read returns [io.ErrUnexpectedEOF](https://pkg.go.dev/io/#ErrUnexpectedEOF).","Decode decodes binary data from buf into data according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes consumed from buf.","Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (\\_) field names.","Encode encodes the binary representation of data into buf according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes written into buf.","Append appends the binary representation of data to buf. buf may be nil, in which case a new buffer will be allocated. See \\[Write] on which data are acceptable. It returns the (possibily extended) buffer containing data or an error.","Size returns how many bytes \\[Write] would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.","NativeEndian is the native-endian implementation of \\[ByteOrder] and \\[AppendByteOrder].","","","","AppendUvarint appends the varint-encoded form of x, as generated by \\[PutUvarint], to buf and returns the extended buffer.","PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.","Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (\u003e 0). If an error occurred, the value is 0 and the number of bytes n is \\\u003c= 0 meaning:\n\n  - n == 0: buf too small;\n  - n \\\u003c 0: value larger than 64 bits (overflow) and -n is the number of bytes read.","AppendVarint appends the varint-encoded form of x, as generated by \\[PutVarint], to buf and returns the extended buffer.","PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.","Varint decodes an int64 from buf and returns that value and the number of bytes read (\u003e 0). If an error occurred, the value is 0 and the number of bytes n is \\\u003c= 0 with the following meaning:\n\n  - n == 0: buf too small;\n  - n \\\u003c 0: value larger than 64 bits (overflow) and -n is the number of bytes read.","ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64. The error is [io.EOF](https://pkg.go.dev/io/#EOF) only if no bytes were read. If an [io.EOF](https://pkg.go.dev/io/#EOF) happens after reading some but not all the bytes, ReadUvarint returns [io.ErrUnexpectedEOF](https://pkg.go.dev/io/#ErrUnexpectedEOF).","ReadVarint reads an encoded signed integer from r and returns it as an int64. The error is [io.EOF](https://pkg.go.dev/io/#EOF) only if no bytes were read. If an [io.EOF](https://pkg.go.dev/io/#EOF) happens after reading some but not all the bytes, ReadVarint returns [io.ErrUnexpectedEOF](https://pkg.go.dev/io/#ErrUnexpectedEOF).","A ParseError is returned for parsing errors. Line and column numbers are 1-indexed.","","","","Deprecated: ErrTrailingComma is no longer used.","A Reader reads records from a CSV-encoded file.\n\nAs returned by \\[NewReader], a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to \\[Reader.Read] or \\[Reader.ReadAll].\n\nThe Reader converts all \\\\r\\\\n sequences in its input to plain \\\\n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses.","NewReader returns a new Reader that reads from r.","A Writer writes records using CSV encoding.\n\nAs returned by \\[NewWriter], a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to \\[Writer.Write] or \\[Writer.WriteAll].\n\n\\[Writer.Comma] is the field delimiter.\n\nIf \\[Writer.UseCRLF] is true, the Writer ends each output line with \\\\r\\\\n instead of \\\\n.\n\nThe writes of individual records are buffered. After all data has been written, the client should call the \\[Writer.Flush] method to guarantee all data has been forwarded to the underlying [io.Writer](https://pkg.go.dev/io/#Writer).  Any errors that occurred should be checked by calling the \\[Writer.Error] method.","NewWriter returns a new Writer that writes to w.","A Decoder manages the receipt of type and data information read from the remote side of a connection.  It is safe for concurrent use by multiple goroutines.\n\nThe Decoder does only basic sanity checking on decoded input sizes, and its limits are not configurable. Take caution when decoding gob data from untrusted sources.","NewDecoder returns a new decoder that reads from the [io.Reader](https://pkg.go.dev/io/#Reader). If r does not also implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), it will be wrapped in a [bufio.Reader](https://pkg.go.dev/bufio/#Reader).","An Encoder manages the transmission of type and data information to the other side of a connection.  It is safe for concurrent use by multiple goroutines.","NewEncoder returns a new encoder that will transmit on the [io.Writer](https://pkg.go.dev/io/#Writer).","CommonType holds elements of all types. It is a historical artifact, kept for binary compatibility and exported only for the benefit of the package's encoding of type descriptors. It is not intended for direct use by clients.","GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.\n\nNote: Since gobs can be stored permanently, it is good design to guarantee the encoding used by a GobEncoder is stable as the software evolves. For instance, it might make sense for GobEncode to include a version number in the encoding.","GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.","RegisterName is like \\[Register] but uses the provided name rather than the type's default.","Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.","EncodedLen returns the length of an encoding of n source bytes. Specifically, it returns n \\* 2.","Encode encodes src into \\[EncodedLen](len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always \\[EncodedLen](len(src)). Encode implements hexadecimal encoding.","AppendEncode appends the hexadecimally encoded src to dst and returns the extended buffer.","ErrLength reports an attempt to decode an odd-length input using \\[Decode] or \\[DecodeString]. The stream-based Decoder returns [io.ErrUnexpectedEOF](https://pkg.go.dev/io/#ErrUnexpectedEOF) instead of ErrLength.","InvalidByteError values describe errors resulting from an invalid byte in a hex string.","DecodedLen returns the length of a decoding of x source bytes. Specifically, it returns x / 2.","Decode decodes src into \\[DecodedLen](len(src)) bytes, returning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, Decode returns the number of bytes decoded before the error.","AppendDecode appends the hexadecimally decoded src to dst and returns the extended buffer. If the input is malformed, it returns the partially decoded src and an error.","EncodeToString returns the hexadecimal encoding of src.","DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, DecodeString returns the bytes decoded before the error.","Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of \\`hexdump -C\\` on the command line.","NewEncoder returns an [io.Writer](https://pkg.go.dev/io/#Writer) that writes lowercase hexadecimal characters to w.","NewDecoder returns an [io.Reader](https://pkg.go.dev/io/#Reader) that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters.","Dumper returns a [io.WriteCloser](https://pkg.go.dev/io/#WriteCloser) that writes a hex dump of all written data to w. The format of the dump matches the output of \\`hexdump -C\\` on the command line.","Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an \\[InvalidUnmarshalError].\n\nUnmarshal uses the inverse of the encodings that \\[Marshal] uses, allocating maps, slices, and pointers as necessary, with the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing \\[Unmarshaler], Unmarshal calls that value's \\[Unmarshaler.UnmarshalJSON] method, including when the input is a JSON null. Otherwise, if the value implements [encoding.TextUnmarshaler](https://pkg.go.dev/encoding/#TextUnmarshaler) and the input is a JSON quoted string, Unmarshal calls [encoding.TextUnmarshaler.UnmarshalText](https://pkg.go.dev/encoding/#TextUnmarshaler.UnmarshalText) with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by \\[Marshal] (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see \\[Decoder.DisallowUnknownFields] for an alternative).\n\nTo unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:\n\n  - bool, for JSON booleans\n  - float64, for JSON numbers\n  - string, for JSON strings\n  - \\[]interface{}, for JSON arrays\n  - map\\[string]interface{}, for JSON objects\n  - nil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, or implement [encoding.TextUnmarshaler](https://pkg.go.dev/encoding/#TextUnmarshaler).\n\nIf the JSON-encoded data contain a syntax error, Unmarshal returns a \\[SyntaxError].\n\nIf a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an \\[UnmarshalTypeError] describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean “not present,” unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.","Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.\n\nBy convention, to approximate the behavior of \\[Unmarshal] itself, Unmarshalers implement UnmarshalJSON(\\[]byte(\"null\")) as a no-op.","An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type.","An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field.\n\nDeprecated: No longer used; kept for compatibility.","An InvalidUnmarshalError describes an invalid argument passed to \\[Unmarshal]. (The argument to \\[Unmarshal] must be a non-nil pointer.)","A Number represents a JSON number literal.","Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively. If an encountered value implements \\[Marshaler] and is not a nil pointer, Marshal calls \\[Marshaler.MarshalJSON] to produce JSON. If no \\[Marshaler.MarshalJSON] method is present but the value implements [encoding.TextMarshaler](https://pkg.go.dev/encoding/#TextMarshaler) instead, Marshal calls [encoding.TextMarshaler.MarshalText](https://pkg.go.dev/encoding/#TextMarshaler.MarshalText) and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of \\[Unmarshaler.UnmarshalJSON].\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and \\[Number] values encode as JSON numbers. NaN and +/-Inf values will return an \\[UnsupportedValueError].\n\nString values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML \\\u003cscript\u003e tags, the string is encoded using \\[HTMLEscape], which replaces \"\\\u003c\", \"\u003e\", \"\u0026\", U+2028, and U+2029 are escaped to \"\\\\u003c\",\"\\\\u003e\", \"\\\\u0026\", \"\\\\u2028\", and \"\\\\u2029\". This replacement can be disabled when using an \\[Encoder], by calling \\[Encoder.SetEscapeHTML](false).\n\nArray and slice values encode as JSON arrays, except that \\[]byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.\n\nStruct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.\n\nThe encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n\t// Field appears in JSON as key \"myName\".\n\tField int `json:\"myName\"`\n\n\t// Field appears in JSON as key \"myName\" and\n\t// the field is omitted from the object if its value is empty,\n\t// as defined above.\n\tField int `json:\"myName,omitempty\"`\n\n\t// Field appears in JSON as key \"Field\" (the default), but\n\t// the field is skipped if empty.\n\t// Note the leading comma.\n\tField int `json:\",omitempty\"`\n\n\t// Field is ignored by this package.\n\tField int `json:\"-\"`\n\n\t// Field appears in JSON as key \"-\".\n\tField int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:\n\n\tInt64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.\n\nEmbedded struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:\n\n1\\) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.\n\n2\\) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3\\) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a string, an integer type, or implement [encoding.TextMarshaler](https://pkg.go.dev/encoding/#TextMarshaler). The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:\n\n  - keys of any string type are used directly\n  - keys that implement [encoding.TextMarshaler](https://pkg.go.dev/encoding/#TextMarshaler) are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an \\[UnsupportedTypeError].\n\nJSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error.","MarshalIndent is like \\[Marshal] but applies \\[Indent] to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.","Marshaler is the interface implemented by types that can marshal themselves into valid JSON.","An UnsupportedTypeError is returned by \\[Marshal] when attempting to encode an unsupported value type.","An UnsupportedValueError is returned by \\[Marshal] when attempting to encode an unsupported value.","Before Go 1.2, an InvalidUTF8Error was returned by \\[Marshal] when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, \\[Marshal] instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD.\n\nDeprecated: No longer used; kept for compatibility.","A MarshalerError represents an error from calling a \\[Marshaler.MarshalJSON] or [encoding.TextMarshaler.MarshalText](https://pkg.go.dev/encoding/#TextMarshaler.MarshalText) method.","HTMLEscape appends to dst the JSON-encoded src with \\\u003c, \u003e, \u0026, U+2028 and U+2029 characters inside string literals changed to \\\\u003c, \\\\u003e, \\\\u0026, \\\\u2028, \\\\u2029 so that the JSON will be safe to embed inside HTML \\\u003cscript\u003e tags. For historical reasons, web browsers don't honor standard HTML escaping within \\\u003cscript\u003e tags, so an alternative JSON encoding must be used.","Compact appends to dst the JSON-encoded src with insignificant space characters elided.","Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.","Valid reports whether data is a valid JSON encoding.","A SyntaxError is a description of a JSON syntax error. \\[Unmarshal] will return a SyntaxError if the JSON can't be parsed.","A Decoder reads and decodes JSON values from an input stream.","NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may read data from r beyond the JSON values requested.","An Encoder writes JSON values to an output stream.","NewEncoder returns a new encoder that writes to w.","RawMessage is a raw encoded JSON value. It implements \\[Marshaler] and \\[Unmarshaler] and can be used to delay JSON decoding or precompute a JSON encoding.","A Token holds a value of one of these types:\n\n  - \\[Delim], for the four JSON delimiters \\[ ] { }\n  - bool, for JSON booleans\n  - float64, for JSON numbers\n  - \\[Number], for JSON numbers\n  - string, for JSON string literals\n  - nil, for JSON null","A Delim is a JSON array or object delimiter, one of \\[ ] { or }.","A Block represents a PEM encoded structure.\n\nThe encoded form is:\n\n\t-----BEGIN Type-----\n\tHeaders\n\tbase64-encoded Bytes\n\t-----END Type-----\n\nwhere \\[Block.Headers] is a possibly empty sequence of Key: Value lines.","Decode will find the next PEM formatted block (certificate, private key etc) in the input. It returns that block and the remainder of the input. If no PEM data is found, p is nil and the whole of the input is returned in rest.","Encode writes the PEM encoding of b to out.","EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use \\[Encode] instead.","Header is a generic XML header suitable for use with the output of \\[Marshal]. This is not automatically added to any output of this package, it is provided as a convenience.","Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n\n  - the tag on the XMLName field, if the data is a struct\n  - the value of the XMLName field of type \\[Name]\n  - the tag of the struct field used to obtain the data\n  - the name of the struct field used to obtain the data\n  - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions:\n\n  - the XMLName field, described above, is omitted.\n  - a field with tag \"-\" is omitted.\n  - a field with tag \"name,attr\" becomes an attribute with the given name in the XML element.\n  - a field with tag \",attr\" becomes an attribute with the field name in the XML element.\n  - a field with tag \",chardata\" is written as character data, not as an XML element.\n  - a field with tag \",cdata\" is written as character data wrapped in one or more \\\u003c!\\[CDATA\\[ ... ]]\u003e tags, not as an XML element.\n  - a field with tag \",innerxml\" is written verbatim, not subject to the usual marshaling procedure.\n  - a field with tag \",comment\" is written as an XML comment, not subject to the usual marshaling procedure. It must not contain the \"--\" string within it.\n  - a field with a tag including the \"omitempty\" option is omitted if the field value is empty. The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero.\n  - an anonymous struct field is handled as if the fields of its value were part of the outer struct.\n  - a field implementing \\[Marshaler] is written by calling its MarshalXML method.\n  - a field implementing [encoding.TextMarshaler](https://pkg.go.dev/encoding/#TextMarshaler) is written by encoding the result of its MarshalText method as text.\n\nIf a field uses a tag \"a\u003eb\u003ec\", then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.\n\nSee \\[MarshalIndent] for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.","Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.\n\nMarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable \\[Unmarshal] to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements.","MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.\n\nMarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable \\[Unmarshal] to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute \\[Attr]{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the \"attr\" option in the field tag.","MarshalIndent works like \\[Marshal], but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.","An Encoder writes XML data to an output stream.","NewEncoder returns a new encoder that writes to w.","UnsupportedTypeError is returned when \\[Marshal] encounters a type that cannot be converted into XML.","Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.\n\nBecause Unmarshal uses the reflect package, it can only assign to exported (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names.\n\nUnmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).\n\n  - If the struct has a field of type \\[]byte or string with tag \",innerxml\", Unmarshal accumulates the raw XML nested inside the element in that field. The rest of the rules still apply.\n\n  - If the struct has a field named XMLName of type Name, Unmarshal records the element name in that field.\n\n  - If the XMLName field has an associated tag of the form \"name\" or \"namespace-URL name\", the XML element must have the given name (and, optionally, name space) or else Unmarshal returns an error.\n\n  - If the XML element has an attribute whose name matches a struct field name with an associated tag containing \",attr\" or the explicit name in a struct field tag of the form \"name,attr\", Unmarshal records the attribute value in that field.\n\n  - If the XML element has an attribute not handled by the previous rule and the struct has a field with an associated tag containing \",any,attr\", Unmarshal records the attribute value in the first such field.\n\n  - If the XML element contains character data, that data is accumulated in the first struct field that has tag \",chardata\". The struct field may have type \\[]byte or string. If there is no such field, the character data is discarded.\n\n  - If the XML element contains comments, they are accumulated in the first struct field that has tag \",comment\".  The struct field may have type \\[]byte or string. If there is no such field, the comments are discarded.\n\n  - If the XML element contains a sub-element whose name matches the prefix of a tag formatted as \"a\" or \"a\u003eb\u003ec\", unmarshal will descend into the XML structure looking for elements with the given names, and will map the innermost elements to that struct field. A tag starting with \"\u003e\" is equivalent to one starting with the field name followed by \"\u003e\".\n\n  - If the XML element contains a sub-element whose name matches a struct field's XMLName tag and the struct field has no explicit name tag as per the previous rule, unmarshal maps the sub-element to that struct field.\n\n  - If the XML element contains a sub-element whose name matches a field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal maps the sub-element to that struct field.\n\n  - If the XML element contains a sub-element that hasn't matched any of the above rules and the struct has a field with tag \",any\", unmarshal maps the sub-element to that struct field.\n\n  - An anonymous struct field is handled as if the fields of its value were part of the outer struct.\n\n  - A struct field with tag \"-\" is never unmarshaled into.\n\nIf Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element.  Otherwise, if the value implements [encoding.TextUnmarshaler](https://pkg.go.dev/encoding/#TextUnmarshaler), Unmarshal calls that value's UnmarshalText method.\n\nUnmarshal maps an XML element to a string or \\[]byte by saving the concatenation of that element's character data in the string or \\[]byte. The saved \\[]byte is never nil.\n\nUnmarshal maps an attribute value to a string or \\[]byte by saving the value in the string or slice.\n\nUnmarshal maps an attribute value to an \\[Attr] by saving the attribute, including its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element name.\n\nUnmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value. If the field is a slice, a zero value will be appended to the field. Otherwise, the field will be set to its zero value.","An UnmarshalError represents an error in the unmarshaling process.","Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.\n\nUnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.","UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.\n\nUnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to \\[Unmarshal] stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the \"attr\" option in the field tag.","A TagPathError represents an error in the unmarshaling process caused by the use of field tags with conflicting paths.","A SyntaxError represents a syntax error in the XML input stream.","A Name represents an XML name (Local) annotated with a name space identifier (Space). In tokens returned by \\[Decoder.Token], the Space identifier is given as a canonical URL, not the short prefix used in the document being parsed.","An Attr represents an attribute in an XML element (Name=Value).","A Token is an interface holding one of the token types: \\[StartElement], \\[EndElement], \\[CharData], \\[Comment], \\[ProcInst], or \\[Directive].","A StartElement represents an XML start element.","An EndElement represents an XML end element.","A CharData represents XML character data (raw text), in which XML escape sequences have been replaced by the characters they represent.","A Comment represents an XML comment of the form \\\u003c!--comment--\u003e. The bytes do not include the \\\u003c!-- and --\u003e comment markers.","A ProcInst represents an XML processing instruction of the form \\\u003c?target inst?\u003e","A Directive represents an XML directive of the form \\\u003c!text\u003e. The bytes do not include the \\\u003c! and \u003e markers.","CopyToken returns a copy of a Token.","A TokenReader is anything that can decode a stream of XML tokens, including a \\[Decoder].\n\nWhen Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, [io.EOF](https://pkg.go.dev/io/#EOF).\n\nImplementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF.","A Decoder represents an XML parser reading a particular input stream. The parser assumes that its input is encoded in UTF-8.","NewDecoder creates a new XML parser reading from r. If r does not implement [io.ByteReader](https://pkg.go.dev/io/#ByteReader), NewDecoder will do its own buffering.","NewTokenDecoder creates a new XML parser using an underlying token stream.","HTMLEntity is an entity map containing translations for the standard HTML entity characters.\n\nSee the \\[Decoder.Strict] and \\[Decoder.Entity] fields' documentation.","HTMLAutoClose is the set of HTML elements that should be considered to close automatically.\n\nSee the \\[Decoder.Strict] and \\[Decoder.Entity] fields' documentation.","EscapeText writes to w the properly escaped XML equivalent of the plain text data s.","Escape is like \\[EscapeText] but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use \\[EscapeText].","All node types implement the Node interface.","All expression nodes implement the Expr interface.","All statement nodes implement the Stmt interface.","All declaration nodes implement the Decl interface.","A Comment node represents a single //-style or /\\*-style comment.\n\nThe Text field contains the comment text without carriage returns (\\\\r) that may have been present in the source. Because a comment's end position is computed using len(Text), the position reported by \\[Comment.End] does not match the true source end position for comments containing carriage returns.","A CommentGroup represents a sequence of comments with no other tokens and no empty lines between.","A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. \\[Field.Names] is nil for unnamed parameters (parameter lists which only contain types) and embedded struct fields. In the latter case, the field name is the type name.","A FieldList represents a list of Fields, enclosed by parentheses, curly braces, or square brackets.","A BadExpr node is a placeholder for an expression containing syntax errors for which a correct expression node cannot be created.","An Ident node represents an identifier.","An Ellipsis node stands for the \"...\" type in a parameter list or the \"...\" length in an array type.","A BasicLit node represents a literal of basic type.","A FuncLit node represents a function literal.","A CompositeLit node represents a composite literal.","A ParenExpr node represents a parenthesized expression.","A SelectorExpr node represents an expression followed by a selector.","An IndexExpr node represents an expression followed by an index.","An IndexListExpr node represents an expression followed by multiple indices.","A SliceExpr node represents an expression followed by slice indices.","A TypeAssertExpr node represents an expression followed by a type assertion.","A CallExpr node represents an expression followed by an argument list.","A StarExpr node represents an expression of the form \"\\*\" Expression. Semantically it could be a unary \"\\*\" expression, or a pointer type.","A UnaryExpr node represents a unary expression. Unary \"\\*\" expressions are represented via StarExpr nodes.","A BinaryExpr node represents a binary expression.","A KeyValueExpr node represents (key : value) pairs in composite literals.","The direction of a channel type is indicated by a bit mask including one or both of the following constants.","","","An ArrayType node represents an array or slice type.","A StructType node represents a struct type.","A FuncType node represents a function type.","An InterfaceType node represents an interface type.","A MapType node represents a map type.","A ChanType node represents a channel type.","NewIdent creates a new \\[Ident] without position. Useful for ASTs generated by code other than the Go parser.","IsExported reports whether name starts with an upper-case letter.","A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created.","A DeclStmt node represents a declaration in a statement list.","An EmptyStmt node represents an empty statement. The \"position\" of the empty statement is the position of the immediately following (explicit or implicit) semicolon.","A LabeledStmt node represents a labeled statement.","An ExprStmt node represents a (stand-alone) expression in a statement list.","A SendStmt node represents a send statement.","An IncDecStmt node represents an increment or decrement statement.","An AssignStmt node represents an assignment or a short variable declaration.","A GoStmt node represents a go statement.","A DeferStmt node represents a defer statement.","A ReturnStmt node represents a return statement.","A BranchStmt node represents a break, continue, goto, or fallthrough statement.","A BlockStmt node represents a braced statement list.","An IfStmt node represents an if statement.","A CaseClause represents a case of an expression or type switch statement.","A SwitchStmt node represents an expression switch statement.","A TypeSwitchStmt node represents a type switch statement.","A CommClause node represents a case of a select statement.","A SelectStmt node represents a select statement.","A ForStmt represents a for statement.","A RangeStmt represents a for statement with a range clause.","The Spec type stands for any of \\*ImportSpec, \\*ValueSpec, and \\*TypeSpec.","An ImportSpec node represents a single package import.","A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production).","A TypeSpec node represents a type declaration (TypeSpec production).","A BadDecl node is a placeholder for a declaration containing syntax errors for which a correct declaration node cannot be created.","A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration.\n\nRelationship between Tok value and Specs element type:\n\n\ttoken.IMPORT  *ImportSpec\n\ttoken.CONST   *ValueSpec\n\ttoken.TYPE    *TypeSpec\n\ttoken.VAR     *ValueSpec","A FuncDecl node represents a function declaration.","A File node represents a Go source file.\n\nThe Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields.\n\nFor correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the \\[File.Comments] list) or moved accordingly (by updating their positions). A \\[CommentMap] may be used to facilitate some of these operations.\n\nWhether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: except for Doc and \\[Comment] comments directly associated with nodes, the remaining comments are \"free-floating\" (see also issues [#18593](https://go.dev/issue/18593), [#20744](https://go.dev/issue/20744)).","A Package node represents a set of source files collectively building a Go package.\n\nDeprecated: use the type checker [go/types](https://pkg.go.dev/go/types/) instead; see \\[Object].","IsGenerated reports whether the file was generated by a program, not handwritten, by detecting the special comment described at [https://go.dev/s/generatedcode](https://go.dev/s/generatedcode).\n\nThe syntax tree must have been parsed with the \\[parser.ParseComments] flag. Example:\n\n\tf, err := parser.ParseFile(fset, filename, src, parser.ParseComments|parser.PackageClauseOnly)\n\tif err != nil { ... }\n\tgen := ast.IsGenerated(f)","Unparen returns the expression with any enclosing parentheses removed.","A CommentMap maps an AST node to a list of comment groups associated with it. See \\[NewCommentMap] for a description of the association.","NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\" node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment.","FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The \\[File.Comments] list is not changed.\n\nFileExports reports whether there are exported declarations.","PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations; it returns false otherwise.","","FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after filtering.","FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The \\[File.Comments] list is not changed.\n\nFilterFile reports whether there are any top-level declarations left after filtering.","FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.\n\nFilterPackage reports whether there are any top-level declarations left after filtering.","The MergeMode flags control the behavior of \\[MergePackageFiles].","If set, duplicate function declarations are excluded.","If set, comments that are not associated with a specific AST node (as Doc or Comment) are excluded.","If set, duplicate import declarations are excluded.","MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior.","SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.","A FieldFilter may be provided to \\[Fprint] to control the output.","NotNilFilter is a \\[FieldFilter] that returns true for field values that are not nil; it returns false otherwise.","Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).\n\nA non-nil \\[FieldFilter] f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed.","Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).","An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new \\*\\[Object] (pkg), record pkg in the imports map, and then return pkg.\n\nDeprecated: use the type checker [go/types](https://pkg.go.dev/go/types/) instead; see \\[Object].","NewPackage creates a new \\[Package] node from a set of \\[File] nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a \\[scanner.ErrorList] if there were errors.\n\nDeprecated: use the type checker [go/types](https://pkg.go.dev/go/types/) instead; see \\[Object].","A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope.\n\nDeprecated: use the type checker [go/types](https://pkg.go.dev/go/types/) instead; see \\[Object].","NewScope creates a new scope nested in the outer scope.","An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label.\n\nThe Data fields contains object-specific data:\n\n\tKind    Data type         Data value\n\tPkg     *Scope            package scope\n\tCon     int               iota for the respective declaration\n\nDeprecated: The relationship between Idents and Objects cannot be correctly computed without type information. For example, the expression T{K: 0} may denote a struct, map, slice, or array literal, depending on the type of T. If T is a struct, then K refers to a field of T, whereas for the other types it refers to a value in the environment.\n\nNew programs should set the \\[parser.SkipObjectResolution] parser flag to disable syntactic object resolution (which also saves CPU and memory), and instead use the type checker [go/types](https://pkg.go.dev/go/types/) if object resolution is desired. See the Defs, Uses, and Implicits fields of the \\[types.Info] struct for details.","NewObj creates a new object of a given kind and name.","ObjKind describes what an \\[Object] represents.","","","","","","","","A Visitor's Visit method is invoked for each node encountered by \\[Walk]. If the result visitor w is not nil, \\[Walk] visits each of the children of node with the visitor w, followed by a call of w.Visit(nil).","Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).","Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).","Preorder returns an iterator over all the nodes of the syntax tree beneath (and including) the specified root, in depth-first preorder.\n\nFor greater control over the traversal of each subtree, use \\[Inspect].","A Context specifies the supporting context for a build.","Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables if set, or else the compiled code's GOARCH, GOOS, and GOROOT.","An ImportMode controls the behavior of the Import method.","If FindOnly is set, Import stops after locating the directory that should contain the sources for a package. It does not read any files in the directory.","If AllowBinary is set, Import can be satisfied by a compiled package object without corresponding sources.\n\nDeprecated: The supported way to create a compiled-only package is to write source code containing a //go:binary-only-package comment at the top of the file. Such a package will be recognized regardless of this flag setting (because it has source code) and will have BinaryOnly set to true in the returned Package.","If ImportComment is set, parse import comments on package statements. Import returns an error if it finds a comment it cannot understand or finds conflicting comments in multiple source files. See golang.org/s/go14customimport for more information.","By default, Import searches vendor directories that apply in the given source directory before searching the GOROOT and GOPATH roots. If an Import finds and returns a package using a vendor directory, the resulting ImportPath is the complete path to the package, including the path elements leading up to and including \"vendor\". For example, if Import(\"y\", \"x/subdir\", 0) finds \"x/vendor/y\", the returned package's ImportPath is \"x/vendor/y\", not plain \"y\". See golang.org/s/go15vendor for more information.\n\nSetting IgnoreVendor ignores vendor directories.\n\nIn contrast to the package's ImportPath, the returned package's Imports, TestImports, and XTestImports are always the exact import paths from the source files: Import makes no attempt to resolve or check those paths.","A Package describes the Go package found in a directory.","A Directive is a Go directive comment (//go:zzz...) found in a source file.","NoGoError is the error used by \\[Import] to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)","MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages.","Import is shorthand for Default.Import.","ImportDir is shorthand for Default.ImportDir.","ToolDir is the directory containing build tools.","IsLocalImport reports whether the import path is a local import path, like \".\", \"..\", \"./foo\", or \"../foo\".","ArchChar returns \"?\" and an error. In earlier versions of Go, the returned string was used to derive the compiler and linker tool names, the default object file suffix, and the default linker output name. As of Go 1.5, those strings no longer vary by architecture; they are compile, link, .o, and a.out, respectively.","Kind specifies the kind of value represented by a \\[Value].","unknown values","non-numeric values","","numeric values","","","A Value represents the value of a Go constant.","MakeUnknown returns the \\[Unknown] value.","MakeBool returns the \\[Bool] value for b.","MakeString returns the \\[String] value for s.","MakeInt64 returns the \\[Int] value for x.","MakeUint64 returns the \\[Int] value for x.","MakeFloat64 returns the \\[Float] value for x. If x is -0.0, the result is 0.0. If x is not finite, the result is an \\[Unknown].","MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of \\[token.INT], \\[token.FLOAT], \\[token.IMAG], \\[token.CHAR], or \\[token.STRING]. The final argument must be zero. If the literal string syntax is invalid, the result is an \\[Unknown].","BoolVal returns the Go boolean value of x, which must be a \\[Bool] or an \\[Unknown]. If x is \\[Unknown], the result is false.","StringVal returns the Go string value of x, which must be a \\[String] or an \\[Unknown]. If x is \\[Unknown], the result is \"\".","Int64Val returns the Go int64 value of x and whether the result is exact; x must be an \\[Int] or an \\[Unknown]. If the result is not exact, its value is undefined. If x is \\[Unknown], the result is (0, false).","Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an \\[Int] or an \\[Unknown]. If the result is not exact, its value is undefined. If x is \\[Unknown], the result is (0, false).","Float32Val is like \\[Float64Val] but for float32 instead of float64.","Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an \\[Unknown], but not \\[Complex]. For values too small (too close to 0) to represent as float64, \\[Float64Val] silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is \\[Unknown], the result is (0, false).","Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:\n\n\tx Kind             type of result\n\t-----------------------------------------\n\tBool               bool\n\tString             string\n\tInt                int64 or *big.Int\n\tFloat              *big.Float or *big.Rat\n\teverything else    nil","Make returns the \\[Value] for x.\n\n\ttype of x        result Kind\n\t----------------------------\n\tbool             Bool\n\tstring           String\n\tint64            Int\n\t*big.Int         Int\n\t*big.Float       Float\n\t*big.Rat         Float\n\tanything else    Unknown","BitLen returns the number of bits required to represent the absolute value x in binary representation; x must be an \\[Int] or an \\[Unknown]. If x is \\[Unknown], the result is 0.","Sign returns -1, 0, or 1 depending on whether x \\\u003c 0, x == 0, or x \u003e 0; x must be numeric or \\[Unknown]. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is \\[Unknown], the result is 1.","Bytes returns the bytes for the absolute value of x in little- endian binary representation; x must be an \\[Int].","MakeFromBytes returns the \\[Int] value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0.","Num returns the numerator of x; x must be \\[Int], \\[Float], or \\[Unknown]. If x is \\[Unknown], or if it is too large or small to represent as a fraction, the result is \\[Unknown]. Otherwise the result is an \\[Int] with the same sign as x.","Denom returns the denominator of x; x must be \\[Int], \\[Float], or \\[Unknown]. If x is \\[Unknown], or if it is too large or small to represent as a fraction, the result is \\[Unknown]. Otherwise the result is an \\[Int] \u003e= 1.","MakeImag returns the \\[Complex] value x\\*i; x must be \\[Int], \\[Float], or \\[Unknown]. If x is \\[Unknown], the result is \\[Unknown].","Real returns the real part of x, which must be a numeric or unknown value. If x is \\[Unknown], the result is \\[Unknown].","Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is \\[Unknown], the result is \\[Unknown].","ToInt converts x to an \\[Int] value if x is representable as an \\[Int]. Otherwise it returns an \\[Unknown].","ToFloat converts x to a \\[Float] value if x is representable as a \\[Float]. Otherwise it returns an \\[Unknown].","ToComplex converts x to a \\[Complex] value if x is representable as a \\[Complex]. Otherwise it returns an \\[Unknown].","UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec \u003e 0 it specifies the ^ (xor) result size in bits. If y is \\[Unknown], the result is \\[Unknown].","BinaryOp returns the result of the binary expression x op y. The operation must be defined for the operands. If one of the operands is \\[Unknown], the result is \\[Unknown]. BinaryOp doesn't handle comparisons or shifts; use \\[Compare] or \\[Shift] instead.\n\nTo force integer division of \\[Int] operands, use op == \\[token.QUO\\_ASSIGN] instead of \\[token.QUO]; the result is guaranteed to be \\[Int] in this case. Division by zero leads to a run-time panic.","Shift returns the result of the shift expression x op s with op == \\[token.SHL] or \\[token.SHR] (\\\u003c\\\u003c or \u003e\u003e). x must be an \\[Int] or an \\[Unknown]. If x is \\[Unknown], the result is x.","Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is \\[Unknown], the result is false.","ToHTML converts comment text to formatted HTML.\n\nDeprecated: ToHTML cannot identify documentation links in the doc comment, because they depend on knowing what package the text came from, which is not included in this API.\n\nGiven the \\*\\[doc.Package] p where text was found, ToHTML(w, text, nil) can be replaced by:\n\n\tw.Write(p.HTML(text))\n\nwhich is in turn shorthand for:\n\n\tw.Write(p.Printer().HTML(p.Parser().Parse(text)))\n\nIf words may be non-nil, the longer replacement is:\n\n\tparser := p.Parser()\n\tparser.Words = words\n\tw.Write(p.Printer().HTML(parser.Parse(d)))","ToText converts comment text to formatted text.\n\nDeprecated: ToText cannot identify documentation links in the doc comment, because they depend on knowing what package the text came from, which is not included in this API.\n\nGiven the \\*\\[doc.Package] p where text was found, ToText(w, text, \"\", \"\\\\t\", 80) can be replaced by:\n\n\tw.Write(p.Text(text))\n\nIn the general case, ToText(w, text, prefix, codePrefix, width) can be replaced by:\n\n\td := p.Parser().Parse(text)\n\tpr := p.Printer()\n\tpr.TextPrefix = prefix\n\tpr.TextCodePrefix = codePrefix\n\tpr.TextWidth = width\n\tw.Write(pr.Text(d))\n\nSee the documentation for \\[Package.Text] and \\[comment.Printer.Text] for more details.","Package is the documentation for an entire package.","Value is the documentation for a (possibly grouped) var or const declaration.","Type is the documentation for a type declaration.","Func is the documentation for a func declaration.","A Note represents a marked comment starting with \"MARKER(uid): note body\". Any note with a marker of 2 or more upper case \\[A-Z] letters and a uid of at least one character is recognized. The \":\" following the uid is optional. Notes are collected in the Package.Notes map indexed by the notes marker.","Mode values control the operation of \\[New] and \\[NewFromFiles].","AllDecls says to extract documentation for all package-level declarations, not just exported ones.","AllMethods says to show all embedded methods, not just the ones of invisible (unexported) anonymous fields.","PreserveAST says to leave the AST unmodified. Originally, pieces of the AST such as function bodies were nil-ed out to save memory in godoc, but not all programs want that behavior.","New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it. To have the \\[Examples] fields populated, use \\[NewFromFiles] and include the package's \\_test.go files.","NewFromFiles computes documentation for a package.\n\nThe package is specified by a list of \\*ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. \"go/build\".Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath.\n\nExamples found in \\_test.go files are associated with the corresponding type, function, method, or the package, based on their name. If the example has a suffix in its name, it is set in the \\[Example.Suffix] field. \\[Examples] with malformed names are skipped.\n\nOptionally, a single extra argument of type \\[Mode] can be provided to control low-level aspects of the documentation extraction behavior.\n\nNewFromFiles takes ownership of the AST files and may edit them, unless the PreserveAST Mode bit is on.","An Example represents an example function found in a test source file.","Examples returns the examples found in testFiles, sorted by Name field. The Order fields record the order in which the examples were encountered. The Suffix field is not populated when Examples is called directly, it is only populated by \\[NewFromFiles] for examples it finds in \\_test.go files.\n\nPlayable Examples must be in a package whose name ends in \"\\_test\". An Example is \"playable\" (the Play field is non-nil) in either of these circumstances:\n\n  - The example function is self-contained: the function references only identifiers from other packages (or predeclared identifiers, such as \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one example function, zero test, fuzz test, or benchmark function, and at least one top-level function, type, variable, or constant declaration other than the example function.","","IsPredeclared reports whether s is a predeclared identifier.","Synopsis returns a cleaned version of the first sentence in text.\n\nDeprecated: New programs should use \\[Package.Synopsis] instead, which handles links in text properly.","IllegalPrefixes is a list of lower-case prefixes that identify a comment as not being a doc comment. This helps to avoid misinterpreting the common mistake of a copyright notice immediately before a package statement as being a doc comment.","Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be \\*\\[ast.File], \\*\\[printer.CommentedNode], \\[]\\[ast.Decl], \\[]\\[ast.Stmt], or assignment-compatible to \\[ast.Expr], \\[ast.Decl], \\[ast.Spec], or \\[ast.Stmt]. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an \\*\\[ast.File] or a \\*\\[printer.CommentedNode] not wrapping an \\*\\[ast.File]).\n\nThe function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.","Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files.","A Lookup function returns a reader to access package data for a given import path, or an error if no matching package is found.","ForCompiler returns an Importer for importing from installed packages for the compilers \"gc\" and \"gccgo\", or for importing directly from the source if the compiler argument is \"source\". In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).\n\nThe lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.\n\nA lookup function must be provided for correct module-aware operation. Deprecated: If lookup is nil, for backwards-compatibility, the importer will attempt to resolve imports in the $GOPATH workspace.","For calls \\[ForCompiler] with a new FileSet.\n\nDeprecated: Use \\[ForCompiler], which populates a FileSet with the positions of objects created by the importer.","Default returns an Importer for the compiler that built the running binary. If available, the result implements \\[types.ImporterFrom].","A Mode value is a set of flags (or 0). They control the amount of source code parsed and other optional parser functionality.","","","","","","","","","ParseFile parses the source code of a single Go source file and returns the corresponding \\[ast.File] node. The source code may be provided via the filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, \\[]byte, or [io.Reader](https://pkg.go.dev/io/#Reader). If src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other optional parser functionality. If the \\[SkipObjectResolution] mode bit is set (recommended), the object resolution phase of parsing will be skipped, causing File.Scope, File.Unresolved, and all Ident.Obj fields to be nil. Those fields are deprecated; see \\[ast.Object] for details.\n\nPosition information is recorded in the file set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with \\[ast.Bad]\\* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.","ParseDir calls \\[ParseFile] for all files with names ending in \".go\" in the directory specified by path and returns a map of package name -\u003e package AST with all the packages found.\n\nIf filter != nil, only the files with \\[fs.FileInfo] entries passing through the filter (and ending in \".go\") are considered. The mode bits are passed to \\[ParseFile] unchanged. Position information is recorded in fset, which must not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.","ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for \\[ParseFile], but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with \\[ast.Bad]\\* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.","ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.\n\nIf syntax errors were found, the result is a partial AST (with \\[ast.Bad]\\* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.","A Mode value is a set of flags (or 0). They control printing.","","","","","A Config node controls the output of Fprint.","A CommentedNode bundles an AST node and corresponding comments. It may be provided as argument to any of the \\[Fprint] functions.","Fprint \"pretty-prints\" an AST node to output. It calls \\[Config.Fprint] with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.","In an \\[ErrorList], an error is represented by an \\*Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.","ErrorList is a list of \\*Errors. The zero value for an ErrorList is an empty ErrorList ready to use.","PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an \\[ErrorList]. Otherwise it prints the err string.","An ErrorHandler may be provided to \\[Scanner.Init]. If a syntax error is encountered and a handler was installed, the handler is called with a position and an error message. The position points to the beginning of the offending token.","A Scanner holds the scanner's internal state while processing a given text. It can be allocated as part of another data structure but must be initialized via \\[Scanner.Init] before use.","A mode value is a set of flags (or 0). They control scanner behavior.","","Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is \u003e 0.","Pos is a compact encoding of a source position within a file set. It can be converted into a \\[Position] for a more convenient, but much larger, representation.\n\nThe Pos value for a given file is a number in the range \\[base, base+size], where base and size are specified when a file is added to the file set. The difference between a Pos value and the corresponding file base corresponds to the byte offset of that position (represented by the Pos value) from the beginning of the file. Thus, the file base offset is the Pos value representing the first byte in the file.\n\nTo create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using \\[FileSet.AddFile] and then call \\[File.Pos](offset) for that file. Given a Pos value p for a specific file set fset, the corresponding \\[Position] value is obtained by calling fset.Position(p).\n\nPos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p \\\u003c q is true if the file implied by p was added to the respective file set before the file implied by q.","The zero value for \\[Pos] is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other \\[Pos] value. The corresponding \\[Position] value for NoPos is the zero value for \\[Position].","A File is a handle for a file belonging to a \\[FileSet]. A File has a name, size, and line offset table.","A FileSet represents a set of source files. Methods of file sets are synchronized; multiple goroutines may invoke them concurrently.\n\nThe byte offsets for each file in a file set are mapped into distinct (integer) intervals, one interval \\[base, base+size] per file. \\[FileSet.Base] represents the first byte in the file, and size is the corresponding file size. A \\[Pos] value is a value in such an interval. By determining the interval a \\[Pos] value belongs to, the file, its file base, and thus the byte offset (position) the \\[Pos] value is representing can be computed.\n\nWhen adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, \\[FileSet.Base] provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the \\[FileSet.Base] should be used as argument for \\[FileSet.AddFile].\n\nA \\[File] may be removed from a FileSet when it is no longer needed. This may reduce memory usage in a long-running application.","NewFileSet creates a new file set.","Token is the set of lexical tokens of the Go programming language.","Special tokens","","","Identifiers and basic type literals (these tokens stand for classes of literals)","","","","","","Operators and delimiters","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Keywords","","","","","","","","","","","","","","","","","","","","","","","","","additional tokens, handled in an ad-hoc manner","","","","Lookup maps an identifier to its keyword token or \\[IDENT] (if not a keyword).","IsExported reports whether name starts with an upper-case letter.","IsKeyword reports whether name is a Go keyword, such as \"func\" or \"return\".","IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers.","An Alias represents an alias type. Whether or not Alias types are created is controlled by the gotypesalias setting with the GODEBUG environment variable. For gotypesalias=1, alias declarations produce an Alias type. Otherwise, the alias information is only in the type name, which points directly to the actual (aliased) type.","NewAlias creates a new Alias type with the given type name and rhs. rhs must not be nil.","Unalias returns t if it is not an alias type; otherwise it follows t's alias chain until it reaches a non-alias type which is then returned. Consequently, the result is never an alias type.","An Error describes a type-checking error; it implements the error interface. A \"soft\" error is an error that still permits a valid interpretation of a package (such as \"unused variable\"); \"hard\" errors may lead to unpredictable behavior if ignored.","An ArgumentError holds an error associated with an argument index.","An Importer resolves import paths to Packages.\n\nCAUTION: This interface does not support the import of locally vendored packages. See [https://golang.org/s/go15vendor](https://golang.org/s/go15vendor). If possible, external implementations should implement \\[ImporterFrom].","ImportMode is reserved for future use.","An ImporterFrom resolves import paths to packages; it supports vendoring per [https://golang.org/s/go15vendor](https://golang.org/s/go15vendor). Use go/importer to obtain an ImporterFrom implementation.","A Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration.","Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.","TypeAndValue reports the type and value (for constants) of the corresponding expression.","Instance reports the type arguments and instantiated type for type and function instantiations. For type instantiations, \\[Type] will be of dynamic type \\*\\[Named]. For function instantiations, \\[Type] will be of dynamic type \\*Signature.","An Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression.","AssertableTo reports whether a value of type V can be asserted to have type T.\n\nThe behavior of AssertableTo is unspecified in three cases:\n\n  - if T is Typ\\[Invalid]\n  - if V is a generalized interface; i.e., an interface that may only be used as a type constraint in Go code\n  - if T is an uninstantiated generic type","AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nThe behavior of AssignableTo is unspecified if V or T is Typ\\[Invalid] or an uninstantiated generic type.","ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nThe behavior of ConvertibleTo is unspecified if V or T is Typ\\[Invalid] or an uninstantiated generic type.","Implements reports whether type V implements interface T.\n\nThe behavior of Implements is unspecified if V is Typ\\[Invalid] or an uninstantiated generic type.","Satisfies reports whether type V satisfies the constraint T.\n\nThe behavior of Satisfies is unspecified if V is Typ\\[Invalid] or an uninstantiated generic type.","Identical reports whether x and y are identical types. Receivers of \\[Signature] types are ignored.\n\nPredicates such as \\[Identical], \\[Implements], and \\[Satisfies] assume that both operands belong to a consistent collection of symbols (\\[Object] values). For example, two \\[Named] types can be identical only if their \\[Named.Obj] methods return the same \\[TypeName] symbol. A collection of symbols is consistent if, for each logical package whose path is P, the creation of those symbols involved at most one call to \\[NewPackage](P, ...). To ensure consistency, use a single \\[Importer] for all loaded packages and their dependencies. For more information, see [https://github.com/golang/go/issues/57497](https://github.com/golang/go/issues/57497).","IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of \\[Signature] types are ignored.","An Array represents an array type.","NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length.","BasicKind describes the kind of basic type.","","predeclared types","","","","","","","","","","","","","","","","","","types for untyped values","","","","","","","aliases","","BasicInfo is a set of flags describing properties of a basic type.","","","","","","","","","","","A Basic represents a basic type.","A Chan represents a channel type.","A ChanDir value indicates a channel direction.","","","","NewChan returns a new channel type for the given direction and element type.","A Checker maintains the state of the type checker. It must be created with \\[NewChecker].","NewChecker returns a new \\[Checker] instance for a given package. \\[Package] files may be added incrementally via checker.Files.","A Context is an opaque type checking context. It may be used to share identical type instances across type-checked packages or calls to Instantiate. Contexts are safe for concurrent use.\n\nThe use of a shared context does not guarantee that identical instances are deduplicated in all cases.","NewContext creates a new Context.","Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set.\n\nThe meaning of the parameters fset, pkg, and pos is the same as in \\[CheckExpr]. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.","CheckExpr type checks the expression expr as if it had appeared at position pos of package pkg. \\[Type] information about the expression is recorded in info. The expression may be an identifier denoting an uninstantiated generic function or type.\n\nIf pkg == nil, the \\[Universe] scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.\n\nAn error is returned if pos is not within the package or if the node cannot be type-checked.\n\nNote: \\[Eval] and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather than the respective context-specific type.","ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.","WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.","Instantiate instantiates the type orig with the given type arguments targs. orig must be an \\*Alias, \\*Named, or \\*Signature type. If there is no error, the resulting Type is an instantiated type of the same kind (\\*Alias, \\*Named or \\*Signature, respectively).\n\nMethods attached to a \\*Named type are also instantiated, and associated with a new \\*Func that has the same position as the original method, but nil function scope.\n\nIf ctxt is non-nil, it may be used to de-duplicate the instance against previous instances with the same identity. As a special case, generic \\*Signature origin types are only considered identical if they are pointer equivalent, so that instantiating distinct (but possibly identical) signatures will yield different instances. The use of a shared context does not guarantee that identical instances are deduplicated in all cases.\n\nIf validate is set, Instantiate verifies that the number of type arguments and parameters match, and that the type arguments satisfy their respective type constraints. If verification fails, the resulting error may wrap an \\*ArgumentError indicating which type argument did not satisfy its type parameter constraint, and why.\n\nIf validate is not set, Instantiate does not verify the type argument count or whether the type arguments satisfy their constraints. Instantiate is guaranteed to not return an error, but may panic. Specifically, for \\*Signature types, Instantiate will panic immediately if the type argument count is incorrect; for \\*Named types, a panic may occur later inside the \\*Named API.","An Interface represents an interface type.","NewInterface returns a new interface for the given methods and embedded types. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers.\n\nDeprecated: Use NewInterfaceType instead which allows arbitrary embedded types.","NewInterfaceType returns a new interface for the given methods and embedded types. NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers.\n\nTo avoid race conditions, the interface's type set should be computed before concurrent use of the interface, by explicitly calling Complete.","LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding \\*Var or \\*Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups). T must not be nil.\n\nThe last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:\n\n 1. the list of declared methods of a named type; or\n 2. the list of all methods (method set) of an interface type; or\n 3. the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning:\n\n  - If index != nil, the index sequence points to an ambiguous entry (the same name appeared more than once at the same embedding level).\n\n  - If indirect is set, a method with a pointer receiver type was found but there was no pointer on the path from the actual receiver type to the method's formal receiver base type, nor was the receiver addressable.","MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type: either a pointer receiver or wrong signature.\n\nFor non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V).","A Map represents a map type.","NewMap returns a new map for the given key and element types.","A MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a \\[MethodVal] selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set.","NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty.","A Named represents a named (defined) type.","NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a \\*Named.","An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. All objects implement the Object interface.","Id returns name if it is exported, otherwise it returns the name qualified with the package path.","A PkgName represents an imported Go package. PkgNames don't have a type.","NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects.","A Const represents a declared constant.","NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects.","A TypeName represents a name for a (defined or alias) type.","NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.","A Variable represents a declared variable (including function parameters and results, and struct fields).","NewVar returns a new variable. The arguments set the attributes found with all Objects.","NewParam returns a new variable representing a function parameter.","NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name under which the field is accessible.","A Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a \\*Signature. An abstract method may belong to many interfaces due to embedding.","NewFunc returns a new function with the given signature, representing the function's type.","A Label represents a declared label. Labels don't have a type.","NewLabel returns a new label.","A Builtin represents a built-in function. Builtins don't have a valid type.","Nil represents the predeclared value nil.","ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil.","A Package describes a Go package.","NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports.","A Pointer represents a pointer type.","NewPointer returns a new pointer type for the given element (base) type.","IsInterface reports whether t is an interface type.","Comparable reports whether values of type T are comparable.","Default returns the default \"typed\" type for an \"untyped\" type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil.","A Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope.","NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only.","SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).\n\nIf x is a struct or \\*struct, a selector expression x.f may denote a sequence of selection operations x.a.b.c.f. The SelectionKind describes the kind of the final (explicit) operation; all the previous (implicit) operations are always field selections. Each element of Indices specifies an implicit field (a, b, c) by its index in the struct type of the field selection operand.\n\nFor a FieldVal operation, the final selection refers to the field specified by Selection.Obj.\n\nFor a MethodVal operation, the final selection refers to a method. If the \"pointerness\" of the method's declared receiver does not match that of the effective receiver after implicit field selection, then an \u0026 or \\* operation is implicitly applied to the receiver variable or value. So, x.f denotes (\u0026x.a.b.c).f when f requires a pointer receiver but x.a.b.c is a non-pointer variable; and it denotes (\\*x.a.b.c).f when f requires a non-pointer receiver but x.a.b.c is a pointer value.\n\nAll pointer indirections, whether due to implicit or explicit field selections or \\* operations inserted for \"pointerness\", panic if applied to a nil pointer, so a method call x.f() may panic even before the function call.\n\nBy contrast, a MethodExpr operation T.f is essentially equivalent to a function literal of the form:\n\n\tfunc(x T, args) (results) { return x.f(args) }\n\nConsequently, any implicit field selections and \\* operations inserted for \"pointerness\" are not evaluated until the function is called, so a T.f or (\\*T).f expression never panics.","","","","A Selection describes a selector expression x.f. For the declarations:\n\n\ttype T struct{ x int; E }\n\ttype E struct{}\n\tfunc (e E) m() {}\n\tvar p *T\n\nthe following relations exist:\n\n\tSelector    Kind          Recv    Obj    Type       Index     Indirect\n\n\tp.x         FieldVal      T       x      int        {0}       true\n\tp.m         MethodVal     *T      m      func()     {1, 0}    true\n\tT.m         MethodExpr    T       m      func(T)    {1, 0}    false","SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.\n\nExamples:\n\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"","A Signature represents a (non-builtin) function or method type. The receiver is ignored when comparing signatures for identity.","NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type.\n\nDeprecated: Use \\[NewSignatureType] instead which allows for type parameters.","NewSignatureType creates a new function type for the given receiver, receiver type parameters, type parameters, parameters, and results. If variadic is set, params must hold at least one parameter and the last parameter's core type must be of unnamed slice or bytestring type. If recv is non-nil, typeParams must be empty. If recvTypeParams is non-empty, recv must be non-nil.","Sizes defines the sizing functions for package unsafe.","StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:\n\n  - The size of explicitly sized basic types (int16, etc.) is the specified size.\n  - The size of strings and interfaces is 2\\*WordSize.\n  - The size of slices is 3\\*WordSize.\n  - The size of an array of n elements corresponds to the size of a struct of n consecutive fields of the array's element type.\n  - The size of a struct is the offset of the last field plus that field's size. As with all element types, if the struct is used in an array its size must first be aligned to a multiple of the struct's alignment.\n  - All other types have size WordSize.\n  - Arrays and structs are aligned per spec definition; all other types are naturally aligned with a maximum alignment MaxAlign.\n\n\\*StdSizes implements Sizes.","SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\": \"386\", \"amd64\", \"amd64p32\", \"arm\", \"arm64\", \"loong64\", \"mips\", \"mipsle\", \"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"sparc64\", \"wasm\".","A Slice represents a slice type.","NewSlice returns a new slice type for the given element type.","A Struct represents a struct type.","NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags\\[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil.","A Tuple represents an ordered list of variables; a nil \\*Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go.","NewTuple returns a new tuple for the given variables.","A Type represents a type of Go. All types implement the Type interface.","TypeParamList holds a list of type parameters.","TypeList holds a list of types.","A TypeParam represents a type parameter type.","NewTypeParam returns a new TypeParam. Type parameters may be set on a Named type by calling SetTypeParams. Setting a type parameter on more than one type will result in a panic.\n\nThe constraint argument can be nil, and set later via SetConstraint. If the constraint is non-nil, it must be fully defined.","A Qualifier controls how named package-level objects are printed in calls to \\[TypeString], \\[ObjectString], and \\[SelectionString].\n\nThese three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.\n\nUsing a nil Qualifier is equivalent to using (\\*\\[Package]).Path: the object is qualified by the import path, e.g., \"encoding/json.Marshal\".","RelativeTo returns a \\[Qualifier] that fully qualifies members of all packages other than pkg.","TypeString returns the string representation of typ. The \\[Qualifier] controls the printing of package-level objects, and may be nil.","WriteType writes the string representation of typ to buf. The \\[Qualifier] controls the printing of package-level objects, and may be nil.","WriteSignature writes the representation of the signature sig to buf, without a leading \"func\" keyword. The \\[Qualifier] controls the printing of package-level objects, and may be nil.","A Union represents a union of terms embedded in an interface.","NewUnion returns a new \\[Union] type with the given terms. It is an error to create an empty union; they are syntactically not possible.","A Term represents a term in a \\[Union].","NewTerm returns a new union term.","The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes.","The Unsafe package is the package returned by an importer for the import path \"unsafe\".","Typ contains the predeclared \\*Basic types indexed by their corresponding BasicKind.\n\nThe \\*Basic type for Typ\\[Byte] will have the name \"uint8\". Use Universe.Lookup(\"byte\").Type() to obtain the specific alias basic type named \"byte\" (and analogous for \"rune\").","DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only.","Lang returns the Go language version for version x. If x is not a valid version, Lang returns the empty string. For example:\n\n\tLang(\"go1.21rc2\") = \"go1.21\"\n\tLang(\"go1.21.2\") = \"go1.21\"\n\tLang(\"go1.21\") = \"go1.21\"\n\tLang(\"go1\") = \"go1\"\n\tLang(\"bad\") = \"\"\n\tLang(\"1.21\") = \"\"","Compare returns -1, 0, or +1 depending on whether x \\\u003c y, x == y, or x \u003e y, interpreted as Go versions. The versions x and y must begin with a \"go\" prefix: \"go1.21\" not \"1.21\". Invalid versions, including the empty string, compare less than valid versions and equal to each other. The language version \"go1.21\" compares less than the release candidate and eventual releases \"go1.21rc1\" and \"go1.21.0\".","IsValid reports whether the version x is valid.","The size of an Adler-32 checksum in bytes.","New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","Checksum returns the Adler-32 checksum of data.","The size of a CRC-32 checksum in bytes.","IEEE is by far and away the most common CRC-32 polynomial. Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...","Castagnoli's polynomial, used in iSCSI. Has better error detection characteristics than IEEE. [https://dx.doi.org/10.1109/26.231911](https://dx.doi.org/10.1109/26.231911)","Koopman's polynomial. Also has better error detection characteristics than IEEE. [https://dx.doi.org/10.1109/DSN.2002.1028931](https://dx.doi.org/10.1109/DSN.2002.1028931)","Table is a 256-word table representing the polynomial for efficient processing.","IEEETable is the table for the \\[IEEE] polynomial.","MakeTable returns a \\[Table] constructed from the specified polynomial. The contents of this \\[Table] must not be modified.","New creates a new [hash.Hash32](https://pkg.go.dev/hash/#Hash32) computing the CRC-32 checksum using the polynomial represented by the \\[Table]. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","NewIEEE creates a new [hash.Hash32](https://pkg.go.dev/hash/#Hash32) computing the CRC-32 checksum using the \\[IEEE] polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","Update returns the result of adding the bytes in p to the crc.","Checksum returns the CRC-32 checksum of data using the polynomial represented by the \\[Table].","ChecksumIEEE returns the CRC-32 checksum of data using the \\[IEEE] polynomial.","The size of a CRC-64 checksum in bytes.","The ISO polynomial, defined in ISO 3309 and used in HDLC.","The ECMA polynomial, defined in ECMA 182.","Table is a 256-word table representing the polynomial for efficient processing.","MakeTable returns a \\[Table] constructed from the specified polynomial. The contents of this \\[Table] must not be modified.","New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the \\[Table]. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding/#BinaryMarshaler) and [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding/#BinaryUnmarshaler) to marshal and unmarshal the internal state of the hash.","Update returns the result of adding the bytes in p to the crc.","Checksum returns the CRC-64 checksum of data using the polynomial represented by the \\[Table].","New32 returns a new 32-bit FNV-1 [hash.Hash](https://pkg.go.dev/hash/#Hash). Its Sum method will lay the value out in big-endian byte order.","New32a returns a new 32-bit FNV-1a [hash.Hash](https://pkg.go.dev/hash/#Hash). Its Sum method will lay the value out in big-endian byte order.","New64 returns a new 64-bit FNV-1 [hash.Hash](https://pkg.go.dev/hash/#Hash). Its Sum method will lay the value out in big-endian byte order.","New64a returns a new 64-bit FNV-1a [hash.Hash](https://pkg.go.dev/hash/#Hash). Its Sum method will lay the value out in big-endian byte order.","New128 returns a new 128-bit FNV-1 [hash.Hash](https://pkg.go.dev/hash/#Hash). Its Sum method will lay the value out in big-endian byte order.","New128a returns a new 128-bit FNV-1a [hash.Hash](https://pkg.go.dev/hash/#Hash). Its Sum method will lay the value out in big-endian byte order.","A Seed is a random value that selects the specific hash function computed by a \\[Hash]. If two Hashes use the same Seeds, they will compute the same hash values for any given input. If two Hashes use different Seeds, they are very likely to compute distinct hash values for any given input.\n\nA Seed must be initialized by calling \\[MakeSeed]. The zero seed is uninitialized and not valid for use with \\[Hash]'s SetSeed method.\n\nEach Seed value is local to a single process and cannot be serialized or otherwise recreated in a different process.","Bytes returns the hash of b with the given seed.\n\nBytes is equivalent to, but more convenient and efficient than:\n\n\tvar h Hash\n\th.SetSeed(seed)\n\th.Write(b)\n\treturn h.Sum64()","String returns the hash of s with the given seed.\n\nString is equivalent to, but more convenient and efficient than:\n\n\tvar h Hash\n\th.SetSeed(seed)\n\th.WriteString(s)\n\treturn h.Sum64()","A Hash computes a seeded hash of a byte sequence.\n\nThe zero Hash is a valid Hash ready to use. A zero Hash chooses a random seed for itself during the first call to a Reset, Write, Seed, or Sum64 method. For control over the seed, use SetSeed.\n\nThe computed hash values depend only on the initial seed and the sequence of bytes provided to the Hash object, not on the way in which the bytes are provided. For example, the three sequences\n\n\th.Write([]byte{'f','o','o'})\n\th.WriteByte('f'); h.WriteByte('o'); h.WriteByte('o')\n\th.WriteString(\"foo\")\n\nall have the same effect.\n\nHashes are intended to be collision-resistant, even for situations where an adversary controls the byte sequences being hashed.\n\nA Hash is not safe for concurrent use by multiple goroutines, but a Seed is. If multiple goroutines must compute the same seeded hash, each can declare its own Hash and call SetSeed with a common Seed.","MakeSeed returns a new random seed.","CSS encapsulates known safe content that matches any of:\n\n 1. The CSS3 stylesheet production, such as \\`p { color: purple }\\`.\n 2. The CSS3 rule production, such as \\`a\\[href=~\"https:\"].foo#bar\\`.\n 3. CSS3 declaration productions, such as \\`color: red; margin: 2px\\`.\n 4. The CSS3 value production, such as \\`rgba(0, 0, 255, 127)\\`.\n\nSee [https://www.w3.org/TR/css3-syntax/#parsing](https://www.w3.org/TR/css3-syntax/#parsing) and [https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style](https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style)\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.","HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.","HTMLAttr encapsulates an HTML attribute from a trusted source, for example, \\` dir=\"ltr\"\\`.\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.","JS encapsulates a known safe EcmaScript5 Expression, for example, \\`(x + y \\* z())\\`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like \"{ foo: bar() }\\\\n\\['foo']()\", which is both a valid Expression and a valid Program with a very different meaning.\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.\n\nUsing JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.","JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:\n\n\tStringCharacter :: SourceCharacter but not `\\` or LineTerminator\n\t                 | EscapeSequence\n\nNote that LineContinuations are not allowed. JSStr(\"foo\\\\\\\\nbar\") is fine, but JSStr(\"foo\\\\\\\\\\\\nbar\") is not.\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.","URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like \\`javascript:checkThatFormNotEditedBeforeLeavingPage()\\` from a trusted source should go in the page, but by default dynamic \\`javascript:\\` URLs are filtered out since they are a frequently exploited injection vector.\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.","Srcset encapsulates a known safe srcset attribute (see [https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset](https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset)).\n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.","Error describes a problem encountered during template Escaping.","ErrorCode is a code for a kind of error.","OK indicates the lack of an error.","ErrAmbigContext: \"... appears in an ambiguous context within a URL\" Example:\n\n\t\u003ca href=\"\n\t   {{if .C}}\n\t     /path/\n\t   {{else}}\n\t     /search?q=\n\t   {{end}}\n\t   {{.X}}\n\t\"\u003e\n\nDiscussion:\n\n\t {{.X}} is in an ambiguous URL context since, depending on {{.C}},\n\tit may be either a URL suffix or a query parameter.\n\t Moving {{.X}} into the condition removes the ambiguity:\n\t \u003ca href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\"\u003e","ErrBadHTML: \"expected space, attr name, or end of tag, but got ...\",\n\n\t\"... in unquoted attr\", \"... in attribute name\"\n\nExample:\n\n\t\u003ca href = /search?q=foo\u003e\n\t\u003chref=foo\u003e\n\t\u003cform na\u003ce=...\u003e\n\t\u003coption selected\u003c\n\nDiscussion:\n\n\tThis is often due to a typo in an HTML element, but some runes\n\tare banned in tag names, attribute names, and unquoted attribute\n\tvalues because they can tickle parser ambiguities.\n\tQuoting all attributes is the best policy.","ErrBranchEnd: \"{{if}} branches end in different contexts\" Example:\n\n\t{{if .C}}\u003ca href=\"{{end}}{{.X}}\n\nDiscussion:\n\n\tPackage html/template statically examines each path through an\n\t{{if}}, {{range}}, or {{with}} to escape any following pipelines.\n\tThe example is ambiguous since {{.X}} might be an HTML text node,\n\tor a URL prefix in an HTML attribute. The context of {{.X}} is\n\tused to figure out how to escape it, but that context depends on\n\tthe run-time value of {{.C}} which is not statically known.\n\n\tThe problem is usually something like missing quotes or angle\n\tbrackets, or can be avoided by refactoring to put the two contexts\n\tinto different branches of an if, range or with. If the problem\n\tis in a {{range}} over a collection that should never be empty,\n\tadding a dummy {{else}} can help.","ErrEndContext: \"... ends in a non-text context: ...\" Examples:\n\n\t\u003cdiv\n\t\u003cdiv title=\"no close quote\u003e\n\t\u003cscript\u003ef()\n\nDiscussion:\n\n\tExecuted templates should produce a DocumentFragment of HTML.\n\tTemplates that end without closing tags will trigger this error.\n\tTemplates that should not be used in an HTML context or that\n\tproduce incomplete Fragments should not be executed directly.\n\n\t{{define \"main\"}} \u003cscript\u003e{{template \"helper\"}}\u003c/script\u003e {{end}}\n\t{{define \"helper\"}} document.write(' \u003cdiv title=\" ') {{end}}\n\n\t\"helper\" does not produce a valid document fragment, so should\n\tnot be Executed directly.","ErrNoSuchTemplate: \"no such template ...\" Examples:\n\n\t{{define \"main\"}}\u003cdiv {{template \"attrs\"}}\u003e{{end}}\n\t{{define \"attrs\"}}href=\"{{.URL}}\"{{end}}\n\nDiscussion:\n\n\tPackage html/template looks through template calls to compute the\n\tcontext.\n\tHere the {{.URL}} in \"attrs\" must be treated as a URL when called\n\tfrom \"main\", but you will get this error if \"attrs\" is not defined\n\twhen \"main\" is parsed.","ErrOutputContext: \"cannot compute output context for template ...\" Examples:\n\n\t{{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}}\n\nDiscussion:\n\n\tA recursive template does not end in the same context in which it\n\tstarts, and a reliable output context cannot be computed.\n\tLook for typos in the named template.\n\tIf the template should not be called in the named start context,\n\tlook for calls to that template in unexpected contexts.\n\tMaybe refactor recursive templates to not be recursive.","ErrPartialCharset: \"unfinished JS regexp charset in ...\" Example:\n\n\t\u003cscript\u003evar pattern = /foo[{{.Chars}}]/\u003c/script\u003e\n\nDiscussion:\n\n\tPackage html/template does not support interpolation into regular\n\texpression literal character sets.","ErrPartialEscape: \"unfinished escape sequence in ...\" Example:\n\n\t\u003cscript\u003ealert(\"\\{{.X}}\")\u003c/script\u003e\n\nDiscussion:\n\n\tPackage html/template does not support actions following a\n\tbackslash.\n\tThis is usually an error and there are better solutions; for\n\texample\n\t  \u003cscript\u003ealert(\"{{.X}}\")\u003c/script\u003e\n\tshould work, and if {{.X}} is a partial escape sequence such as\n\t\"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`)","ErrRangeLoopReentry: \"on range loop re-entry: ...\" Example:\n\n\t\u003cscript\u003evar x = [{{range .}}'{{.}},{{end}}]\u003c/script\u003e\n\nDiscussion:\n\n\tIf an iteration through a range would cause it to end in a\n\tdifferent context than an earlier pass, there is no single context.\n\tIn the example, there is missing a quote, so it is not clear\n\twhether {{.}} is meant to be inside a JS string or in a JS value\n\tcontext. The second iteration would produce something like\n\n\t  \u003cscript\u003evar x = ['firstValue,'secondValue]\u003c/script\u003e","ErrSlashAmbig: '/' could start a division or regexp. Example:\n\n\t\u003cscript\u003e\n\t  {{if .C}}var x = 1{{end}}\n\t  /-{{.N}}/i.test(x) ? doThis : doThat();\n\t\u003c/script\u003e\n\nDiscussion:\n\n\tThe example above could produce `var x = 1/-2/i.test(s)...`\n\tin which the first '/' is a mathematical division operator or it\n\tcould produce `/-2/i.test(s)` in which the first '/' starts a\n\tregexp literal.\n\tLook for missing semicolons inside branches, and maybe add\n\tparentheses to make it clear which interpretation you intend.","ErrPredefinedEscaper: \"predefined escaper ... disallowed in template\" Example:\n\n\t\u003cdiv class={{. | html}}\u003eHello\u003cdiv\u003e\n\nDiscussion:\n\n\tPackage html/template already contextually escapes all pipelines to\n\tproduce HTML output safe against code injection. Manually escaping\n\tpipeline output using the predefined escapers \"html\" or \"urlquery\" is\n\tunnecessary, and may affect the correctness or safety of the escaped\n\tpipeline output in Go 1.8 and earlier.\n\n\tIn most cases, such as the given example, this error can be resolved by\n\tsimply removing the predefined escaper from the pipeline and letting the\n\tcontextual autoescaper handle the escaping of the pipeline. In other\n\tinstances, where the predefined escaper occurs in the middle of a\n\tpipeline where subsequent commands expect escaped input, e.g.\n\t  {{.X | html | makeALink}}\n\twhere makeALink does\n\t  return `\u003ca href=\"`+input+`\"\u003elink\u003c/a\u003e`\n\tconsider refactoring the surrounding template to make use of the\n\tcontextual autoescaper, i.e.\n\t  \u003ca href=\"{{.X}}\"\u003elink\u003c/a\u003e\n\n\tTo ease migration to Go 1.9 and beyond, \"html\" and \"urlquery\" will\n\tcontinue to be allowed as the last command in a pipeline. However, if the\n\tpipeline occurs in an unquoted attribute value context, \"html\" is\n\tdisallowed. Avoid using \"html\" and \"urlquery\" entirely in new templates.","ErrJSTemplate: \"... appears in a JS template literal\" Example:\n\n\t\u003cscript\u003evar tmpl = `{{.Interp}}`\u003c/script\u003e\n\nDiscussion:\n\n\tPackage html/template does not support actions inside of JS template\n\tliterals.\n\nDeprecated: ErrJSTemplate is no longer returned when an action is present in a JS template literal. Actions inside of JS template literals are now escaped as expected.","HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.","HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.","HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.","JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.","JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.","JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.","URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.","Template is a specialized Template from \"text/template\" that produces a safe HTML document fragment.","New allocates a new HTML template with the given name.","","Must is a helper that wraps a call to a function returning (\\[\\*Template], error) and panics if the error is non-nil. It is intended for use in variable initializations such as\n\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))","ParseFiles creates a new \\[Template] and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned \\[\\*Template] is nil.\n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable.","ParseGlob creates a new \\[Template] and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling \\[ParseFiles] with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.","IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.","ParseFS is like \\[ParseFiles] or \\[ParseGlob] but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.)","Color can convert itself to alpha-premultiplied 16-bits per channel RGBA. The conversion may be lossy.","RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.\n\nAn alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 \\\u003c= C \\\u003c= A.","RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.\n\nAn alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 \\\u003c= C \\\u003c= A.","NRGBA represents a non-alpha-premultiplied 32-bit color.","NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha.","Alpha represents an 8-bit alpha color.","Alpha16 represents a 16-bit alpha color.","Gray represents an 8-bit grayscale color.","Gray16 represents a 16-bit grayscale color.","Model can convert any \\[Color] to one from its own color model. The conversion may be lossy.","ModelFunc returns a \\[Model] that invokes f to implement the conversion.","","","","","","","","","Palette is a palette of colors.","","","","","RGBToYCbCr converts an RGB triple to a Y'CbCr triple.","YCbCrToRGB converts a Y'CbCr triple to an RGB triple.","YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for one luma and two chroma components.\n\nJPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.\n\nConversion between RGB and Y'CbCr is lossy and there are multiple, slightly different formulae for converting between the two. This package follows the JFIF specification at [https://www.w3.org/Graphics/JPEG/jfif3.pdf](https://www.w3.org/Graphics/JPEG/jfif3.pdf).","YCbCrModel is the \\[Model] for Y'CbCr colors.","NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component.","NYCbCrAModel is the \\[Model] for non-alpha-premultiplied Y'CbCr-with-alpha colors.","RGBToCMYK converts an RGB triple to a CMYK quadruple.","CMYKToRGB converts a \\[CMYK] quadruple to an RGB triple.","CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan, magenta, yellow and black.\n\nIt is not associated with any particular color profile.","CMYKModel is the \\[Model] for CMYK colors.","Image is an image.Image with a Set method to change a single pixel.","RGBA64Image extends both the \\[Image] and [image.RGBA64Image](https://pkg.go.dev/image/#RGBA64Image) interfaces with a SetRGBA64 method to change a single pixel. SetRGBA64 is equivalent to calling Set, but it can avoid allocations from converting concrete color types to the \\[color.Color] interface type.","Quantizer produces a palette for an image.","Op is a Porter-Duff compositing operator.","Over specifies “(src in mask) over dst”.","Src specifies “src in mask”.","Drawer contains the \\[Draw] method.","FloydSteinberg is a \\[Drawer] that is the \\[Src] \\[Op] with Floyd-Steinberg error diffusion.","Draw calls \\[DrawMask] with a nil mask.","DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.","","","","Decode reads a GIF image from r and returns the first embedded image as an [image.Image](https://pkg.go.dev/image/#Image).","GIF represents the possibly multiple images stored in a GIF file.","DecodeAll reads a GIF image from r and returns the sequential frames and timing information.","DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image.","Options are the encoding parameters.","EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames.","Encode writes the Image m to w in GIF format.","A FormatError reports that the input is not a valid JPEG.","An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature.","Deprecated: Reader is not used by the [image/jpeg](https://pkg.go.dev/image/jpeg/) package and should not be used by others. It is kept for compatibility.","Decode reads a JPEG image from r and returns it as an [image.Image](https://pkg.go.dev/image/#Image).","DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image.","DefaultQuality is the default quality encoding parameter.","Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better.","Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil \\*\\[Options] is passed.","A FormatError reports that the input is not a valid PNG.","An UnsupportedError reports that the input uses a valid but unimplemented PNG feature.","Decode reads a PNG image from r and returns it as an [image.Image](https://pkg.go.dev/image/#Image). The type of Image returned depends on the PNG contents.","DecodeConfig returns the color model and dimensions of a PNG image without decoding the entire image.","Encoder configures encoding PNG images.","EncoderBufferPool is an interface for getting and returning temporary instances of the \\[EncoderBuffer] struct. This can be used to reuse buffers when encoding multiple images.","EncoderBuffer holds the buffers used for encoding PNG images.","CompressionLevel indicates the compression level.","","","","","Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not [image.NRGBA](https://pkg.go.dev/image/#NRGBA) might be encoded lossily.","Index implements a suffix array for fast substring search.","New creates a new \\[Index] for data. \\[Index] creation time is O(N) for N = len(data).","FormatFileInfo returns a formatted version of info for human readability. Implementations of \\[FileInfo] can call this from a String method. The output for a file named \"hello.go\", 100 bytes, mode 0o644, created January 1, 1970 at noon is\n\n\t-rw-r--r-- 100 1970-01-01 12:00:00 hello.go","FormatDirEntry returns a formatted version of dir for human readability. Implementations of \\[DirEntry] can call this from a String method. The outputs for a directory named subdir and a file named hello.go are:\n\n\td subdir/\n\t- hello.go","An FS provides access to a hierarchical file system.\n\nThe FS interface is the minimum implementation required of the file system. A file system may implement additional interfaces, such as \\[ReadFileFS], to provide additional or optimized functionality.\n\n[testing/fstest.TestFS](https://pkg.go.dev/testing/fstest/#TestFS) may be used to test implementations of an FS for correctness.","ValidPath reports whether the given path name is valid for use in a call to Open.\n\nPath names passed to open are UTF-8-encoded, unrooted, slash-separated sequences of path elements, like “x/y/z”. Path names must not contain an element that is “.” or “..” or the empty string, except for the special case that the root directory is named “.”. Paths must not start or end with a slash: “/x” and “x/” are invalid.\n\nNote that paths are slash-separated on all systems, even Windows. Paths containing other characters such as backslash and colon are accepted as valid, but those characters must never be interpreted by an \\[FS] implementation as path element separators.","A File provides access to a single file. The File interface is the minimum implementation required of the file. Directory files should also implement \\[ReadDirFile]. A file may implement [io.ReaderAt](https://pkg.go.dev/io/#ReaderAt) or [io.Seeker](https://pkg.go.dev/io/#Seeker) as optimizations.","A DirEntry is an entry read from a directory (using the \\[ReadDir] function or a \\[ReadDirFile]'s ReadDir method).","A ReadDirFile is a directory file whose entries can be read with the ReadDir method. Every directory file should implement this interface. (It is permissible for any file to implement this interface, but if so ReadDir should return an error for non-directories.)","","","","","","A FileInfo describes a file and is returned by \\[Stat].","A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is \\[ModeDir] for directories.","The single letters are the abbreviations used by the String method's formatting.","","","","","","","","","","","","","Mask for the type bits. For regular files, none will be set.","","PathError records an error and the operation and file path that caused it.","A GlobFS is a file system with a Glob method.","Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in [path.Match](https://pkg.go.dev/path/#Match). The pattern may describe hierarchical names such as usr/\\*/bin/ed.\n\nGlob ignores file system errors such as I/O errors reading directories. The only possible returned error is [path.ErrBadPattern](https://pkg.go.dev/path/#ErrBadPattern), reporting that the pattern is malformed.\n\nIf fs implements \\[GlobFS], Glob calls fs.Glob. Otherwise, Glob uses \\[ReadDir] to traverse the directory tree and look for matches for the pattern.","ReadDirFS is the interface implemented by a file system that provides an optimized implementation of \\[ReadDir].","ReadDir reads the named directory and returns a list of directory entries sorted by filename.\n\nIf fs implements \\[ReadDirFS], ReadDir calls fs.ReadDir. Otherwise ReadDir calls fs.Open and uses ReadDir and Close on the returned file.","FileInfoToDirEntry returns a \\[DirEntry] that returns information from info. If info is nil, FileInfoToDirEntry returns nil.","ReadFileFS is the interface implemented by a file system that provides an optimized implementation of \\[ReadFile].","ReadFile reads the named file from the file system fs and returns its contents. A successful call returns a nil error, not [io.EOF](https://pkg.go.dev/io/#EOF). (Because ReadFile reads the whole file, the expected EOF from the final Read is not treated as an error to be reported.)\n\nIf fs implements \\[ReadFileFS], ReadFile calls fs.ReadFile. Otherwise ReadFile calls fs.Open and uses Read and Close on the returned \\[File].","A StatFS is a file system with a Stat method.","Stat returns a \\[FileInfo] describing the named file from the file system.\n\nIf fs implements \\[StatFS], Stat calls fs.Stat. Otherwise, Stat opens the \\[File] to stat it.","A SubFS is a file system with a Sub method.","Sub returns an \\[FS] corresponding to the subtree rooted at fsys's dir.\n\nIf dir is \".\", Sub returns fsys unchanged. Otherwise, if fs implements \\[SubFS], Sub returns fsys.Sub(dir). Otherwise, Sub returns a new \\[FS] implementation sub that, in effect, implements sub.Open(name) as fsys.Open(path.Join(dir, name)). The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately.\n\nNote that Sub(os.DirFS(\"/\"), \"prefix\") is equivalent to os.DirFS(\"/prefix\") and that neither of them guarantees to avoid operating system accesses outside \"/prefix\", because the implementation of [os.DirFS](https://pkg.go.dev/os/#DirFS) does not check for symbolic links inside \"/prefix\" that point to other directories. That is, [os.DirFS](https://pkg.go.dev/os/#DirFS) is not a general substitute for a chroot-style security mechanism, and Sub does not change that fact.","SkipDir is used as a return value from \\[WalkDirFunc] to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.","SkipAll is used as a return value from \\[WalkDirFunc] to indicate that all remaining files and directories are to be skipped. It is not returned as an error by any function.","WalkDirFunc is the type of the function called by \\[WalkDir] to visit each file or directory.\n\nThe path argument contains the argument to \\[WalkDir] as a prefix. That is, if WalkDir is called with root argument \"dir\" and finds a file named \"a\" in that directory, the walk function will be called with argument \"dir/a\".\n\nThe d argument is the \\[DirEntry] for the named path.\n\nThe error result returned by the function controls how \\[WalkDir] continues. If the function returns the special value \\[SkipDir], WalkDir skips the current directory (path if d.IsDir() is true, otherwise path's parent directory). If the function returns the special value \\[SkipAll], WalkDir skips all remaining files and directories. Otherwise, if the function returns a non-nil error, WalkDir stops entirely and returns that error.\n\nThe err argument reports an error related to path, signaling that \\[WalkDir] will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause WalkDir to stop walking the entire tree.\n\n\\[WalkDir] calls the function with a non-nil err argument in two cases.\n\nFirst, if the initial \\[Stat] on the root directory fails, WalkDir calls the function with path set to root, d set to nil, and err set to the error from \\[fs.Stat].\n\nSecond, if a directory's ReadDir method (see \\[ReadDirFile]) fails, WalkDir calls the function with path set to the directory's path, d set to an \\[DirEntry] describing the directory, and err set to the error from ReadDir. In this second case, the function is called twice with the path of the directory: the first call is before the directory read is attempted and has err set to nil, giving the function a chance to return \\[SkipDir] or \\[SkipAll] and avoid the ReadDir entirely. The second call is after a failed ReadDir and reports the error from ReadDir. (If ReadDir succeeds, there is no second call.)\n\nThe differences between WalkDirFunc compared to [path/filepath.WalkFunc](https://pkg.go.dev/path/filepath/#WalkFunc) are:\n\n  - The second argument has type \\[DirEntry] instead of \\[FileInfo].\n  - The function is called before reading a directory, to allow \\[SkipDir] or \\[SkipAll] to bypass the directory read entirely or skip all remaining files and directories respectively.\n  - If a directory read fails, the function is called a second time for that directory to report the error.","WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.\n\nAll errors that arise visiting files and directories are filtered by fn: see the \\[fs.WalkDirFunc] documentation for details.\n\nThe files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory.\n\nWalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked.","ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io/#ReadAll).","ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [os.ReadFile](https://pkg.go.dev/os/#ReadFile).","WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions.\n\nDeprecated: As of Go 1.16, this function simply calls [os.WriteFile](https://pkg.go.dev/os/#WriteFile).","ReadDir reads the directory named by dirname and returns a list of fs.FileInfo for the directory's contents, sorted by filename. If an error occurs reading the directory, ReadDir returns no directory entries along with the error.\n\nDeprecated: As of Go 1.16, [os.ReadDir](https://pkg.go.dev/os/#ReadDir) is a more efficient and correct choice: it returns a list of \\[fs.DirEntry] instead of \\[fs.FileInfo], and it returns partial results in the case of an error midway through reading a directory.\n\nIf you must continue obtaining a list of \\[fs.FileInfo], you still can:\n\n\tentries, err := os.ReadDir(dirname)\n\tif err != nil { ... }\n\tinfos := make([]fs.FileInfo, 0, len(entries))\n\tfor _, entry := range entries {\n\t\tinfo, err := entry.Info()\n\t\tif err != nil { ... }\n\t\tinfos = append(infos, info)\n\t}","NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.\n\nDeprecated: As of Go 1.16, this function simply calls [io.NopCloser](https://pkg.go.dev/io/#NopCloser).","Discard is an io.Writer on which all Write calls succeed without doing anything.\n\nDeprecated: As of Go 1.16, this value is simply [io.Discard](https://pkg.go.dev/io/#Discard).","TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting \\*[os.File](https://pkg.go.dev/os/#File). The filename is generated by taking pattern and adding a random string to the end. If pattern includes a \"\\*\", the random string replaces the last \"\\*\". If dir is the empty string, TempFile uses the default directory for temporary files (see [os.TempDir](https://pkg.go.dev/os/#TempDir)). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.\n\nDeprecated: As of Go 1.17, this function simply calls [os.CreateTemp](https://pkg.go.dev/os/#CreateTemp).","TempDir creates a new temporary directory in the directory dir. The directory name is generated by taking pattern and applying a random string to the end. If pattern includes a \"\\*\", the random string replaces the last \"\\*\". TempDir returns the name of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see [os.TempDir](https://pkg.go.dev/os/#TempDir)). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.\n\nDeprecated: As of Go 1.17, this function simply calls [os.MkdirTemp](https://pkg.go.dev/os/#MkdirTemp).","An Attr is a key-value pair.","String returns an Attr for a string value.","Int64 returns an Attr for an int64.","Int converts an int to an int64 and returns an Attr with that value.","Uint64 returns an Attr for a uint64.","Float64 returns an Attr for a floating-point number.","Bool returns an Attr for a bool.","Time returns an Attr for a [time.Time](https://pkg.go.dev/time/#Time). It discards the monotonic portion.","Duration returns an Attr for a [time.Duration](https://pkg.go.dev/time/#Duration).","Group returns an Attr for a Group \\[Value]. The first argument is the key; the remaining arguments are converted to Attrs as in \\[Logger.Log].\n\nUse Group to collect several key-value pairs under a single key on a log line, or as the result of LogValue in order to log a single value as multiple Attrs.","Any returns an Attr for the supplied value. See \\[AnyValue] for how values are treated.","A Handler handles log records produced by a Logger.\n\nA typical handler may print log records to standard error, or write them to a file or database, or perhaps augment them with additional attributes and pass them on to another handler.\n\nAny of the Handler's methods may be called concurrently with itself or with other methods. It is the responsibility of the Handler to manage this concurrency.\n\nUsers of the slog package should not invoke Handler methods directly. They should use the methods of \\[Logger] instead.","HandlerOptions are options for a \\[TextHandler] or \\[JSONHandler]. A zero HandlerOptions consists entirely of default values.","TimeKey is the key used by the built-in handlers for the time when the log method is called. The associated Value is a [time.Time](https://pkg.go.dev/time/#Time).","LevelKey is the key used by the built-in handlers for the level of the log call. The associated value is a \\[Level].","MessageKey is the key used by the built-in handlers for the message of the log call. The associated value is a string.","SourceKey is the key used by the built-in handlers for the source file and line of the log call. The associated value is a \\*\\[Source].","JSONHandler is a \\[Handler] that writes Records to an [io.Writer](https://pkg.go.dev/io/#Writer) as line-delimited JSON objects.","NewJSONHandler creates a \\[JSONHandler] that writes to w, using the given options. If opts is nil, the default options are used.","A Level is the importance or severity of a log event. The higher the level, the more important or severe the event.","","","","","A LevelVar is a \\[Level] variable, to allow a \\[Handler] level to change dynamically. It implements \\[Leveler] as well as a Set method, and it is safe for use by multiple goroutines. The zero LevelVar corresponds to \\[LevelInfo].","A Leveler provides a \\[Level] value.\n\nAs Level itself implements Leveler, clients typically supply a Level value wherever a Leveler is needed, such as in \\[HandlerOptions]. Clients who need to vary the level dynamically can provide a more complex Leveler implementation such as \\*\\[LevelVar].","SetLogLoggerLevel controls the level for the bridge to the [log](https://pkg.go.dev/log/) package.\n\nBefore \\[SetDefault] is called, slog top-level logging functions call the default [log.Logger](https://pkg.go.dev/log/#Logger). In that mode, SetLogLoggerLevel sets the minimum level for those calls. By default, the minimum level is Info, so calls to \\[Debug] (as well as top-level logging calls at lower levels) will not be passed to the log.Logger. After calling\n\n\tslog.SetLogLoggerLevel(slog.LevelDebug)\n\ncalls to \\[Debug] will be passed to the log.Logger.\n\nAfter \\[SetDefault] is called, calls to the default [log.Logger](https://pkg.go.dev/log/#Logger) are passed to the slog default handler. In that mode, SetLogLoggerLevel sets the level at which those calls are logged. That is, after calling\n\n\tslog.SetLogLoggerLevel(slog.LevelDebug)\n\nA call to [log.Printf](https://pkg.go.dev/log/#Printf) will result in output at level \\[LevelDebug].\n\nSetLogLoggerLevel returns the previous value.","Default returns the default \\[Logger].","SetDefault makes l the default \\[Logger], which is used by the top-level functions \\[Info], \\[Debug] and so on. After this call, output from the log package's default Logger (as with [log.Print](https://pkg.go.dev/log/#Print), etc.) will be logged using l's Handler, at a level controlled by \\[SetLogLoggerLevel].","A Logger records structured information about each call to its Log, Debug, Info, Warn, and Error methods. For each call, it creates a \\[Record] and passes it to a \\[Handler].\n\nTo create a new Logger, call \\[New] or a Logger method that begins \"With\".","New creates a new Logger with the given non-nil Handler.","With calls \\[Logger.With] on the default logger.","NewLogLogger returns a new [log.Logger](https://pkg.go.dev/log/#Logger) such that each call to its Output method dispatches a Record to the specified handler. The logger acts as a bridge from the older log API to newer structured logging handlers.","Debug calls \\[Logger.Debug] on the default logger.","DebugContext calls \\[Logger.DebugContext] on the default logger.","Info calls \\[Logger.Info] on the default logger.","InfoContext calls \\[Logger.InfoContext] on the default logger.","Warn calls \\[Logger.Warn] on the default logger.","WarnContext calls \\[Logger.WarnContext] on the default logger.","Error calls \\[Logger.Error] on the default logger.","ErrorContext calls \\[Logger.ErrorContext] on the default logger.","Log calls \\[Logger.Log] on the default logger.","LogAttrs calls \\[Logger.LogAttrs] on the default logger.","A Record holds information about a log event. Copies of a Record share state. Do not modify a Record after handing out a copy to it. Call \\[NewRecord] to create a new Record. Use \\[Record.Clone] to create a copy with no shared state.","NewRecord creates a \\[Record] from the given arguments. Use \\[Record.AddAttrs] to add attributes to the Record.\n\nNewRecord is intended for logging APIs that want to support a \\[Handler] as a backend.","Source describes the location of a line of source code.","TextHandler is a \\[Handler] that writes Records to an [io.Writer](https://pkg.go.dev/io/#Writer) as a sequence of key=value pairs separated by spaces and followed by a newline.","NewTextHandler creates a \\[TextHandler] that writes to w, using the given options. If opts is nil, the default options are used.","A Value can represent any Go value, but unlike type any, it can represent most small values without an allocation. The zero Value corresponds to nil.","Kind is the kind of a \\[Value].","","","","","","","","","","","StringValue returns a new \\[Value] for a string.","IntValue returns a \\[Value] for an int.","Int64Value returns a \\[Value] for an int64.","Uint64Value returns a \\[Value] for a uint64.","Float64Value returns a \\[Value] for a floating-point number.","BoolValue returns a \\[Value] for a bool.","TimeValue returns a \\[Value] for a [time.Time](https://pkg.go.dev/time/#Time). It discards the monotonic portion.","DurationValue returns a \\[Value] for a [time.Duration](https://pkg.go.dev/time/#Duration).","GroupValue returns a new \\[Value] for a list of Attrs. The caller must not subsequently mutate the argument slice.","AnyValue returns a \\[Value] for the supplied value.\n\nIf the supplied value is of type Value, it is returned unmodified.\n\nGiven a value of one of Go's predeclared string, bool, or (non-complex) numeric types, AnyValue returns a Value of kind \\[KindString], \\[KindBool], \\[KindUint64], \\[KindInt64], or \\[KindFloat64]. The width of the original numeric type is not preserved.\n\nGiven a [time.Time](https://pkg.go.dev/time/#Time) or [time.Duration](https://pkg.go.dev/time/#Duration) value, AnyValue returns a Value of kind \\[KindTime] or \\[KindDuration]. The monotonic time is not preserved.\n\nFor nil, or values of all other types, including named types whose underlying type is numeric, AnyValue returns a value of kind \\[KindAny].","A LogValuer is any Go value that can convert itself into a Value for logging.\n\nThis mechanism may be used to defer expensive operations until they are needed, or to expand a single value into a sequence of components.","The Priority is a combination of the syslog facility and severity. For example, \\[LOG\\_ALERT] | \\[LOG\\_FTP] sends an alert severity message from the FTP facility. The default severity is \\[LOG\\_EMERG]; the default facility is \\[LOG\\_KERN].","From /usr/include/sys/syslog.h. These are the same on Linux, BSD, and OS X.","","","","","","","","From /usr/include/sys/syslog.h. These are the same up to LOG\\_FTP on Linux, BSD, and OS X.","","","","","","","","","","","","","","","","","","","","A Writer is a connection to a syslog server.","New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the [os.Args](https://pkg.go.dev/os/#Args)\\[0] is used.","Dial establishes a connection to a log daemon by connecting to address raddr on the specified network. Each write to the returned writer sends a log message with the facility and severity (from priority) and tag. If tag is empty, the [os.Args](https://pkg.go.dev/os/#Args)\\[0] is used. If network is empty, Dial will connect to the local syslog server. Otherwise, see the documentation for net.Dial for valid values of network and raddr.","NewLogger creates a [log.Logger](https://pkg.go.dev/log/#Logger) whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to [log.New](https://pkg.go.dev/log/#New) to create the Logger.","A Word represents a single digit of a multi-precision unsigned integer.","A nonzero finite Float represents a multi-precision floating point number\n\n\tsign × mantissa × 2**exponent\n\nwith 0.5 \\\u003c= mantissa \\\u003c 1.0, and MinExp \\\u003c= exponent \\\u003c= MaxExp. A Float may also be zero (+0, -0) or infinite (+Inf, -Inf). All Floats are ordered, and the ordering of two Floats x and y is defined by x.Cmp(y).\n\nEach Float value also has a precision, rounding mode, and accuracy. The precision is the maximum number of mantissa bits available to represent the value. The rounding mode specifies how a result should be rounded to fit into the mantissa bits, and accuracy describes the rounding error with respect to the exact result.\n\nUnless specified otherwise, all operations (including setters) that specify a \\*Float variable for the result (usually via the receiver with the exception of \\[Float.MantExp]), round the numeric result according to the precision and rounding mode of the result variable.\n\nIf the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).\n\nBy setting the desired precision to 24 or 53 and using matching rounding mode (typically \\[ToNearestEven]), Float operations produce the same results as the corresponding float32 or float64 IEEE 754 arithmetic for operands that correspond to normal (i.e., not denormal) float32 or float64 numbers. Exponent underflow and overflow lead to a 0 or an Infinity for different values than IEEE 754 because Float exponents have a much larger range.\n\nThe zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode \\[ToNearestEven].\n\nOperations always take pointer arguments (\\*Float) rather than Float values, and each unique Float value requires its own unique \\*Float pointer. To \"copy\" a Float value, an existing (or newly allocated) Float must be set to a new value using the \\[Float.Set] method; shallow copies of Floats are not supported and may lead to errors.","An ErrNaN panic is raised by a \\[Float] operation that would lead to a NaN under IEEE 754 rules. An ErrNaN implements the error interface.","NewFloat allocates and returns a new \\[Float] set to x, with precision 53 and rounding mode \\[ToNearestEven]. NewFloat panics with \\[ErrNaN] if x is a NaN.","","","","RoundingMode determines how a \\[Float] value is rounded to the desired precision. Rounding may change the \\[Float] value; the rounding error is described by the \\[Float]'s \\[Accuracy].","","","","","","","Accuracy describes the rounding error produced by the most recent operation that generated a \\[Float] value, relative to the exact value.","","","","ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.","An Int represents a signed multi-precision integer. The zero value for an Int represents the value 0.\n\nOperations always take pointer arguments (\\*Int) rather than Int values, and each unique Int value requires its own unique \\*Int pointer. To \"copy\" an Int value, an existing (or newly allocated) Int must be set to a new value using the \\[Int.Set] method; shallow copies of Ints are not supported and may lead to errors.\n\nNote that methods may leak the Int's value through timing side-channels. Because of this and because of the scope and complexity of the implementation, Int is not well-suited to implement cryptographic operations. The standard library avoids exposing non-trivial Int methods to attacker-controlled inputs and the determination of whether a bug in math/big is considered a security vulnerability might depend on the impact on the standard library.","NewInt allocates and returns a new \\[Int] set to x.","Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.","MaxBase is the largest number base accepted for string conversions.","A Rat represents a quotient a/b of arbitrary precision. The zero value for a Rat represents the value 0.\n\nOperations always take pointer arguments (\\*Rat) rather than Rat values, and each unique Rat value requires its own unique \\*Rat pointer. To \"copy\" a Rat value, an existing (or newly allocated) Rat must be set to a new value using the \\[Rat.Set] method; shallow copies of Rats are not supported and may lead to errors.","NewRat creates a new \\[Rat] with numerator a and denominator b.","UintSize is the size of a uint in bits.","LeadingZeros returns the number of leading zero bits in x; the result is \\[UintSize] for x == 0.","LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.","LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.","LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.","LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.","TrailingZeros returns the number of trailing zero bits in x; the result is \\[UintSize] for x == 0.","TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.","TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.","TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.","TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.","OnesCount returns the number of one bits (\"population count\") in x.","OnesCount8 returns the number of one bits (\"population count\") in x.","OnesCount16 returns the number of one bits (\"population count\") in x.","OnesCount32 returns the number of one bits (\"population count\") in x.","OnesCount64 returns the number of one bits (\"population count\") in x.","RotateLeft returns the value of x rotated left by (k mod \\[UintSize]) bits. To rotate x right by k bits, call RotateLeft(x, -k).\n\nThis function's execution time does not depend on the inputs.","RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).\n\nThis function's execution time does not depend on the inputs.","RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).\n\nThis function's execution time does not depend on the inputs.","RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).\n\nThis function's execution time does not depend on the inputs.","RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).\n\nThis function's execution time does not depend on the inputs.","Reverse returns the value of x with its bits in reversed order.","Reverse8 returns the value of x with its bits in reversed order.","Reverse16 returns the value of x with its bits in reversed order.","Reverse32 returns the value of x with its bits in reversed order.","Reverse64 returns the value of x with its bits in reversed order.","ReverseBytes returns the value of x with its bytes in reversed order.\n\nThis function's execution time does not depend on the inputs.","ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nThis function's execution time does not depend on the inputs.","ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nThis function's execution time does not depend on the inputs.","ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nThis function's execution time does not depend on the inputs.","Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.","Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.","Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.","Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.","Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.","Add returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.\n\nThis function's execution time does not depend on the inputs.","Add32 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.\n\nThis function's execution time does not depend on the inputs.","Add64 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.\n\nThis function's execution time does not depend on the inputs.","Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.\n\nThis function's execution time does not depend on the inputs.","Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.\n\nThis function's execution time does not depend on the inputs.","Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.\n\nThis function's execution time does not depend on the inputs.","Mul returns the full-width product of x and y: (hi, lo) = x \\* y with the product bits' upper half returned in hi and the lower half returned in lo.\n\nThis function's execution time does not depend on the inputs.","Mul32 returns the 64-bit product of x and y: (hi, lo) = x \\* y with the product bits' upper half returned in hi and the lower half returned in lo.\n\nThis function's execution time does not depend on the inputs.","Mul64 returns the 128-bit product of x and y: (hi, lo) = x \\* y with the product bits' upper half returned in hi and the lower half returned in lo.\n\nThis function's execution time does not depend on the inputs.","Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div panics for y == 0 (division by zero) or y \\\u003c= hi (quotient overflow).","Div32 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div32 panics for y == 0 (division by zero) or y \\\u003c= hi (quotient overflow).","Div64 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div64 panics for y == 0 (division by zero) or y \\\u003c= hi (quotient overflow).","Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0 (division by zero) but, unlike Div, it doesn't panic on a quotient overflow.","Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y == 0 (division by zero) but, unlike \\[Div32], it doesn't panic on a quotient overflow.","Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics for y == 0 (division by zero) but, unlike \\[Div64], it doesn't panic on a quotient overflow.","Abs returns the absolute value (also called the modulus) of x.","Asin returns the inverse sine of x.","Asinh returns the inverse hyperbolic sine of x.","Acos returns the inverse cosine of x.","Acosh returns the inverse hyperbolic cosine of x.","Atan returns the inverse tangent of x.","Atanh returns the inverse hyperbolic tangent of x.","Conj returns the complex conjugate of x.","Exp returns e\\*\\*x, the base-e exponential of x.","IsInf reports whether either real(x) or imag(x) is an infinity.","Inf returns a complex infinity, complex(+Inf, +Inf).","IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity.","NaN returns a complex “not-a-number” value.","Log returns the natural logarithm of x.","Log10 returns the decimal logarithm of x.","Phase returns the phase (also called the argument) of x. The returned value is in the range \\[-Pi, Pi].","Polar returns the absolute value r and phase θ of x, such that x = r \\* e\\*\\*θi. The phase is in the range \\[-Pi, Pi].","Pow returns x\\*\\*y, the base-x exponential of y. For generalized compatibility with [math.Pow](https://pkg.go.dev/math/#Pow):\n\n\tPow(0, ±0) returns 1+0i\n\tPow(0, c) for real(c)\u003c0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.","Rect returns the complex number x with polar coordinates r, θ.","Sin returns the sine of x.","Sinh returns the hyperbolic sine of x.","Cos returns the cosine of x.","Cosh returns the hyperbolic cosine of x.","Sqrt returns the square root of x. The result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x).","Tan returns the tangent of x.","Tanh returns the hyperbolic tangent of x.","Cot returns the cotangent of x.","A Source represents a source of uniformly-distributed pseudo-random int64 values in the range \\[0, 1\\\u003c\\\u003c63).\n\nA Source is not safe for concurrent use by multiple goroutines.","A Source64 is a \\[Source] that can also generate uniformly-distributed pseudo-random uint64 values in the range \\[0, 1\\\u003c\\\u003c64) directly. If a \\[Rand] r's underlying \\[Source] s implements Source64, then r.Uint64 returns the result of one call to s.Uint64 instead of making two calls to s.Int63.","NewSource returns a new pseudo-random \\[Source] seeded with the given value. Unlike the default \\[Source] used by top-level functions, this source is not safe for concurrent use by multiple goroutines. The returned \\[Source] implements \\[Source64].","A Rand is a source of random numbers.","New returns a new \\[Rand] that uses random values from src to generate other random values.","Seed uses the provided seed value to initialize the default Source to a deterministic state. Seed values that have the same remainder when divided by 2³¹-1 generate the same pseudo-random sequence. Seed, unlike the \\[Rand.Seed] method, is safe for concurrent use.\n\nIf Seed is not called, the generator is seeded randomly at program startup.\n\nPrior to Go 1.20, the generator was seeded like Seed(1) at program startup. To force the old behavior, call Seed(1) at program startup. Alternately, set GODEBUG=randautoseed=0 in the environment before making any calls to functions in this package.\n\nDeprecated: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator.","Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default \\[Source].","Uint32 returns a pseudo-random 32-bit value as a uint32 from the default \\[Source].","Uint64 returns a pseudo-random 64-bit value as a uint64 from the default \\[Source].","Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default \\[Source].","Int returns a non-negative pseudo-random int from the default \\[Source].","Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval \\[0,n) from the default \\[Source]. It panics if n \\\u003c= 0.","Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval \\[0,n) from the default \\[Source]. It panics if n \\\u003c= 0.","Intn returns, as an int, a non-negative pseudo-random number in the half-open interval \\[0,n) from the default \\[Source]. It panics if n \\\u003c= 0.","Float64 returns, as a float64, a pseudo-random number in the half-open interval \\[0.0,1.0) from the default \\[Source].","Float32 returns, as a float32, a pseudo-random number in the half-open interval \\[0.0,1.0) from the default \\[Source].","Perm returns, as a slice of n ints, a pseudo-random permutation of the integers in the half-open interval \\[0,n) from the default \\[Source].","Shuffle pseudo-randomizes the order of elements using the default \\[Source]. n is the number of elements. Shuffle panics if n \\\u003c 0. swap swaps the elements with indexes i and j.","Read generates len(p) random bytes from the default \\[Source] and writes them into p. It always returns len(p) and a nil error. Read, unlike the \\[Rand.Read] method, is safe for concurrent use.\n\nDeprecated: For almost all use cases, [crypto/rand.Read](https://pkg.go.dev/crypto/rand/#Read) is more appropriate. If a deterministic source is required, use [math/rand/v2.ChaCha8.Read](https://pkg.go.dev/math/rand/v2/#ChaCha8.Read).","NormFloat64 returns a normally distributed float64 in the range \\[-[math.MaxFloat64](https://pkg.go.dev/math/#MaxFloat64), +\\[math.MaxFloat64]] with standard normal distribution (mean = 0, stddev = 1) from the default \\[Source]. To produce a different normal distribution, callers can adjust the output using:\n\n\tsample = NormFloat64() * desiredStdDev + desiredMean","ExpFloat64 returns an exponentially distributed float64 in the range (0, +\\[math.MaxFloat64]] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default \\[Source]. To produce a distribution with a different rate parameter, callers can adjust the output using:\n\n\tsample = ExpFloat64() / desiredRateParameter","A Zipf generates Zipf distributed variates.","NewZipf returns a \\[Zipf] variate generator. The generator generates values k ∈ \\[0, imax] such that P(k) is proportional to (v + k) \\*\\* (-s). Requirements: s \u003e 1 and v \u003e= 1.","ErrMessageTooLarge is returned by ReadForm if the message form data is too large to be processed.","Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the \\[\\*FileHeader]'s Open method. Its Value parts are stored as strings. Both are keyed by field name.","A FileHeader describes a file part of a multipart request.","File is an interface to access the file part of a multipart message. Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an \\*os.File.","A Part represents a single part in a multipart body.","NewReader creates a new multipart \\[Reader] reading from r using the given MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of the message's \"Content-Type\" header. Use [mime.ParseMediaType](https://pkg.go.dev/mime/#ParseMediaType) to parse such headers.","Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.","A Writer generates multipart messages.","NewWriter returns a new multipart \\[Writer] with a random boundary, writing to w.","Reader is a quoted-printable decoder.","NewReader returns a quoted-printable reader, decoding from r.","A Writer is a quoted-printable writer that implements [io.WriteCloser](https://pkg.go.dev/io/#WriteCloser).","NewWriter returns a new \\[Writer] that writes to w.","A Client is an HTTP client. Its zero value (\\[DefaultClient]) is a usable client that uses \\[DefaultTransport].\n\nThe \\[Client.Transport] typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a \\[RoundTripper] (such as \\[Transport]) and additionally handles HTTP details such as cookies and redirects.\n\nWhen following redirects, the Client will forward all headers set on the initial \\[Request] except:\n\n  - when forwarding sensitive headers like \"Authorization\", \"WWW-Authenticate\", and \"Cookie\" to untrusted targets. These headers will be ignored when following a redirect to a domain that is not a subdomain match or exact match of the initial domain. For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\" will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n  - when forwarding the \"Cookie\" header with a non-nil cookie Jar. Since each redirect may mutate the state of the cookie jar, a redirect may possibly alter a cookie set in the initial request. When forwarding the \"Cookie\" header, any mutated cookies will be omitted, with the expectation that the Jar will insert those mutated cookies with the updated values (assuming the origin matches). If Jar is nil, the initial cookies are forwarded without change.","DefaultClient is the default \\[Client] and is used by \\[Get], \\[Head], and \\[Post].","RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the \\[Response] for a given \\[Request].\n\nA RoundTripper must be safe for concurrent use by multiple goroutines.","ErrSchemeMismatch is returned when a server returns an HTTP response to an HTTPS client.","Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:\n\n\t301 (Moved Permanently)\n\t302 (Found)\n\t303 (See Other)\n\t307 (Temporary Redirect)\n\t308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type \\[\\*url.Error]. The url.Error value's Timeout method will report true if the request timed out.\n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use \\[NewRequest] and DefaultClient.Do.\n\nTo make a request with a specified context.Context, use \\[NewRequestWithContext] and DefaultClient.Do.","ErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed.","Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an [io.Closer](https://pkg.go.dev/io/#Closer), it is closed after the request.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use \\[NewRequest] and DefaultClient.Do.\n\nSee the \\[Client.Do] method documentation for details on how redirects are handled.\n\nTo make a request with a specified context.Context, use \\[NewRequestWithContext] and DefaultClient.Do.","PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use \\[NewRequest] and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the \\[Client.Do] method documentation for details on how redirects are handled.\n\nTo make a request with a specified [context.Context](https://pkg.go.dev/context/#Context), use \\[NewRequestWithContext] and DefaultClient.Do.","Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:\n\n\t301 (Moved Permanently)\n\t302 (Found)\n\t303 (See Other)\n\t307 (Temporary Redirect)\n\t308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head.\n\nTo make a request with a specified [context.Context](https://pkg.go.dev/context/#Context), use \\[NewRequestWithContext] and DefaultClient.Do.","A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request.\n\nSee [https://tools.ietf.org/html/rfc6265](https://tools.ietf.org/html/rfc6265) for details.","SameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks.\n\nSee [https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for details.","","","","","ParseCookie parses a Cookie header value and returns all the cookies which were set in it. Since the same cookie name can appear multiple times the returned Values can contain more than one value for a given key.","ParseSetCookie parses a Set-Cookie header value and returns a cookie. It returns an error on syntax error.","SetCookie adds a Set-Cookie header to the provided \\[ResponseWriter]'s headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.","NewFileTransport returns a new \\[RoundTripper], serving the provided \\[FileSystem]. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.\n\nThe typical use case for NewFileTransport is to register the \"file\" protocol with a \\[Transport], as in:\n\n\tt := \u0026http.Transport{}\n\tt.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n\tc := \u0026http.Client{Transport: t}\n\tres, err := c.Get(\"file:///etc/passwd\")\n\t...","NewFileTransportFS returns a new \\[RoundTripper], serving the provided file system fsys. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. The files provided by fsys must implement [io.Seeker](https://pkg.go.dev/io/#Seeker).\n\nThe typical use case for NewFileTransportFS is to register the \"file\" protocol with a \\[Transport], as in:\n\n\tfsys := os.DirFS(\"/\")\n\tt := \u0026http.Transport{}\n\tt.RegisterProtocol(\"file\", http.NewFileTransportFS(fsys))\n\tc := \u0026http.Client{Transport: t}\n\tres, err := c.Get(\"file:///etc/passwd\")\n\t...","A Dir implements \\[FileSystem] using the native file system restricted to a specific directory tree.\n\nWhile the \\[FileSystem.Open] method takes '/'-separated paths, a Dir's string value is a directory path on the native file system, not a URL, so it is separated by \\[filepath.Separator], which isn't necessarily '/'.\n\nNote that Dir could expose sensitive files and directories. Dir will follow symlinks pointing out of the directory tree, which can be especially dangerous if serving from a directory in which users are able to create arbitrary symlinks. Dir will also allow access to files and directories starting with a period, which could expose sensitive directories like .git or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.\n\nAn empty Dir is treated as \".\".","A FileSystem implements access to a collection of named files. The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention. See the \\[FileServer] function to convert a FileSystem to a \\[Handler].\n\nThis interface predates the \\[fs.FS] interface, which can be used instead: the \\[FS] adapter function converts an fs.FS to a FileSystem.","A File is returned by a \\[FileSystem]'s Open method and can be served by the \\[FileServer] implementation.\n\nThe methods should behave the same as those on an [\\*os.File](https://pkg.go.dev/os/#File).","ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over [io.Copy](https://pkg.go.dev/io/#Copy) is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to \\[DetectContentType]. The name is otherwise unused; in particular it can be empty and is never sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. Note that [\\*os.File](https://pkg.go.dev/os/#File) implements the [io.ReadSeeker](https://pkg.go.dev/io/#ReadSeeker) interface.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nIf an error occurs when serving the request (for example, when handling an invalid range request), ServeContent responds with an error message. By default, ServeContent strips the Cache-Control, Content-Encoding, ETag, and Last-Modified headers from error responses. The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent to preserve these headers.","ServeFile replies to the request with the contents of the named file or directory.\n\nIf the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling \\[ServeFile].\n\nAs a precaution, ServeFile will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use \\[filepath.Join] on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use \\[ServeContent].\n\nOutside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.","ServeFileFS replies to the request with the contents of the named file or directory from the file system fsys. The files provided by fsys must implement [io.Seeker](https://pkg.go.dev/io/#Seeker).\n\nIf the provided name is constructed from user input, it should be sanitized before calling \\[ServeFileFS].\n\nAs a precaution, ServeFileFS will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use \\[filepath.Join] on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFileFS redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use \\[ServeContent].\n\nOutside of those two special cases, ServeFileFS does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.","FS converts fsys to a \\[FileSystem] implementation, for use with \\[FileServer] and \\[NewFileTransport]. The files provided by fsys must implement [io.Seeker](https://pkg.go.dev/io/#Seeker).","FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.\n\nAs a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\".\n\nTo use the operating system's file system implementation, use \\[http.Dir]:\n\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nTo use an \\[fs.FS] implementation, use \\[http.FileServerFS] instead.","FileServerFS returns a handler that serves HTTP requests with the contents of the file system fsys. The files provided by fsys must implement [io.Seeker](https://pkg.go.dev/io/#Seeker).\n\nAs a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\".\n\n\thttp.Handle(\"/\", http.FileServerFS(fsys))","A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by \\[CanonicalHeaderKey].","ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: \\[TimeFormat], [time.RFC850](https://pkg.go.dev/time/#RFC850), and [time.ANSIC](https://pkg.go.dev/time/#ANSIC).","CanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications.","NoBody is an [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser) with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set \\[Request.Body] to nil.","PushOptions describes options for \\[Pusher.Push].","Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see [https://tools.ietf.org/html/rfc7540#section-8.2](https://tools.ietf.org/html/rfc7540#section-8.2).","A CookieJar manages storage and use of cookies in HTTP requests.\n\nImplementations of CookieJar must be safe for concurrent use by multiple goroutines.\n\nThe net/http/cookiejar package provides a CookieJar implementation.","","","","","","","","","","ErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field.","ProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors are of type ProtocolError.","ErrNotSupported indicates that a feature is not supported.\n\nIt is returned by ResponseController methods to indicate that the handler does not support the method, and by the Push method of Pusher implementations to indicate that HTTP/2 Push support is not available.","Deprecated: ErrUnexpectedTrailer is no longer returned by anything in the net/http package. Callers should not compare errors against this variable.","ErrMissingBoundary is returned by Request.MultipartReader when the request's Content-Type does not include a \"boundary\" parameter.","ErrNotMultipart is returned by Request.MultipartReader when the request's Content-Type is not multipart/form-data.","Deprecated: ErrHeaderTooLong is no longer returned by anything in the net/http package. Callers should not compare errors against this variable.","Deprecated: ErrShortBody is no longer returned by anything in the net/http package. Callers should not compare errors against this variable.","Deprecated: ErrMissingContentLength is no longer returned by anything in the net/http package. Callers should not compare errors against this variable.","A Request represents an HTTP request received by a server or to be sent by a client.\n\nThe field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for \\[Request.Write] and \\[RoundTripper].","ErrNoCookie is returned by Request's Cookie method when a cookie is not found.","ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6. \"HTTP/1.0\" returns (1, 0, true). Note that strings without a minor version, such as \"HTTP/2\", are not valid.","NewRequest wraps \\[NewRequestWithContext] using [context.Background](https://pkg.go.dev/context/#Background).","NewRequestWithContext returns a new \\[Request] given a method, URL, and optional body.\n\nIf the provided body is also an [io.Closer](https://pkg.go.dev/io/#Closer), the returned \\[Request.Body] is set to body and will be closed (possibly asynchronously) by the Client methods Do, Post, and PostForm, and \\[Transport.RoundTrip].\n\nNewRequestWithContext returns a Request suitable for use with \\[Client.Do] or \\[Transport.RoundTrip]. To create a request for use with testing a Server Handler, either use the \\[NewRequest] function in the net/http/httptest package, use \\[ReadRequest], or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields.\n\nIf body is of type [\\*bytes.Buffer](https://pkg.go.dev/bytes/#Buffer), [\\*bytes.Reader](https://pkg.go.dev/bytes/#Reader), or [\\*strings.Reader](https://pkg.go.dev/strings/#Reader), the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to \\[NoBody] if the ContentLength is 0.","ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for specialized applications; most code should use the \\[Server] to read requests and handle them via the \\[Handler] interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.","MaxBytesReader is similar to [io.LimitReader](https://pkg.go.dev/io/#LimitReader) but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-nil error of type \\[\\*MaxBytesError] for a Read beyond the limit, and closes the underlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, it tells the \\[ResponseWriter] to close the connection after the limit has been reached.","MaxBytesError is returned by \\[MaxBytesReader] when its read limit is exceeded.","Response represents the response from an HTTP request.\n\nThe \\[Client] and \\[Transport] return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read.","ErrNoLocation is returned by the \\[Response.Location] method when no Location header is present.","ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the \\[Request] that corresponds to this \\[Response]. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.","A ResponseController is used by an HTTP handler to control the response.\n\nA ResponseController may not be used after the \\[Handler.ServeHTTP] method has returned.","NewResponseController creates a \\[ResponseController] for a request.\n\nThe ResponseWriter should be the original value passed to the \\[Handler.ServeHTTP] method, or have an Unwrap method returning the original ResponseWriter.\n\nIf the ResponseWriter implements any of the following methods, the ResponseController will call them as appropriate:\n\n\tFlush()\n\tFlushError() error // alternative Flush returning an error\n\tHijack() (net.Conn, *bufio.ReadWriter, error)\n\tSetReadDeadline(deadline time.Time) error\n\tSetWriteDeadline(deadline time.Time) error\n\tEnableFullDuplex() error\n\nIf the ResponseWriter does not support a method, ResponseController returns an error matching \\[ErrNotSupported].","ErrBodyNotAllowed is returned by ResponseWriter.Write calls when the HTTP method or response code does not permit a body.","ErrHijacked is returned by ResponseWriter.Write calls when the underlying connection has been hijacked using the Hijacker interface. A zero-byte write on a hijacked connection will return ErrHijacked without any other side effects.","ErrContentLength is returned by ResponseWriter.Write calls when a Handler set a Content-Length response header with a declared size and then attempted to write more bytes than declared.","Deprecated: ErrWriteAfterFlush is no longer returned by anything in the net/http package. Callers should not compare errors against this variable.","A Handler responds to an HTTP request.\n\n\\[Handler.ServeHTTP] should write reply headers and data to the \\[ResponseWriter] and then return. Returning signals that the request is finished; it is not valid to use the \\[ResponseWriter] or read from the \\[Request.Body] after or concurrently with the completion of the ServeHTTP call.\n\nDepending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the \\[Request.Body] after writing to the \\[ResponseWriter]. Cautious handlers should read the \\[Request.Body] first, and then reply.\n\nExcept for reading the body, handlers should not modify the provided Request.\n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST\\_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value \\[ErrAbortHandler].","A ResponseWriter interface is used by an HTTP handler to construct an HTTP response.\n\nA ResponseWriter may not be used after \\[Handler.ServeHTTP] has returned.","The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.\n\nThe default HTTP/1.x and HTTP/2 \\[ResponseWriter] implementations support \\[Flusher], but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.\n\nNote that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes.","The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.\n\nThe default \\[ResponseWriter] for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.","The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.\n\nThis mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.\n\nDeprecated: the CloseNotifier interface predates Go's context package. New code should use \\[Request.Context] instead.","ServerContextKey is a context key. It can be used in HTTP handlers with Context.Value to access the server that started the handler. The associated value will be of type \\*Server.","LocalAddrContextKey is a context key. It can be used in HTTP handlers with Context.Value to access the local address the connection arrived on. The associated value will be of type net.Addr.","TrailerPrefix is a magic prefix for \\[ResponseWriter.Header] map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.\n\nThis mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:\n\n\thttps://pkg.go.dev/net/http#ResponseWriter\n\thttps://pkg.go.dev/net/http#example-ResponseWriter-Trailers","DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting \\[Server.MaxHeaderBytes].","TimeFormat is the time format to use when generating times in HTTP headers. It is like [time.RFC1123](https://pkg.go.dev/time/#RFC1123) but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.\n\nFor parsing this time format, see \\[ParseTime].","ErrAbortHandler is a sentinel panic value to abort a handler. While any panic from ServeHTTP aborts the response to the client, panicking with ErrAbortHandler also suppresses logging of a stack trace to the server's error log.","The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a \\[Handler] that calls f.","Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text.\n\nError deletes the Content-Length header, sets Content-Type to “text/plain; charset=utf-8”, and sets X-Content-Type-Options to “nosniff”. This configures the header properly for the error message, in case the caller had set it up expecting a successful output.","NotFound replies to the request with an HTTP 404 not found error.","NotFoundHandler returns a simple request handler that replies to each request with a “404 page not found” reply.","StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path (and RawPath if set) and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. The prefix must match exactly: if the prefix in the request contains escaped characters the reply is also an HTTP 404 not found error.","Redirect replies to the request with a redirect to url, which may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually \\[StatusMovedPermanently], \\[StatusFound] or \\[StatusSeeOther].\n\nIf the Content-Type header has not been set, \\[Redirect] sets it to \"text/html; charset=utf-8\" and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.","RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.\n\nThe provided code should be in the 3xx range and is usually \\[StatusMovedPermanently], \\[StatusFound] or \\[StatusSeeOther].","ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.\n\n### Patterns {#hdr-Patterns}\n\nPatterns can match the method, host and path of a request. Some examples:\n\n  - \"/index.html\" matches the path \"/index.html\" for any host and method.\n  - \"GET /static/\" matches a GET request whose path begins with \"/static/\".\n  - \"example.com/\" matches any request to the host \"example.com\".\n  - \"example.com/{$}\" matches requests with host \"example.com\" and path \"/\".\n  - \"/b/{bucket}/o/{objectname...}\" matches paths whose first segment is \"b\" and whose third segment is \"o\". The name \"bucket\" denotes the second segment and \"objectname\" denotes the remainder of the path.\n\nIn general, a pattern looks like\n\n\t[METHOD ][HOST]/[PATH]\n\nAll three parts are optional; \"/\" is a valid pattern. If METHOD is present, it must be followed by at least one space or tab.\n\nLiteral (that is, non-wildcard) parts of a pattern match the corresponding parts of a request case-sensitively.\n\nA pattern with no method matches every method. A pattern with the method GET matches both GET and HEAD requests. Otherwise, the method must match exactly.\n\nA pattern with no host matches every host. A pattern with a host matches URLs on that host only.\n\nA path can include wildcard segments of the form {NAME} or {NAME...}. For example, \"/b/{bucket}/o/{objectname...}\". The wildcard name must be a valid Go identifier. Wildcards must be full path segments: they must be preceded by a slash and followed by either a slash or the end of the string. For example, \"/b\\_{bucket}\" is not a valid pattern.\n\nNormally a wildcard matches only a single path segment, ending at the next literal slash (not %2F) in the request URL. But if the \"...\" is present, then the wildcard matches the remainder of the URL path, including slashes. (Therefore it is invalid for a \"...\" wildcard to appear anywhere but at the end of a pattern.) The match for a wildcard can be obtained by calling \\[Request.PathValue] with the wildcard's name. A trailing slash in a path acts as an anonymous \"...\" wildcard.\n\nThe special wildcard {$} matches only the end of the URL. For example, the pattern \"/{$}\" matches only the path \"/\", whereas the pattern \"/\" matches every path.\n\nFor matching, both pattern paths and incoming request paths are unescaped segment by segment. So, for example, the path \"/a%2Fb/100%25\" is treated as having two segments, \"a/b\" and \"100%\". The pattern \"/a%2fb/\" matches it, but the pattern \"/a/b/\" does not.\n\n### Precedence {#hdr-Precedence}\n\nIf two or more patterns match a request, then the most specific pattern takes precedence. A pattern P1 is more specific than P2 if P1 matches a strict subset of P2’s requests; that is, if P2 matches all the requests of P1 and more. If neither is more specific, then the patterns conflict. There is one exception to this rule, for backwards compatibility: if two patterns would otherwise conflict and one has a host while the other does not, then the pattern with the host takes precedence. If a pattern passed to \\[ServeMux.Handle] or \\[ServeMux.HandleFunc] conflicts with another pattern that is already registered, those functions panic.\n\nAs an example of the general rule, \"/images/thumbnails/\" is more specific than \"/images/\", so both can be registered. The former matches paths beginning with \"/images/thumbnails/\" and the latter will match any other path in the \"/images/\" subtree.\n\nAs another example, consider the patterns \"GET /\" and \"/index.html\": both match a GET request for \"/index.html\", but the former pattern matches all other GET and HEAD requests, while the latter matches any request for \"/index.html\" that uses a different method. The patterns conflict.\n\n### Trailing-slash redirection {#hdr-Trailing_slash_redirection}\n\nConsider a \\[ServeMux] with a handler for a subtree, registered using a trailing slash or \"...\" wildcard. If the ServeMux receives a request for the subtree root without a trailing slash, it redirects the request by adding the trailing slash. This behavior can be overridden with a separate registration for the path without the trailing slash or \"...\" wildcard. For example, registering \"/images/\" causes ServeMux to redirect a request for \"/images\" to \"/images/\", unless \"/images\" has been registered separately.\n\n### Request sanitizing {#hdr-Request_sanitizing}\n\nServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. segments or repeated slashes to an equivalent, cleaner URL.\n\n### Compatibility {#hdr-Compatibility}\n\nThe pattern syntax and matching behavior of ServeMux changed significantly in Go 1.22. To restore the old behavior, set the GODEBUG environment variable to \"httpmuxgo121=1\". This setting is read once, at program startup; changes during execution will be ignored.\n\nThe backwards-incompatible changes include:\n\n  - Wildcards are just ordinary literal path segments in 1.21. For example, the pattern \"/{x}\" will match only that path in 1.21, but will match any one-segment path in 1.22.\n  - In 1.21, no pattern was rejected, unless it was empty or conflicted with an existing pattern. In 1.22, syntactically invalid patterns will cause \\[ServeMux.Handle] and \\[ServeMux.HandleFunc] to panic. For example, in 1.21, the patterns \"/{\"  and \"/a{x}\" match themselves, but in 1.22 they are invalid and will cause a panic when registered.\n  - In 1.22, each segment of a pattern is unescaped; this was not done in 1.21. For example, in 1.22 the pattern \"/%61\" matches the path \"/a\" (\"%61\" being the URL escape sequence for \"a\"), but in 1.21 it would match only the path \"/%2561\" (where \"%25\" is the escape for the percent sign).\n  - When matching patterns to paths, in 1.22 each segment of the path is unescaped; in 1.21, the entire path is unescaped. This change mostly affects how paths with %2F escapes adjacent to slashes are treated. See [https://go.dev/issue/21955](https://go.dev/issue/21955) for details.","NewServeMux allocates and returns a new \\[ServeMux].","DefaultServeMux is the default \\[ServeMux] used by \\[Serve].","Handle registers the handler for the given pattern in \\[DefaultServeMux]. The documentation for \\[ServeMux] explains how patterns are matched.","HandleFunc registers the handler function for the given pattern in \\[DefaultServeMux]. The documentation for \\[ServeMux] explains how patterns are matched.","Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case \\[DefaultServeMux] is used.\n\nHTTP/2 support is only enabled if the Listener returns \\[\\*tls.Conn] connections and they were configured with \"h2\" in the TLS Config.NextProtos.\n\nServe always returns a non-nil error.","ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case \\[DefaultServeMux] is used.\n\nAdditionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.","A Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration.","A ConnState represents the state of a client connection to a server. It's used by the optional \\[Server.ConnState] hook.","StateNew represents a new connection that is expected to send a request immediately. Connections begin at this state and then transition to either StateActive or StateClosed.","StateActive represents a connection that has read 1 or more bytes of a request. The Server.ConnState hook for StateActive fires before the request has entered a handler and doesn't fire again until the request has been handled. After the request is handled, the state transitions to StateClosed, StateHijacked, or StateIdle. For HTTP/2, StateActive fires on the transition from zero to one active request, and only transitions away once all active requests are complete. That means that ConnState cannot be used to do per-request work; ConnState only notes the overall state of the connection.","StateIdle represents a connection that has finished handling a request and is in the keep-alive state, waiting for a new request. Connections transition from StateIdle to either StateActive or StateClosed.","StateHijacked represents a hijacked connection. This is a terminal state. It does not transition to StateClosed.","StateClosed represents a closed connection. This is a terminal state. Hijacked connections do not transition to StateClosed.","AllowQuerySemicolons returns a handler that serves requests by converting any unescaped semicolons in the URL query to ampersands, and invoking the handler h.\n\nThis restores the pre-Go 1.17 behavior of splitting query parameters on both semicolons and ampersands. (See golang.org/issue/25192). Note that this behavior doesn't match that of many proxies, and the mismatch can lead to security issues.\n\nAllowQuerySemicolons should be invoked before \\[Request.ParseForm] is called.","ErrServerClosed is returned by the \\[Server.Serve], \\[ServeTLS], \\[ListenAndServe], and \\[ListenAndServeTLS] methods after a call to \\[Server.Shutdown] or \\[Server.Close].","ListenAndServe listens on the TCP network address addr and then calls \\[Serve] with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case \\[DefaultServeMux] is used.\n\nListenAndServe always returns a non-nil error.","ListenAndServeTLS acts identically to \\[ListenAndServe], except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.","TimeoutHandler returns a \\[Handler] that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its \\[ResponseWriter] will return \\[ErrHandlerTimeout].\n\nTimeoutHandler supports the \\[Pusher] interface but does not support the \\[Hijacker] or \\[Flusher] interfaces.","ErrHandlerTimeout is returned on \\[ResponseWriter] Write calls in handlers which have timed out.","MaxBytesHandler returns a \\[Handler] that runs h with its \\[ResponseWriter] and \\[Request.Body] wrapped by a MaxBytesReader.","DetectContentType implements the algorithm described at [https://mimesniff.spec.whatwg.org/](https://mimesniff.spec.whatwg.org/) to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\".","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.","ErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding.","ErrBodyReadAfterClose is returned when reading a \\[Request] or \\[Response] Body after the body has been closed. This typically happens when the body is read after an HTTP \\[Handler] calls WriteHeader or Write on its \\[ResponseWriter].","DefaultTransport is the default implementation of \\[Transport] and is used by \\[DefaultClient]. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the environment variables HTTP\\_PROXY, HTTPS\\_PROXY and NO\\_PROXY (or the lowercase versions thereof).","DefaultMaxIdleConnsPerHost is the default value of \\[Transport]'s MaxIdleConnsPerHost.","Transport is an implementation of \\[RoundTripper] that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use. This may leave many open connections when accessing many hosts. This behavior can be managed using \\[Transport.CloseIdleConnections] method and the \\[Transport.MaxIdleConnsPerHost] and \\[Transport.DisableKeepAlives] fields.\n\nTransports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests. For high-level functionality, such as cookies and redirects, see \\[Client].\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The \\[DefaultTransport] supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.\n\nResponses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by \\[Transport.RoundTrip]. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse.\n\nTransport only retries a request upon encountering a network error if the connection has been already been used successfully and if the request is idempotent and either has no body or has its \\[Request.GetBody] defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their \\[Header] map contains an \"Idempotency-Key\" or \"X-Idempotency-Key\" entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.","ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP\\_PROXY, HTTPS\\_PROXY and NO\\_PROXY (or the lowercase versions thereof). Requests use the proxy from the environment variable matching their scheme, unless excluded by NO\\_PROXY.\n\nThe environment values may be either a complete URL or a \"host\\[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO\\_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without a port number), then a nil URL and nil error will be returned.","ProxyURL returns a proxy function (for use in a \\[Transport]) that always returns the same URL.","ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.","A Message represents a parsed mail message.","ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.","ParseDate parses an RFC 5322 date string.","A Header represents the key-value pairs in a mail message header.","","Address represents a single mail address. An address such as \"Barry Gibbs \\\u003cbg@example.com\u003e\" is represented as Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.","ParseAddress parses a single RFC 5322 address, e.g. \"Barry Gibbs \\\u003cbg@example.com\u003e\"","ParseAddressList parses the given string as a list of addresses.","An AddressParser is an RFC 5322 address parser.","Addr represents an IPv4 or IPv6 address (with or without a scoped addressing zone), similar to [net.IP](https://pkg.go.dev/net/#IP) or [net.IPAddr](https://pkg.go.dev/net/#IPAddr).\n\nUnlike [net.IP](https://pkg.go.dev/net/#IP) or [net.IPAddr](https://pkg.go.dev/net/#IPAddr), Addr is a comparable value type (it supports == and can be a map key) and is immutable.\n\nThe zero Addr is not a valid IP address. Addr{} is distinct from both 0.0.0.0 and ::.","IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast address ff02::1.","IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast address ff02::2.","IPv6Loopback returns the IPv6 loopback address ::1.","IPv6Unspecified returns the IPv6 unspecified address \"::\".","IPv4Unspecified returns the IPv4 unspecified address \"0.0.0.0\".","AddrFrom4 returns the address of the IPv4 address given by the bytes in addr.","AddrFrom16 returns the IPv6 address given by the bytes in addr. An IPv4-mapped IPv6 address is left as an IPv6 address. (Use Unmap to convert them if needed.)","ParseAddr parses s as an IP address, returning the result. The string s can be in dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv6 with a scoped addressing zone (\"fe80::1cc0:3e8c:119f:c2e1%ens18\").","MustParseAddr calls \\[ParseAddr](s) and panics on error. It is intended for use in tests with hard-coded strings.","AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6 address. Note that a [net.IP](https://pkg.go.dev/net/#IP) can be passed directly as the \\[]byte argument. If slice's length is not 4 or 16, AddrFromSlice returns \\[Addr]{}, false.","AddrPort is an IP and a port number.","AddrPortFrom returns an \\[AddrPort] with the provided IP and port. It does not allocate.","ParseAddrPort parses s as an \\[AddrPort].\n\nIt doesn't do any name resolution: both the address and the port must be numeric.","MustParseAddrPort calls \\[ParseAddrPort](s) and panics on error. It is intended for use in tests with hard-coded strings.","Prefix is an IP address prefix (CIDR) representing an IP network.\n\nThe first \\[Prefix.Bits]() of \\[Addr]() are specified. The remaining bits match any address. The range of Bits() is \\[0,32] for IPv4 or \\[0,128] for IPv6.","PrefixFrom returns a \\[Prefix] with the provided IP address and bit prefix length.\n\nIt does not allocate. Unlike \\[Addr.Prefix], \\[PrefixFrom] does not mask off the host bits of ip.\n\nIf bits is less than zero or greater than ip.BitLen, \\[Prefix.Bits] will return an invalid value -1.","ParsePrefix parses s as an IP address prefix. The string can be in the form \"192.168.1.0/24\" or \"2001:db8::/32\", the CIDR notation defined in RFC 4632 and RFC 4291. IPv6 zones are not permitted in prefixes, and an error will be returned if a zone is present.\n\nNote that masked address bits are not zeroed. Use Masked for that.","MustParsePrefix calls \\[ParsePrefix](s) and panics on error. It is intended for use in tests with hard-coded strings.","ServerError represents an error that has been returned from the remote side of the RPC connection.","","Call represents an active RPC.","Client represents an RPC Client. There may be multiple outstanding Calls associated with a single Client, and a Client may be used by multiple goroutines simultaneously.","A ClientCodec implements writing of RPC requests and reading of RPC responses for the client side of an RPC session. The client calls \\[ClientCodec.WriteRequest] to write a request to the connection and calls \\[ClientCodec.ReadResponseHeader] and \\[ClientCodec.ReadResponseBody] in pairs to read responses. The client calls \\[ClientCodec.Close] when finished with the connection. ReadResponseBody may be called with a nil argument to force the body of the response to be read and then discarded. See \\[NewClient]'s comment for information about concurrent access.","NewClient returns a new \\[Client] to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.","NewClientWithCodec is like \\[NewClient] but uses the specified codec to encode requests and decode responses.","DialHTTP connects to an HTTP RPC server at the specified network address listening on the default HTTP RPC path.","DialHTTPPath connects to an HTTP RPC server at the specified network address and path.","Dial connects to an RPC server at the specified network address.","Defaults used by HandleHTTP","","Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.","Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.","Server represents an RPC Server.","NewServer returns a new \\[Server].","DefaultServer is the default instance of \\[\\*Server].","Register publishes the receiver's methods in the \\[DefaultServer].","RegisterName is like \\[Register] but uses the provided name for the type instead of the receiver's concrete type.","A ServerCodec implements reading of RPC requests and writing of RPC responses for the server side of an RPC session. The server calls \\[ServerCodec.ReadRequestHeader] and \\[ServerCodec.ReadRequestBody] in pairs to read requests from the connection, and it calls \\[ServerCodec.WriteResponse] to write a response back. The server calls \\[ServerCodec.Close] when finished with the connection. ReadRequestBody may be called with a nil argument to force the body of the request to be read and discarded. See \\[NewClient]'s comment for information about concurrent access.","ServeConn runs the \\[DefaultServer] on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use \\[ServeCodec]. See \\[NewClient]'s comment for information about concurrent access.","ServeCodec is like \\[ServeConn] but uses the specified codec to decode requests and encode responses.","ServeRequest is like \\[ServeCodec] but synchronously serves a single request. It does not close the codec upon completion.","Accept accepts connections on the listener and serves requests to \\[DefaultServer] for each incoming connection. Accept blocks; the caller typically invokes it in a go statement.","HandleHTTP registers an HTTP handler for RPC messages to \\[DefaultServer] on \\[DefaultRPCPath] and a debugging handler on \\[DefaultDebugPath]. It is still necessary to invoke \\[http.Serve](), typically in a go statement.","Auth is implemented by an SMTP authentication mechanism.","ServerInfo records information about an SMTP server.","PlainAuth returns an \\[Auth] that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials.","CRAMMD5Auth returns an \\[Auth] that implements the CRAM-MD5 authentication mechanism as defined in RFC 2195. The returned Auth uses the given username and secret to authenticate to the server using the challenge-response mechanism.","A Client represents a client connection to an SMTP server.","Dial returns a new \\[Client] connected to an SMTP server at addr. The addr must include a port, as in \"mail.example.com:smtp\".","NewClient returns a new \\[Client] using an existing connection and host as a server name to be used when authenticating.","SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\" messages is accomplished by including an email address in the to parameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library.","A MIMEHeader represents a MIME-style header mapping keys to sets of values.","A Pipeline manages a pipelined in-order request/response sequence.\n\nTo use a Pipeline p to manage multiple clients on a connection, each client should run:\n\n\tid := p.Next()\t// take a number\n\n\tp.StartRequest(id)\t// wait for turn to send request\n\t«send request»\n\tp.EndRequest(id)\t// notify Pipeline that request is sent\n\n\tp.StartResponse(id)\t// wait for turn to read response\n\t«read response»\n\tp.EndResponse(id)\t// notify Pipeline that response is read\n\nA pipelined server can use the same calls to ensure that responses computed in parallel are written in the correct order.","A Reader implements convenience methods for reading requests or responses from a text protocol network connection.","NewReader returns a new \\[Reader] reading from r.\n\nTo avoid denial of service attacks, the provided [bufio.Reader](https://pkg.go.dev/bufio/#Reader) should be reading from an [io.LimitReader](https://pkg.go.dev/io/#LimitReader) or similar Reader to bound the size of responses.","CanonicalMIMEHeaderKey returns the canonical format of the MIME header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". MIME header keys are assumed to be ASCII only. If s contains a space or invalid header field bytes, it is returned without modifications.","An Error represents a numeric error response from a server.","A ProtocolError describes a protocol violation such as an invalid response or a hung-up connection.","A Conn represents a textual network protocol connection. It consists of a \\[Reader] and \\[Writer] to manage I/O and a \\[Pipeline] to sequence concurrent requests on the connection. These embedded types carry methods with them; see the documentation of those types for details.","NewConn returns a new \\[Conn] using conn for I/O.","Dial connects to the given address on the given network using [net.Dial](https://pkg.go.dev/net/#Dial) and then returns a new \\[Conn] for the connection.","TrimString returns s without leading and trailing ASCII space.","TrimBytes returns b without leading and trailing ASCII space.","A Writer implements convenience methods for writing requests or responses to a text protocol network connection.","NewWriter returns a new \\[Writer] writing to w.","Error reports an error and the operation and URL that caused it.","","","QueryUnescape does the inverse transformation of \\[QueryEscape], converting each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.","PathUnescape does the inverse transformation of \\[PathEscape], converting each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.\n\nPathUnescape is identical to \\[QueryUnescape] except that it does not unescape '+' to ' ' (space).","QueryEscape escapes the string so it can be safely placed inside a \\[URL] query.","PathEscape escapes the string so it can be safely placed inside a \\[URL] path segment, replacing special characters (including /) with %XX sequences as needed.","A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nThe Host field contains the host and port subcomponents of the URL. When the port is present, it is separated from the host with a colon. When the host is an IPv6 address, it must be enclosed in square brackets: \"\\[fe80::1]:80\". The [net.JoinHostPort](https://pkg.go.dev/net/#JoinHostPort) function combines a host and port into a string suitable for the Host field, adding square brackets to the host when necessary.\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, the code should use the \\[URL.EscapedPath] method, which preserves the original encoding of Path.\n\nThe RawPath field is an optional field which is only set when the default encoding of Path is different from the escaped path. See the EscapedPath method for more details.\n\nURL's String method uses the EscapedPath method to obtain the path.","User returns a \\[Userinfo] containing the provided username and no password set.","UserPassword returns a \\[Userinfo] containing the provided username and password.\n\nThis functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way “is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.”","The Userinfo type is an immutable encapsulation of username and password details for a \\[URL]. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.","Parse parses a raw url into a \\[URL] structure.\n\nThe url may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.","ParseRequestURI parses a raw url into a \\[URL] structure. It assumes that url was received in an HTTP request, so the url is interpreted only as an absolute URI or an absolute path. The string url is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)","Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.","ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.\n\nQuery is expected to be a list of key=value settings separated by ampersands. A setting without an equals sign is interpreted as a key set to an empty value. Settings containing a non-URL-encoded semicolon are considered invalid.","JoinPath returns a \\[URL] string with the provided path elements joined to the existing path of base and the resulting path cleaned of any ./ or ../ elements.","Error is returned by \\[LookPath] when it fails to classify a file as an executable.","ErrWaitDelay is returned by \\[Cmd.Wait] if the process exits with a successful status code but its output pipes are not closed before the command's WaitDelay expires.","Cmd represents an external command being prepared or run.\n\nA Cmd cannot be reused after calling its \\[Cmd.Run], \\[Cmd.Output] or \\[Cmd.CombinedOutput] methods.","Command returns the \\[Cmd] struct to execute the named program with the given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses \\[LookPath] to resolve name to a complete path if possible. Otherwise it uses name directly as Path.\n\nThe returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(\"echo\", \"hello\"). Args\\[0] is always name, not the possibly resolved Path.\n\nOn Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty.","CommandContext is like \\[Command] but includes a context.\n\nThe provided context is used to interrupt the process (by calling cmd.Cancel or [os.Process.Kill](https://pkg.go.dev/os/#Process.Kill)) if the context becomes done before the command completes on its own.\n\nCommandContext sets the command's Cancel function to invoke the Kill method on its Process, and leaves its WaitDelay unset. The caller may change the cancellation behavior by modifying those fields before starting the command.","An ExitError reports an unsuccessful exit by a command.","ErrDot indicates that a path lookup resolved to an executable in the current directory due to ‘.’ being in the path, either implicitly or explicitly. See the package documentation for details.\n\nNote that functions in this package do not return ErrDot directly. Code should use errors.Is(err, ErrDot), not err == ErrDot, to test whether a returned error err is due to this condition.","ErrNotFound is the error resulting if a path search failed to find an executable file.","LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. Otherwise, on success, the result is an absolute path.\n\nIn older versions of Go, LookPath could return a path relative to the current directory. As of Go 1.19, LookPath will instead return that path along with an error satisfying [errors.Is](https://pkg.go.dev/errors/#Is)(err, \\[ErrDot]). See the package documentation for more details.","Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to \\[Notify] for the provided signals. If no signals are provided, all incoming signals will be ignored.","Ignored reports whether sig is currently ignored.","Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call \\[Stop].\n\nIt is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently.","Reset undoes the effect of any prior calls to \\[Notify] for the provided signals. If no signals are provided, all signal handlers will be reset.","Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to \\[Notify] using c. When Stop returns, it is guaranteed that c will receive no more signals.","NotifyContext returns a copy of the parent context that is marked done (its Done channel is closed) when one of the listed signals arrives, when the returned stop function is called, or when the parent context's Done channel is closed, whichever happens first.\n\nThe stop function unregisters the signal behavior, which, like \\[signal.Reset], may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving [os.Interrupt](https://pkg.go.dev/os/#Interrupt) is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called.\n\nThe stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context.","Current returns the current user.\n\nThe first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.","Lookup looks up a user by username. If the user cannot be found, the returned error is of type \\[UnknownUserError].","LookupId looks up a user by userid. If the user cannot be found, the returned error is of type \\[UnknownUserIdError].","LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type \\[UnknownGroupError].","LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type \\[UnknownGroupIdError].","User represents a user account.","Group represents a grouping of users.\n\nOn POSIX systems Gid contains a decimal number representing the group ID.","UnknownUserIdError is returned by \\[LookupId] when a user cannot be found.","UnknownUserError is returned by \\[Lookup] when a user cannot be found.","UnknownGroupIdError is returned by \\[LookupGroupId] when a group cannot be found.","UnknownGroupError is returned by \\[LookupGroup] when a group cannot be found.","ErrBadPattern indicates a pattern was malformed.","Match reports whether name matches the shell file name pattern. The pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo \u003c= c \u003c= hi\n\nMatch requires pattern to match all of name, not just a substring. The only possible returned error is \\[ErrBadPattern], when pattern is malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\\\\\' is treated as path separator.","Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in \\[Match]. The pattern may describe hierarchical names such as /usr/\\*/bin/ed (assuming the \\[Separator] is '/').\n\nGlob ignores file system errors such as I/O errors reading directories. The only possible returned error is \\[ErrBadPattern], when pattern is malformed.","","","Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:\n\n 1. Replace multiple \\[Separator] elements with a single one.\n 2. Eliminate each . path name element (the current directory).\n 3. Eliminate each inner .. path name element (the parent directory) along with the non-.. element that precedes it.\n 4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\" by \"/\" at the beginning of a path, assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory, such as \"/\" on Unix or \\`C:\\\\\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean returns the string \".\".\n\nOn Windows, Clean does not modify the volume name other than to replace occurrences of \"/\" with \\`\\\\\\`. For example, Clean(\"//host/share/../x\") returns \\`\\\\\\\\host\\\\share\\\\x\\`.\n\nSee also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,” [https://9p.io/sys/doc/lexnames.html](https://9p.io/sys/doc/lexnames.html)","IsLocal reports whether path, using lexical analysis only, has all of these properties:\n\n  - is within the subtree rooted at the directory in which path is evaluated\n  - is not an absolute path\n  - is not empty\n  - on Windows, is not a reserved name such as \"NUL\"\n\nIf IsLocal(path) returns true, then Join(base, path) will always produce a path contained within base and Clean(path) will always produce an unrooted path with no \"..\" path elements.\n\nIsLocal is a purely lexical operation. In particular, it does not account for the effect of any symbolic links that may exist in the filesystem.","Localize converts a slash-separated path into an operating system path. The input path must be a valid path as reported by [io/fs.ValidPath](https://pkg.go.dev/io/fs/#ValidPath).\n\nLocalize returns an error if the path cannot be represented by the operating system. For example, the path a\\\\b is rejected on Windows, on which \\\\ is a separator character and cannot be part of a filename.\n\nThe path returned by Localize will always be local, as reported by IsLocal.","ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.","FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.\n\nSee also the Localize function, which converts a slash-separated path as used by the io/fs package to an operating system path.","SplitList splits a list of paths joined by the OS-specific \\[ListSeparator], usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string.","Split splits path immediately following the final \\[Separator], separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.","Join joins any number of path elements into a single path, separating them with an OS specific \\[Separator]. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.","Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot.","EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls \\[Clean] on the result.","IsAbs reports whether the path is absolute.","Abs returns an absolute representation of path. If the path is not absolute it will be joined with the current working directory to turn it into an absolute path. The absolute path name for a given file is not guaranteed to be unique. Abs calls \\[Clean] on the result.","Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, \\[Join](basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls \\[Clean] on the result.","SkipDir is used as a return value from \\[WalkFunc] to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.","SkipAll is used as a return value from \\[WalkFunc] to indicate that all remaining files and directories are to be skipped. It is not returned as an error by any function.","WalkFunc is the type of the function called by \\[Walk] to visit each file or directory.\n\nThe path argument contains the argument to Walk as a prefix. That is, if Walk is called with root argument \"dir\" and finds a file named \"a\" in that directory, the walk function will be called with argument \"dir/a\".\n\nThe directory and file are joined with Join, which may clean the directory name: if Walk is called with the root argument \"x/../dir\" and finds a file named \"a\" in that directory, the walk function will be called with argument \"dir/a\", not \"x/../dir/a\".\n\nThe info argument is the fs.FileInfo for the named path.\n\nThe error result returned by the function controls how Walk continues. If the function returns the special value \\[SkipDir], Walk skips the current directory (path if info.IsDir() is true, otherwise path's parent directory). If the function returns the special value \\[SkipAll], Walk skips all remaining files and directories. Otherwise, if the function returns a non-nil error, Walk stops entirely and returns that error.\n\nThe err argument reports an error related to path, signaling that Walk will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause Walk to stop walking the entire tree.\n\nWalk calls the function with a non-nil err argument in two cases.\n\nFirst, if an [os.Lstat](https://pkg.go.dev/os/#Lstat) on the root directory or any directory or file in the tree fails, Walk calls the function with path set to that directory or file's path, info set to nil, and err set to the error from os.Lstat.\n\nSecond, if a directory's Readdirnames method fails, Walk calls the function with path set to the directory's path, info, set to an \\[fs.FileInfo] describing the directory, and err set to the error from Readdirnames.","WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.\n\nAll errors that arise visiting files and directories are filtered by fn: see the \\[fs.WalkDirFunc] documentation for details.\n\nThe files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory.\n\nWalkDir does not follow symbolic links.\n\nWalkDir calls fn with paths that use the separator character appropriate for the operating system. This is unlike [io/fs.WalkDir](https://pkg.go.dev/io/fs/#WalkDir), which always uses slash separated paths.","Walk walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.\n\nAll errors that arise visiting files and directories are filtered by fn: see the \\[WalkFunc] documentation for details.\n\nThe files are walked in lexical order, which makes the output deterministic but requires Walk to read an entire directory into memory before proceeding to walk that directory.\n\nWalk does not follow symbolic links.\n\nWalk is less efficient than \\[WalkDir], introduced in Go 1.16, which avoids calling os.Lstat on every visited file or directory.","Base returns the last element of path. Trailing path separators are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of separators, Base returns a single separator.","Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls \\[Clean] on the path and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory.","VolumeName returns leading volume name. Given \"C:\\\\foo\\\\bar\" it returns \"C:\" on Windows. Given \"\\\\\\\\host\\\\share\\\\foo\" it returns \"\\\\\\\\host\\\\share\". On other platforms it returns \"\".","HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and does not ignore case when required.","Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify).","An Error describes a failure to parse a regular expression and gives the offending expression.","An ErrorCode describes a failure to parse a regular expression.","Unexpected error","Parse errors","","","","","","","","","","","","","","","Flags control the behavior of the parser and record information about regexp context.","","","","","","","","","","","","","","Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment.","A Prog is a compiled regular expression program.","An InstOp is an instruction opcode.","","","","","","","","","","","","An EmptyOp specifies a kind or mixture of zero-width assertions.","","","","","","","EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text.","IsWordChar reports whether r is considered a “word character” during the evaluation of the \\\\b and \\\\B zero-width assertions. These assertions are ASCII-only: the word characters are \\[A-Za-z0-9\\_].","An Inst is a single instruction in a regular expression program.","A Regexp is a node in a regular expression syntax tree.","An Op is a single regular expression operator.","","","","","","","","","","","","","","","","","","","","Incomplete is used specifically for the semantics of incomplete C types.","Handle provides a way to pass values that contain Go pointers (pointers to memory allocated by Go) between Go and C without breaking the cgo pointer passing rules. A Handle is an integer value that can represent any Go value. A Handle can be passed through C and back to Go, and Go code can use the Handle to retrieve the original Go value.\n\nThe underlying type of Handle is guaranteed to fit in an integer type that is large enough to hold the bit pattern of any pointer. The zero value of a Handle is not valid, and thus is safe to use as a sentinel in C APIs.\n\nFor instance, on the Go side:\n\n\tpackage main\n\n\t/*\n\t#include \u003cstdint.h\u003e // for uintptr_t\n\n\textern void MyGoPrint(uintptr_t handle);\n\tvoid myprint(uintptr_t handle);\n\t*/\n\timport \"C\"\n\timport \"runtime/cgo\"\n\n\t//export MyGoPrint\n\tfunc MyGoPrint(handle C.uintptr_t) {\n\t\th := cgo.Handle(handle)\n\t\tval := h.Value().(string)\n\t\tprintln(val)\n\t\th.Delete()\n\t}\n\n\tfunc main() {\n\t\tval := \"hello Go\"\n\t\tC.myprint(C.uintptr_t(cgo.NewHandle(val)))\n\t\t// Output: hello Go\n\t}\n\nand on the C side:\n\n\t#include \u003cstdint.h\u003e // for uintptr_t\n\n\t// A Go function\n\textern void MyGoPrint(uintptr_t handle);\n\n\t// A C function\n\tvoid myprint(uintptr_t handle) {\n\t    MyGoPrint(handle);\n\t}\n\nSome C functions accept a void\\* argument that points to an arbitrary data value supplied by the caller. It is not safe to coerce a \\[cgo.Handle] (an integer) to a Go [unsafe.Pointer](https://pkg.go.dev/unsafe/#Pointer), but instead we can pass the address of the cgo.Handle to the void\\* parameter, as in this variant of the previous example:\n\n\tpackage main\n\n\t/*\n\textern void MyGoPrint(void *context);\n\tstatic inline void myprint(void *context) {\n\t    MyGoPrint(context);\n\t}\n\t*/\n\timport \"C\"\n\timport (\n\t\t\"runtime/cgo\"\n\t\t\"unsafe\"\n\t)\n\n\t//export MyGoPrint\n\tfunc MyGoPrint(context unsafe.Pointer) {\n\t\th := *(*cgo.Handle)(context)\n\t\tval := h.Value().(string)\n\t\tprintln(val)\n\t\th.Delete()\n\t}\n\n\tfunc main() {\n\t\tval := \"hello Go\"\n\t\th := cgo.NewHandle(val)\n\t\tC.myprint(unsafe.Pointer(\u0026h))\n\t\t// Output: hello Go\n\t}","NewHandle returns a handle for a given value.\n\nThe handle is valid until the program calls Delete on it. The handle uses resources, and this package assumes that C code may hold on to the handle, so a program must explicitly call Delete when the handle is no longer needed.\n\nThe intended use is to pass the returned handle to C code, which passes it back to Go, which calls Value.","WriteMetaDir writes a coverage meta-data file for the currently running program to the directory specified in 'dir'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if the directory does not exist).","WriteMeta writes the meta-data content (the payload that would normally be emitted to a meta-data file) for the currently running program to the writer 'w'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if a write fails).","WriteCountersDir writes a coverage counter-data file for the currently running program to the directory specified in 'dir'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if the directory does not exist). The counter data written will be a snapshot taken at the point of the call.","WriteCounters writes coverage counter-data content for the currently running program to the writer 'w'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if a write fails). The counter data written will be a snapshot taken at the point of the invocation.","ClearCounters clears/resets all coverage counter variables in the currently running program. It returns an error if the program in question was not built with the \"-cover\" flag. Clearing of coverage counters is also not supported for programs not using atomic counter mode (see more detailed comments below for the rationale here).","GCStats collect information about recent garbage collections.","ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.","SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. This setting may be effectively reduced in order to maintain a memory limit. A negative percentage effectively disables garbage collection, unless the memory limit is reached. See SetMemoryLimit for more details.","FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)","SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems. There may be a system-imposed maximum stack limit regardless of the value provided to SetMaxStack.\n\nSetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth.","SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system.","SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. The runtime.Error that the runtime panics with may have an additional method:\n\n\tAddr() uintptr\n\nIf that method exists, it returns the memory address which triggered the fault. The results of Addr are best-effort and the veracity of the result may depend on the platform. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.","WriteHeapDump writes a description of the heap and the objects in it to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap dump is completely written.  Thus, the file descriptor must not be connected to a pipe or socket whose other end is in the same Go process; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at [https://golang.org/s/go15heapdump](https://golang.org/s/go15heapdump).","SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(\"all\") ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.","SetMemoryLimit provides the runtime with a soft memory limit.\n\nThe runtime undertakes several processes to try to respect this memory limit, including adjustments to the frequency of garbage collections and returning memory to the underlying system more aggressively. This limit will be respected even if GOGC=off (or, if SetGCPercent(-1) is executed).\n\nThe input limit is provided as bytes, and includes all memory mapped, managed, and not released by the Go runtime. Notably, it does not account for space used by the Go binary and memory external to Go, such as memory managed by the underlying system on behalf of the process, or memory managed by non-Go code inside the same process. Examples of excluded memory sources include: OS kernel memory held on behalf of the process, memory allocated by C code, and memory mapped by syscall.Mmap (because it is not managed by the Go runtime).\n\nMore specifically, the following expression accurately reflects the value the runtime attempts to maintain as the limit:\n\n\truntime.MemStats.Sys - runtime.MemStats.HeapReleased\n\nor in terms of the runtime/metrics package:\n\n\t/memory/classes/total:bytes - /memory/classes/heap/released:bytes\n\nA zero limit or a limit that's lower than the amount of memory used by the Go runtime may cause the garbage collector to run nearly continuously. However, the application may still make progress.\n\nThe memory limit is always respected by the Go runtime, so to effectively disable this behavior, set the limit very high. [math.MaxInt64](https://pkg.go.dev/math/#MaxInt64) is the canonical value for disabling the limit, but values much greater than the available memory on the underlying system work just as well.\n\nSee [https://go.dev/doc/gc-guide](https://go.dev/doc/gc-guide) for a detailed guide explaining the soft memory limit in more detail, as well as a variety of common use-cases and scenarios.\n\nThe initial setting is math.MaxInt64 unless the GOMEMLIMIT environment variable is set, in which case it provides the initial setting. GOMEMLIMIT is a numeric value in bytes with an optional unit suffix. The supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes represent quantities of bytes as defined by the IEC 80000-13 standard. That is, they are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes, and so on.\n\nSetMemoryLimit returns the previously set memory limit. A negative input does not adjust the limit, and allows for retrieval of the currently set memory limit.","ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support.","BuildInfo represents the build information read from a Go binary.","A Module describes a single module included in a build.","A BuildSetting is a key-value pair describing one setting that influenced a build.\n\nDefined keys include:\n\n  - \\-buildmode: the buildmode flag used (typically \"exe\")\n  - \\-compiler: the compiler toolchain flag used (typically \"gc\")\n  - CGO\\_ENABLED: the effective CGO\\_ENABLED environment variable\n  - CGO\\_CFLAGS: the effective CGO\\_CFLAGS environment variable\n  - CGO\\_CPPFLAGS: the effective CGO\\_CPPFLAGS environment variable\n  - CGO\\_CXXFLAGS:  the effective CGO\\_CXXFLAGS environment variable\n  - CGO\\_LDFLAGS: the effective CGO\\_LDFLAGS environment variable\n  - GOARCH: the architecture target\n  - GOAMD64/GOARM/GO386/etc: the architecture feature level for GOARCH\n  - GOOS: the operating system target\n  - vcs: the version control system for the source tree where the build ran\n  - vcs.revision: the revision identifier for the current commit or checkout\n  - vcs.time: the modification time associated with vcs.revision, in RFC3339 format\n  - vcs.modified: true or false indicating whether the source tree had local modifications","","PrintStack prints to standard error the stack trace returned by runtime.Stack.","Stack returns a formatted stack trace of the goroutine that calls it. It calls [runtime.Stack](https://pkg.go.dev/runtime/#Stack) with a large enough buffer to capture the entire trace.","CrashOptions provides options that control the formatting of the fatal crash message.","SetCrashOutput configures a single additional file where unhandled panics and other fatal errors are printed, in addition to standard error. There is only one additional file: calling SetCrashOutput again overrides any earlier call. SetCrashOutput duplicates f's file descriptor, so the caller may safely close f as soon as SetCrashOutput returns. To disable this additional crash output, call SetCrashOutput(nil). If called concurrently with a crash, some in-progress output may be written to the old file even after an overriding SetCrashOutput returns.","Description describes a runtime metric.","All returns a slice of containing metric descriptions for all supported metrics.","Float64Histogram represents a distribution of float64 values.","Sample captures a single metric sample.","Read populates each \\[Value] field in the given slice of metric samples.\n\nDesired metrics should be present in the slice with the appropriate name. The user of this API is encouraged to re-use the same slice between calls for efficiency, but is not required to do so.\n\nNote that re-use has some caveats. Notably, Values should not be read or manipulated while a Read with that value is outstanding; that is a data race. This property includes pointer-typed Values (for example, \\[Float64Histogram]) whose underlying storage will be reused by Read when possible. To safely use such values in a concurrent setting, all data must be deep-copied.\n\nIt is safe to execute multiple Read calls concurrently, but their arguments must share no underlying memory. When in doubt, create a new \\[]Sample from scratch, which is always safe, though may be inefficient.\n\nSample values with names not appearing in \\[All] will have their Value populated as KindBad to indicate that the name is unknown.","ValueKind is a tag for a metric \\[Value] which indicates its type.","KindBad indicates that the Value has no type and should not be used.","KindUint64 indicates that the type of the Value is a uint64.","KindFloat64 indicates that the type of the Value is a float64.","KindFloat64Histogram indicates that the type of the Value is a \\*Float64Histogram.","Value represents a metric value returned by the runtime.","LabelSet is a set of labels.","WithLabels returns a new [context.Context](https://pkg.go.dev/context/#Context) with the given labels added. A label overwrites a prior label with the same key.","Labels takes an even number of strings representing key-value pairs and makes a \\[LabelSet] containing them. A label overwrites a prior label with the same key. Currently only the CPU and goroutine profiles utilize any labels information. See [https://golang.org/issue/23458](https://golang.org/issue/23458) for details.","Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.","ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.","A Profile is a collection of stack traces showing the call sequences that led to instances of a particular event, such as allocation. Packages can create and maintain their own profiles; the most common use is for tracking resources that must be explicitly closed, such as files or network connections.\n\nA Profile's methods can be called from multiple goroutines simultaneously.\n\nEach Profile has a unique name. A few profiles are predefined:\n\n\tgoroutine    - stack traces of all current goroutines\n\theap         - a sampling of memory allocations of live objects\n\tallocs       - a sampling of all past memory allocations\n\tthreadcreate - stack traces that led to the creation of new OS threads\n\tblock        - stack traces that led to blocking on synchronization primitives\n\tmutex        - stack traces of holders of contended mutexes\n\nThese predefined profiles maintain themselves and panic on an explicit \\[Profile.Add] or \\[Profile.Remove] method call.\n\nThe CPU profile is not available as a Profile. It has a special API, the \\[StartCPUProfile] and \\[StopCPUProfile] functions, because it streams output to a writer during profiling.\n\n### Heap profile {#hdr-Heap_profile}\n\nThe heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.\n\nThe heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse\\_space, -inuse\\_objects, -alloc\\_space, and -alloc\\_objects flags select which to display, defaulting to -inuse\\_space (live objects, scaled by size).\n\n### Allocs profile {#hdr-Allocs_profile}\n\nThe allocs profile is the same as the heap profile but changes the default pprof display to -alloc\\_space, the total number of bytes allocated since the program began (including garbage-collected bytes).\n\n### Block profile {#hdr-Block_profile}\n\nThe block profile tracks time spent blocked on synchronization primitives, such as [sync.Mutex](https://pkg.go.dev/sync/#Mutex), [sync.RWMutex](https://pkg.go.dev/sync/#RWMutex), [sync.WaitGroup](https://pkg.go.dev/sync/#WaitGroup), [sync.Cond](https://pkg.go.dev/sync/#Cond), and channel send/receive/select.\n\nStack traces correspond to the location that blocked (for example, [sync.Mutex.Lock](https://pkg.go.dev/sync/#Mutex.Lock)).\n\nSample values correspond to cumulative time spent blocked at that stack trace, subject to time-based sampling specified by [runtime.SetBlockProfileRate](https://pkg.go.dev/runtime/#SetBlockProfileRate).\n\n### Mutex profile {#hdr-Mutex_profile}\n\nThe mutex profile tracks contention on mutexes, such as [sync.Mutex](https://pkg.go.dev/sync/#Mutex), [sync.RWMutex](https://pkg.go.dev/sync/#RWMutex), and runtime-internal locks.\n\nStack traces correspond to the end of the critical section causing contention. For example, a lock held for a long time while other goroutines are waiting to acquire the lock will report contention when the lock is finally unlocked (that is, at [sync.Mutex.Unlock](https://pkg.go.dev/sync/#Mutex.Unlock)).\n\nSample values correspond to the approximate cumulative time other goroutines spent blocked waiting for the lock, subject to event-based sampling specified by [runtime.SetMutexProfileFraction](https://pkg.go.dev/runtime/#SetMutexProfileFraction). For example, if a caller holds a lock for 1s while 5 other goroutines are waiting for the entire second to acquire the lock, its unlock call stack will report 5s of contention.\n\nRuntime-internal locks are always reported at the location \"runtime.\\_LostContendedRuntimeLock\". More detailed stack traces for runtime-internal locks can be obtained by setting \\`GODEBUG=runtimecontentionstacks=1\\` (see package [runtime](https://pkg.go.dev/runtime/) docs for caveats).","NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces.","Lookup returns the profile with the given name, or nil if no such profile exists.","Profiles returns a slice of all the known profiles, sorted by name.","WriteHeapProfile is shorthand for \\[Lookup](\"heap\").WriteTo(w, 0). It is preserved for backwards compatibility.","StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call [os/signal.Notify](https://pkg.go.dev/os/signal/#Notify) for [syscall.SIGPROF](https://pkg.go.dev/syscall/#SIGPROF), but note that doing so may break any profiling being done by the main program.","StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed.","SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than \\[Do], which should be used instead when possible.","Do calls f with a copy of the parent context with the given labels added to the parent's label map. Goroutines spawned while executing f will inherit the augmented label-set. Each key/value pair in labels is inserted into the label map in the order provided, overriding any previous value for the same key. The augmented label map will be set for the duration of the call to f and restored once f returns.","NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.\n\nThe returned Task's \\[Task.End] method is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the End method is called, and provides the latency distribution per task type. If the End method is called multiple times, only the first call is used in the latency measurement.\n\n\tctx, task := trace.NewTask(ctx, \"awesomeTask\")\n\ttrace.WithRegion(ctx, \"preparation\", prepWork)\n\t// preparation of the task\n\tgo func() {  // continue processing the task in a separate goroutine.\n\t    defer task.End()\n\t    trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n\t}()","Task is a data type for tracing a user-defined, logical operation.","Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.","Logf is like \\[Log], but the value is formatted using the specified format spec.","WithRegion starts a region associated with its calling goroutine, runs fn, and then ends the region. If the context carries a task, the region is associated with the task. Otherwise, the region is attached to the background task.\n\nThe regionType is used to classify regions, so there should be only a handful of unique region types.","StartRegion starts a region and returns it. The returned Region's \\[Region.End] method must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is\n\n\tdefer trace.StartRegion(ctx, \"myTracedRegion\").End()","Region is a region of code whose execution time interval is traced.","IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.","Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled.","Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed.","SwapInt32 atomically stores new into \\*addr and returns the previous \\*addr value. Consider using the more ergonomic and less error-prone \\[Int32.Swap] instead.","SwapInt64 atomically stores new into \\*addr and returns the previous \\*addr value. Consider using the more ergonomic and less error-prone \\[Int64.Swap] instead (particularly if you target 32-bit platforms; see the bugs section).","SwapUint32 atomically stores new into \\*addr and returns the previous \\*addr value. Consider using the more ergonomic and less error-prone \\[Uint32.Swap] instead.","SwapUint64 atomically stores new into \\*addr and returns the previous \\*addr value. Consider using the more ergonomic and less error-prone \\[Uint64.Swap] instead (particularly if you target 32-bit platforms; see the bugs section).","SwapUintptr atomically stores new into \\*addr and returns the previous \\*addr value. Consider using the more ergonomic and less error-prone \\[Uintptr.Swap] instead.","SwapPointer atomically stores new into \\*addr and returns the previous \\*addr value. Consider using the more ergonomic and less error-prone \\[Pointer.Swap] instead.","CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. Consider using the more ergonomic and less error-prone \\[Int32.CompareAndSwap] instead.","CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value. Consider using the more ergonomic and less error-prone \\[Int64.CompareAndSwap] instead (particularly if you target 32-bit platforms; see the bugs section).","CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value. Consider using the more ergonomic and less error-prone \\[Uint32.CompareAndSwap] instead.","CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value. Consider using the more ergonomic and less error-prone \\[Uint64.CompareAndSwap] instead (particularly if you target 32-bit platforms; see the bugs section).","CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value. Consider using the more ergonomic and less error-prone \\[Uintptr.CompareAndSwap] instead.","CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value. Consider using the more ergonomic and less error-prone \\[Pointer.CompareAndSwap] instead.","AddInt32 atomically adds delta to \\*addr and returns the new value. Consider using the more ergonomic and less error-prone \\[Int32.Add] instead.","AddUint32 atomically adds delta to \\*addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(\u0026x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(\u0026x, ^uint32(0)). Consider using the more ergonomic and less error-prone \\[Uint32.Add] instead.","AddInt64 atomically adds delta to \\*addr and returns the new value. Consider using the more ergonomic and less error-prone \\[Int64.Add] instead (particularly if you target 32-bit platforms; see the bugs section).","AddUint64 atomically adds delta to \\*addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(\u0026x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(\u0026x, ^uint64(0)). Consider using the more ergonomic and less error-prone \\[Uint64.Add] instead (particularly if you target 32-bit platforms; see the bugs section).","AddUintptr atomically adds delta to \\*addr and returns the new value. Consider using the more ergonomic and less error-prone \\[Uintptr.Add] instead.","AndInt32 atomically performs a bitwise AND operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Int32.And] instead.","AndUint32 atomically performs a bitwise AND operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Uint32.And] instead.","AndInt64 atomically performs a bitwise AND operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Int64.And] instead.","AndUint64 atomically performs a bitwise AND operation on \\*addr using the bitmask provided as mask and returns the old. Consider using the more ergonomic and less error-prone \\[Uint64.And] instead.","AndUintptr atomically performs a bitwise AND operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Uintptr.And] instead.","OrInt32 atomically performs a bitwise OR operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Int32.Or] instead.","OrUint32 atomically performs a bitwise OR operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Uint32.Or] instead.","OrInt64 atomically performs a bitwise OR operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Int64.Or] instead.","OrUint64 atomically performs a bitwise OR operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Uint64.Or] instead.","OrUintptr atomically performs a bitwise OR operation on \\*addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone \\[Uintptr.Or] instead.","LoadInt32 atomically loads \\*addr. Consider using the more ergonomic and less error-prone \\[Int32.Load] instead.","LoadInt64 atomically loads \\*addr. Consider using the more ergonomic and less error-prone \\[Int64.Load] instead (particularly if you target 32-bit platforms; see the bugs section).","LoadUint32 atomically loads \\*addr. Consider using the more ergonomic and less error-prone \\[Uint32.Load] instead.","LoadUint64 atomically loads \\*addr. Consider using the more ergonomic and less error-prone \\[Uint64.Load] instead (particularly if you target 32-bit platforms; see the bugs section).","LoadUintptr atomically loads \\*addr. Consider using the more ergonomic and less error-prone \\[Uintptr.Load] instead.","LoadPointer atomically loads \\*addr. Consider using the more ergonomic and less error-prone \\[Pointer.Load] instead.","StoreInt32 atomically stores val into \\*addr. Consider using the more ergonomic and less error-prone \\[Int32.Store] instead.","StoreInt64 atomically stores val into \\*addr. Consider using the more ergonomic and less error-prone \\[Int64.Store] instead (particularly if you target 32-bit platforms; see the bugs section).","StoreUint32 atomically stores val into \\*addr. Consider using the more ergonomic and less error-prone \\[Uint32.Store] instead.","StoreUint64 atomically stores val into \\*addr. Consider using the more ergonomic and less error-prone \\[Uint64.Store] instead (particularly if you target 32-bit platforms; see the bugs section).","StoreUintptr atomically stores val into \\*addr. Consider using the more ergonomic and less error-prone \\[Uintptr.Store] instead.","StorePointer atomically stores val into \\*addr. Consider using the more ergonomic and less error-prone \\[Pointer.Store] instead.","A Bool is an atomic boolean value. The zero value is false.","A Pointer is an atomic pointer of type \\*T. The zero value is a nil \\*T.","An Int32 is an atomic int32. The zero value is zero.","An Int64 is an atomic int64. The zero value is zero.","A Uint32 is an atomic uint32. The zero value is zero.","A Uint64 is an atomic uint64. The zero value is zero.","A Uintptr is an atomic uintptr. The zero value is zero.","A Value provides an atomic load and store of a consistently typed value. The zero value for a Value returns nil from \\[Value.Load]. Once \\[Value.Store] has been called, a Value must not be copied.\n\nA Value must not be copied after first use.","Func is a wrapped Go function to be called by JavaScript.","FuncOf returns a function to be used by JavaScript.\n\nThe Go function fn is called with the value of JavaScript's \"this\" keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.\n\nInvoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.\n\nAs a consequence, if one wrapped function blocks, JavaScript's event loop is blocked until that function returns. Hence, calling any async JavaScript API, which requires the event loop, like fetch (http.Client), will cause an immediate deadlock. Therefore a blocking function should explicitly start a new goroutine.\n\nFunc.Release must be called to free up resources when the function will not be invoked any more.","Value represents a JavaScript value. The zero value is the JavaScript value \"undefined\". Values can be checked for equality with the Equal method.","Error wraps a JavaScript error.","Undefined returns the JavaScript value \"undefined\".","Null returns the JavaScript value \"null\".","Global returns the JavaScript global object, usually \"window\" or \"global\".","ValueOf returns x as a JavaScript value:\n\n\t| Go                     | JavaScript             |\n\t| ---------------------- | ---------------------- |\n\t| js.Value               | [its value]            |\n\t| js.Func                | function               |\n\t| nil                    | null                   |\n\t| bool                   | boolean                |\n\t| integers and floats    | number                 |\n\t| string                 | string                 |\n\t| []interface{}          | new array              |\n\t| map[string]interface{} | new object             |\n\nPanics if x is not one of the expected types.","Type represents the JavaScript type of a Value.","","","","","","","","","A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method.","CopyBytesToGo copies bytes from src to dst. It panics if src is not a Uint8Array or Uint8ClampedArray. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst.","CopyBytesToJS copies bytes from src to dst. It panics if dst is not a Uint8Array or Uint8ClampedArray. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst.","A MapFS is a simple in-memory file system for use in tests, represented as a map from path names (arguments to Open) to information about the files or directories they represent.\n\nThe map need not include parent directories for files contained in the map; those will be synthesized if needed. But a directory can still be included by setting the \\[MapFile.Mode]'s \\[fs.ModeDir] bit; this may be necessary for detailed control over the directory's \\[fs.FileInfo] or to create an empty directory.\n\nFile system operations read directly from the map, so that the file system can be changed by editing the map as needed. An implication is that file system operations must not run concurrently with changes to the map, which would be a race. Another implication is that opening or reading a directory requires iterating over the entire map, so a MapFS should typically be used with not more than a few hundred entries or directory reads.","A MapFile describes a single file in a \\[MapFS].","TestFS tests a file system implementation. It walks the entire tree of files in fsys, opening and checking that each file behaves correctly. It also checks that the file system contains at least the expected files. As a special case, if no expected files are listed, fsys must be empty. Otherwise, fsys must contain at least the listed files; it can also contain others. The contents of fsys must not change concurrently with TestFS.\n\nIf TestFS finds any misbehaviors, it returns either the first error or a list of errors. Use [errors.Is](https://pkg.go.dev/errors/#Is) or [errors.As](https://pkg.go.dev/errors/#As) to inspect.\n\nTypical usage inside a test is:\n\n\tif err := fstest.TestFS(myFS, \"file/that/should/be/present\"); err != nil {\n\t\tt.Fatal(err)\n\t}","NewWriteLogger returns a writer that behaves like w except that it logs (using [log.Printf](https://pkg.go.dev/log/#Printf)) each write to standard error, printing the prefix and the hexadecimal data written.","NewReadLogger returns a reader that behaves like r except that it logs (using [log.Printf](https://pkg.go.dev/log/#Printf)) each read to standard error, printing the prefix and the hexadecimal data read.","OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r.","HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.","DataErrReader changes the way errors are handled by a Reader. Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data.","ErrTimeout is a fake timeout error.","TimeoutReader returns \\[ErrTimeout] on the second read with no data. Subsequent calls to read succeed.","ErrReader returns an [io.Reader](https://pkg.go.dev/io/#Reader) that returns 0, err from all Read calls.","TestReader tests that reading from r returns the expected file content. It does reads of different sizes, until EOF. If r implements [io.ReaderAt](https://pkg.go.dev/io/#ReaderAt) or [io.Seeker](https://pkg.go.dev/io/#Seeker), TestReader also checks that those operations behave as they should.\n\nIf TestReader finds any misbehaviors, it returns an error reporting them. The error text may span multiple lines.","TruncateWriter returns a Writer that writes to w but stops silently after n bytes.","A Generator can generate random values of its own type.","Value returns an arbitrary value of the given type. If the type implements the \\[Generator] interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.","A Config structure contains options for running a test.","A SetupError is the result of an error in the way that check is being used, independent of the functions being tested.","A CheckError is the result of Check finding an error.","A CheckEqualError is the result \\[CheckEqual] finding an error.","Check looks for an input to f, any function that returns bool, such that f returns false. It calls f repeatedly, with arbitrary values for each argument. If f returns false on a given input, Check returns that input as a \\*\\[CheckError]. For example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 \u0026\u0026 y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}","CheckEqual looks for an input on which f and g return different results. It calls f and g repeatedly with arbitrary values for each argument. If f and g return different answers, CheckEqual returns a \\*\\[CheckEqualError] describing the input and the outputs.","TestHandler tests a \\[slog.Handler]. If TestHandler finds any misbehaviors, it returns an error for each, combined into a single error with [errors.Join](https://pkg.go.dev/errors/#Join).\n\nTestHandler installs the given Handler in a \\[slog.Logger] and makes several calls to the Logger's output methods. The Handler should be enabled for levels Info and above.\n\nThe results function is invoked after all such calls. It should return a slice of map\\[string]any, one for each call to a Logger output method. The keys and values of the map should correspond to the keys and values of the Handler's output. Each group in the output should be represented as its own nested map\\[string]any. The standard keys \\[slog.TimeKey], \\[slog.LevelKey] and \\[slog.MessageKey] should be used.\n\nIf the Handler outputs JSON, then calling [encoding/json.Unmarshal](https://pkg.go.dev/encoding/json/#Unmarshal) with a \\`map\\[string]any\\` will create the right data structure.\n\nIf a Handler intentionally drops an attribute that is checked by a test, then the results function should check for its absence and add it to the map it returns.","Run exercises a \\[slog.Handler] on the same test cases as \\[TestHandler], but runs each case in a subtest. For each test case, it first calls newHandler to get an instance of the handler under test, then runs the test case, then calls result to get the result. If the test case fails, it calls t.Error.","Position is a value that represents a source position. A position is valid if Line \u003e 0.","","","","","","","","","","","","","","","","","","TokenString returns a printable string for a token or Unicode character.","GoWhitespace is the default value for the \\[Scanner]'s Whitespace field. Its value selects Go's white space characters.","A Scanner implements reading of Unicode characters and tokens from an [io.Reader](https://pkg.go.dev/io/#Reader).","A Writer is a filter that inserts padding around tab-delimited columns in its input to align them in the output.\n\nThe Writer treats incoming bytes as UTF-8-encoded text consisting of cells terminated by horizontal ('\\\\t') or vertical ('\\\\v') tabs, and newline ('\\\\n') or formfeed ('\\\\f') characters; both newline and formfeed act as line breaks.\n\nTab-terminated cells in contiguous lines constitute a column. The Writer inserts padding as needed to make all cells in a column have the same width, effectively aligning the columns. It assumes that all characters have the same width, except for tabs for which a tabwidth must be specified. Column cells must be tab-terminated, not tab-separated: non-tab terminated trailing text at the end of a line forms a cell but that cell is not part of an aligned column. For instance, in this example (where | stands for a horizontal tab):\n\n\taaaa|bbb|d\n\taa  |b  |dd\n\ta   |\n\taa  |cccc|eee\n\nthe b and c are in distinct columns (the b column is not contiguous all the way). The d and e are not in a column at all (there's no terminating tab, nor would the column be contiguous).\n\nThe Writer assumes that all Unicode code points have the same width; this may not be true in some fonts or if the string contains combining characters.\n\nIf \\[DiscardEmptyColumns] is set, empty columns that are terminated entirely by vertical (or \"soft\") tabs are discarded. Columns terminated by horizontal (or \"hard\") tabs are not affected by this flag.\n\nIf a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes.\n\nA segment of text may be escaped by bracketing it with \\[Escape] characters. The tabwriter passes escaped text segments through unchanged. In particular, it does not interpret any tabs or line breaks within the segment. If the \\[StripEscape] flag is set, the Escape characters are stripped from the output; otherwise they are passed through as well. For the purpose of formatting, the width of the escaped text is always computed excluding the Escape characters.\n\nThe formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling \\[Writer.Flush]). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.\n\nThe Writer must buffer input internally, because proper spacing of one line may depend on the cells in future lines. Clients must call Flush when done calling \\[Writer.Write].","Ignore html tags and treat entities (starting with '\u0026' and ending in ';') as single characters (width = 1).","Strip Escape characters bracketing escaped text segments instead of passing them through unchanged with the text.","Force right-alignment of cell content. Default is left-alignment.","Handle empty columns as if they were not present in the input in the first place.","Always use tabs for indentation columns (i.e., padding of leading empty cells on the left) independent of padchar.","Print a vertical bar ('|') between columns (after formatting). Discarded columns appear as zero-width columns (\"||\").","To escape a text segment, bracket it with Escape characters. For instance, the tab in this string \"Ignore this tab: \\\\xff\\\\t\\\\xff\" does not terminate a cell and constitutes a single character of width one for formatting purposes.\n\nThe value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.","NewWriter allocates and initializes a new \\[Writer]. The parameters are the same as for the Init function.","ExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.)","IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.","FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.\n\nErrors returned by Execute wrap the underlying error; call [errors.As](https://pkg.go.dev/errors/#As) to unwrap them.\n\nWhen template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type [reflect.Value](https://pkg.go.dev/reflect/#Value). Similarly, functions meant to return a result of arbitrary type can return interface{} or [reflect.Value](https://pkg.go.dev/reflect/#Value).","HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.","HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.","HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.","JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.","JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.","JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.","URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.","Must is a helper that wraps a call to a function returning (\\[\\*Template], error) and panics if the error is non-nil. It is intended for use in variable initializations such as\n\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))","ParseFiles creates a new \\[Template] and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned \\*Template is nil.\n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable.","ParseGlob creates a new \\[Template] and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of \\[filepath.Match], and the pattern must match at least one file. The returned template will have the \\[filepath.Base] name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling \\[ParseFiles] with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.","ParseFS is like \\[Template.ParseFiles] or \\[Template.ParseGlob] but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns (see [path.Match](https://pkg.go.dev/path/#Match)). (Note that most file names serve as glob patterns matching only themselves.)","Template is the representation of a parsed template. The \\*parse.Tree field is exported only for use by [html/template](https://pkg.go.dev/html/template/) and should be treated as unexported by all other clients.","New allocates a new, undefined template with the given name.","IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.","DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD.","EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD.","RuneLen returns the number of 16-bit words in the UTF-16 encoding of the rune. It returns -1 if the rune is not a valid value to encode in UTF-16.","Encode returns the UTF-16 encoding of the Unicode code point sequence s.","AppendRune appends the UTF-16 encoding of the Unicode code point r to the end of p and returns the extended buffer. If the rune is not a valid Unicode code point, it appends the encoding of U+FFFD.","Decode returns the Unicode code point sequence represented by the UTF-16 encoding s.","","","","","FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.","FullRuneInString is like FullRune but its input is a string.","DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (\\[RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed.","DecodeRuneInString is like \\[DecodeRune] but its input is a string. If s is empty it returns (\\[RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed.","DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (\\[RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed.","DecodeLastRuneInString is like \\[DecodeLastRune] but its input is a string. If s is empty it returns (\\[RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed.","RuneLen returns the number of bytes in the UTF-8 encoding of the rune. It returns -1 if the rune is not a valid value to encode in UTF-8.","EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune. If the rune is out of range, it writes the encoding of \\[RuneError]. It returns the number of bytes written.","AppendRune appends the UTF-8 encoding of r to the end of p and returns the extended buffer. If the rune is out of range, it appends the encoding of \\[RuneError].","RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte.","RuneCountInString is like \\[RuneCount] but its input is a string.","RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10.","Valid reports whether p consists entirely of valid UTF-8-encoded runes.","ValidString reports whether s consists entirely of valid UTF-8-encoded runes.","ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.","AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC 5280, section 4.1.1.2.","","","AttributeTypeAndValue mirrors the ASN.1 structure of the same name in RFC 5280, Section 4.1.2.4.","AttributeTypeAndValueSET represents a set of ASN.1 sequences of \\[AttributeTypeAndValue] sequences from RFC 2986 (PKCS #10).","Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2.","Name represents an X.509 distinguished name. This only includes the common elements of a DN. Note that Name is only an approximation of the X.509 structure. If an accurate representation is needed, asn1.Unmarshal the raw subject or issuer as an \\[RDNSequence].","CertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the signature.\n\nDeprecated: x509.RevocationList should be used instead.","TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.\n\nDeprecated: x509.RevocationList should be used instead.","RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.","Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's \\[NamedValueChecker] interface, or an instance of one of these types:\n\n\tint64\n\tfloat64\n\tbool\n\t[]byte\n\tstring\n\ttime.Time\n\nIf the driver supports cursors, a returned Value may also implement the \\[Rows] interface in this package. This is used, for example, when a user selects a cursor such as \"select cursor(select \\* from my\\_table) from dual\". If the \\[Rows] from the select is closed, the cursor \\[Rows] will also be closed.","NamedValue holds both the value name and value.","Driver is the interface that must be implemented by a database driver.\n\nDatabase drivers may implement \\[DriverContext] for access to contexts and to parse the name only once for a pool of connections, instead of once per connection.","If a \\[Driver] implements DriverContext, then [database/sql.DB](https://pkg.go.dev/database/sql/#DB) will call OpenConnector to obtain a \\[Connector] and then invoke that \\[Connector]'s Connect method to obtain each needed connection, instead of invoking the \\[Driver]'s Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-\\[Conn] contexts.","A Connector represents a driver in a fixed configuration and can create any number of equivalent Conns for use by multiple goroutines.\n\nA Connector can be passed to [database/sql.OpenDB](https://pkg.go.dev/database/sql/#OpenDB), to allow drivers to implement their own [database/sql.DB](https://pkg.go.dev/database/sql/#DB) constructors, or returned by \\[DriverContext]'s OpenConnector method, to allow drivers access to context and to avoid repeated parsing of driver configuration.\n\nIf a Connector implements [io.Closer](https://pkg.go.dev/io/#Closer), the [database/sql.DB.Close](https://pkg.go.dev/database/sql/#DB.Close) method will call the Close method and return error (if any).","ErrSkip may be returned by some optional interfaces' methods to indicate at runtime that the fast path is unavailable and the sql package should continue as if the optional interface was not implemented. ErrSkip is only supported where explicitly documented.","ErrBadConn should be returned by a driver to signal to the [database/sql](https://pkg.go.dev/database/sql/) package that a driver.\\[Conn] is in a bad state (such as the server having earlier closed the connection) and the [database/sql](https://pkg.go.dev/database/sql/) package should retry on a new connection.\n\nTo prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.\n\nErrors will be checked using [errors.Is](https://pkg.go.dev/errors/#Is). An error may wrap ErrBadConn or implement the Is(error) bool method.","Pinger is an optional interface that may be implemented by a \\[Conn].\n\nIf a \\[Conn] does not implement Pinger, the [database/sql.DB.Ping](https://pkg.go.dev/database/sql/#DB.Ping) and [database/sql.DB.PingContext](https://pkg.go.dev/database/sql/#DB.PingContext) will check if there is at least one \\[Conn] available.\n\nIf Conn.Ping returns \\[ErrBadConn], [database/sql.DB.Ping](https://pkg.go.dev/database/sql/#DB.Ping) and [database/sql.DB.PingContext](https://pkg.go.dev/database/sql/#DB.PingContext) will remove the \\[Conn] from pool.","Execer is an optional interface that may be implemented by a \\[Conn].\n\nIf a \\[Conn] implements neither \\[ExecerContext] nor \\[Execer], the [database/sql.DB.Exec](https://pkg.go.dev/database/sql/#DB.Exec) will first prepare a query, execute the statement, and then close the statement.\n\nExec may return \\[ErrSkip].\n\nDeprecated: Drivers should implement \\[ExecerContext] instead.","ExecerContext is an optional interface that may be implemented by a \\[Conn].\n\nIf a \\[Conn] does not implement \\[ExecerContext], the [database/sql.DB.Exec](https://pkg.go.dev/database/sql/#DB.Exec) will fall back to \\[Execer]; if the Conn does not implement Execer either, [database/sql.DB.Exec](https://pkg.go.dev/database/sql/#DB.Exec) will first prepare a query, execute the statement, and then close the statement.\n\nExecContext may return \\[ErrSkip].\n\nExecContext must honor the context timeout and return when the context is canceled.","Queryer is an optional interface that may be implemented by a \\[Conn].\n\nIf a \\[Conn] implements neither \\[QueryerContext] nor \\[Queryer], the [database/sql.DB.Query](https://pkg.go.dev/database/sql/#DB.Query) will first prepare a query, execute the statement, and then close the statement.\n\nQuery may return \\[ErrSkip].\n\nDeprecated: Drivers should implement \\[QueryerContext] instead.","QueryerContext is an optional interface that may be implemented by a \\[Conn].\n\nIf a \\[Conn] does not implement QueryerContext, the [database/sql.DB.Query](https://pkg.go.dev/database/sql/#DB.Query) will fall back to \\[Queryer]; if the \\[Conn] does not implement \\[Queryer] either, [database/sql.DB.Query](https://pkg.go.dev/database/sql/#DB.Query) will first prepare a query, execute the statement, and then close the statement.\n\nQueryContext may return \\[ErrSkip].\n\nQueryContext must honor the context timeout and return when the context is canceled.","Conn is a connection to a database. It is not used concurrently by multiple goroutines.\n\nConn is assumed to be stateful.","ConnPrepareContext enhances the \\[Conn] interface with context.","IsolationLevel is the transaction isolation level stored in \\[TxOptions].\n\nThis type should be considered identical to [database/sql.IsolationLevel](https://pkg.go.dev/database/sql/#IsolationLevel) along with any values defined on it.","TxOptions holds the transaction options.\n\nThis type should be considered identical to [database/sql.TxOptions](https://pkg.go.dev/database/sql/#TxOptions).","ConnBeginTx enhances the \\[Conn] interface with context and \\[TxOptions].","SessionResetter may be implemented by \\[Conn] to allow drivers to reset the session state associated with the connection and to signal a bad connection.","Validator may be implemented by \\[Conn] to allow drivers to signal if a connection is valid or if it should be discarded.\n\nIf implemented, drivers may return the underlying error from queries, even if the connection should be discarded by the connection pool.","Result is the result of a query execution.","Stmt is a prepared statement. It is bound to a \\[Conn] and not used by multiple goroutines concurrently.","StmtExecContext enhances the \\[Stmt] interface by providing Exec with context.","StmtQueryContext enhances the \\[Stmt] interface by providing Query with context.","ErrRemoveArgument may be returned from \\[NamedValueChecker] to instruct the [database/sql](https://pkg.go.dev/database/sql/) package to not pass the argument to the driver query interface. Return when accepting query specific options or structures that aren't SQL query arguments.","NamedValueChecker may be optionally implemented by \\[Conn] or \\[Stmt]. It provides the driver more control to handle Go and database types beyond the default \\[Value] types allowed.\n\nThe [database/sql](https://pkg.go.dev/database/sql/) package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, \\[DefaultParameterConverter].\n\nIf CheckNamedValue returns \\[ErrRemoveArgument], the \\[NamedValue] will not be included in the final query arguments. This may be used to pass special options to the query itself.\n\nIf \\[ErrSkip] is returned the column converter error checking path is used for the argument. Drivers may wish to return \\[ErrSkip] after they have exhausted their own special cases.","ColumnConverter may be optionally implemented by \\[Stmt] if the statement is aware of its own columns' types and can convert from any type to a driver \\[Value].\n\nDeprecated: Drivers should implement \\[NamedValueChecker].","Rows is an iterator over an executed query's results.","RowsNextResultSet extends the \\[Rows] interface by providing a way to signal the driver to advance to the next result set.","RowsColumnTypeScanType may be implemented by \\[Rows]. It should return the value type that can be used to scan types into. For example, the database column type \"bigint\" this should return \"[reflect.TypeOf](https://pkg.go.dev/reflect/#TypeOf)(int64(0))\".","RowsColumnTypeDatabaseTypeName may be implemented by \\[Rows]. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: \"VARCHAR\", \"NVARCHAR\", \"VARCHAR2\", \"CHAR\", \"TEXT\", \"DECIMAL\", \"SMALLINT\", \"INT\", \"BIGINT\", \"BOOL\", \"\\[]BIGINT\", \"JSONB\", \"XML\", \"TIMESTAMP\".","RowsColumnTypeLength may be implemented by \\[Rows]. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return [math.MaxInt64](https://pkg.go.dev/math/#MaxInt64). The following are examples of returned values for various types:\n\n\tTEXT          (math.MaxInt64, true)\n\tvarchar(10)   (10, true)\n\tnvarchar(10)  (10, true)\n\tdecimal       (0, false)\n\tint           (0, false)\n\tbytea(30)     (30, true)","RowsColumnTypeNullable may be implemented by \\[Rows]. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.","RowsColumnTypePrecisionScale may be implemented by \\[Rows]. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:\n\n\tdecimal(38, 4)    (38, 4, true)\n\tint               (0, 0, false)\n\tdecimal           (math.MaxInt64, math.MaxInt64, true)","Tx is a transaction.","RowsAffected implements \\[Result] for an INSERT or UPDATE operation which mutates a number of rows.","ResultNoRows is a pre-defined \\[Result] for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and \\[RowsAffected].","ValueConverter is the interface providing the ConvertValue method.\n\nVarious implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:\n\n  - converting from the \\[Value] types as provided by the sql package into a database table's specific column type and making sure it fits, such as making sure a particular int64 fits in a table's uint16 column.\n\n  - converting a value as given from the database into one of the driver \\[Value] types.\n\n  - by the [database/sql](https://pkg.go.dev/database/sql/) package, for converting from a driver's \\[Value] type to a user's type in a scan.","Valuer is the interface providing the Value method.\n\nErrors returned by the \\[Value] method are wrapped by the database/sql package. This allows callers to use [errors.Is](https://pkg.go.dev/errors/#Is) for precise error handling after operations like [database/sql.Query](https://pkg.go.dev/database/sql/#Query), [database/sql.Exec](https://pkg.go.dev/database/sql/#Exec), or [database/sql.QueryRow](https://pkg.go.dev/database/sql/#QueryRow).\n\nTypes implementing Valuer interface are able to convert themselves to a driver \\[Value].","Bool is a \\[ValueConverter] that converts input values to bool.\n\nThe conversion rules are:\n\n  - booleans are returned unchanged\n  - for integer types, 1 is true 0 is false, other integers are an error\n  - for strings and \\[]byte, same rules as [strconv.ParseBool](https://pkg.go.dev/strconv/#ParseBool)\n  - all other types are an error","Int32 is a \\[ValueConverter] that converts input values to int64, respecting the limits of an int32 value.","String is a \\[ValueConverter] that converts its input to a string. If the value is already a string or \\[]byte, it's unchanged. If the value is of another type, conversion to string is done with fmt.Sprintf(\"%v\", v).","Null is a type that implements \\[ValueConverter] by allowing nil values but otherwise delegating to another \\[ValueConverter].","NotNull is a type that implements \\[ValueConverter] by disallowing nil values but otherwise delegating to another \\[ValueConverter].","IsValue reports whether v is a valid \\[Value] parameter type.","IsScanValue is equivalent to \\[IsValue]. It exists for compatibility.","DefaultParameterConverter is the default implementation of \\[ValueConverter] that's used when a \\[Stmt] doesn't implement \\[ColumnConverter].\n\nDefaultParameterConverter returns its argument directly if IsValue(arg). Otherwise, if the argument implements \\[Valuer], its Value method is used to return a \\[Value]. As a fallback, the provided argument's underlying type is used to convert it to a \\[Value]: underlying integer types are converted to int64, floats to float64, bool, string, and \\[]byte to themselves. If the argument is a nil pointer, defaultConverter.ConvertValue returns a nil \\[Value]. If the argument is a non-nil pointer, it is dereferenced and defaultConverter.ConvertValue is called recursively. Other types are an error.","An Expr is a build tag constraint expression. The underlying concrete type is \\*\\[AndExpr], \\*\\[OrExpr], \\*\\[NotExpr], or \\*\\[TagExpr].","A TagExpr is an \\[Expr] for the single tag Tag.","A NotExpr represents the expression !X (the negation of X).","An AndExpr represents the expression X \u0026\u0026 Y.","An OrExpr represents the expression X || Y.","A SyntaxError reports a syntax error in a parsed build expression.","Parse parses a single build constraint line of the form “//go:build ...” or “// +build ...” and returns the corresponding boolean expression.","IsGoBuild reports whether the line of text is a “//go:build” constraint. It only checks the prefix of the text, not that the expression itself parses.","IsPlusBuild reports whether the line of text is a “// +build” constraint. It only checks the prefix of the text, not that the expression itself parses.","PlusBuildLines returns a sequence of “// +build” lines that evaluate to the build expression x. If the expression is too complex to convert directly to “// +build” lines, PlusBuildLines returns an error.","GoVersion returns the minimum Go version implied by a given build expression. If the expression can be satisfied without any Go version tags, GoVersion returns an empty string.\n\nFor example:\n\n\tGoVersion(linux \u0026\u0026 go1.22) = \"go1.22\"\n\tGoVersion((linux \u0026\u0026 go1.22) || (windows \u0026\u0026 go1.20)) = \"go1.20\" =\u003e go1.20\n\tGoVersion(linux) = \"\"\n\tGoVersion(linux || (windows \u0026\u0026 go1.22)) = \"\"\n\tGoVersion(!go1.22) = \"\"\n\nGoVersion assumes that any tag or negated tag may independently be true, so that its analysis can be purely structural, without SAT solving. “Impossible” subexpressions may therefore affect the result.\n\nFor example:\n\n\tGoVersion((linux \u0026\u0026 !linux \u0026\u0026 go1.20) || go1.21) = \"go1.20\"","A Doc is a parsed Go doc comment.","A LinkDef is a single link definition.","A Block is block-level content in a doc comment, one of \\[\\*Code], \\[\\*Heading], \\[\\*List], or \\[\\*Paragraph].","A Heading is a doc comment heading.","A List is a numbered or bullet list. Lists are always non-empty: len(Items) \u003e 0. In a numbered list, every Items\\[i].Number is a non-empty string. In a bullet list, every Items\\[i].Number is an empty string.","A ListItem is a single item in a numbered or bullet list.","A Paragraph is a paragraph of text.","A Code is a preformatted code block.","A Text is text-level content in a doc comment, one of \\[Plain], \\[Italic], \\[\\*Link], or \\[\\*DocLink].","A Plain is a string rendered as plain text (not italicized).","An Italic is a string rendered as italicized text.","A Link is a link to a specific URL.","A DocLink is a link to documentation for a Go package or symbol.","A Parser is a doc comment parser. The fields in the struct can be filled in before calling \\[Parser.Parse] in order to customize the details of the parsing process.","DefaultLookupPackage is the default package lookup function, used when \\[Parser.LookupPackage] is nil. It recognizes names of the packages from the standard library with single-element import paths, such as math, which would otherwise be impossible to name.\n\nNote that the go/doc package provides a more sophisticated lookup based on the imports used in the current package.","A Printer is a doc comment printer. The fields in the struct can be filled in before calling any of the printing methods in order to customize the details of the printing process.","Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4×4×4 subdivision, with 4 shades in each subcube. Compared to the \\[WebSafe], the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones.\n\nThis palette was used in the Plan 9 Operating System, described at [https://9p.io/magic/man2html/6/color](https://9p.io/magic/man2html/6/color)","WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.\n\nSee [https://en.wikipedia.org/wiki/Web\\_colors#Web-safe\\_colors](https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors) for details.","A ChaCha8 is a ChaCha8-based cryptographically strong random number generator.","NewChaCha8 returns a new ChaCha8 seeded with the given seed.","A PCG is a PCG generator with 128 bits of internal state. A zero PCG is equivalent to NewPCG(0, 0).","NewPCG returns a new PCG seeded with the given values.","A Source is a source of uniformly-distributed pseudo-random uint64 values in the range \\[0, 1\\\u003c\\\u003c64).\n\nA Source is not safe for concurrent use by multiple goroutines.","A Rand is a source of random numbers.","New returns a new Rand that uses random values from src to generate other random values.","Int64 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.","Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.","Uint64N returns, as a uint64, a pseudo-random number in the half-open interval \\[0,n) from the default Source. It panics if n \\\u003c= 0.","Uint32N returns, as a uint32, a pseudo-random number in the half-open interval \\[0,n) from the default Source. It panics if n \\\u003c= 0.","Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.","Int32 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.","Int returns a non-negative pseudo-random int from the default Source.","Uint returns a pseudo-random uint from the default Source.","Int64N returns, as an int64, a pseudo-random number in the half-open interval \\[0,n) from the default Source. It panics if n \\\u003c= 0.","Int32N returns, as an int32, a pseudo-random number in the half-open interval \\[0,n) from the default Source. It panics if n \\\u003c= 0.","IntN returns, as an int, a pseudo-random number in the half-open interval \\[0,n) from the default Source. It panics if n \\\u003c= 0.","UintN returns, as a uint, a pseudo-random number in the half-open interval \\[0,n) from the default Source. It panics if n \\\u003c= 0.","N returns a pseudo-random number in the half-open interval \\[0,n) from the default Source. The type parameter Int can be any integer type. It panics if n \\\u003c= 0.","Float64 returns, as a float64, a pseudo-random number in the half-open interval \\[0.0,1.0) from the default Source.","Float32 returns, as a float32, a pseudo-random number in the half-open interval \\[0.0,1.0) from the default Source.","Perm returns, as a slice of n ints, a pseudo-random permutation of the integers in the half-open interval \\[0,n) from the default Source.","Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n \\\u003c 0. swap swaps the elements with indexes i and j.","NormFloat64 returns a normally distributed float64 in the range \\[-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using:\n\n\tsample = NormFloat64() * desiredStdDev + desiredMean","ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To produce a distribution with a different rate parameter, callers can adjust the output using:\n\n\tsample = ExpFloat64() / desiredRateParameter","A Zipf generates Zipf distributed variates.","NewZipf returns a Zipf variate generator. The generator generates values k ∈ \\[0, imax] such that P(k) is proportional to (v + k) \\*\\* (-s). Requirements: s \u003e 1 and v \u003e= 1.","Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable.","RequestFromMap creates an \\[http.Request] from CGI variables. The returned Request's Body field is not populated.","Serve executes the provided \\[Handler] on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use \\[http.DefaultServeMux].","Handler runs an executable in a subprocess with a CGI environment.","PublicSuffixList provides the public suffix of a domain. For example:\n\n  - the public suffix of \"example.com\" is \"com\",\n  - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n  - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".\n\nImplementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.\n\nAn implementation that always returns \"\" is valid and may be useful for testing but it is not secure: it means that the HTTP server for foo.com can set a cookie for bar.com.\n\nA public suffix list implementation is in the package golang.org/x/net/publicsuffix.","Options are the options for creating a new Jar.","Jar implements the http.CookieJar interface from the net/http package.","New returns a new cookie jar. A nil \\[\\*Options] is equivalent to a zero Options.","ErrRequestAborted is returned by Read when a handler attempts to read the body of a request that has been aborted by the web server.","ErrConnClosed is returned by Read when a handler attempts to read the body of a request after the connection to the web server has been closed.","Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, \\[http.DefaultServeMux] is used.","ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE\\_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).","NewRequest wraps NewRequestWithContext using context.Background.","NewRequestWithContext returns a new incoming server Request, suitable for passing to an \\[http.Handler] for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme \"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type \\*bytes.Reader, \\*strings.Reader, or \\*bytes.Buffer, the Request.ContentLength is set.\n\nNewRequest panics on error for ease of use in testing, where a panic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.","ResponseRecorder is an implementation of \\[http.ResponseWriter] that records its mutations for later inspection in tests.","NewRecorder returns an initialized \\[ResponseRecorder].","DefaultRemoteAddr is the default remote address to return in RemoteAddr if an explicit DefaultRemoteAddr isn't set on \\[ResponseRecorder].","A Server is an HTTP server listening on a system-chosen port on the local loopback interface, for use in end-to-end HTTP tests.","NewServer starts and returns a new \\[Server]. The caller should call Close when finished, to shut it down.","NewUnstartedServer returns a new \\[Server] but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or StartTLS.\n\nThe caller should call Close when finished, to shut it down.","NewTLSServer starts and returns a new \\[Server] using TLS. The caller should call Close when finished, to shut it down.","ContextClientTrace returns the \\[ClientTrace] associated with the provided context. If none, it returns nil.","WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.","ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. Any particular hook may be nil. Functions may be called concurrently from different goroutines and some may be called after the request has completed or failed.\n\nClientTrace currently traces a single HTTP request \u0026 response during a single round trip and has no hooks that span a series of redirected requests.\n\nSee [https://blog.golang.org/http-tracing](https://blog.golang.org/http-tracing) for more.","WroteRequestInfo contains information provided to the WroteRequest hook.","DNSStartInfo contains information about a DNS request.","DNSDoneInfo contains information about the results of a DNS lookup.","GotConnInfo is the argument to the \\[ClientTrace.GotConn] function and contains information about the obtained connection.","DumpRequestOut is like \\[DumpRequest] but for outgoing client requests. It includes any headers that the standard \\[http.Transport] adds, such as User-Agent.","DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an \\[http.Request]. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new [io.ReadCloser](https://pkg.go.dev/io/#ReadCloser) that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.\n\nThe documentation for \\[http.Request.Write] details which fields of req are included in the dump.","DumpResponse is like DumpRequest but dumps a response.","NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns [io.EOF](https://pkg.go.dev/io/#EOF) when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies.","NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.","ErrLineTooLong is returned when reading malformed chunked data with lines that are too long.","Deprecated: No longer used.","Deprecated: No longer used.","Deprecated: No longer used.","ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.\n\nDeprecated: Use the Server in package [net/http](https://pkg.go.dev/net/http/) instead.","NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.\n\nDeprecated: Use the Server in package [net/http](https://pkg.go.dev/net/http/) instead.","ClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.\n\nDeprecated: Use Client or Transport in package [net/http](https://pkg.go.dev/net/http/) instead.","NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package [net/http](https://pkg.go.dev/net/http/) instead.","NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package [net/http](https://pkg.go.dev/net/http/) instead.","A ProxyRequest contains a request to be rewritten by a \\[ReverseProxy].","ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.\n\n1xx responses are forwarded to the client if the underlying transport supports ClientTrace.Got1xxResponse.","A BufferPool is an interface for getting and returning temporary byte slices for use by [io.CopyBuffer](https://pkg.go.dev/io/#CopyBuffer).","NewSingleHostReverseProxy returns a new \\[ReverseProxy] that routes URLs to the scheme, host, and base path provided in target. If the target's path is \"/base\" and the incoming request was for \"/dir\", the target request will be for /base/dir.\n\nNewSingleHostReverseProxy does not rewrite the Host header.\n\nTo customize the ReverseProxy behavior beyond what NewSingleHostReverseProxy provides, use ReverseProxy directly with a Rewrite function. The ProxyRequest SetURL method may be used to route the outbound request. (Note that SetURL, unlike NewSingleHostReverseProxy, rewrites the Host header of the outbound request by default.)\n\n\tproxy := \u0026ReverseProxy{\n\t\tRewrite: func(r *ProxyRequest) {\n\t\t\tr.SetURL(target)\n\t\t\tr.Out.Host = r.In.Host // if desired\n\t\t},\n\t}","Cmdline responds with the running program's command line, with arguments separated by NUL bytes. The package initialization registers it as /debug/pprof/cmdline.","Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.","Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.","Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol.","Handler returns an HTTP handler that serves the named profile. Available profiles can be found in [runtime/pprof.Profile](https://pkg.go.dev/runtime/pprof/#Profile).","Index responds with the pprof-formatted profile named by the request. For example, \"/debug/pprof/heap\" serves the \"heap\" profile. Index responds to a request for \"/debug/pprof/\" with an HTML page listing the available profiles.","NewClientCodec returns a new \\[rpc.ClientCodec] using JSON-RPC on conn.","NewClient returns a new \\[rpc.Client] to handle requests to the set of services at the other end of the connection.","Dial connects to a JSON-RPC server at the specified network address.","NewServerCodec returns a new \\[rpc.ServerCodec] using JSON-RPC on conn.","ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.","A Node is an element in the parse tree. The interface is trivial. The interface contains an unexported method so that only types local to this package can satisfy it.","NodeType identifies the type of a parse tree node.","Pos represents a byte position in the original input text from which this template was parsed.","","","","","","","","","","","","","","","","","","","","","","ListNode holds a sequence of nodes.","TextNode holds plain text.","CommentNode holds a comment.","PipeNode holds a pipeline with optional declaration","ActionNode holds an action (something bounded by delimiters). Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines.","CommandNode holds a command (a pipeline inside an evaluating action).","IdentifierNode holds an identifier.","NewIdentifier returns a new \\[IdentifierNode] with the given identifier name.","VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.","DotNode holds the special identifier '.'.","NilNode holds the special identifier 'nil' representing an untyped nil constant.","FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident.","ChainNode holds a term followed by a chain of field accesses (identifier starting with '.'). The names may be chained ('.x.y'). The periods are dropped from each ident.","BoolNode holds a boolean constant.","NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants.","StringNode holds a string constant. The value has been \"unquoted\".","BranchNode is the common representation of if, range, and with.","IfNode represents an {{if}} action and its commands.","BreakNode represents a {{break}} action.","ContinueNode represents a {{continue}} action.","RangeNode represents a {{range}} action and its commands.","WithNode represents a {{with}} action and its commands.","TemplateNode represents a {{template}} action.","Tree is the representation of a single parsed template.","A mode value is a set of flags (or 0). Modes control parser behavior.","","","Parse returns a map from template name to \\[Tree], created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error.","New allocates a new parse tree with the given name.","IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.","KeySize is the size of the key used by this cipher, in bytes.","NonceSize is the size of the nonce used with the standard variant of this cipher, in bytes.\n\nNote that this is too short to be safely generated at random if the same key is reused more than 2³² times.","NonceSizeX is the size of the nonce used with the XChaCha20 variant of this cipher, in bytes.","Cipher is a stateful instance of ChaCha20 or XChaCha20 using a particular key and nonce. A \\*Cipher implements the cipher.Stream interface.","NewUnauthenticatedCipher creates a new ChaCha20 stream cipher with the given 32 bytes key and a 12 or 24 bytes nonce. If a nonce of 24 bytes is provided, the XChaCha20 construction will be used. It returns an error if key or nonce have any other length.\n\nNote that ChaCha20, like all stream ciphers, is not authenticated and allows attackers to silently tamper with the plaintext. For this reason, it is more appropriate as a building block than as a standalone encryption mechanism. Instead, consider using package golang.org/x/crypto/chacha20poly1305.","HChaCha20 uses the ChaCha20 core to generate a derived key from a 32 bytes key and a 16 bytes nonce. It returns an error if key or nonce have any other length. It is used as part of the XChaCha20 construction.","KeySize is the size of the key used by this AEAD, in bytes.","NonceSize is the size of the nonce used with the standard variant of this AEAD, in bytes.\n\nNote that this is too short to be safely generated at random if the same key is reused more than 2³² times.","NonceSizeX is the size of the nonce used with the XChaCha20-Poly1305 variant of this AEAD, in bytes.","Overhead is the size of the Poly1305 authentication tag, and the difference between a ciphertext length and its plaintext.","New returns a ChaCha20-Poly1305 AEAD that uses the given 256-bit key.","NewX returns a XChaCha20-Poly1305 AEAD that uses the given 256-bit key.\n\nXChaCha20-Poly1305 is a ChaCha20-Poly1305 variant that takes a longer nonce, suitable to be generated randomly without risk of collisions. It should be preferred when nonce uniqueness cannot be trivially ensured, or whenever nonces are randomly generated.","A Builder builds byte strings from fixed-length and length-prefixed values. Builders either allocate space as needed, or are ‘fixed’, which means that they write into a given buffer and produce an error if it's exhausted.\n\nThe zero value is a usable Builder that allocates space as needed.\n\nSimple values are marshaled and appended to a Builder using methods on the Builder. Length-prefixed values are marshaled by providing a BuilderContinuation, which is a function that writes the inner contents of the value to a given Builder. See the documentation for BuilderContinuation for details.","NewBuilder creates a Builder that appends its output to the given buffer. Like append(), the slice will be reallocated if its capacity is exceeded. Use Bytes to get the final buffer.","NewFixedBuilder creates a Builder that appends its output into the given buffer. This builder does not reallocate the output buffer. Writes that would exceed the buffer's capacity are treated as an error.","BuilderContinuation is a continuation-passing interface for building length-prefixed byte sequences. Builder methods for length-prefixed sequences (AddUint8LengthPrefixed etc) will invoke the BuilderContinuation supplied to them. The child builder passed to the continuation can be used to build the content of the length-prefixed sequence. For example:\n\n\tparent := cryptobyte.NewBuilder()\n\tparent.AddUint8LengthPrefixed(func (child *Builder) {\n\t  child.AddUint8(42)\n\t  child.AddUint8LengthPrefixed(func (grandchild *Builder) {\n\t    grandchild.AddUint8(5)\n\t  })\n\t})\n\nIt is an error to write more bytes to the child than allowed by the reserved length prefix. After the continuation returns, the child must be considered invalid, i.e. users must not store any copies or references of the child that outlive the continuation.\n\nIf the continuation panics with a value of type BuildError then the inner error will be returned as the error from Bytes. If the child panics otherwise then Bytes will repanic with the same value.","BuildError wraps an error. If a BuilderContinuation panics with this value, the panic will be recovered and the inner error will be returned from Builder.Bytes.","A MarshalingValue marshals itself into a Builder.","String represents a string of bytes. It provides methods for parsing fixed-length and length-prefixed values from it.","Extract generates a pseudorandom key for use with Expand from an input secret and an optional independent salt.\n\nOnly use this function if you need to reuse the extracted key with multiple Expand invocations and different context values. Most common scenarios, including the generation of multiple keys, should use New instead.","Expand returns a Reader, from which keys can be read, using the given pseudorandom key and optional context info, skipping the extraction step.\n\nThe pseudorandomKey should have been generated by Extract, or be a uniformly random or pseudorandom cryptographically strong key. See RFC 5869, Section 3.3. Most common scenarios will want to use New instead.","New returns a Reader, from which keys can be read, using the given hash, secret, salt and context info. Salt and info can be nil.","New224 creates a new SHA3-224 hash. Its generic security strength is 224 bits against preimage attacks, and 112 bits against collision attacks.","New256 creates a new SHA3-256 hash. Its generic security strength is 256 bits against preimage attacks, and 128 bits against collision attacks.","New384 creates a new SHA3-384 hash. Its generic security strength is 384 bits against preimage attacks, and 192 bits against collision attacks.","New512 creates a new SHA3-512 hash. Its generic security strength is 512 bits against preimage attacks, and 256 bits against collision attacks.","NewLegacyKeccak256 creates a new Keccak-256 hash.\n\nOnly use this function if you require compatibility with an existing cryptosystem that uses non-standard padding. All other users should use New256 instead.","NewLegacyKeccak512 creates a new Keccak-512 hash.\n\nOnly use this function if you require compatibility with an existing cryptosystem that uses non-standard padding. All other users should use New512 instead.","Sum224 returns the SHA3-224 digest of the data.","Sum256 returns the SHA3-256 digest of the data.","Sum384 returns the SHA3-384 digest of the data.","Sum512 returns the SHA3-512 digest of the data.","ShakeHash defines the interface to hash functions that support arbitrary-length output. When used as a plain [hash.Hash](https://pkg.go.dev/hash/#Hash), it produces minimum-length outputs that provide full-strength generic security.","NewShake128 creates a new SHAKE128 variable-output-length ShakeHash. Its generic security strength is 128 bits against all attacks if at least 32 bytes of its output are used.","NewShake256 creates a new SHAKE256 variable-output-length ShakeHash. Its generic security strength is 256 bits against all attacks if at least 64 bytes of its output are used.","NewCShake128 creates a new instance of cSHAKE128 variable-output-length ShakeHash, a customizable variant of SHAKE128. N is used to define functions based on cSHAKE, it can be empty when plain cSHAKE is desired. S is a customization byte string used for domain separation - two cSHAKE computations on same input with different S yield unrelated outputs. When N and S are both empty, this is equivalent to NewShake128.","NewCShake256 creates a new instance of cSHAKE256 variable-output-length ShakeHash, a customizable variant of SHAKE256. N is used to define functions based on cSHAKE, it can be empty when plain cSHAKE is desired. S is a customization byte string used for domain separation - two cSHAKE computations on same input with different S yield unrelated outputs. When N and S are both empty, this is equivalent to NewShake256.","ShakeSum128 writes an arbitrary-length digest of data into hash.","ShakeSum256 writes an arbitrary-length digest of data into hash.","ToASCII is a wrapper for Punycode.ToASCII.","ToUnicode is a wrapper for Punycode.ToUnicode.","An Option configures a Profile at creation time.","Transitional sets a Profile to use the Transitional mapping as defined in UTS #46. This will cause, for example, \"ß\" to be mapped to \"ss\". Using the transitional mapping provides a compromise between IDNA2003 and IDNA2008 compatibility. It is used by some browsers when resolving domain names. This option is only meaningful if combined with MapForLookup.","VerifyDNSLength sets whether a Profile should fail if any of the IDN parts are longer than allowed by the RFC.\n\nThis option corresponds to the VerifyDnsLength flag in UTS #46.","RemoveLeadingDots removes leading label separators. Leading runes that map to dots, such as U+3002 IDEOGRAPHIC FULL STOP, are removed as well.","ValidateLabels sets whether to check the mandatory label validation criteria as defined in Section 5.4 of RFC 5891. This includes testing for correct use of hyphens ('-'), normalization, validity of runes, and the context rules. In particular, ValidateLabels also sets the CheckHyphens and CheckJoiners flags in UTS #46.","CheckHyphens sets whether to check for correct use of hyphens ('-') in labels. Most web browsers do not have this option set, since labels such as \"r3---sn-apo3qvuoxuxbt-j5pe\" are in common use.\n\nThis option corresponds to the CheckHyphens flag in UTS #46.","CheckJoiners sets whether to check the ContextJ rules as defined in Appendix A of RFC 5892, concerning the use of joiner runes.\n\nThis option corresponds to the CheckJoiners flag in UTS #46.","StrictDomainName limits the set of permissible ASCII characters to those allowed in domain names as defined in RFC 1034 (A-Z, a-z, 0-9 and the hyphen). This is set by default for MapForLookup and ValidateForRegistration, but is only useful if ValidateLabels is set.\n\nThis option is useful, for instance, for browsers that allow characters outside this range, for example a '\\_' (U+005F LOW LINE). See [http://www.rfc-editor.org/std/std3.txt](http://www.rfc-editor.org/std/std3.txt) for more details.\n\nThis option corresponds to the UseSTD3ASCIIRules flag in UTS #46.","BidiRule enables the Bidi rule as defined in RFC 5893. Any application that relies on proper validation of labels should include this rule.\n\nThis option corresponds to the CheckBidi flag in UTS #46.","ValidateForRegistration sets validation options to verify that a given IDN is properly formatted for registration as defined by Section 4 of RFC 5891.","MapForLookup sets validation and mapping options such that a given IDN is transformed for domain name lookup according to the requirements set out in Section 5 of RFC 5891. The mappings follow the recommendations of RFC 5894, RFC 5895 and UTS 46. It does not add the Bidi Rule. Use the BidiRule option to add this check.\n\nThe mappings include normalization and mapping case, width and other compatibility mappings.","A Profile defines the configuration of a IDNA mapper.","New creates a new Profile.\n\nWith no options, the returned Profile is the most permissive and equals the Punycode Profile. Options can be passed to further restrict the Profile. The MapForLookup and ValidateForRegistration options set a collection of options, for lookup and registration purposes respectively, which can be tailored by adding more fine-grained options, where later options override earlier options.","Punycode is a Profile that does raw punycode processing with a minimum of validation.","Lookup is the recommended profile for looking up domain names, according to Section 5 of RFC 5891. The exact configuration of this profile may change over time.","Display is the recommended profile for displaying domain names. The configuration of this profile may change over time.","Registration is the recommended profile for checking whether a given IDN is valid for registration, according to Section 4 of RFC 5891.","UnicodeVersion is the Unicode version from which the tables in this package are derived.","MakePipe creates a connection between two endpoints and returns the pair as c1 and c2, such that anything written to c1 is read by c2 and vice-versa. The stop function closes all resources, including c1, c2, and the underlying net.Listener (if there is one), and should not be nil.","TestConn tests that a net.Conn implementation properly satisfies the interface. The tests should not produce any false positives, but may experience false negatives. Thus, some issues may only be detected when the test is run multiple times. For maximal effectiveness, run the tests under the race detector.","SupportsIPv4 reports whether the platform supports IPv4 networking functionality.","SupportsIPv6 reports whether the platform supports IPv6 networking functionality.","SupportsRawSocket reports whether the current session is available to use raw sockets.","TestableNetwork reports whether network is testable on the current platform configuration.\n\nSee func Dial of the standard library for the supported networks.","TestableAddress reports whether address of network is testable on the current platform configuration.","NewLocalListener returns a listener which listens to a loopback IP address or local file system path.\n\nThe provided network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".","NewLocalPacketListener returns a packet listener which listens to a loopback IP address or local file system path.\n\nThe provided network must be \"udp\", \"udp4\", \"udp6\" or \"unixgram\".","LocalPath returns a local path that can be used for Unix-domain protocol testing.","MulticastSource returns a unicast IP address on ifi when ifi is an IP multicast-capable network interface.\n\nThe provided network must be \"ip\", \"ip4\" or \"ip6\".","LoopbackInterface returns an available logical network interface for loopback test.","RoutedInterface returns a network interface that can route IP traffic and satisfies flags.\n\nThe provided network must be \"ip\", \"ip4\" or \"ip6\".","Initialized reports whether the CPU features were initialized.\n\nFor some GOOS/GOARCH combinations initialization of the CPU features depends on reading an operating specific file, e.g. /proc/self/auxv on linux/arm Initialized will report false if reading the file fails.","CacheLinePad is used to pad structs to avoid false sharing.","X86 contains the supported CPU features of the current X86/AMD64 platform. If the current platform is not X86/AMD64 then all feature flags are false.\n\nX86 is padded to avoid false sharing. Further the HasAVX and HasAVX2 are only set if the OS supports XMM and YMM registers in addition to the CPUID feature bit being set.","ARM64 contains the supported CPU features of the current ARMv8(aarch64) platform. If the current platform is not arm64 then all feature flags are false.","ARM contains the supported CPU features of the current ARM (32-bit) platform. All feature flags are false if:\n\n 1. the current platform is not arm, or\n 2. the current operating system is not Linux.","MIPS64X contains the supported CPU features of the current mips64/mips64le platforms. If the current platform is not mips64/mips64le or the current operating system is not Linux then all feature flags are false.","PPC64 contains the supported CPU features of the current ppc64/ppc64le platforms. If the current platform is not ppc64/ppc64le then all feature flags are false.\n\nFor ppc64/ppc64le, it is safe to check only for ISA level starting on ISA v3.00, since there are no optional categories. There are some exceptions that also require kernel support to work (DARN, SCV), so there are feature bits for those as well. The struct is padded to avoid false sharing.","S390X contains the supported CPU features of the current IBM Z (s390x) platform. If the current platform is not IBM Z then all feature flags are false.\n\nS390X is padded to avoid false sharing. Further HasVX is only set if the OS supports vector registers in addition to the STFLE feature bit being set.","IsBigEndian records whether the GOARCH's byte order is big endian.","ErrShortDst means that the destination buffer was too short to receive all of the transformed bytes.","ErrShortSrc means that the source buffer has insufficient data to complete the transformation.","ErrEndOfSpan means that the input and output (the transformed input) are not identical.","Transformer transforms bytes.","SpanningTransformer extends the Transformer interface with a Span method that determines how much of the input already conforms to the Transformer.","NopResetter can be embedded by implementations of Transformer to add a nop Reset method.","Reader wraps another io.Reader by transforming the bytes read.","NewReader returns a new Reader that wraps r by transforming the bytes read via t. It calls Reset on t.","Writer wraps another io.Writer by transforming the bytes read. The user needs to call Close to flush unwritten bytes that may be buffered.","NewWriter returns a new Writer that wraps w by transforming the bytes written via t. It calls Reset on t.","Discard is a Transformer for which all Transform calls succeed by consuming all bytes and writing nothing.","Nop is a SpanningTransformer that copies src to dst.","Chain returns a Transformer that applies t in sequence.","Deprecated: Use runes.Remove instead.","String returns a string with the result of converting s\\[:n] using t, where n \\\u003c= len(s). If err == nil, n will be len(s). It calls Reset on t.","Bytes returns a new byte slice with the result of converting b\\[:n] using t, where n \\\u003c= len(b). If err == nil, n will be len(b). It calls Reset on t.","Append appends the result of converting src\\[:n] using t to dst, where n \\\u003c= len(src), If err == nil, n will be len(src). It calls Reset on t.","Tag represents an ASN.1 identifier octet, consisting of a tag number (indicating a type) and class (such as context-specific or constructed).\n\nMethods in the cryptobyte package only support the low-tag-number form, i.e. a single identifier octet with bits 7-8 encoding the class and bits 1-6 encoding the tag number.","","","","","","","","","","","","","","","","","A Type is a type of DNS request and response.","ResourceHeader.Type and Question.Type","","","","","","","","","","Question.Type","","","","","A Class is a type of network.","ResourceHeader.Class and Question.Class","","","","Question.Class","An OpCode is a DNS operation code.","An RCode is a DNS response status code.","","","","","","","ErrNotStarted indicates that the prerequisite information isn't available yet because the previous records haven't been appropriately parsed, skipped or finished.","ErrSectionDone indicated that all records in the section have been parsed or finished.","Header is a representation of a DNS message header.","Message is a representation of a DNS message.","A Resource is a DNS resource record.","A ResourceBody is a DNS resource record minus the header.","A Parser allows incrementally parsing a DNS message.\n\nWhen parsing is started, the Header is parsed. Next, each Question can be either parsed or skipped. Alternatively, all Questions can be skipped at once. When all Questions have been parsed, attempting to parse Questions will return the \\[ErrSectionDone] error. After all Questions have been either parsed or skipped, all Answers, Authorities and Additionals can be either parsed or skipped in the same way, and each type of Resource must be fully parsed or skipped before proceeding to the next type of Resource.\n\nParser is safe to copy to preserve the parsing state.\n\nNote that there is no requirement to fully skip or parse the message.","A Builder allows incrementally packing a DNS message.\n\nExample usage:\n\n\tbuf := make([]byte, 2, 514)\n\tb := NewBuilder(buf, Header{...})\n\tb.EnableCompression()\n\t// Optionally start a section and add things to that section.\n\t// Repeat adding sections as necessary.\n\tbuf, err := b.Finish()\n\t// If err is nil, buf[2:] will contain the built bytes.","NewBuilder creates a new builder with compression disabled.\n\nNote: Most users will want to immediately enable compression with the EnableCompression method. See that method's comment for why you may or may not want to enable compression.\n\nThe DNS message is appended to the provided initial buffer buf (which may be nil) as it is built. The final message is returned by the (\\*Builder).Finish method, which includes buf\\[:len(buf)] and may return the same underlying array if there was sufficient capacity in the slice.","A ResourceHeader is the header of a DNS resource record. There are many types of DNS resource records, but they all share the same header.","A Name is a non-encoded and non-escaped domain name. It is used instead of strings to avoid allocations.","NewName creates a new Name from a string.","MustNewName creates a new Name from a string and panics on error.","A Question is a DNS query.","A CNAMEResource is a CNAME Resource record.","An MXResource is an MX Resource record.","An NSResource is an NS Resource record.","A PTRResource is a PTR Resource record.","An SOAResource is an SOA Resource record.","A TXTResource is a TXT Resource record.","An SRVResource is an SRV Resource record.","An AResource is an A Resource record.","An AAAAResource is an AAAA Resource record.","An OPTResource is an OPT pseudo Resource record.\n\nThe pseudo resource record is part of the extension mechanisms for DNS as defined in RFC 6891.","An Option represents a DNS message option within OPTResource.\n\nThe message option is part of the extension mechanisms for DNS as defined in RFC 6891.","An UnknownResource is a catch-all container for unknown record types.","ValidTrailerHeader reports whether name is a valid header field name to appear in trailers. See RFC 7230, Section 4.1.2","","HeaderValuesContainsToken reports whether any string in values contains the provided token, ASCII case-insensitively.","ValidHeaderFieldName reports whether v is a valid HTTP/1.x header name. HTTP/2 imposes the additional restriction that uppercase ASCII letters are not allowed.\n\nRFC 7230 says:\n\n\theader-field   = field-name \":\" OWS field-value OWS\n\tfield-name     = token\n\ttoken          = 1*tchar\n\ttchar = \"!\" / \"#\" / \"$\" / \"%\" / \"\u0026\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n\t        \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA","ValidHostHeader reports whether h is a valid host header.","ValidHeaderFieldValue reports whether v is a valid \"field-value\" according to [http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2](http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2) :\n\n\tmessage-header = field-name \":\" [ field-value ]\n\tfield-value    = *( field-content | LWS )\n\tfield-content  = \u003cthe OCTETs making up the field-value\n\t                 and consisting of either *TEXT or combinations\n\t                 of token, separators, and quoted-string\u003e\n\n[http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2](http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2) :\n\n\tTEXT           = \u003cany OCTET except CTLs,\n\t                  but including LWS\u003e\n\tLWS            = [CRLF] 1*( SP | HT )\n\tCTL            = \u003cany US-ASCII control character\n\t                 (octets 0 - 31) and DEL (127)\u003e\n\nRFC 7230 says:\n\n\tfield-value    = *( field-content / obs-fold )\n\tobj-fold       =  N/A to http2, and deprecated\n\tfield-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n\tfield-vchar    = VCHAR / obs-text\n\tobs-text       = %x80-FF\n\tVCHAR          = \"any visible [USASCII] character\"\n\nhttp2 further says: \"Similarly, HTTP/2 allows header field values that are not valid. While most of the values that can be encoded will not alter header field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII 0x0) might be exploited by an attacker if they are translated verbatim. Any request or response that contains a character not permitted in a header field value MUST be treated as malformed (Section 8.1.2.6). Valid characters are defined by the field-content ABNF rule in Section 3.2 of \\[RFC7230].\"\n\nThis function does not (yet?) properly handle the rejection of strings that begin or end with SP or HTAB.","PunycodeHostPort returns the IDNA Punycode version of the provided \"host\" or \"host:port\" string.","Config holds configuration for HTTP proxy settings. See FromEnvironment for details.","FromEnvironment returns a Config instance populated from the environment variables HTTP\\_PROXY, HTTPS\\_PROXY and NO\\_PROXY (or the lowercase versions thereof).\n\nThe environment values may be either a complete URL or a \"host\\[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form.","","NewEncoder returns a new Encoder which performs HPACK encoding. An encoded data is written to w.","A DecodingError is something the spec defines as a decoding error.","An InvalidIndexError is returned when an encoder references a table entry before the static table or after the end of the dynamic table.","A HeaderField is a name-value pair. Both the name and value are treated as opaque sequences of octets.","A Decoder is the decoding context for incremental processing of header blocks.","NewDecoder returns a new decoder with the provided maximum dynamic table size. The emitFunc will be called for each valid field parsed, in the same goroutine as calls to Write, before Write returns.","ErrStringLength is returned by Decoder.Write when the max string length (as configured by Decoder.SetMaxStringLength) would be violated.","HuffmanDecode decodes the string in v and writes the expanded result to w, returning the number of bytes written to w and the Write call's return value. At most one Write call is made.","HuffmanDecodeToString decodes the string in v.","ErrInvalidHuffman is returned for errors found decoding Huffman-encoded strings.","AppendHuffmanString appends s, as encoded in Huffman codes, to dst and returns the extended buffer.","HuffmanEncodeLength returns the number of bytes required to encode s in Huffman codes. The result is round up to byte boundary.","ErrInvalid indicates a label is invalid according to the Bidi Rule.","Direction reports the direction of the given label as defined by RFC 5893. The Bidi Rule does not have to be applied to labels of the category LeftToRight.","DirectionString reports the direction of the given label as defined by RFC 5893. The Bidi Rule does not have to be applied to labels of the category LeftToRight.","Valid reports whether b conforms to the BiDi rule.","ValidString reports whether s conforms to the BiDi rule.","New returns a Transformer that verifies that input adheres to the Bidi Rule.","Transformer implements transform.Transform.","A Direction indicates the overall flow of text.","LeftToRight indicates the text contains no right-to-left characters and that either there are some left-to-right characters or the option DefaultDirection(LeftToRight) was passed.","RightToLeft indicates the text contains no left-to-right characters and that either there are some right-to-left characters or the option DefaultDirection(RightToLeft) was passed.","Mixed indicates text contains both left-to-right and right-to-left characters.","Neutral means that text contains no left-to-right and right-to-left characters and that no default direction has been set.","An Option is an option for Bidi processing.","DefaultDirection sets the default direction for a Paragraph. The direction is overridden if the text contains directional characters.","A Paragraph holds a single Paragraph for Bidi processing.","An Ordering holds the computed visual order of runs of a Paragraph. Calling SetBytes or SetString on the originating Paragraph invalidates an Ordering. The methods of an Ordering should only be called by one goroutine at a time.","A Run is a continuous sequence of characters of a single direction.","AppendReverse reverses the order of characters of in, appends them to out, and returns the result. Modifiers will still follow the runes they modify. Brackets are replaced with their counterparts.","ReverseString reverses the order of characters in s and returns a new string. Modifiers will still follow the runes they modify. Brackets are replaced with their counterparts.","Properties provides access to BiDi properties of runes.","LookupRune returns properties for r.","Lookup returns properties for the first rune in s and the width in bytes of its encoding. The size will be 0 if s does not hold enough bytes to complete the encoding.","LookupString returns properties for the first rune in s and the width in bytes of its encoding. The size will be 0 if s does not hold enough bytes to complete the encoding.","UnicodeVersion is the Unicode version from which the tables in this package are derived.","Class is the Unicode BiDi class. Each rune has a single class.","","","","","","","","","","","","","","","","","","","","","","","","","GraphemeJoiner is inserted after maxNonStarters non-starter runes.","Properties provides access to normalization properties of a rune.","MaxSegmentSize is the maximum size of a byte buffer needed to consider any sequence of starter and non-starter runes for the purpose of normalization.","An Iter iterates over a string or byte slice, while normalizing it to a given Form.","A Form denotes a canonical representation of Unicode code points. The Unicode-defined normalization and equivalence forms are:\n\n\tNFC   Unicode Normalization Form C\n\tNFD   Unicode Normalization Form D\n\tNFKC  Unicode Normalization Form KC\n\tNFKD  Unicode Normalization Form KD\n\nFor a Form f, this documentation uses the notation f(x) to mean the bytes or string x converted to the given form. A position n in x is called a boundary if conversion to the form can proceed independently on both sides:\n\n\tf(x) == append(f(x[0:n]), f(x[n:])...)\n\nReferences: [https://unicode.org/reports/tr15/](https://unicode.org/reports/tr15/) and [https://unicode.org/notes/tn5/](https://unicode.org/notes/tn5/).","","","","","Version is the Unicode edition from which the tables are derived.","MaxTransformChunkSize indicates the maximum number of bytes that Transform may need to write atomically for any Form. Making a destination buffer at least this size ensures that Transform can always make progress and that the user does not need to grow the buffer on an ErrShortDst."],"details":["","","","","struct{...}","func(rd io.Reader, size int) *Reader","func(rd io.Reader) *Reader","struct{...}","func(w io.Writer, size int) *Writer","func(w io.Writer) *Writer","struct{...}","func(r *Reader, w *Writer) *ReadWriter","struct{...}","","","","","","","func(r io.Reader) *Scanner","","func(data []byte, atEOF bool) (advance int, token []byte, err error)","func(data []byte, atEOF bool) (advance int, token []byte, err error)","func(data []byte, atEOF bool) (advance int, token []byte, err error)","func(data []byte, atEOF bool) (advance int, token []byte, err error)","","","","","","","","","","","","","","","","","","","","","","interface{...}","interface{...}","","","func(slice []Type, elems ...Type) []Type","func(dst, src []Type) int","func(m map[Type]Type1, key Type)","func(v Type) int","func(v Type) int","func(t Type, size ...IntegerType) Type","func[T cmp.Ordered](x T, y ...T) T","func[T cmp.Ordered](x T, y ...T) T","func(Type) *Type","func(r, i FloatType) ComplexType","func(c ComplexType) FloatType","func(c ComplexType) FloatType","func[T ~[]Type | ~map[Type]Type1](t T)","func(c chan\u003c- Type)","func(v any)","func() any","func(args ...Type)","func(args ...Type)","interface{...}","struct{...}","","","func(buf []byte) *Buffer","func(s string) *Buffer","func(a, b []byte) bool","func(a, b []byte) int","func(s, sep []byte) int","func(b, subslice []byte) bool","func(b []byte, chars string) bool","func(b []byte, r rune) bool","func(b []byte, f func(rune) bool) bool","func(b []byte, c byte) int","func(s, sep []byte) int","func(s []byte, c byte) int","func(s []byte, r rune) int","func(s []byte, chars string) int","func(s []byte, chars string) int","func(s, sep []byte, n int) [][]byte","func(s, sep []byte, n int) [][]byte","func(s, sep []byte) [][]byte","func(s, sep []byte) [][]byte","func(s []byte) [][]byte","func(s []byte, f func(rune) bool) [][]byte","func(s [][]byte, sep []byte) []byte","func(s, prefix []byte) bool","func(s, suffix []byte) bool","func(mapping func(r rune) rune, s []byte) []byte","func(b []byte, count int) []byte","func(s []byte) []byte","func(s []byte) []byte","func(s []byte) []byte","func(c unicode.SpecialCase, s []byte) []byte","func(c unicode.SpecialCase, s []byte) []byte","func(c unicode.SpecialCase, s []byte) []byte","func(s, replacement []byte) []byte","func(s []byte) []byte","func(s []byte, f func(r rune) bool) []byte","func(s []byte, f func(r rune) bool) []byte","func(s []byte, f func(r rune) bool) []byte","func(s, prefix []byte) []byte","func(s, suffix []byte) []byte","func(s []byte, f func(r rune) bool) int","func(s []byte, f func(r rune) bool) int","func(s []byte, cutset string) []byte","func(s []byte, cutset string) []byte","func(s []byte, cutset string) []byte","func(s []byte) []byte","func(s []byte) []rune","func(s, old, new []byte, n int) []byte","func(s, old, new []byte) []byte","func(s, t []byte) bool","func(s, sep []byte) int","func(s, sep []byte) (before, after []byte, found bool)","func(b []byte) []byte","func(s, prefix []byte) (after []byte, found bool)","func(s, suffix []byte) (before []byte, found bool)","struct{...}","func(b []byte) *Reader","interface{...}","func[T Ordered](x, y T) bool","func[T Ordered](x, y T) int","func[T comparable](vals ...T) T","interface{...}","","","func() Context","func() Context","","func(parent Context) (ctx Context, cancel CancelFunc)","","func(parent Context) (ctx Context, cancel CancelCauseFunc)","func(c Context) error","func(ctx Context, f func()) (stop func() bool)","func(parent Context) Context","func(parent Context, d time.Time) (Context, CancelFunc)","func(parent Context, d time.Time, cause error) (Context, CancelFunc)","func(parent Context, timeout time.Duration) (Context, CancelFunc)","func(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)","func(parent Context, key, val any) Context","","","","","","","","","","","","","","","","","","","","","func(h Hash, f func() hash.Hash)","","","interface{...}","interface{...}","interface{...}","","struct{...}","interface{...}","interface{...}","interface{...}","interface{...}","func(text string) error","","func(errs ...error) error","func(err error) error","func(err, target error) bool","func(err error, target any) bool","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","func(name string, v Var)","func(name string) Var","func(name string) *Int","func(name string) *Float","func(name string) *Map","func(name string) *String","func(f func(KeyValue))","func() http.Handler","","interface{...}","interface{...}","","","","","struct{...}","struct{...}","func(fn func(*Flag))","func(fn func(*Flag))","func(name string) *Flag","func(name, value string) error","func(flag *Flag) (name string, usage string)","func()","","func() int","func(i int) string","func() int","func() []string","func(p *bool, name string, value bool, usage string)","func(name string, value bool, usage string) *bool","func(p *int, name string, value int, usage string)","func(name string, value int, usage string) *int","func(p *int64, name string, value int64, usage string)","func(name string, value int64, usage string) *int64","func(p *uint, name string, value uint, usage string)","func(name string, value uint, usage string) *uint","func(p *uint64, name string, value uint64, usage string)","func(name string, value uint64, usage string) *uint64","func(p *string, name string, value string, usage string)","func(name string, value string, usage string) *string","func(p *float64, name string, value float64, usage string)","func(name string, value float64, usage string) *float64","func(p *time.Duration, name string, value time.Duration, usage string)","func(name string, value time.Duration, usage string) *time.Duration","func(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string)","func(name, usage string, fn func(string) error)","func(name, usage string, fn func(string) error)","func(value Value, name string, usage string)","func()","func() bool","","func(name string, errorHandling ErrorHandling) *FlagSet","func(format string, a ...any) error","interface{...}","interface{...}","interface{...}","interface{...}","func(state State, verb rune) string","func(w io.Writer, format string, a ...any) (n int, err error)","func(format string, a ...any) (n int, err error)","func(format string, a ...any) string","func(b []byte, format string, a ...any) []byte","func(w io.Writer, a ...any) (n int, err error)","func(a ...any) (n int, err error)","func(a ...any) string","func(b []byte, a ...any) []byte","func(w io.Writer, a ...any) (n int, err error)","func(a ...any) (n int, err error)","func(a ...any) string","func(b []byte, a ...any) []byte","interface{...}","interface{...}","func(a ...any) (n int, err error)","func(a ...any) (n int, err error)","func(format string, a ...any) (n int, err error)","func(str string, a ...any) (n int, err error)","func(str string, a ...any) (n int, err error)","func(str string, format string, a ...any) (n int, err error)","func(r io.Reader, a ...any) (n int, err error)","func(r io.Reader, a ...any) (n int, err error)","func(r io.Reader, format string, a ...any) (n int, err error)","interface{...}","interface{...}","interface{...}","func(s string) string","func(s string) string","","func(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))","func(r io.Reader) (Image, string, error)","func(r io.Reader) (Config, string, error)","struct{...}","","func(X, Y int) Point","struct{...}","","func(x0, y0, x1, y1 int) Rectangle","struct{...}","interface{...}","interface{...}","interface{...}","struct{...}","func(r Rectangle) *RGBA","struct{...}","func(r Rectangle) *RGBA64","struct{...}","func(r Rectangle) *NRGBA","struct{...}","func(r Rectangle) *NRGBA64","struct{...}","func(r Rectangle) *Alpha","struct{...}","func(r Rectangle) *Alpha16","struct{...}","func(r Rectangle) *Gray","struct{...}","func(r Rectangle) *Gray16","struct{...}","func(r Rectangle) *CMYK","struct{...}","func(r Rectangle, p color.Palette) *Paletted","","","","","struct{...}","func(c color.Color) *Uniform","","","","","","","","struct{...}","func(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr","struct{...}","func(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA","","","","","","","","","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","func(w Writer, s string) (n int, err error)","func(r Reader, buf []byte, min int) (n int, err error)","func(r Reader, buf []byte) (n int, err error)","func(dst Writer, src Reader, n int64) (written int64, err error)","func(dst Writer, src Reader) (written int64, err error)","func(dst Writer, src Reader, buf []byte) (written int64, err error)","func(r Reader, n int64) Reader","struct{...}","func(r ReaderAt, off int64, n int64) *SectionReader","struct{...}","struct{...}","func(w WriterAt, off int64) *OffsetWriter","func(r Reader, w Writer) Reader","","func(r Reader) ReadCloser","func(r Reader) ([]byte, error)","func(readers ...Reader) Reader","func(writers ...Writer) Writer","","struct{...}","struct{...}","func() (*PipeReader, *PipeWriter)","","","func[V any](seq Seq[V]) (next func() (V, bool), stop func())","func[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())","","","","","","","","","struct{...}","func(out io.Writer, prefix string, flag int) *Logger","func() *Logger","func(w io.Writer)","func() int","func(flag int)","func() string","func(prefix string)","func() io.Writer","func(v ...any)","func(format string, v ...any)","func(v ...any)","func(v ...any)","func(format string, v ...any)","func(v ...any)","func(v ...any)","func(format string, v ...any)","func(v ...any)","func(calldepth int, s string) error","func[Map ~map[K]V, K comparable, V any](m Map) iter.Seq2[K, V]","func[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[K]","func[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[V]","func[Map ~map[K]V, K comparable, V any](m Map, seq iter.Seq2[K, V])","func[K comparable, V any](seq iter.Seq2[K, V]) map[K]V","func[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool","func[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool","func[M ~map[K]V, K comparable, V any](m M) M","func[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)","func[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(y, x float64) float64","func(x float64) float64","func(sign int) float64","func() float64","func(f float64) (is bool)","func(f float64, sign int) bool","func(x float64) float64","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(f, sign float64) float64","func(x, y float64) float64","func(x, y float64) float64","func(x, y float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x, y, z float64) float64","func(f float64) (frac float64, exp int)","func(x float64) float64","func(p, q float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(n int, x float64) float64","func(n int, x float64) float64","func(frac float64, exp int) float64","func(x float64) (lgamma float64, sign int)","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) int","func(x, y float64) float64","func(f float64) (int float64, frac float64)","func(x, y float32) (r float32)","func(x, y float64) (r float64)","func(x, y float64) float64","func(n int) float64","func(x, y float64) float64","func(x float64) bool","func(x float64) float64","func(x float64) float64","func(x float64) (sin, cos float64)","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(x float64) float64","func(f float32) uint32","func(b uint32) float32","func(f float64) uint64","func(b uint64) float64","","","","struct{...}","func(t string, param map[string]string) string","","func(v string) (mediatype string, params map[string]string, err error)","func(ext string) string","func(typ string) ([]string, error)","func(ext, typ string) error","struct{...}","func(network, address string) (Conn, error)","func(network, address string, timeout time.Duration) (Conn, error)","struct{...}","func(network, address string) (Listener, error)","func(network, address string) (PacketConn, error)","struct{...}","struct{...}","struct{...}","func(f *os.File) (c Conn, err error)","func(f *os.File) (ln Listener, err error)","func(f *os.File) (c PacketConn, err error)","struct{...}","","","","","","","","func() ([]Interface, error)","func() ([]Addr, error)","func(index int) (*Interface, error)","func(name string) (*Interface, error)","","","","","struct{...}","func(a, b, c, d byte) IP","func(a, b, c, d byte) IPMask","func(ones, bits int) IPMask","","","","","","","","","","","func(s string) IP","func(s string) (IP, *IPNet, error)","struct{...}","func(network, address string) (*IPAddr, error)","struct{...}","func(network string, laddr, raddr *IPAddr) (*IPConn, error)","func(network string, laddr *IPAddr) (*IPConn, error)","func(hostport string) (host, port string, err error)","func(host, port string) string","","struct{...}","func(host string) (addrs []string, err error)","func(host string) ([]IP, error)","func(network, service string) (port int, err error)","func(host string) (cname string, err error)","func(service, proto, name string) (cname string, addrs []*SRV, err error)","func(name string) ([]*MX, error)","func(name string) ([]*NS, error)","func(name string) ([]string, error)","func(addr string) (names []string, err error)","","func(s string) (hw HardwareAddr, err error)","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","","struct{...}","struct{...}","struct{...}","","","struct{...}","struct{...}","","","func() (Conn, Conn)","struct{...}","func(network, address string) (*TCPAddr, error)","func(addr netip.AddrPort) *TCPAddr","struct{...}","struct{...}","func(network string, laddr, raddr *TCPAddr) (*TCPConn, error)","struct{...}","func(network string, laddr *TCPAddr) (*TCPListener, error)","struct{...}","func(network, address string) (*UDPAddr, error)","func(addr netip.AddrPort) *UDPAddr","struct{...}","func(network string, laddr, raddr *UDPAddr) (*UDPConn, error)","func(network string, laddr *UDPAddr) (*UDPConn, error)","func(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)","struct{...}","func(network, address string) (*UnixAddr, error)","struct{...}","func(network string, laddr, raddr *UnixAddr) (*UnixConn, error)","struct{...}","func(network string, laddr *UnixAddr) (*UnixListener, error)","func(network string, laddr *UnixAddr) (*UnixConn, error)","","func(name string) ([]DirEntry, error)","func(dir string, fsys fs.FS) error","func(s string, mapping func(string) string) string","func(s string) string","func(key string) string","func(key string) (string, bool)","func(key, value string) error","func(key string) error","func()","func() []string","","","","","","","","","struct{...}","func(syscall string, err error) error","func(err error) bool","func(err error) bool","func(err error) bool","func(err error) bool","","struct{...}","struct{...}","interface{...}","func() int","func() int","func(pid int) (*Process, error)","func(name string, argv []string, attr *ProcAttr) (*Process, error)","","","struct{...}","func() (string, error)","","","","","","","","","","","","","","","struct{...}","func(name string, perm FileMode) error","func(dir string) error","func(name string) (*File, error)","func(name string) (*File, error)","func(name string, flag int, perm FileMode) (*File, error)","func(oldpath, newpath string) error","func(name string) (string, error)","func() string","func() (string, error)","func() (string, error)","func() (string, error)","func(name string, mode FileMode) error","func(dir string) fs.FS","func(name string) ([]byte, error)","func(name string, data []byte, perm FileMode) error","func(name string, uid, gid int) error","func(name string, uid, gid int) error","func(name string, atime time.Time, mtime time.Time) error","func(fd uintptr, name string) *File","","func(name string, size int64) error","func(name string) error","func(oldname, newname string) error","func(oldname, newname string) error","func() (dir string, err error)","func(path string, perm FileMode) error","func(path string) error","","","func(c uint8) bool","func() (r *File, w *File, err error)","","func() int","func() int","func() int","func() int","func() ([]int, error)","func(code int)","func(name string) (FileInfo, error)","func(name string) (FileInfo, error)","func() (name string, err error)","func(dir, pattern string) (*File, error)","func(dir, pattern string) (string, error)","func() int","struct{...}","","","","","","","","","","","","","","","","","","func(fi1, fi2 FileInfo) bool","","func(pattern, name string) (matched bool, err error)","func(path string) string","func(path string) (dir, file string)","func(elem ...string) string","func(path string) string","func(path string) string","func(path string) bool","func(path string) string","struct{...}","func(path string) (*Plugin, error)","","func(x, y any) bool","func(typ Type, fn func(args []Value) (results []Value)) Value","func(slice any) func(i, j int)","interface{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","","func(i any) Type","func(t Type) Type","func(t Type) Type","func(dir ChanDir, t Type) Type","func(key, elem Type) Type","func(in, out []Type, variadic bool) Type","func(t Type) Type","func(fields []StructField) Type","func(length int, elem Type) Type","func[T any]() Type","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(s Value, x ...Value) Value","func(s, t Value) Value","func(dst, src Value) int","","","","","struct{...}","func(cases []SelectCase) (chosen int, recv Value, recvOK bool)","func(typ Type, len, cap int) Value","func(typ Type, p unsafe.Pointer, n int) Value","func(typ Type, buffer int) Value","func(typ Type) Value","func(typ Type, n int) Value","func(v Value) Value","func(i any) Value","func(typ Type) Value","func(typ Type) Value","func(typ Type, p unsafe.Pointer) Value","func(t Type) []StructField","struct{...}","func(expr string) (*Regexp, error)","func(expr string) (*Regexp, error)","func(str string) *Regexp","func(str string) *Regexp","func(pattern string, r io.RuneReader) (matched bool, err error)","func(pattern string, s string) (matched bool, err error)","func(pattern string, b []byte) (matched bool, err error)","func(s string) string","","func(hz int)","func() []byte","func(n int) int","func() int","func() int64","func() int","interface{...}","struct{...}","func(skip int) (pc uintptr, file string, line int, ok bool)","func(skip int, pc []uintptr) int","func() string","func() string","","","func(obj any, finalizer any)","func(x any)","func()","func(rate int)","func(rate int) int","struct{...}","","struct{...}","func(p []MemProfileRecord, inuseZero bool) (n int, ok bool)","struct{...}","func(p []BlockProfileRecord) (n int, ok bool)","func(p []BlockProfileRecord) (n int, ok bool)","func(p []StackRecord) (n int, ok bool)","func(p []StackRecord) (n int, ok bool)","func(buf []byte, all bool) int","struct{...}","func(m *MemStats)","func()","struct{...}","struct{...}","func()","func()","func()","func()","struct{...}","struct{...}","func(callers []uintptr) *Frames","struct{...}","func(pc uintptr) *Func","func() error","func()","func() []byte","func(version int, traceback, context, symbolizer unsafe.Pointer)","func[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]","func[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]","func[Slice ~[]E, E any](s Slice) iter.Seq[E]","func[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice","func[E any](seq iter.Seq[E]) []E","func[E cmp.Ordered](seq iter.Seq[E]) []E","func[E any](seq iter.Seq[E], cmp func(E, E) int) []E","func[E any](seq iter.Seq[E], cmp func(E, E) int) []E","func[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice]","func[S ~[]E, E comparable](s1, s2 S) bool","func[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool","func[S ~[]E, E cmp.Ordered](s1, s2 S) int","func[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int","func[S ~[]E, E comparable](s S, v E) int","func[S ~[]E, E any](s S, f func(E) bool) int","func[S ~[]E, E comparable](s S, v E) bool","func[S ~[]E, E any](s S, f func(E) bool) bool","func[S ~[]E, E any](s S, i int, v ...E) S","func[S ~[]E, E any](s S, i, j int) S","func[S ~[]E, E any](s S, del func(E) bool) S","func[S ~[]E, E any](s S, i, j int, v ...E) S","func[S ~[]E, E any](s S) S","func[S ~[]E, E comparable](s S) S","func[S ~[]E, E any](s S, eq func(E, E) bool) S","func[S ~[]E, E any](s S, n int) S","func[S ~[]E, E any](s S) S","func[S ~[]E, E any](s S)","func[S ~[]E, E any](slices ...S) S","func[S ~[]E, E any](x S, count int) S","func[S ~[]E, E cmp.Ordered](x S)","func[S ~[]E, E any](x S, cmp func(a, b E) int)","func[S ~[]E, E any](x S, cmp func(a, b E) int)","func[S ~[]E, E cmp.Ordered](x S) bool","func[S ~[]E, E any](x S, cmp func(a, b E) int) bool","func[S ~[]E, E cmp.Ordered](x S) E","func[S ~[]E, E any](x S, cmp func(a, b E) int) E","func[S ~[]E, E cmp.Ordered](x S) E","func[S ~[]E, E any](x S, cmp func(a, b E) int) E","func[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)","func[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)","func(n int, f func(int) bool) int","func(n int, cmp func(int) int) (i int, found bool)","func(a []int, x int) int","func(a []float64, x float64) int","func(a []string, x string) int","func(x any, less func(i, j int) bool)","func(x any, less func(i, j int) bool)","func(x any, less func(i, j int) bool) bool","interface{...}","func(data Interface)","func(data Interface) Interface","func(data Interface) bool","","","","func(x []int)","func(x []float64)","func(x []string)","func(x []int) bool","func(x []float64) bool","func(x []string) bool","func(data Interface)","func(str string) (bool, error)","func(b bool) string","func(dst []byte, b bool) []byte","func(s string, bitSize int) (complex128, error)","func(s string, bitSize int) (float64, error)","","","struct{...}","","func(s string, base int, bitSize int) (uint64, error)","func(s string, base int, bitSize int) (i int64, err error)","func(s string) (int, error)","func(c complex128, fmt byte, prec, bitSize int) string","func(f float64, fmt byte, prec, bitSize int) string","func(dst []byte, f float64, fmt byte, prec, bitSize int) []byte","func(i uint64, base int) string","func(i int64, base int) string","func(i int) string","func(dst []byte, i int64, base int) []byte","func(dst []byte, i uint64, base int) []byte","func(s string) string","func(dst []byte, s string) []byte","func(s string) string","func(dst []byte, s string) []byte","func(s string) string","func(dst []byte, s string) []byte","func(r rune) string","func(dst []byte, r rune) []byte","func(r rune) string","func(dst []byte, r rune) []byte","func(r rune) string","func(dst []byte, r rune) []byte","func(s string) bool","func(s string, quote byte) (value rune, multibyte bool, tail string, err error)","func(s string) (string, error)","func(s string) (string, error)","func(r rune) bool","func(r rune) bool","struct{...}","func(s string) string","func(a, b string) int","struct{...}","func(s string) *Reader","struct{...}","func(oldnew ...string) *Replacer","func(s, substr string) int","func(s, substr string) bool","func(s, chars string) bool","func(s string, r rune) bool","func(s string, f func(rune) bool) bool","func(s, substr string) int","func(s string, c byte) int","func(s string, r rune) int","func(s, chars string) int","func(s, chars string) int","func(s string, c byte) int","func(s, sep string, n int) []string","func(s, sep string, n int) []string","func(s, sep string) []string","func(s, sep string) []string","func(s string) []string","func(s string, f func(rune) bool) []string","func(elems []string, sep string) string","func(s, prefix string) bool","func(s, suffix string) bool","func(mapping func(rune) rune, s string) string","func(s string, count int) string","func(s string) string","func(s string) string","func(s string) string","func(c unicode.SpecialCase, s string) string","func(c unicode.SpecialCase, s string) string","func(c unicode.SpecialCase, s string) string","func(s, replacement string) string","func(s string) string","func(s string, f func(rune) bool) string","func(s string, f func(rune) bool) string","func(s string, f func(rune) bool) string","func(s string, f func(rune) bool) int","func(s string, f func(rune) bool) int","func(s, cutset string) string","func(s, cutset string) string","func(s, cutset string) string","func(s string) string","func(s, prefix string) string","func(s, suffix string) string","func(s, old, new string, n int) string","func(s, old, new string) string","func(s, t string) bool","func(s, substr string) int","func(s, sep string) (before, after string, found bool)","func(s, prefix string) (after string, found bool)","func(s, suffix string) (before string, found bool)","struct{...}","struct{...}","func(l Locker) *Cond","struct{...}","struct{...}","interface{...}","struct{...}","func(f func()) func()","func[T any](f func() T) func() T","func[T1, T2 any](f func() (T1, T2)) func() (T1, T2)","struct{...}","struct{...}","struct{...}","func(buf []byte, max int, names []string) (consumed int, count int, newnames []string)","func(key string) error","func(key string) (value string, found bool)","func(key, value string) error","func()","func() []string","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","","func(ss []string) []*byte","func(ss []string) ([]*byte, error)","func(fd int)","func(fd int, nonblocking bool) (err error)","struct{...}","struct{...}","func(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)","func(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)","func(argv0 string, argv []string, envv []string) (err error)","func(fd uintptr, cmd int, lk *Flock_t) error","func(code, k int) *SockFilter","func(code, k, jt, jf int) *SockFilter","func(ifindex, proto int) (int, error)","func(name string, m bool) error","func(fd int, i []SockFilter) error","func(fd int) error","interface{...}","interface{...}","struct{...}","func(proto, family int) ([]byte, error)","struct{...}","func(b []byte) ([]NetlinkMessage, error)","struct{...}","func(m *NetlinkMessage) ([]NetlinkRouteAttr, error)","func(resource int, rlim *Rlimit) error","func(ucred *Ucred) []byte","func(m *SocketControlMessage) (*Ucred, error)","func(datalen int) int","func(datalen int) int","struct{...}","func(b []byte) ([]SocketControlMessage, error)","func(fds ...int) []byte","func(m *SocketControlMessage) ([]int, error)","func(s string) []byte","func(s string) ([]byte, error)","func(s string) *byte","func(s string) (*byte, error)","func() int","func(code int)","func(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)","func(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)","func(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)","func(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)","func(path string, mode uint32) (err error)","func(path string, mode uint32) (err error)","func(path string, uid int, gid int) (err error)","func(path string, mode uint32) (fd int, err error)","func(size int) (fd int, err error)","func(dirfd int, path string, mode uint32, flags int) (err error)","func(dirfd int, path string, mode uint32, flags int) error","func(oldpath string, newpath string) (err error)","func(path string, mode uint32) (err error)","func(path string, mode uint32, dev int) (err error)","func(path string, mode int, perm uint32) (fd int, err error)","func(dirfd int, path string, flags int, mode uint32) (fd int, err error)","func(p []int) error","func(p []int, flags int) error","func(path string, buf []byte) (n int, err error)","func(oldpath string, newpath string) (err error)","func(path string) error","func(oldpath string, newpath string) (err error)","func(path string) error","func(dirfd int, path string) error","func(path string, tv []Timeval) (err error)","func(path string, ts []Timespec) (err error)","func(dirfd int, path string, tv []Timeval) (err error)","func(fd int, tv []Timeval) (err error)","","func() (wd string, err error)","func() (gids []int, err error)","func(gids []int) (err error)","","func(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)","func(path string, mode uint32) (err error)","struct{...}","struct{...}","func(fd int, flags int) (nfd int, sa Sockaddr, err error)","func(fd int) (sa Sockaddr, err error)","func(fd, level, opt int) (value [4]byte, err error)","func(fd, level, opt int) (*IPMreq, error)","func(fd, level, opt int) (*IPMreqn, error)","func(fd, level, opt int) (*IPv6Mreq, error)","func(fd, level, opt int) (*IPv6MTUInfo, error)","func(fd, level, opt int) (*ICMPv6Filter, error)","func(fd, level, opt int) (*Ucred, error)","func(fd, level, opt int, mreq *IPMreqn) (err error)","func(fd int, device string) (err error)","func(pid int, addr uintptr, out []byte) (count int, err error)","func(pid int, addr uintptr, out []byte) (count int, err error)","func(pid int, addr uintptr, data []byte) (count int, err error)","func(pid int, addr uintptr, data []byte) (count int, err error)","func(pid int, regsout *PtraceRegs) (err error)","func(pid int, regs *PtraceRegs) (err error)","func(pid int, options int) (err error)","func(pid int) (msg uint, err error)","func(pid int, signal int) (err error)","func(pid int, signal int) (err error)","func(pid int) (err error)","func(pid int) (err error)","func(pid int) (err error)","func(cmd int) (err error)","func(fd int, buf []byte) (n int, err error)","func(source string, target string, fstype string, flags uintptr, data string) (err error)","func() (pid int)","func(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)","func(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)","func(egid int) (err error)","func(euid int) (err error)","func(gid int) (err error)","func(rgid, egid int) (err error)","func(rgid, egid, sgid int) (err error)","func(ruid, euid, suid int) (err error)","func(ruid, euid int) (err error)","func(uid int) (err error)","func(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)","func(b []byte) (err error)","func(fd int) (nfd int, sa Sockaddr, err error)","func(path string, stat *Stat_t) (err error)","func(path string, uid int, gid int) (err error)","func(path string, stat *Stat_t) (err error)","func(tv *Timeval) (err error)","func(t *Time_t) (tt Time_t, err error)","","","","","","func(fd int, p []byte) (n int, err error)","func(fd int, p []byte) (n int, err error)","func(fd int, p []byte, offset int64) (n int, err error)","func(fd int, p []byte, offset int64) (n int, err error)","","interface{...}","struct{...}","struct{...}","struct{...}","func(fd int, sa Sockaddr) (err error)","func(fd int, sa Sockaddr) (err error)","func(fd int) (sa Sockaddr, err error)","func(fd, level, opt int) (value int, err error)","func(fd int, p []byte, flags int) (n int, from Sockaddr, err error)","func(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)","func(fd int, p, oob []byte, to Sockaddr, flags int) (err error)","func(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)","func(fd int, p []byte, flags int, to Sockaddr) (err error)","func(fd, level, opt int, value byte) (err error)","func(fd, level, opt int, value int) (err error)","func(fd, level, opt int, value [4]byte) (err error)","func(fd, level, opt int, mreq *IPMreq) (err error)","func(fd, level, opt int, mreq *IPv6Mreq) (err error)","func(fd, level, opt int, filter *ICMPv6Filter) error","func(fd, level, opt int, l *Linger) (err error)","func(fd, level, opt int, s string) (err error)","func(fd, level, opt int, tv *Timeval) (err error)","func(domain, typ, proto int) (fd int, err error)","func(domain, typ, proto int) (fd [2]int, err error)","func(outfd int, infd int, offset *int64, count int) (written int, err error)","func(ts Timespec) int64","func(nsec int64) Timespec","func(tv Timeval) int64","func(nsec int64) Timeval","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(buf []byte) (n int, err error)","func(path string) (err error)","func(buf *Timex) (state int, err error)","func(path string) (err error)","func(path string) (err error)","func(fd int) (err error)","func(oldfd int) (fd int, err error)","func(oldfd int, newfd int, flags int) (err error)","func(flag int) (fd int, err error)","func(epfd int, op int, fd int, event *EpollEvent) (err error)","func(fd int, mode uint32, off int64, len int64) (err error)","func(fd int) (err error)","func(fd int, mode uint32) (err error)","func(dirfd int, path string, uid int, gid int, flags int) (err error)","func(fd int) (err error)","func(fd int, how int) (err error)","func(fd int) (err error)","func(fd int, buf []byte) (n int, err error)","func(pid int) (pgid int, err error)","func() (pid int)","func() (ppid int)","func(which int, who int) (prio int, err error)","func(who int, rusage *Rusage) (err error)","func() (tid int)","func(path string, attr string, dest []byte) (sz int, err error)","func(fd int, pathname string, mask uint32) (watchdesc int, err error)","func(flags int) (fd int, err error)","func(fd int, watchdesc uint32) (success int, err error)","func(pid int, sig Signal) (err error)","func(typ int, buf []byte) (n int, err error)","func(path string, dest []byte) (sz int, err error)","func(dirfd int, path string, mode uint32) (err error)","func(dirfd int, path string, mode uint32, dev int) (err error)","func(time *Timespec, leftover *Timespec) (err error)","func(newroot string, putold string) (err error)","func(path string, attr string) (err error)","func(p []byte) (err error)","func(p []byte) (err error)","func(pid int, pgid int) (err error)","func() (pid int, err error)","func(tv *Timeval) (err error)","func(which int, who int, prio int) (err error)","func(path string, attr string, data []byte, flags int) (err error)","func()","func(info *Sysinfo_t) (err error)","func(rfd int, wfd int, len int, flags int) (n int64, err error)","func(tgid int, tid int, sig Signal) (err error)","func(tms *Tms) (ticks uintptr, err error)","func(mask int) (oldmask int)","func(buf *Utsname) (err error)","func(target string, flags int) (err error)","func(flags int) (err error)","func(b []byte, advice int) (err error)","func(b []byte, prot int) (err error)","func(b []byte) (err error)","func(b []byte) (err error)","func(flags int) (err error)","func() (err error)","func(oldfd int, newfd int) (err error)","func(fd int, uid int, gid int) (err error)","func(fd int, stat *Stat_t) (err error)","func(fd int, buf *Statfs_t) (err error)","func(fd int, length int64) (err error)","func() (egid int)","func() (euid int)","func() (gid int)","func(resource int, rlim *Rlimit) (err error)","func() (uid int)","func() (fd int, err error)","func(from int, num int, on int) (err error)","func(level int) (err error)","func(s int, n int) (err error)","func() (err error)","func(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)","func(fd int, offset int64, whence int) (off int64, err error)","func(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)","func(gid int) (err error)","func(uid int) (err error)","func(fd int, how int) (err error)","func(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)","func(path string, buf *Statfs_t) (err error)","func(fd int, off int64, n int64, flags int) (err error)","func(path string, length int64) (err error)","func(dev int, ubuf *Ustat_t) (err error)","func(epfd int, events []EpollEvent, msec int) (n int, err error)","func(path string, buf *Utimbuf) (err error)","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","struct{...}","struct{...}","struct{...}","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(runs int, f func()) (avg float64)","struct{...}","struct{...}","struct{...}","func(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)","struct{...}","func(f func(b *B)) BenchmarkResult","struct{...}","struct{...}","func() float64","func(c Cover)","struct{...}","func(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)","struct{...}","struct{...}","func()","func() bool","func() bool","func() string","func() bool","interface{...}","struct{...}","struct{...}","func(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)","struct{...}","func(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M","func(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)","","","","","","","","","","","","","","","","","","","","struct{...}","func(layout, value string) (Time, error)","func(layout, value string, loc *Location) (Time, error)","func(s string) (Duration, error)","func(d Duration)","struct{...}","func(d Duration) *Timer","func(d Duration) \u003c-chan Time","func(d Duration, f func()) *Timer","struct{...}","func(d Duration) *Ticker","func(d Duration) \u003c-chan Time","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(t Time) Duration","func(t Time) Duration","func() Time","func(sec int64, nsec int64) Time","func(msec int64) Time","func(usec int64) Time","func(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time","struct{...}","","","func(name string, offset int) *Location","func(name string) (*Location, error)","func(name string, data []byte) (*Location, error)","","","func(r rune) bool","","","func(r rune) bool","func(r rune) bool","func(ranges []*RangeTable, r rune) bool","func(r rune, ranges ...*RangeTable) bool","func(r rune) bool","func(r rune) bool","func(r rune) bool","func(r rune) bool","func(r rune) bool","func(r rune) bool","func(r rune) bool","","","","","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","func(rangeTab *RangeTable, r rune) bool","func(r rune) bool","func(r rune) bool","func(r rune) bool","func(_case int, r rune) rune","func(r rune) rune","func(r rune) rune","func(r rune) rune","func(r rune) rune","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","func[T comparable](value T) Handle[T]","","","","func(x ArbitraryType) uintptr","func(x ArbitraryType) uintptr","func(x ArbitraryType) uintptr","func(ptr Pointer, len IntegerType) Pointer","func(ptr *ArbitraryType, len IntegerType) []ArbitraryType","func(slice []ArbitraryType) *ArbitraryType","func(ptr *byte, len IntegerType) string","func(str string) *byte","","","","","","","","","","","","","","","","","","","","struct{...}","func(fi fs.FileInfo, link string) (*Header, error)","interface{...}","","","","","","struct{...}","func(r io.Reader) *Reader","struct{...}","func(w io.Writer) *Writer","","","","","struct{...}","struct{...}","struct{...}","func(name string) (*ReadCloser, error)","func(r io.ReaderAt, size int64) (*Reader, error)","","","func(method uint16, dcomp Decompressor)","func(method uint16, comp Compressor)","","","struct{...}","func(fi fs.FileInfo) (*FileHeader, error)","struct{...}","func(w io.Writer) *Writer","","func(r io.Reader) io.Reader","","","","","","func(w io.Writer, level int) (*Writer, error)","func(w io.Writer, level int, dict []byte) (*Writer, error)","struct{...}","","","struct{...}","struct{...}","interface{...}","interface{...}","func(r io.Reader) io.ReadCloser","func(r io.Reader, dict []byte) io.ReadCloser","","","struct{...}","struct{...}","func(r io.Reader) (*Reader, error)","","","","","","struct{...}","func(w io.Writer) *Writer","func(w io.Writer, level int) (*Writer, error)","","","","struct{...}","func(r io.Reader, order Order, litWidth int) io.ReadCloser","struct{...}","func(w io.Writer, order Order, litWidth int) io.WriteCloser","","","","interface{...}","func(r io.Reader) (io.ReadCloser, error)","func(r io.Reader, dict []byte) (io.ReadCloser, error)","","","","","","struct{...}","func(w io.Writer) *Writer","func(w io.Writer, level int) (*Writer, error)","func(w io.Writer, level int, dict []byte) (*Writer, error)","interface{...}","func(h Interface)","func(h Interface, x any)","func(h Interface) any","func(h Interface, i int) any","func(h Interface, i int)","struct{...}","struct{...}","func() *List","struct{...}","func(n int) *Ring","","","func(key []byte) (cipher.Block, error)","func(b Block, iv []byte) BlockMode","func(b Block, iv []byte) BlockMode","func(block Block, iv []byte) Stream","func(block Block, iv []byte) Stream","interface{...}","interface{...}","interface{...}","func(block Block, iv []byte) Stream","interface{...}","func(cipher Block) (AEAD, error)","func(cipher Block, size int) (AEAD, error)","func(cipher Block, tagSize int) (AEAD, error)","struct{...}","struct{...}","func(b Block, iv []byte) Stream","","","func(key []byte) (cipher.Block, error)","func(key []byte) (cipher.Block, error)","struct{...}","struct{...}","struct{...}","","","","","","","func(params *Parameters, rand io.Reader, sizes ParameterSizes) error","func(priv *PrivateKey, rand io.Reader) error","func(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)","func(pub *PublicKey, hash []byte, r, s *big.Int) bool","interface{...}","struct{...}","struct{...}","func() Curve","func() Curve","func() Curve","func() Curve","struct{...}","struct{...}","func(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)","func(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)","func(pub *PublicKey, hash, sig []byte) bool","func(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)","func(pub *PublicKey, hash []byte, r, s *big.Int) bool","","","","","","","struct{...}","func(rand io.Reader) (PublicKey, PrivateKey, error)","func(seed []byte) PrivateKey","func(privateKey PrivateKey, message []byte) []byte","func(publicKey PublicKey, message, sig []byte) bool","func(publicKey PublicKey, message, sig []byte, opts *Options) error","interface{...}","func(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)","func(curve Curve, x, y *big.Int) []byte","func(curve Curve, x, y *big.Int) []byte","func(curve Curve, data []byte) (x, y *big.Int)","func(curve Curve, data []byte) (x, y *big.Int)","func() Curve","func() Curve","func() Curve","func() Curve","struct{...}","func(h func() hash.Hash, key []byte) hash.Hash","func(mac1, mac2 []byte) bool","","","func() hash.Hash","func(data []byte) [Size]byte","","func(b []byte) (n int, err error)","func(rand io.Reader, bits int) (*big.Int, error)","func(rand io.Reader, max *big.Int) (n *big.Int, err error)","struct{...}","","func(key []byte) (*Cipher, error)","struct{...}","func(random io.Reader, pub *PublicKey, msg []byte) ([]byte, error)","func(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)","func(random io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error","func(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)","func(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error","","","struct{...}","func(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error)","func(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(random io.Reader, bits int) (*PrivateKey, error)","func(random io.Reader, nprimes int, bits int) (*PrivateKey, error)","","func(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)","","","func(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)","","","func() hash.Hash","func(data []byte) [Size]byte","","","","func() hash.Hash","func() hash.Hash","func(data []byte) [Size]byte","func(data []byte) [Size224]byte","","","","","","func() hash.Hash","func() hash.Hash","func() hash.Hash","func() hash.Hash","func(data []byte) [Size]byte","func(data []byte) [Size384]byte","func(data []byte) [Size224]byte","func(data []byte) [Size256]byte","func(x, y []byte) int","func(v, x, y int) int","func(x, y uint8) int","func(x, y int32) int","func(v int, x, y []byte)","func(x, y int) int","func(dst, x, y []byte) int","","struct{...}","func() []*CipherSuite","func() []*CipherSuite","func(id uint16) string","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(version uint16) string","","","","","","struct{...}","","","","","","","interface{...}","","","","","","","","","","","","","","struct{...}","struct{...}","","","","","struct{...}","struct{...}","func(capacity int) ClientSessionCache","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","struct{...}","struct{...}","","","","","","","","","","","","struct{...}","func(config *QUICConfig) *QUICConn","func(config *QUICConfig) *QUICConn","struct{...}","struct{...}","func(data []byte) (*SessionState, error)","struct{...}","func(ticket []byte, state *SessionState) (*ClientSessionState, error)","func(conn net.Conn, config *Config) *Conn","func(conn net.Conn, config *Config) *Conn","func(inner net.Listener, config *Config) net.Listener","func(network, laddr string, config *Config) (net.Listener, error)","func(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)","func(network, addr string, config *Config) (*Conn, error)","struct{...}","func(certFile, keyFile string) (Certificate, error)","func(certPEMBlock, keyPEMBlock []byte) (Certificate, error)","struct{...}","func() *CertPool","func() (*CertPool, error)","struct{...}","func(oid string) (OID, error)","func(oid []uint64) (OID, error)","func(der []byte) (*Certificate, error)","func(der []byte) ([]*Certificate, error)","func(der []byte) (*RevocationList, error)","","","","","","","func(b *pem.Block) bool","","func(b *pem.Block, password []byte) ([]byte, error)","func(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)","func(der []byte) (*rsa.PrivateKey, error)","func(key *rsa.PrivateKey) []byte","func(der []byte) (*rsa.PublicKey, error)","func(key *rsa.PublicKey) []byte","func(der []byte) (key any, err error)","func(key any) ([]byte, error)","func(roots *CertPool)","func(der []byte) (*ecdsa.PrivateKey, error)","func(key *ecdsa.PrivateKey) ([]byte, error)","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(derBytes []byte) (pub any, err error)","func(pub any) ([]byte, error)","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","","","struct{...}","struct{...}","func(rand io.Reader, template, parent *Certificate, pub, priv any) ([]byte, error)","func(crlBytes []byte) (*pkix.CertificateList, error)","func(derBytes []byte) (*pkix.CertificateList, error)","struct{...}","func(rand io.Reader, template *CertificateRequest, priv any) (csr []byte, err error)","func(asn1Data []byte) (*CertificateRequest, error)","struct{...}","struct{...}","func(rand io.Reader, template *RevocationList, issuer *Certificate, priv crypto.Signer) ([]byte, error)","func(name string, driver driver.Driver)","func() []string","struct{...}","func(name string, value any) NamedArg","","","","","","","","","","struct{...}","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","interface{...}","struct{...}","","struct{...}","func(c driver.Connector) *DB","func(driverName, dataSourceName string) (*DB, error)","struct{...}","","struct{...}","struct{...}","","struct{...}","struct{...}","struct{...}","struct{...}","interface{...}","","func(name string) (info *BuildInfo, err error)","func(r io.ReaderAt) (*BuildInfo, error)","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","struct{...}","func(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(info uint32) uint32","func(info uint32) uint32","func(sym, typ uint32) uint32","struct{...}","","func(info uint8) SymBind","func(info uint8) SymType","func(bind SymBind, typ SymType) uint8","func(other uint8) SymVis","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(info uint64) uint32","func(info uint64) uint32","func(sym, typ uint32) uint64","struct{...}","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(name string) (*File, error)","func(r io.ReaderAt) (*File, error)","","struct{...}","struct{...}","func(data []byte, text uint64) *LineTable","struct{...}","struct{...}","struct{...}","struct{...}","func(symtab []byte, pcln *LineTable) (*Table, error)","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","func(r io.ReaderAt) (*FatFile, error)","func(name string) (*FatFile, error)","struct{...}","interface{...}","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(name string) (*File, error)","func(r io.ReaderAt) (*File, error)","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","func(name string) (*File, error)","func(r io.ReaderAt) (*File, error)","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","","","","","","","","","","","struct{...}","struct{...}","struct{...}","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(name string) (*File, error)","func(r io.ReaderAt) (*File, error)","","","","","","func(dst, src []byte) int","func(n int) int","func(w io.Writer) io.WriteCloser","","func(dst, src []byte, flush bool) (ndst, nsrc int, err error)","func(r io.Reader) io.Reader","struct{...}","struct{...}","struct{...}","","","","","","struct{...}","","func(b []byte, val any) (rest []byte, err error)","func(b []byte, val any, params string) (rest []byte, err error)","","","","","","","","","","","","","","","","","","","","","","","func(val any) ([]byte, error)","func(val any, params string) ([]byte, error)","struct{...}","","","func(encoder string) *Encoding","","","func(enc *Encoding, w io.Writer) io.WriteCloser","","func(enc *Encoding, r io.Reader) io.Reader","struct{...}","","","func(encoder string) *Encoding","","","","","func(enc *Encoding, w io.Writer) io.WriteCloser","","func(enc *Encoding, r io.Reader) io.Reader","interface{...}","interface{...}","","","func(r io.Reader, order ByteOrder, data any) error","func(buf []byte, order ByteOrder, data any) (int, error)","func(w io.Writer, order ByteOrder, data any) error","func(buf []byte, order ByteOrder, data any) (int, error)","func(buf []byte, order ByteOrder, data any) ([]byte, error)","func(v any) int","","","","","func(buf []byte, x uint64) []byte","func(buf []byte, x uint64) int","func(buf []byte) (uint64, int)","func(buf []byte, x int64) []byte","func(buf []byte, x int64) int","func(buf []byte) (int64, int)","func(r io.ByteReader) (uint64, error)","func(r io.ByteReader) (int64, error)","struct{...}","","","","","struct{...}","func(r io.Reader) *Reader","struct{...}","func(w io.Writer) *Writer","struct{...}","func(r io.Reader) *Decoder","struct{...}","func(w io.Writer) *Encoder","struct{...}","interface{...}","interface{...}","func(name string, value any)","func(value any)","func(n int) int","func(dst, src []byte) int","func(dst, src []byte) []byte","","","func(x int) int","func(dst, src []byte) (int, error)","func(dst, src []byte) ([]byte, error)","func(src []byte) string","func(s string) ([]byte, error)","func(data []byte) string","func(w io.Writer) io.Writer","func(r io.Reader) io.Reader","func(w io.Writer) io.WriteCloser","func(data []byte, v any) error","interface{...}","struct{...}","struct{...}","struct{...}","","func(v any) ([]byte, error)","func(v any, prefix, indent string) ([]byte, error)","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(dst *bytes.Buffer, src []byte)","func(dst *bytes.Buffer, src []byte) error","func(dst *bytes.Buffer, src []byte, prefix, indent string) error","func(data []byte) bool","struct{...}","struct{...}","func(r io.Reader) *Decoder","struct{...}","func(w io.Writer) *Encoder","","","","struct{...}","func(data []byte) (p *Block, rest []byte)","func(out io.Writer, b *Block) error","func(b *Block) []byte","","func(v any) ([]byte, error)","interface{...}","interface{...}","func(v any, prefix, indent string) ([]byte, error)","struct{...}","func(w io.Writer) *Encoder","struct{...}","func(data []byte, v any) error","","interface{...}","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","","struct{...}","struct{...}","","","struct{...}","","func(t Token) Token","interface{...}","struct{...}","func(r io.Reader) *Decoder","func(t TokenReader) *Decoder","","","func(w io.Writer, s []byte) error","func(w io.Writer, s []byte)","interface{...}","interface{...}","interface{...}","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(name string) *Ident","func(name string) bool","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(file *File) bool","func(e Expr) Expr","","func(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap","func(src *File) bool","func(pkg *Package) bool","","func(decl Decl, f Filter) bool","func(src *File, f Filter) bool","func(pkg *Package, f Filter) bool","","","","","func(pkg *Package, mode MergeMode) *File","func(fset *token.FileSet, f *File)","","func(_ string, v reflect.Value) bool","func(w io.Writer, fset *token.FileSet, x any, f FieldFilter) error","func(fset *token.FileSet, x any) error","","func(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)","struct{...}","func(outer *Scope) *Scope","struct{...}","func(kind ObjKind, name string) *Object","","","","","","","","","interface{...}","func(v Visitor, node Node)","func(node Node, f func(Node) bool)","func(root Node) iter.Seq[Node]","struct{...}","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","func(path, srcDir string, mode ImportMode) (*Package, error)","func(dir string, mode ImportMode) (*Package, error)","","func(path string) bool","func(goarch string) (string, error)","","","","","","","","interface{...}","func() Value","func(b bool) Value","func(s string) Value","func(x int64) Value","func(x uint64) Value","func(x float64) Value","func(lit string, tok token.Token, zero uint) Value","func(x Value) bool","func(x Value) string","func(x Value) (int64, bool)","func(x Value) (uint64, bool)","func(x Value) (float32, bool)","func(x Value) (float64, bool)","func(x Value) any","func(x any) Value","func(x Value) int","func(x Value) int","func(x Value) []byte","func(bytes []byte) Value","func(x Value) Value","func(x Value) Value","func(x Value) Value","func(x Value) Value","func(x Value) Value","func(x Value) Value","func(x Value) Value","func(x Value) Value","func(op token.Token, y Value, prec uint) Value","func(x_ Value, op token.Token, y_ Value) Value","func(x Value, op token.Token, s uint) Value","func(x_ Value, op token.Token, y_ Value) bool","func(w io.Writer, text string, words map[string]string)","func(w io.Writer, text string, prefix, codePrefix string, width int)","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","","func(pkg *ast.Package, importPath string, mode Mode) *Package","func(fset *token.FileSet, files []*ast.File, importPath string, opts ...any) (*Package, error)","struct{...}","func(testFiles ...*ast.File) []*Example","","func(s string) bool","func(text string) string","","func(dst io.Writer, fset *token.FileSet, node any) error","func(src []byte) ([]byte, error)","","func(fset *token.FileSet, compiler string, lookup Lookup) types.Importer","func(compiler string, lookup Lookup) types.Importer","func() types.Importer","","","","","","","","","","func(fset *token.FileSet, filename string, src any, mode Mode) (f *ast.File, err error)","func(fset *token.FileSet, path string, filter func(fs.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error)","func(fset *token.FileSet, filename string, src any, mode Mode) (expr ast.Expr, err error)","func(x string) (ast.Expr, error)","","","","","","struct{...}","struct{...}","func(output io.Writer, fset *token.FileSet, node any) error","struct{...}","","func(w io.Writer, err error)","","struct{...}","","","struct{...}","","","struct{...}","struct{...}","func() *FileSet","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(ident string) Token","func(name string) bool","func(name string) bool","func(name string) bool","struct{...}","func(obj *TypeName, rhs Type) *Alias","func(t Type) Type","struct{...}","struct{...}","interface{...}","","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(V *Interface, T Type) bool","func(V, T Type) bool","func(V, T Type) bool","func(V Type, T *Interface) bool","func(V Type, T *Interface) bool","func(x, y Type) bool","func(x, y Type) bool","struct{...}","func(elem Type, len int64) *Array","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","","","","","func(dir ChanDir, elem Type) *Chan","struct{...}","func(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker","struct{...}","func() *Context","func(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)","func(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)","func(x ast.Expr) string","func(buf *bytes.Buffer, x ast.Expr)","func(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)","struct{...}","func(methods []*Func, embeddeds []*Named) *Interface","func(methods []*Func, embeddeds []Type) *Interface","func(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)","func(V Type, T *Interface, static bool) (method *Func, wrongType bool)","struct{...}","func(key, elem Type) *Map","struct{...}","func(T Type) *MethodSet","struct{...}","func(obj *TypeName, underlying Type, methods []*Func) *Named","interface{...}","func(pkg *Package, name string) string","struct{...}","func(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName","struct{...}","func(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const","struct{...}","func(pos token.Pos, pkg *Package, name string, typ Type) *TypeName","struct{...}","func(pos token.Pos, pkg *Package, name string, typ Type) *Var","func(pos token.Pos, pkg *Package, name string, typ Type) *Var","func(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var","struct{...}","func(pos token.Pos, pkg *Package, name string, sig *Signature) *Func","struct{...}","func(pos token.Pos, pkg *Package, name string) *Label","struct{...}","struct{...}","func(obj Object, qf Qualifier) string","struct{...}","func(path, name string) *Package","struct{...}","func(elem Type) *Pointer","func(t Type) bool","func(T Type) bool","func(t Type) Type","struct{...}","func(parent *Scope, pos, end token.Pos, comment string) *Scope","","","","","struct{...}","func(s *Selection, qf Qualifier) string","struct{...}","func(recv *Var, params, results *Tuple, variadic bool) *Signature","func(recv *Var, recvTypeParams, typeParams []*TypeParam, params, results *Tuple, variadic bool) *Signature","interface{...}","struct{...}","func(compiler, arch string) Sizes","struct{...}","func(elem Type) *Slice","struct{...}","func(fields []*Var, tags []string) *Struct","struct{...}","func(x ...*Var) *Tuple","interface{...}","struct{...}","struct{...}","struct{...}","func(obj *TypeName, constraint Type) *TypeParam","","func(pkg *Package) Qualifier","func(typ Type, qf Qualifier) string","func(buf *bytes.Buffer, typ Type, qf Qualifier)","func(buf *bytes.Buffer, sig *Signature, qf Qualifier)","struct{...}","func(terms []*Term) *Union","","func(tilde bool, typ Type) *Term","","","","func()","func(x string) string","func(x, y string) int","func(x string) bool","","func() hash.Hash32","func(data []byte) uint32","","","","","","","func(poly uint32) *Table","func(tab *Table) hash.Hash32","func() hash.Hash32","func(crc uint32, tab *Table, p []byte) uint32","func(data []byte, tab *Table) uint32","func(data []byte) uint32","","","","","func(poly uint64) *Table","func(tab *Table) hash.Hash64","func(crc uint64, tab *Table, p []byte) uint64","func(data []byte, tab *Table) uint64","func() hash.Hash32","func() hash.Hash32","func() hash.Hash64","func() hash.Hash64","func() hash.Hash","func() hash.Hash","struct{...}","func(seed Seed, b []byte) uint64","func(seed Seed, s string) uint64","struct{...}","func() Seed","","","","","","","","struct{...}","","","","","","","","","","","","","","","func(w io.Writer, b []byte)","func(s string) string","func(args ...any) string","func(w io.Writer, b []byte)","func(s string) string","func(args ...any) string","func(args ...any) string","struct{...}","func(name string) *Template","","func(t *Template, err error) *Template","func(filenames ...string) (*Template, error)","func(pattern string) (*Template, error)","func(val any) (truth, ok bool)","func(fs fs.FS, patterns ...string) (*Template, error)","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","interface{...}","func(f func(Color) Color) Model","","","","","","","","","","","","","","func(r, g, b uint8) (uint8, uint8, uint8)","func(y, cb, cr uint8) (uint8, uint8, uint8)","struct{...}","","struct{...}","","func(r, g, b uint8) (uint8, uint8, uint8, uint8)","func(c, m, y, k uint8) (uint8, uint8, uint8)","struct{...}","","interface{...}","interface{...}","interface{...}","","","","interface{...}","","func(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)","func(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)","","","","func(r io.Reader) (image.Image, error)","struct{...}","func(r io.Reader) (*GIF, error)","func(r io.Reader) (image.Config, error)","struct{...}","func(w io.Writer, g *GIF) error","func(w io.Writer, m image.Image, o *Options) error","","","interface{...}","func(r io.Reader) (image.Image, error)","func(r io.Reader) (image.Config, error)","","struct{...}","func(w io.Writer, m image.Image, o *Options) error","","","func(r io.Reader) (image.Image, error)","func(r io.Reader) (image.Config, error)","struct{...}","interface{...}","","","","","","","func(w io.Writer, m image.Image) error","struct{...}","func(data []byte) *Index","func(info FileInfo) string","func(dir DirEntry) string","interface{...}","func(name string) bool","interface{...}","interface{...}","interface{...}","","","","","","interface{...}","","","","","","","","","","","","","","","","","struct{...}","interface{...}","func(fsys FS, pattern string) (matches []string, err error)","interface{...}","func(fsys FS, name string) ([]DirEntry, error)","func(info FileInfo) DirEntry","interface{...}","func(fsys FS, name string) ([]byte, error)","interface{...}","func(fsys FS, name string) (FileInfo, error)","interface{...}","func(fsys FS, dir string) (FS, error)","","","","func(fsys FS, root string, fn WalkDirFunc) error","func(r io.Reader) ([]byte, error)","func(filename string) ([]byte, error)","func(filename string, data []byte, perm fs.FileMode) error","func(dirname string) ([]fs.FileInfo, error)","func(r io.Reader) io.ReadCloser","","func(dir, pattern string) (f *os.File, err error)","func(dir, pattern string) (name string, err error)","struct{...}","func(key, value string) Attr","func(key string, value int64) Attr","func(key string, value int) Attr","func(key string, v uint64) Attr","func(key string, v float64) Attr","func(key string, v bool) Attr","func(key string, v time.Time) Attr","func(key string, v time.Duration) Attr","func(key string, args ...any) Attr","func(key string, value any) Attr","interface{...}","struct{...}","","","","","struct{...}","func(w io.Writer, opts *HandlerOptions) *JSONHandler","","","","","","struct{...}","interface{...}","func(level Level) (oldLevel Level)","func() *Logger","func(l *Logger)","struct{...}","func(h Handler) *Logger","func(args ...any) *Logger","func(h Handler, level Level) *log.Logger","func(msg string, args ...any)","func(ctx context.Context, msg string, args ...any)","func(msg string, args ...any)","func(ctx context.Context, msg string, args ...any)","func(msg string, args ...any)","func(ctx context.Context, msg string, args ...any)","func(msg string, args ...any)","func(ctx context.Context, msg string, args ...any)","func(ctx context.Context, level Level, msg string, args ...any)","func(ctx context.Context, level Level, msg string, attrs ...Attr)","struct{...}","func(t time.Time, level Level, msg string, pc uintptr) Record","struct{...}","struct{...}","func(w io.Writer, opts *HandlerOptions) *TextHandler","struct{...}","","","","","","","","","","","","func(value string) Value","func(v int) Value","func(v int64) Value","func(v uint64) Value","func(v float64) Value","func(v bool) Value","func(v time.Time) Value","func(v time.Duration) Value","func(as ...Attr) Value","func(v any) Value","interface{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","func(priority Priority, tag string) (*Writer, error)","func(network, raddr string, priority Priority, tag string) (*Writer, error)","func(p Priority, logFlag int) (*log.Logger, error)","","struct{...}","struct{...}","func(x float64) *Float","","","","","","","","","","","","","","","func(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)","struct{...}","func(x int64) *Int","func(x, y *Int) int","","struct{...}","func(a, b int64) *Rat","","func(x uint) int","func(x uint8) int","func(x uint16) int","func(x uint32) int","func(x uint64) int","func(x uint) int","func(x uint8) int","func(x uint16) int","func(x uint32) int","func(x uint64) int","func(x uint) int","func(x uint8) int","func(x uint16) int","func(x uint32) int","func(x uint64) int","func(x uint, k int) uint","func(x uint8, k int) uint8","func(x uint16, k int) uint16","func(x uint32, k int) uint32","func(x uint64, k int) uint64","func(x uint) uint","func(x uint8) uint8","func(x uint16) uint16","func(x uint32) uint32","func(x uint64) uint64","func(x uint) uint","func(x uint16) uint16","func(x uint32) uint32","func(x uint64) uint64","func(x uint) int","func(x uint8) int","func(x uint16) (n int)","func(x uint32) (n int)","func(x uint64) (n int)","func(x, y, carry uint) (sum, carryOut uint)","func(x, y, carry uint32) (sum, carryOut uint32)","func(x, y, carry uint64) (sum, carryOut uint64)","func(x, y, borrow uint) (diff, borrowOut uint)","func(x, y, borrow uint32) (diff, borrowOut uint32)","func(x, y, borrow uint64) (diff, borrowOut uint64)","func(x, y uint) (hi, lo uint)","func(x, y uint32) (hi, lo uint32)","func(x, y uint64) (hi, lo uint64)","func(hi, lo, y uint) (quo, rem uint)","func(hi, lo, y uint32) (quo, rem uint32)","func(hi, lo, y uint64) (quo, rem uint64)","func(hi, lo, y uint) uint","func(hi, lo, y uint32) uint32","func(hi, lo, y uint64) uint64","func(x complex128) float64","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) bool","func() complex128","func(x complex128) bool","func() complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) float64","func(x complex128) (r, θ float64)","func(x, y complex128) complex128","func(r, θ float64) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","func(x complex128) complex128","interface{...}","interface{...}","func(seed int64) Source","struct{...}","func(src Source) *Rand","func(seed int64)","func() int64","func() uint32","func() uint64","func() int32","func() int","func(n int64) int64","func(n int32) int32","func(n int) int","func() float64","func() float32","func(n int) []int","func(n int, swap func(i, j int))","func(p []byte) (n int, err error)","func() float64","func() float64","struct{...}","func(r *Rand, s float64, v float64, imax uint64) *Zipf","","struct{...}","struct{...}","interface{...}","struct{...}","func(r io.Reader, boundary string) *Reader","struct{...}","struct{...}","func(w io.Writer) *Writer","struct{...}","func(r io.Reader) *Reader","struct{...}","func(w io.Writer) *Writer","struct{...}","","interface{...}","","func(url string) (resp *Response, err error)","","func(url, contentType string, body io.Reader) (resp *Response, err error)","func(url string, data url.Values) (resp *Response, err error)","func(url string) (resp *Response, err error)","struct{...}","","","","","","func(line string) ([]*Cookie, error)","func(line string) (*Cookie, error)","func(w ResponseWriter, cookie *Cookie)","func(fs FileSystem) RoundTripper","func(fsys fs.FS) RoundTripper","","interface{...}","interface{...}","func(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)","func(w ResponseWriter, r *Request, name string)","func(w ResponseWriter, r *Request, fsys fs.FS, name string)","func(fsys fs.FS) FileSystem","func(root FileSystem) Handler","func(root fs.FS) Handler","","func(text string) (t time.Time, err error)","func(s string) string","","struct{...}","interface{...}","interface{...}","","","","","","","","","","","struct{...}","","","","","","","","struct{...}","","func(vers string) (major, minor int, ok bool)","func(method, url string, body io.Reader) (*Request, error)","func(ctx context.Context, method, url string, body io.Reader) (*Request, error)","func(b *bufio.Reader) (*Request, error)","func(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser","struct{...}","struct{...}","","func(r *bufio.Reader, req *Request) (*Response, error)","struct{...}","func(rw ResponseWriter) *ResponseController","","","","","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","","","","","","","","func(w ResponseWriter, error string, code int)","func(w ResponseWriter, r *Request)","func() Handler","func(prefix string, h Handler) Handler","func(w ResponseWriter, r *Request, url string, code int)","func(url string, code int) Handler","struct{...}","func() *ServeMux","","func(pattern string, handler Handler)","func(pattern string, handler func(ResponseWriter, *Request))","func(l net.Listener, handler Handler) error","func(l net.Listener, handler Handler, certFile, keyFile string) error","struct{...}","","","","","","","func(h Handler) Handler","","func(addr string, handler Handler) error","func(addr, certFile, keyFile string, handler Handler) error","func(h Handler, dt time.Duration, msg string) Handler","","func(h Handler, n int64) Handler","func(data []byte) string","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(code int) string","","","","","struct{...}","func(req *Request) (*url.URL, error)","func(fixedURL *url.URL) func(*Request) (*url.URL, error)","","struct{...}","func(r io.Reader) (msg *Message, err error)","func(date string) (time.Time, error)","","","struct{...}","func(address string) (*Address, error)","func(list string) ([]*Address, error)","struct{...}","struct{...}","func() Addr","func() Addr","func() Addr","func() Addr","func() Addr","func(addr [4]byte) Addr","func(addr [16]byte) Addr","func(s string) (Addr, error)","func(s string) Addr","func(slice []byte) (ip Addr, ok bool)","struct{...}","func(ip Addr, port uint16) AddrPort","func(s string) (AddrPort, error)","func(s string) AddrPort","struct{...}","func(ip Addr, bits int) Prefix","func(s string) (Prefix, error)","func(s string) Prefix","","","struct{...}","struct{...}","interface{...}","func(conn io.ReadWriteCloser) *Client","func(codec ClientCodec) *Client","func(network, address string) (*Client, error)","func(network, address, path string) (*Client, error)","func(network, address string) (*Client, error)","","","struct{...}","struct{...}","struct{...}","func() *Server","","func(rcvr any) error","func(name string, rcvr any) error","interface{...}","func(conn io.ReadWriteCloser)","func(codec ServerCodec)","func(codec ServerCodec) error","func(lis net.Listener)","func()","interface{...}","struct{...}","func(identity, username, password, host string) Auth","func(username, secret string) Auth","struct{...}","func(addr string) (*Client, error)","func(conn net.Conn, host string) (*Client, error)","func(addr string, a Auth, from string, to []string, msg []byte) error","","struct{...}","struct{...}","func(r *bufio.Reader) *Reader","func(s string) string","struct{...}","","struct{...}","func(conn io.ReadWriteCloser) *Conn","func(network, addr string) (*Conn, error)","func(s string) string","func(b []byte) []byte","struct{...}","func(w *bufio.Writer) *Writer","struct{...}","","","func(s string) (string, error)","func(s string) (string, error)","func(s string) string","func(s string) string","struct{...}","func(username string) *Userinfo","func(username, password string) *Userinfo","struct{...}","func(rawURL string) (*URL, error)","func(rawURL string) (*URL, error)","","func(query string) (Values, error)","func(base string, elem ...string) (result string, err error)","struct{...}","","struct{...}","func(name string, arg ...string) *Cmd","func(ctx context.Context, name string, arg ...string) *Cmd","struct{...}","","","func(file string) (string, error)","func(sig ...os.Signal)","func(sig os.Signal) bool","func(c chan\u003c- os.Signal, sig ...os.Signal)","func(sig ...os.Signal)","func(c chan\u003c- os.Signal)","func(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)","func() (*User, error)","func(username string) (*User, error)","func(uid string) (*User, error)","func(name string) (*Group, error)","func(gid string) (*Group, error)","struct{...}","struct{...}","","","","","","func(pattern, name string) (matched bool, err error)","func(pattern string) (matches []string, err error)","","","func(path string) string","func(path string) bool","func(path string) (string, error)","func(path string) string","func(path string) string","func(path string) []string","func(path string) (dir, file string)","func(elem ...string) string","func(path string) string","func(path string) (string, error)","func(path string) bool","func(path string) (string, error)","func(basepath, targpath string) (string, error)","","","","func(root string, fn fs.WalkDirFunc) error","func(root string, fn WalkFunc) error","func(path string) string","func(path string) string","func(path string) string","func(p, prefix string) bool","func(re *Regexp) (*Prog, error)","struct{...}","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func(s string, flags Flags) (*Regexp, error)","struct{...}","","","","","","","","","","","","","","","","","","","","func(r1, r2 rune) EmptyOp","func(r rune) bool","struct{...}","struct{...}","","","","","","","","","","","","","","","","","","","","","struct{...}","","func(v any) Handle","func(dir string) error","func(w io.Writer) error","func(dir string) error","func(w io.Writer) error","func() error","struct{...}","func(stats *GCStats)","func(percent int) int","func()","func(bytes int) int","func(threads int) int","func(enabled bool) bool","func(fd uintptr)","func(level string)","func(limit int64) int64","func() (info *BuildInfo, ok bool)","struct{...}","struct{...}","struct{...}","func(data string) (bi *BuildInfo, err error)","func()","func() []byte","struct{...}","func(f *os.File, opts CrashOptions) error","struct{...}","func() []Description","struct{...}","struct{...}","func(m []Sample)","","","","","","struct{...}","struct{...}","func(ctx context.Context, labels LabelSet) context.Context","func(args ...string) LabelSet","func(ctx context.Context, key string) (string, bool)","func(ctx context.Context, f func(key, value string) bool)","struct{...}","func(name string) *Profile","func(name string) *Profile","func() []*Profile","func(w io.Writer) error","func(w io.Writer) error","func()","func(ctx context.Context)","func(ctx context.Context, labels LabelSet, f func(context.Context))","func(pctx context.Context, taskType string) (ctx context.Context, task *Task)","struct{...}","func(ctx context.Context, category, message string)","func(ctx context.Context, category, format string, args ...any)","func(ctx context.Context, regionType string, fn func())","func(ctx context.Context, regionType string) *Region","struct{...}","func() bool","func(w io.Writer) error","func()","func(addr *int32, new int32) (old int32)","func(addr *int64, new int64) (old int64)","func(addr *uint32, new uint32) (old uint32)","func(addr *uint64, new uint64) (old uint64)","func(addr *uintptr, new uintptr) (old uintptr)","func(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)","func(addr *int32, old, new int32) (swapped bool)","func(addr *int64, old, new int64) (swapped bool)","func(addr *uint32, old, new uint32) (swapped bool)","func(addr *uint64, old, new uint64) (swapped bool)","func(addr *uintptr, old, new uintptr) (swapped bool)","func(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)","func(addr *int32, delta int32) (new int32)","func(addr *uint32, delta uint32) (new uint32)","func(addr *int64, delta int64) (new int64)","func(addr *uint64, delta uint64) (new uint64)","func(addr *uintptr, delta uintptr) (new uintptr)","func(addr *int32, mask int32) (old int32)","func(addr *uint32, mask uint32) (old uint32)","func(addr *int64, mask int64) (old int64)","func(addr *uint64, mask uint64) (old uint64)","func(addr *uintptr, mask uintptr) (old uintptr)","func(addr *int32, mask int32) (old int32)","func(addr *uint32, mask uint32) (old uint32)","func(addr *int64, mask int64) (old int64)","func(addr *uint64, mask uint64) (old uint64)","func(addr *uintptr, mask uintptr) (old uintptr)","func(addr *int32) (val int32)","func(addr *int64) (val int64)","func(addr *uint32) (val uint32)","func(addr *uint64) (val uint64)","func(addr *uintptr) (val uintptr)","func(addr *unsafe.Pointer) (val unsafe.Pointer)","func(addr *int32, val int32)","func(addr *int64, val int64)","func(addr *uint32, val uint32)","func(addr *uint64, val uint64)","func(addr *uintptr, val uintptr)","func(addr *unsafe.Pointer, val unsafe.Pointer)","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(fn func(this Value, args []Value) any) Func","struct{...}","struct{...}","func() Value","func() Value","func() Value","func(x any) Value","","","","","","","","","","struct{...}","func(dst []byte, src Value) int","func(dst Value, src []byte) int","","struct{...}","func(fsys fs.FS, expected ...string) error","func(prefix string, w io.Writer) io.Writer","func(prefix string, r io.Reader) io.Reader","func(r io.Reader) io.Reader","func(r io.Reader) io.Reader","func(r io.Reader) io.Reader","","func(r io.Reader) io.Reader","func(err error) io.Reader","func(r io.Reader, content []byte) error","func(w io.Writer, n int64) io.Writer","interface{...}","func(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)","struct{...}","","struct{...}","struct{...}","func(f any, config *Config) error","func(f, g any, config *Config) error","func(h slog.Handler, results func() []map[string]any) error","func(t *testing.T, newHandler func(*testing.T) slog.Handler, result func(*testing.T) map[string]any)","struct{...}","","","","","","","","","","","","","","","","","","func(tok rune) string","","struct{...}","struct{...}","","","","","","","","func(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer","struct{...}","func(val any) (truth, ok bool)","","func(w io.Writer, b []byte)","func(s string) string","func(args ...any) string","func(w io.Writer, b []byte)","func(s string) string","func(args ...any) string","func(args ...any) string","func(t *Template, err error) *Template","func(filenames ...string) (*Template, error)","func(pattern string) (*Template, error)","func(fsys fs.FS, patterns ...string) (*Template, error)","struct{...}","func(name string) *Template","func(r rune) bool","func(r1, r2 rune) rune","func(r rune) (r1, r2 rune)","func(r rune) int","func(s []rune) []uint16","func(a []uint16, r rune) []uint16","func(s []uint16) []rune","","","","","func(p []byte) bool","func(s string) bool","func(p []byte) (r rune, size int)","func(s string) (r rune, size int)","func(p []byte) (r rune, size int)","func(s string) (r rune, size int)","func(r rune) int","func(p []byte, r rune) int","func(p []byte, r rune) []byte","func(p []byte) int","func(s string) (n int)","func(b byte) bool","func(p []byte) bool","func(s string) bool","func(r rune) bool","struct{...}","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","struct{...}","interface{...}","interface{...}","interface{...}","","","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","","struct{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","interface{...}","","","interface{...}","interface{...}","","","","struct{...}","struct{...}","func(v any) bool","func(v any) bool","","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(line string) (Expr, error)","func(line string) bool","func(line string) bool","func(x Expr) ([]string, error)","func(x Expr) string","struct{...}","struct{...}","interface{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","interface{...}","","","struct{...}","struct{...}","struct{...}","func(name string) (importPath string, ok bool)","struct{...}","","","struct{...}","func(seed [32]byte) *ChaCha8","struct{...}","func(seed1, seed2 uint64) *PCG","interface{...}","struct{...}","func(src Source) *Rand","func() int64","func() uint32","func(n uint64) uint64","func(n uint32) uint32","func() uint64","func() int32","func() int","func() uint","func(n int64) int64","func(n int32) int32","func(n int) int","func(n uint) uint","func[Int intType](n Int) Int","func() float64","func() float32","func(n int) []int","func(n int, swap func(i, j int))","func() float64","func() float64","struct{...}","func(r *Rand, s float64, v float64, imax uint64) *Zipf","func() (*http.Request, error)","func(params map[string]string) (*http.Request, error)","func(handler http.Handler) error","struct{...}","interface{...}","struct{...}","struct{...}","func(o *Options) (*Jar, error)","","","func(l net.Listener, handler http.Handler) error","func(r *http.Request) map[string]string","func(method, target string, body io.Reader) *http.Request","func(ctx context.Context, method, target string, body io.Reader) *http.Request","struct{...}","func() *ResponseRecorder","","struct{...}","func(handler http.Handler) *Server","func(handler http.Handler) *Server","func(handler http.Handler) *Server","func(ctx context.Context) *ClientTrace","func(ctx context.Context, trace *ClientTrace) context.Context","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(req *http.Request, body bool) ([]byte, error)","func(req *http.Request, body bool) ([]byte, error)","func(resp *http.Response, body bool) ([]byte, error)","func(r io.Reader) io.Reader","func(w io.Writer) io.WriteCloser","","","","","struct{...}","func(c net.Conn, r *bufio.Reader) *ServerConn","struct{...}","func(c net.Conn, r *bufio.Reader) *ClientConn","func(c net.Conn, r *bufio.Reader) *ClientConn","struct{...}","struct{...}","interface{...}","func(target *url.URL) *ReverseProxy","func(w http.ResponseWriter, r *http.Request)","func(w http.ResponseWriter, r *http.Request)","func(w http.ResponseWriter, r *http.Request)","func(w http.ResponseWriter, r *http.Request)","func(name string) http.Handler","func(w http.ResponseWriter, r *http.Request)","func(conn io.ReadWriteCloser) rpc.ClientCodec","func(conn io.ReadWriteCloser) *rpc.Client","func(network, address string) (*rpc.Client, error)","func(conn io.ReadWriteCloser) rpc.ServerCodec","func(conn io.ReadWriteCloser)","interface{...}","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(ident string) *IdentifierNode","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","","","","func(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error)","func(name string, funcs ...map[string]any) *Tree","func(n Node) bool","","","","struct{...}","func(key, nonce []byte) (*Cipher, error)","func(key, nonce []byte) ([]byte, error)","","","","","func(key []byte) (cipher.AEAD, error)","func(key []byte) (cipher.AEAD, error)","struct{...}","func(buffer []byte) *Builder","func(buffer []byte) *Builder","","struct{...}","interface{...}","","func(hash func() hash.Hash, secret, salt []byte) []byte","func(hash func() hash.Hash, pseudorandomKey, info []byte) io.Reader","func(hash func() hash.Hash, secret, salt, info []byte) io.Reader","func() hash.Hash","func() hash.Hash","func() hash.Hash","func() hash.Hash","func() hash.Hash","func() hash.Hash","func(data []byte) (digest [28]byte)","func(data []byte) (digest [32]byte)","func(data []byte) (digest [48]byte)","func(data []byte) (digest [64]byte)","interface{...}","func() ShakeHash","func() ShakeHash","func(N, S []byte) ShakeHash","func(N, S []byte) ShakeHash","func(hash, data []byte)","func(hash, data []byte)","func(s string) (string, error)","func(s string) (string, error)","","func(transitional bool) Option","func(verify bool) Option","func(remove bool) Option","func(enable bool) Option","func(enable bool) Option","func(enable bool) Option","func(use bool) Option","func() Option","func() Option","func() Option","struct{...}","func(o ...Option) *Profile","","","","","","","func(t *testing.T, mp MakePipe)","func() bool","func() bool","func() bool","func(network string) bool","func(network, address string) bool","func(network string) (net.Listener, error)","func(network string) (net.PacketConn, error)","func() (string, error)","func(network string, ifi *net.Interface) (net.IP, error)","func() (*net.Interface, error)","func(network string, flags net.Flags) (*net.Interface, error)","","struct{...}","","","","","","","","","","","interface{...}","interface{...}","struct{...}","struct{...}","func(r io.Reader, t Transformer) *Reader","struct{...}","func(w io.Writer, t Transformer) *Writer","","","func(t ...Transformer) Transformer","func(f func(r rune) bool) Transformer","func(t Transformer, s string) (result string, n int, err error)","func(t Transformer, b []byte) (result []byte, n int, err error)","func(t Transformer, dst, src []byte) (result []byte, n int, err error)","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","struct{...}","struct{...}","interface{...}","struct{...}","struct{...}","func(buf []byte, h Header) Builder","struct{...}","struct{...}","func(name string) (Name, error)","func(name string) Name","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","struct{...}","func(name string) bool","func(r rune) bool","func(values []string, token string) bool","func(v string) bool","func(h string) bool","func(v string) bool","func(v string) (string, error)","struct{...}","func() *Config","struct{...}","func(w io.Writer) *Encoder","struct{...}","","struct{...}","struct{...}","func(maxDynamicTableSize uint32, emitFunc func(f HeaderField)) *Decoder","","func(w io.Writer, v []byte) (int, error)","func(v []byte) (string, error)","","func(dst []byte, s string) []byte","func(s string) uint64","","func(b []byte) bidi.Direction","func(s string) bidi.Direction","func(b []byte) bool","func(s string) bool","func() *Transformer","struct{...}","","","","","","","func(d Direction) Option","struct{...}","struct{...}","struct{...}","func(out, in []byte) []byte","func(s string) string","struct{...}","func(r rune) (p Properties, size int)","func(s []byte) (p Properties, sz int)","func(s string) (p Properties, sz int)","","","","","","","","","","","","","","","","","","","","","","","","","","","","struct{...}","","struct{...}","","","","","","",""],"signatures":["","","","","type Reader struct {\n\tbuf\t\t[]byte\n\trd\t\tio.Reader\t// reader provided by the client\n\tr, w\t\tint\t\t// buf read and write positions\n\terr\t\terror\n\tlastByte\tint\t// last byte read for UnreadByte; -1 means invalid\n\tlastRuneSize\tint\t// size of last rune read for UnreadRune; -1 means invalid\n}","func NewReaderSize(rd io.Reader, size int) *Reader","func NewReader(rd io.Reader) *Reader","type Writer struct {\n\terr\terror\n\tbuf\t[]byte\n\tn\tint\n\twr\tio.Writer\n}","func NewWriterSize(w io.Writer, size int) *Writer","func NewWriter(w io.Writer) *Writer","type ReadWriter struct {\n\t*Reader\n\t*Writer\n}","func NewReadWriter(r *Reader, w *Writer) *ReadWriter","type Scanner struct {\n\tr\t\tio.Reader\t// The reader provided by the client.\n\tsplit\t\tSplitFunc\t// The function to split the tokens.\n\tmaxTokenSize\tint\t\t// Maximum size of a token; modified by tests.\n\ttoken\t\t[]byte\t\t// Last token returned by split.\n\tbuf\t\t[]byte\t\t// Buffer used as argument to split.\n\tstart\t\tint\t\t// First non-processed byte in buf.\n\tend\t\tint\t\t// End of data in buf.\n\terr\t\terror\t\t// Sticky error.\n\tempties\t\tint\t\t// Count of successive empty tokens.\n\tscanCalled\tbool\t\t// Scan has been called; buffer is in use.\n\tdone\t\tbool\t\t// Scan has finished.\n}","type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)","","","","","","func NewScanner(r io.Reader) *Scanner","","func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)","func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)","func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)","func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)","","const true = 0 == 0","const false = 0 != 0","","","","","","","","","","","","","","","","","","","type any = interface{}","type comparable interface{ comparable }","const iota = 0","var nil Type","func append(slice []Type, elems ...Type) []Type","func copy(dst, src []Type) int","func delete(m map[Type]Type1, key Type)","func len(v Type) int","func cap(v Type) int","func make(t Type, size ...IntegerType) Type","func max[T cmp.Ordered](x T, y ...T) T","func min[T cmp.Ordered](x T, y ...T) T","func new(Type) *Type","func complex(r, i FloatType) ComplexType","func real(c ComplexType) FloatType","func imag(c ComplexType) FloatType","func clear[T ~[]Type | ~map[Type]Type1](t T)","func close(c chan\u003c- Type)","func panic(v any)","func recover() any","func print(args ...Type)","func println(args ...Type)","type error interface {\n\tError() string\n}","type Buffer struct {\n\tbuf\t\t[]byte\t// contents are the bytes buf[off : len(buf)]\n\toff\t\tint\t// read at \u0026buf[off], write at \u0026buf[len(buf)]\n\tlastRead\treadOp\t// last read operation, so that Unread* can work correctly.\n}","","const MinRead = 512","func NewBuffer(buf []byte) *Buffer","func NewBufferString(s string) *Buffer","func Equal(a, b []byte) bool","func Compare(a, b []byte) int","func Count(s, sep []byte) int","func Contains(b, subslice []byte) bool","func ContainsAny(b []byte, chars string) bool","func ContainsRune(b []byte, r rune) bool","func ContainsFunc(b []byte, f func(rune) bool) bool","func IndexByte(b []byte, c byte) int","func LastIndex(s, sep []byte) int","func LastIndexByte(s []byte, c byte) int","func IndexRune(s []byte, r rune) int","func IndexAny(s []byte, chars string) int","func LastIndexAny(s []byte, chars string) int","func SplitN(s, sep []byte, n int) [][]byte","func SplitAfterN(s, sep []byte, n int) [][]byte","func Split(s, sep []byte) [][]byte","func SplitAfter(s, sep []byte) [][]byte","func Fields(s []byte) [][]byte","func FieldsFunc(s []byte, f func(rune) bool) [][]byte","func Join(s [][]byte, sep []byte) []byte","func HasPrefix(s, prefix []byte) bool","func HasSuffix(s, suffix []byte) bool","func Map(mapping func(r rune) rune, s []byte) []byte","func Repeat(b []byte, count int) []byte","func ToUpper(s []byte) []byte","func ToLower(s []byte) []byte","func ToTitle(s []byte) []byte","func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte","func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte","func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte","func ToValidUTF8(s, replacement []byte) []byte","func Title(s []byte) []byte","func TrimLeftFunc(s []byte, f func(r rune) bool) []byte","func TrimRightFunc(s []byte, f func(r rune) bool) []byte","func TrimFunc(s []byte, f func(r rune) bool) []byte","func TrimPrefix(s, prefix []byte) []byte","func TrimSuffix(s, suffix []byte) []byte","func IndexFunc(s []byte, f func(r rune) bool) int","func LastIndexFunc(s []byte, f func(r rune) bool) int","func Trim(s []byte, cutset string) []byte","func TrimLeft(s []byte, cutset string) []byte","func TrimRight(s []byte, cutset string) []byte","func TrimSpace(s []byte) []byte","func Runes(s []byte) []rune","func Replace(s, old, new []byte, n int) []byte","func ReplaceAll(s, old, new []byte) []byte","func EqualFold(s, t []byte) bool","func Index(s, sep []byte) int","func Cut(s, sep []byte) (before, after []byte, found bool)","func Clone(b []byte) []byte","func CutPrefix(s, prefix []byte) (after []byte, found bool)","func CutSuffix(s, suffix []byte) (before []byte, found bool)","type Reader struct {\n\ts\t\t[]byte\n\ti\t\tint64\t// current reading index\n\tprevRune\tint\t// index of previous rune; or \u003c 0\n}","func NewReader(b []byte) *Reader","type Ordered interface {\n\t~int | ~int8 | ~int16 | ~int32 | ~int64 |\n\t\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |\n\t\t~float32 | ~float64 |\n\t\t~string\n}","func Less[T Ordered](x, y T) bool","func Compare[T Ordered](x, y T) int","func Or[T comparable](vals ...T) T","type Context interface {\n\t// Deadline returns the time when work done on behalf of this context\n\t// should be canceled. Deadline returns ok==false when no deadline is\n\t// set. Successive calls to Deadline return the same results.\n\tDeadline() (deadline time.Time, ok bool)\n\n\t// Done returns a channel that's closed when work done on behalf of this\n\t// context should be canceled. Done may return nil if this context can\n\t// never be canceled. Successive calls to Done return the same value.\n\t// The close of the Done channel may happen asynchronously,\n\t// after the cancel function returns.\n\t//\n\t// WithCancel arranges for Done to be closed when cancel is called;\n\t// WithDeadline arranges for Done to be closed when the deadline\n\t// expires; WithTimeout arranges for Done to be closed when the timeout\n\t// elapses.\n\t//\n\t// Done is provided for use in select statements:\n\t//\n\t//  // Stream generates values with DoSomething and sends them to out\n\t//  // until DoSomething returns an error or ctx.Done is closed.\n\t//  func Stream(ctx context.Context, out chan\u003c- Value) error {\n\t//  \tfor {\n\t//  \t\tv, err := DoSomething(ctx)\n\t//  \t\tif err != nil {\n\t//  \t\t\treturn err\n\t//  \t\t}\n\t//  \t\tselect {\n\t//  \t\tcase \u003c-ctx.Done():\n\t//  \t\t\treturn ctx.Err()\n\t//  \t\tcase out \u003c- v:\n\t//  \t\t}\n\t//  \t}\n\t//  }\n\t//\n\t// See https://blog.golang.org/pipelines for more examples of how to use\n\t// a Done channel for cancellation.\n\tDone() \u003c-chan struct{}\n\n\t// If Done is not yet closed, Err returns nil.\n\t// If Done is closed, Err returns a non-nil error explaining why:\n\t// Canceled if the context was canceled\n\t// or DeadlineExceeded if the context's deadline passed.\n\t// After Err returns a non-nil error, successive calls to Err return the same error.\n\tErr() error\n\n\t// Value returns the value associated with this context for key, or nil\n\t// if no value is associated with key. Successive calls to Value with\n\t// the same key returns the same result.\n\t//\n\t// Use context values only for request-scoped data that transits\n\t// processes and API boundaries, not for passing optional parameters to\n\t// functions.\n\t//\n\t// A key identifies a specific value in a Context. Functions that wish\n\t// to store values in Context typically allocate a key in a global\n\t// variable then use that key as the argument to context.WithValue and\n\t// Context.Value. A key can be any type that supports equality;\n\t// packages should define keys as an unexported type to avoid\n\t// collisions.\n\t//\n\t// Packages that define a Context key should provide type-safe accessors\n\t// for the values stored using that key:\n\t//\n\t// \t// Package user defines a User type that's stored in Contexts.\n\t// \tpackage user\n\t//\n\t// \timport \"context\"\n\t//\n\t// \t// User is the type of value stored in the Contexts.\n\t// \ttype User struct {...}\n\t//\n\t// \t// key is an unexported type for keys defined in this package.\n\t// \t// This prevents collisions with keys defined in other packages.\n\t// \ttype key int\n\t//\n\t// \t// userKey is the key for user.User values in Contexts. It is\n\t// \t// unexported; clients use user.NewContext and user.FromContext\n\t// \t// instead of using this key directly.\n\t// \tvar userKey key\n\t//\n\t// \t// NewContext returns a new Context that carries value u.\n\t// \tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t// \t\treturn context.WithValue(ctx, userKey, u)\n\t// \t}\n\t//\n\t// \t// FromContext returns the User value stored in ctx, if any.\n\t// \tfunc FromContext(ctx context.Context) (*User, bool) {\n\t// \t\tu, ok := ctx.Value(userKey).(*User)\n\t// \t\treturn u, ok\n\t// \t}\n\tValue(key any) any\n}","","var DeadlineExceeded error","func Background() Context","func TODO() Context","type CancelFunc func()","func WithCancel(parent Context) (ctx Context, cancel CancelFunc)","type CancelCauseFunc func(cause error)","func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)","func Cause(c Context) error","func AfterFunc(ctx Context, f func()) (stop func() bool)","func WithoutCancel(parent Context) Context","func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)","func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)","func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)","func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)","func WithValue(parent Context, key, val any) Context","","const MD4 Hash","const MD5","const SHA1","const SHA224","const SHA256","const SHA384","const SHA512","const MD5SHA1","const RIPEMD160","const SHA3_224","const SHA3_256","const SHA3_384","const SHA3_512","const SHA512_224","const SHA512_256","const BLAKE2s_256","const BLAKE2b_256","const BLAKE2b_384","const BLAKE2b_512","func RegisterHash(h Hash, f func() hash.Hash)","","","type Signer interface {\n\t// Public returns the public key corresponding to the opaque,\n\t// private key.\n\tPublic() PublicKey\n\n\t// Sign signs digest with the private key, possibly using entropy from\n\t// rand. For an RSA key, the resulting signature should be either a\n\t// PKCS #1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA\n\t// key, it should be a DER-serialised, ASN.1 signature structure.\n\t//\n\t// Hash implements the SignerOpts interface and, in most cases, one can\n\t// simply pass in the hash function used as opts. Sign may also attempt\n\t// to type assert opts to other types in order to obtain algorithm\n\t// specific values. See the documentation in each package for details.\n\t//\n\t// Note that when a signature of a hash of a larger message is needed,\n\t// the caller is responsible for hashing the larger message and passing\n\t// the hash (as digest) and the hash function (as opts) to Sign.\n\tSign(rand io.Reader, digest []byte, opts SignerOpts) (signature []byte, err error)\n}","type SignerOpts interface {\n\t// HashFunc returns an identifier for the hash function used to produce\n\t// the message passed to Signer.Sign, or else zero to indicate that no\n\t// hashing was done.\n\tHashFunc() Hash\n}","type Decrypter interface {\n\t// Public returns the public key corresponding to the opaque,\n\t// private key.\n\tPublic() PublicKey\n\n\t// Decrypt decrypts msg. The opts argument should be appropriate for\n\t// the primitive used. See the documentation in each implementation for\n\t// details.\n\tDecrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error)\n}","","type FS struct {\n\t// The compiler knows the layout of this struct.\n\t// See cmd/compile/internal/staticdata's WriteEmbed.\n\t//\n\t// The files list is sorted by name but not by simple string comparison.\n\t// Instead, each file's name takes the form \"dir/elem\" or \"dir/elem/\".\n\t// The optional trailing slash indicates that the file is itself a directory.\n\t// The files list is sorted first by dir (if dir is missing, it is taken to be \".\")\n\t// and then by base, so this list of files:\n\t//\n\t//\tp\n\t//\tq/\n\t//\tq/r\n\t//\tq/s/\n\t//\tq/s/t\n\t//\tq/s/u\n\t//\tq/v\n\t//\tw\n\t//\n\t// is actually sorted as:\n\t//\n\t//\tp       # dir=.    elem=p\n\t//\tq/      # dir=.    elem=q\n\t//\tw/      # dir=.    elem=w\n\t//\tq/r     # dir=q    elem=r\n\t//\tq/s/    # dir=q    elem=s\n\t//\tq/v     # dir=q    elem=v\n\t//\tq/s/t   # dir=q/s  elem=t\n\t//\tq/s/u   # dir=q/s  elem=u\n\t//\n\t// This order brings directory contents together in contiguous sections\n\t// of the list, allowing a directory read to use binary search to find\n\t// the relevant sequence of entries.\n\tfiles *[]file\n}","type BinaryMarshaler interface {\n\tMarshalBinary() (data []byte, err error)\n}","type BinaryUnmarshaler interface {\n\tUnmarshalBinary(data []byte) error\n}","type TextMarshaler interface {\n\tMarshalText() (text []byte, err error)\n}","type TextUnmarshaler interface {\n\tUnmarshalText(text []byte) error\n}","func New(text string) error","","func Join(errs ...error) error","func Unwrap(err error) error","func Is(err, target error) bool","func As(err error, target any) bool","type Var interface {\n\t// String returns a valid JSON value for the variable.\n\t// Types with String methods that do not return valid JSON\n\t// (such as time.Time) must not be used as a Var.\n\tString() string\n}","type Int struct {\n\ti atomic.Int64\n}","type Float struct {\n\tf atomic.Uint64\n}","type Map struct {\n\tm\tsync.Map\t// map[string]Var\n\tkeysMu\tsync.RWMutex\n\tkeys\t[]string\t// sorted\n}","type KeyValue struct {\n\tKey\tstring\n\tValue\tVar\n}","type String struct {\n\ts atomic.Value\t// string\n}","type Func func() any","func Publish(name string, v Var)","func Get(name string) Var","func NewInt(name string) *Int","func NewFloat(name string) *Float","func NewMap(name string) *Map","func NewString(name string) *String","func Do(f func(KeyValue))","func Handler() http.Handler","","type Value interface {\n\tString() string\n\tSet(string) error\n}","type Getter interface {\n\tValue\n\tGet() any\n}","","const ContinueOnError ErrorHandling","const ExitOnError","const PanicOnError","type FlagSet struct {\n\t// Usage is the function called when an error occurs while parsing flags.\n\t// The field is a function (not a method) that may be changed to point to\n\t// a custom error handler. What happens after Usage is called depends\n\t// on the ErrorHandling setting; for the command line, this defaults\n\t// to ExitOnError, which exits the program after calling Usage.\n\tUsage\tfunc()\n\n\tname\t\tstring\n\tparsed\t\tbool\n\tactual\t\tmap[string]*Flag\n\tformal\t\tmap[string]*Flag\n\targs\t\t[]string\t// arguments after flags\n\terrorHandling\tErrorHandling\n\toutput\t\tio.Writer\t\t// nil means stderr; use Output() accessor\n\tundef\t\tmap[string]string\t// flags which didn't exist at the time of Set\n}","type Flag struct {\n\tName\t\tstring\t// name as it appears on command line\n\tUsage\t\tstring\t// help message\n\tValue\t\tValue\t// value as set\n\tDefValue\tstring\t// default value (as text); for usage message\n}","func VisitAll(fn func(*Flag))","func Visit(fn func(*Flag))","func Lookup(name string) *Flag","func Set(name, value string) error","func UnquoteUsage(flag *Flag) (name string, usage string)","func PrintDefaults()","","func NFlag() int","func Arg(i int) string","func NArg() int","func Args() []string","func BoolVar(p *bool, name string, value bool, usage string)","func Bool(name string, value bool, usage string) *bool","func IntVar(p *int, name string, value int, usage string)","func Int(name string, value int, usage string) *int","func Int64Var(p *int64, name string, value int64, usage string)","func Int64(name string, value int64, usage string) *int64","func UintVar(p *uint, name string, value uint, usage string)","func Uint(name string, value uint, usage string) *uint","func Uint64Var(p *uint64, name string, value uint64, usage string)","func Uint64(name string, value uint64, usage string) *uint64","func StringVar(p *string, name string, value string, usage string)","func String(name string, value string, usage string) *string","func Float64Var(p *float64, name string, value float64, usage string)","func Float64(name string, value float64, usage string) *float64","func DurationVar(p *time.Duration, name string, value time.Duration, usage string)","func Duration(name string, value time.Duration, usage string) *time.Duration","func TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string)","func Func(name, usage string, fn func(string) error)","func BoolFunc(name, usage string, fn func(string) error)","func Var(value Value, name string, usage string)","func Parse()","func Parsed() bool","","func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet","func Errorf(format string, a ...any) error","type State interface {\n\t// Write is the function to call to emit formatted output to be printed.\n\tWrite(b []byte) (n int, err error)\n\t// Width returns the value of the width option and whether it has been set.\n\tWidth() (wid int, ok bool)\n\t// Precision returns the value of the precision option and whether it has been set.\n\tPrecision() (prec int, ok bool)\n\n\t// Flag reports whether the flag c, a character, has been set.\n\tFlag(c int) bool\n}","type Formatter interface {\n\tFormat(f State, verb rune)\n}","type Stringer interface {\n\tString() string\n}","type GoStringer interface {\n\tGoString() string\n}","func FormatString(state State, verb rune) string","func Fprintf(w io.Writer, format string, a ...any) (n int, err error)","func Printf(format string, a ...any) (n int, err error)","func Sprintf(format string, a ...any) string","func Appendf(b []byte, format string, a ...any) []byte","func Fprint(w io.Writer, a ...any) (n int, err error)","func Print(a ...any) (n int, err error)","func Sprint(a ...any) string","func Append(b []byte, a ...any) []byte","func Fprintln(w io.Writer, a ...any) (n int, err error)","func Println(a ...any) (n int, err error)","func Sprintln(a ...any) string","func Appendln(b []byte, a ...any) []byte","type ScanState interface {\n\t// ReadRune reads the next rune (Unicode code point) from the input.\n\t// If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will\n\t// return EOF after returning the first '\\n' or when reading beyond\n\t// the specified width.\n\tReadRune() (r rune, size int, err error)\n\t// UnreadRune causes the next call to ReadRune to return the same rune.\n\tUnreadRune() error\n\t// SkipSpace skips space in the input. Newlines are treated appropriately\n\t// for the operation being performed; see the package documentation\n\t// for more information.\n\tSkipSpace()\n\t// Token skips space in the input if skipSpace is true, then returns the\n\t// run of Unicode code points c satisfying f(c).  If f is nil,\n\t// !unicode.IsSpace(c) is used; that is, the token will hold non-space\n\t// characters. Newlines are treated appropriately for the operation being\n\t// performed; see the package documentation for more information.\n\t// The returned slice points to shared data that may be overwritten\n\t// by the next call to Token, a call to a Scan function using the ScanState\n\t// as input, or when the calling Scan method returns.\n\tToken(skipSpace bool, f func(rune) bool) (token []byte, err error)\n\t// Width returns the value of the width option and whether it has been set.\n\t// The unit is Unicode code points.\n\tWidth() (wid int, ok bool)\n\t// Because ReadRune is implemented by the interface, Read should never be\n\t// called by the scanning routines and a valid implementation of\n\t// ScanState may choose always to return an error from Read.\n\tRead(buf []byte) (n int, err error)\n}","type Scanner interface {\n\tScan(state ScanState, verb rune) error\n}","func Scan(a ...any) (n int, err error)","func Scanln(a ...any) (n int, err error)","func Scanf(format string, a ...any) (n int, err error)","func Sscan(str string, a ...any) (n int, err error)","func Sscanln(str string, a ...any) (n int, err error)","func Sscanf(str string, format string, a ...any) (n int, err error)","func Fscan(r io.Reader, a ...any) (n int, err error)","func Fscanln(r io.Reader, a ...any) (n int, err error)","func Fscanf(r io.Reader, format string, a ...any) (n int, err error)","type Hash interface {\n\t// Write (via the embedded io.Writer interface) adds more data to the running hash.\n\t// It never returns an error.\n\tio.Writer\n\n\t// Sum appends the current hash to b and returns the resulting slice.\n\t// It does not change the underlying hash state.\n\tSum(b []byte) []byte\n\n\t// Reset resets the Hash to its initial state.\n\tReset()\n\n\t// Size returns the number of bytes Sum will return.\n\tSize() int\n\n\t// BlockSize returns the hash's underlying block size.\n\t// The Write method must be able to accept any amount\n\t// of data, but it may operate more efficiently if all writes\n\t// are a multiple of the block size.\n\tBlockSize() int\n}","type Hash32 interface {\n\tHash\n\tSum32() uint32\n}","type Hash64 interface {\n\tHash\n\tSum64() uint64\n}","func EscapeString(s string) string","func UnescapeString(s string) string","","func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))","func Decode(r io.Reader) (Image, string, error)","func DecodeConfig(r io.Reader) (Config, string, error)","type Point struct {\n\tX, Y int\n}","var ZP Point","func Pt(X, Y int) Point","type Rectangle struct {\n\tMin, Max Point\n}","var ZR Rectangle","func Rect(x0, y0, x1, y1 int) Rectangle","type Config struct {\n\tColorModel\tcolor.Model\n\tWidth, Height\tint\n}","type Image interface {\n\t// ColorModel returns the Image's color model.\n\tColorModel() color.Model\n\t// Bounds returns the domain for which At can return non-zero color.\n\t// The bounds do not necessarily contain the point (0, 0).\n\tBounds() Rectangle\n\t// At returns the color of the pixel at (x, y).\n\t// At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.\n\t// At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.\n\tAt(x, y int) color.Color\n}","type RGBA64Image interface {\n\t// RGBA64At returns the RGBA64 color of the pixel at (x, y). It is\n\t// equivalent to calling At(x, y).RGBA() and converting the resulting\n\t// 32-bit return values to a color.RGBA64, but it can avoid allocations\n\t// from converting concrete color types to the color.Color interface type.\n\tRGBA64At(x, y int) color.RGBA64\n\tImage\n}","type PalettedImage interface {\n\t// ColorIndexAt returns the palette index of the pixel at (x, y).\n\tColorIndexAt(x, y int) uint8\n\tImage\n}","type RGBA struct {\n\t// Pix holds the image's pixels, in R, G, B, A order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewRGBA(r Rectangle) *RGBA","type RGBA64 struct {\n\t// Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewRGBA64(r Rectangle) *RGBA64","type NRGBA struct {\n\t// Pix holds the image's pixels, in R, G, B, A order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewNRGBA(r Rectangle) *NRGBA","type NRGBA64 struct {\n\t// Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewNRGBA64(r Rectangle) *NRGBA64","type Alpha struct {\n\t// Pix holds the image's pixels, as alpha values. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewAlpha(r Rectangle) *Alpha","type Alpha16 struct {\n\t// Pix holds the image's pixels, as alpha values in big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewAlpha16(r Rectangle) *Alpha16","type Gray struct {\n\t// Pix holds the image's pixels, as gray values. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewGray(r Rectangle) *Gray","type Gray16 struct {\n\t// Pix holds the image's pixels, as gray values in big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewGray16(r Rectangle) *Gray16","type CMYK struct {\n\t// Pix holds the image's pixels, in C, M, Y, K order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n}","func NewCMYK(r Rectangle) *CMYK","type Paletted struct {\n\t// Pix holds the image's pixels, as palette indices. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix\t[]uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride\tint\n\t// Rect is the image's bounds.\n\tRect\tRectangle\n\t// Palette is the image's palette.\n\tPalette\tcolor.Palette\n}","func NewPaletted(r Rectangle, p color.Palette) *Paletted","","","","","type Uniform struct {\n\tC color.Color\n}","func NewUniform(c color.Color) *Uniform","","const YCbCrSubsampleRatio444 YCbCrSubsampleRatio","const YCbCrSubsampleRatio422","const YCbCrSubsampleRatio420","const YCbCrSubsampleRatio440","const YCbCrSubsampleRatio411","const YCbCrSubsampleRatio410","type YCbCr struct {\n\tY, Cb, Cr\t[]uint8\n\tYStride\t\tint\n\tCStride\t\tint\n\tSubsampleRatio\tYCbCrSubsampleRatio\n\tRect\t\tRectangle\n}","func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr","type NYCbCrA struct {\n\tYCbCr\n\tA\t[]uint8\n\tAStride\tint\n}","func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA","const SeekStart = 0","const SeekCurrent = 1","const SeekEnd = 2","","","","","","type Reader interface {\n\tRead(p []byte) (n int, err error)\n}","type Writer interface {\n\tWrite(p []byte) (n int, err error)\n}","type Closer interface {\n\tClose() error\n}","type Seeker interface {\n\tSeek(offset int64, whence int) (int64, error)\n}","type ReadWriter interface {\n\tReader\n\tWriter\n}","type ReadCloser interface {\n\tReader\n\tCloser\n}","type WriteCloser interface {\n\tWriter\n\tCloser\n}","type ReadWriteCloser interface {\n\tReader\n\tWriter\n\tCloser\n}","type ReadSeeker interface {\n\tReader\n\tSeeker\n}","type ReadSeekCloser interface {\n\tReader\n\tSeeker\n\tCloser\n}","type WriteSeeker interface {\n\tWriter\n\tSeeker\n}","type ReadWriteSeeker interface {\n\tReader\n\tWriter\n\tSeeker\n}","type ReaderFrom interface {\n\tReadFrom(r Reader) (n int64, err error)\n}","type WriterTo interface {\n\tWriteTo(w Writer) (n int64, err error)\n}","type ReaderAt interface {\n\tReadAt(p []byte, off int64) (n int, err error)\n}","type WriterAt interface {\n\tWriteAt(p []byte, off int64) (n int, err error)\n}","type ByteReader interface {\n\tReadByte() (byte, error)\n}","type ByteScanner interface {\n\tByteReader\n\tUnreadByte() error\n}","type ByteWriter interface {\n\tWriteByte(c byte) error\n}","type RuneReader interface {\n\tReadRune() (r rune, size int, err error)\n}","type RuneScanner interface {\n\tRuneReader\n\tUnreadRune() error\n}","type StringWriter interface {\n\tWriteString(s string) (n int, err error)\n}","func WriteString(w Writer, s string) (n int, err error)","func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)","func ReadFull(r Reader, buf []byte) (n int, err error)","func CopyN(dst Writer, src Reader, n int64) (written int64, err error)","func Copy(dst Writer, src Reader) (written int64, err error)","func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)","func LimitReader(r Reader, n int64) Reader","type LimitedReader struct {\n\tR\tReader\t// underlying reader\n\tN\tint64\t// max bytes remaining\n}","func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader","type SectionReader struct {\n\tr\tReaderAt\t// constant after creation\n\tbase\tint64\t\t// constant after creation\n\toff\tint64\n\tlimit\tint64\t// constant after creation\n\tn\tint64\t// constant after creation\n}","type OffsetWriter struct {\n\tw\tWriterAt\n\tbase\tint64\t// the original offset\n\toff\tint64\t// the current offset\n}","func NewOffsetWriter(w WriterAt, off int64) *OffsetWriter","func TeeReader(r Reader, w Writer) Reader","var Discard Writer","func NopCloser(r Reader) ReadCloser","func ReadAll(r Reader) ([]byte, error)","func MultiReader(readers ...Reader) Reader","func MultiWriter(writers ...Writer) Writer","","type PipeReader struct{ pipe }","type PipeWriter struct{ r PipeReader }","func Pipe() (*PipeReader, *PipeWriter)","type Seq[V any] func(yield func(V) bool)","type Seq2[K, V any] func(yield func(K, V) bool)","func Pull[V any](seq Seq[V]) (next func() (V, bool), stop func())","func Pull2[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())","","const Ltime","const Lmicroseconds","const Llongfile","const Lshortfile","const LUTC","const Lmsgprefix","","type Logger struct {\n\toutMu\tsync.Mutex\n\tout\tio.Writer\t// destination for output\n\n\tprefix\t\tatomic.Pointer[string]\t// prefix on each line to identify the logger (but see Lmsgprefix)\n\tflag\t\tatomic.Int32\t\t// properties\n\tisDiscard\tatomic.Bool\n}","func New(out io.Writer, prefix string, flag int) *Logger","func Default() *Logger","func SetOutput(w io.Writer)","func Flags() int","func SetFlags(flag int)","func Prefix() string","func SetPrefix(prefix string)","func Writer() io.Writer","func Print(v ...any)","func Printf(format string, v ...any)","func Println(v ...any)","func Fatal(v ...any)","func Fatalf(format string, v ...any)","func Fatalln(v ...any)","func Panic(v ...any)","func Panicf(format string, v ...any)","func Panicln(v ...any)","func Output(calldepth int, s string) error","func All[Map ~map[K]V, K comparable, V any](m Map) iter.Seq2[K, V]","func Keys[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[K]","func Values[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[V]","func Insert[Map ~map[K]V, K comparable, V any](m Map, seq iter.Seq2[K, V])","func Collect[K comparable, V any](seq iter.Seq2[K, V]) map[K]V","func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool","func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool","func Clone[M ~map[K]V, K comparable, V any](m M) M","func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)","func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)","func Abs(x float64) float64","func Acosh(x float64) float64","func Asin(x float64) float64","func Acos(x float64) float64","func Asinh(x float64) float64","func Atan(x float64) float64","func Atan2(y, x float64) float64","func Atanh(x float64) float64","func Inf(sign int) float64","func NaN() float64","func IsNaN(f float64) (is bool)","func IsInf(f float64, sign int) bool","func Cbrt(x float64) float64","const E = 2.71828182845904523536028747135266249775724709369995957496696763","const Pi = 3.14159265358979323846264338327950288419716939937510582097494459","const Phi = 1.61803398874989484820458683436563811772030917980576286213544862","const Sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974","const SqrtE = 1.64872127070012814684865078781416357165377610071014801157507931","const SqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779","const SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038","const Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009","","const Ln10 = 2.30258509299404568401799145468436420760110148862877297603332790","","","","","","","","","","","","","","","","","","","","","func Copysign(f, sign float64) float64","func Dim(x, y float64) float64","func Max(x, y float64) float64","func Min(x, y float64) float64","func Erf(x float64) float64","func Erfc(x float64) float64","func Erfinv(x float64) float64","func Erfcinv(x float64) float64","func Exp(x float64) float64","func Exp2(x float64) float64","func Expm1(x float64) float64","func Floor(x float64) float64","func Ceil(x float64) float64","func Trunc(x float64) float64","func Round(x float64) float64","func RoundToEven(x float64) float64","func FMA(x, y, z float64) float64","func Frexp(f float64) (frac float64, exp int)","func Gamma(x float64) float64","func Hypot(p, q float64) float64","func J0(x float64) float64","func Y0(x float64) float64","func J1(x float64) float64","func Y1(x float64) float64","func Jn(n int, x float64) float64","func Yn(n int, x float64) float64","func Ldexp(frac float64, exp int) float64","func Lgamma(x float64) (lgamma float64, sign int)","func Log(x float64) float64","func Log10(x float64) float64","func Log2(x float64) float64","func Log1p(x float64) float64","func Logb(x float64) float64","func Ilogb(x float64) int","func Mod(x, y float64) float64","func Modf(f float64) (int float64, frac float64)","func Nextafter32(x, y float32) (r float32)","func Nextafter(x, y float64) (r float64)","func Pow(x, y float64) float64","func Pow10(n int) float64","func Remainder(x, y float64) float64","func Signbit(x float64) bool","func Cos(x float64) float64","func Sin(x float64) float64","func Sincos(x float64) (sin, cos float64)","func Sinh(x float64) float64","func Cosh(x float64) float64","func Sqrt(x float64) float64","func Tan(x float64) float64","func Tanh(x float64) float64","func Float32bits(f float32) uint32","func Float32frombits(b uint32) float32","func Float64bits(f float64) uint64","func Float64frombits(b uint64) float64","","","","type WordDecoder struct {\n\t// CharsetReader, if non-nil, defines a function to generate\n\t// charset-conversion readers, converting from the provided\n\t// charset into UTF-8.\n\t// Charsets are always lower-case. utf-8, iso-8859-1 and us-ascii charsets\n\t// are handled by default.\n\t// One of the CharsetReader's result values must be non-nil.\n\tCharsetReader func(charset string, input io.Reader) (io.Reader, error)\n}","func FormatMediaType(t string, param map[string]string) string","","func ParseMediaType(v string) (mediatype string, params map[string]string, err error)","func TypeByExtension(ext string) string","func ExtensionsByType(typ string) ([]string, error)","func AddExtensionType(ext, typ string) error","type Dialer struct {\n\t// Timeout is the maximum amount of time a dial will wait for\n\t// a connect to complete. If Deadline is also set, it may fail\n\t// earlier.\n\t//\n\t// The default is no timeout.\n\t//\n\t// When using TCP and dialing a host name with multiple IP\n\t// addresses, the timeout may be divided between them.\n\t//\n\t// With or without a timeout, the operating system may impose\n\t// its own earlier timeout. For instance, TCP timeouts are\n\t// often around 3 minutes.\n\tTimeout\ttime.Duration\n\n\t// Deadline is the absolute point in time after which dials\n\t// will fail. If Timeout is set, it may fail earlier.\n\t// Zero means no deadline, or dependent on the operating system\n\t// as with the Timeout option.\n\tDeadline\ttime.Time\n\n\t// LocalAddr is the local address to use when dialing an\n\t// address. The address must be of a compatible type for the\n\t// network being dialed.\n\t// If nil, a local address is automatically chosen.\n\tLocalAddr\tAddr\n\n\t// DualStack previously enabled RFC 6555 Fast Fallback\n\t// support, also known as \"Happy Eyeballs\", in which IPv4 is\n\t// tried soon if IPv6 appears to be misconfigured and\n\t// hanging.\n\t//\n\t// Deprecated: Fast Fallback is enabled by default. To\n\t// disable, set FallbackDelay to a negative value.\n\tDualStack\tbool\n\n\t// FallbackDelay specifies the length of time to wait before\n\t// spawning a RFC 6555 Fast Fallback connection. That is, this\n\t// is the amount of time to wait for IPv6 to succeed before\n\t// assuming that IPv6 is misconfigured and falling back to\n\t// IPv4.\n\t//\n\t// If zero, a default delay of 300ms is used.\n\t// A negative value disables Fast Fallback support.\n\tFallbackDelay\ttime.Duration\n\n\t// KeepAlive specifies the interval between keep-alive\n\t// probes for an active network connection.\n\t//\n\t// KeepAlive is ignored if KeepAliveConfig.Enable is true.\n\t//\n\t// If zero, keep-alive probes are sent with a default value\n\t// (currently 15 seconds), if supported by the protocol and operating\n\t// system. Network protocols or operating systems that do\n\t// not support keep-alive ignore this field.\n\t// If negative, keep-alive probes are disabled.\n\tKeepAlive\ttime.Duration\n\n\t// KeepAliveConfig specifies the keep-alive probe configuration\n\t// for an active network connection, when supported by the\n\t// protocol and operating system.\n\t//\n\t// If KeepAliveConfig.Enable is true, keep-alive probes are enabled.\n\t// If KeepAliveConfig.Enable is false and KeepAlive is negative,\n\t// keep-alive probes are disabled.\n\tKeepAliveConfig\tKeepAliveConfig\n\n\t// Resolver optionally specifies an alternate resolver to use.\n\tResolver\t*Resolver\n\n\t// Cancel is an optional channel whose closure indicates that\n\t// the dial should be canceled. Not all types of dials support\n\t// cancellation.\n\t//\n\t// Deprecated: Use DialContext instead.\n\tCancel\t\u003c-chan struct{}\n\n\t// If Control is not nil, it is called after creating the network\n\t// connection but before actually dialing.\n\t//\n\t// Network and address parameters passed to Control function are not\n\t// necessarily the ones passed to Dial. For example, passing \"tcp\" to Dial\n\t// will cause the Control function to be called with \"tcp4\" or \"tcp6\".\n\t//\n\t// Control is ignored if ControlContext is not nil.\n\tControl\tfunc(network, address string, c syscall.RawConn) error\n\n\t// If ControlContext is not nil, it is called after creating the network\n\t// connection but before actually dialing.\n\t//\n\t// Network and address parameters passed to ControlContext function are not\n\t// necessarily the ones passed to Dial. For example, passing \"tcp\" to Dial\n\t// will cause the ControlContext function to be called with \"tcp4\" or \"tcp6\".\n\t//\n\t// If ControlContext is not nil, Control is ignored.\n\tControlContext\tfunc(ctx context.Context, network, address string, c syscall.RawConn) error\n\n\t// If mptcpStatus is set to a value allowing Multipath TCP (MPTCP) to be\n\t// used, any call to Dial with \"tcp(4|6)\" as network will use MPTCP if\n\t// supported by the operating system.\n\tmptcpStatus\tmptcpStatus\n}","func Dial(network, address string) (Conn, error)","func DialTimeout(network, address string, timeout time.Duration) (Conn, error)","type ListenConfig struct {\n\t// If Control is not nil, it is called after creating the network\n\t// connection but before binding it to the operating system.\n\t//\n\t// Network and address parameters passed to Control method are not\n\t// necessarily the ones passed to Listen. For example, passing \"tcp\" to\n\t// Listen will cause the Control function to be called with \"tcp4\" or \"tcp6\".\n\tControl\tfunc(network, address string, c syscall.RawConn) error\n\n\t// KeepAlive specifies the keep-alive period for network\n\t// connections accepted by this listener.\n\t//\n\t// KeepAlive is ignored if KeepAliveConfig.Enable is true.\n\t//\n\t// If zero, keep-alive are enabled if supported by the protocol\n\t// and operating system. Network protocols or operating systems\n\t// that do not support keep-alive ignore this field.\n\t// If negative, keep-alive are disabled.\n\tKeepAlive\ttime.Duration\n\n\t// KeepAliveConfig specifies the keep-alive probe configuration\n\t// for an active network connection, when supported by the\n\t// protocol and operating system.\n\t//\n\t// If KeepAliveConfig.Enable is true, keep-alive probes are enabled.\n\t// If KeepAliveConfig.Enable is false and KeepAlive is negative,\n\t// keep-alive probes are disabled.\n\tKeepAliveConfig\tKeepAliveConfig\n\n\t// If mptcpStatus is set to a value allowing Multipath TCP (MPTCP) to be\n\t// used, any call to Listen with \"tcp(4|6)\" as network will use MPTCP if\n\t// supported by the operating system.\n\tmptcpStatus\tmptcpStatus\n}","func Listen(network, address string) (Listener, error)","func ListenPacket(network, address string) (PacketConn, error)","type SRV struct {\n\tTarget\t\tstring\n\tPort\t\tuint16\n\tPriority\tuint16\n\tWeight\t\tuint16\n}","type MX struct {\n\tHost\tstring\n\tPref\tuint16\n}","type NS struct {\n\tHost string\n}","func FileConn(f *os.File) (c Conn, err error)","func FileListener(f *os.File) (ln Listener, err error)","func FilePacketConn(f *os.File) (c PacketConn, err error)","type Interface struct {\n\tIndex\t\tint\t\t// positive integer that starts at one, zero is never used\n\tMTU\t\tint\t\t// maximum transmission unit\n\tName\t\tstring\t\t// e.g., \"en0\", \"lo0\", \"eth0.100\"\n\tHardwareAddr\tHardwareAddr\t// IEEE MAC-48, EUI-48 and EUI-64 form\n\tFlags\t\tFlags\t\t// e.g., FlagUp, FlagLoopback, FlagMulticast\n}","","const FlagUp Flags","const FlagBroadcast","const FlagLoopback","const FlagPointToPoint","const FlagMulticast","const FlagRunning","func Interfaces() ([]Interface, error)","func InterfaceAddrs() ([]Addr, error)","func InterfaceByIndex(index int) (*Interface, error)","func InterfaceByName(name string) (*Interface, error)","const IPv4len = 4","const IPv6len = 16","type IP []byte","type IPMask []byte","type IPNet struct {\n\tIP\tIP\t// network number\n\tMask\tIPMask\t// network mask\n}","func IPv4(a, b, c, d byte) IP","func IPv4Mask(a, b, c, d byte) IPMask","func CIDRMask(ones, bits int) IPMask","","","","","","","","","","","func ParseIP(s string) IP","func ParseCIDR(s string) (IP, *IPNet, error)","type IPAddr struct {\n\tIP\tIP\n\tZone\tstring\t// IPv6 scoped addressing zone\n}","func ResolveIPAddr(network, address string) (*IPAddr, error)","type IPConn struct {\n\tconn\n}","func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)","func ListenIP(network string, laddr *IPAddr) (*IPConn, error)","func SplitHostPort(hostport string) (host, port string, err error)","func JoinHostPort(host, port string) string","","type Resolver struct {\n\t// PreferGo controls whether Go's built-in DNS resolver is preferred\n\t// on platforms where it's available. It is equivalent to setting\n\t// GODEBUG=netdns=go, but scoped to just this resolver.\n\tPreferGo\tbool\n\n\t// StrictErrors controls the behavior of temporary errors\n\t// (including timeout, socket errors, and SERVFAIL) when using\n\t// Go's built-in resolver. For a query composed of multiple\n\t// sub-queries (such as an A+AAAA address lookup, or walking the\n\t// DNS search list), this option causes such errors to abort the\n\t// whole query instead of returning a partial result. This is\n\t// not enabled by default because it may affect compatibility\n\t// with resolvers that process AAAA queries incorrectly.\n\tStrictErrors\tbool\n\n\t// Dial optionally specifies an alternate dialer for use by\n\t// Go's built-in DNS resolver to make TCP and UDP connections\n\t// to DNS services. The host in the address parameter will\n\t// always be a literal IP address and not a host name, and the\n\t// port in the address parameter will be a literal port number\n\t// and not a service name.\n\t// If the Conn returned is also a PacketConn, sent and received DNS\n\t// messages must adhere to RFC 1035 section 4.2.1, \"UDP usage\".\n\t// Otherwise, DNS messages transmitted over Conn must adhere\n\t// to RFC 7766 section 5, \"Transport Protocol Selection\".\n\t// If nil, the default dialer is used.\n\tDial\tfunc(ctx context.Context, network, address string) (Conn, error)\n\n\t// lookupGroup merges LookupIPAddr calls together for lookups for the same\n\t// host. The lookupGroup key is the LookupIPAddr.host argument.\n\t// The return values are ([]IPAddr, error).\n\tlookupGroup\tsingleflight.Group\n}","func LookupHost(host string) (addrs []string, err error)","func LookupIP(host string) ([]IP, error)","func LookupPort(network, service string) (port int, err error)","func LookupCNAME(host string) (cname string, err error)","func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)","func LookupMX(name string) ([]*MX, error)","func LookupNS(name string) ([]*NS, error)","func LookupTXT(name string) ([]string, error)","func LookupAddr(addr string) (names []string, err error)","type HardwareAddr []byte","func ParseMAC(s string) (hw HardwareAddr, err error)","type Addr interface {\n\tNetwork() string\t// name of the network (for example, \"tcp\", \"udp\")\n\tString() string\t\t// string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\")\n}","type Conn interface {\n\t// Read reads data from the connection.\n\t// Read can be made to time out and return an error after a fixed\n\t// time limit; see SetDeadline and SetReadDeadline.\n\tRead(b []byte) (n int, err error)\n\n\t// Write writes data to the connection.\n\t// Write can be made to time out and return an error after a fixed\n\t// time limit; see SetDeadline and SetWriteDeadline.\n\tWrite(b []byte) (n int, err error)\n\n\t// Close closes the connection.\n\t// Any blocked Read or Write operations will be unblocked and return errors.\n\tClose() error\n\n\t// LocalAddr returns the local network address, if known.\n\tLocalAddr() Addr\n\n\t// RemoteAddr returns the remote network address, if known.\n\tRemoteAddr() Addr\n\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\t//\n\t// A deadline is an absolute time after which I/O operations\n\t// fail instead of blocking. The deadline applies to all future\n\t// and pending I/O, not just the immediately following call to\n\t// Read or Write. After a deadline has been exceeded, the\n\t// connection can be refreshed by setting a deadline in the future.\n\t//\n\t// If the deadline is exceeded a call to Read or Write or to other\n\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\n\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\n\t// The error's Timeout method will return true, but note that there\n\t// are other possible errors for which the Timeout method will\n\t// return true even if the deadline has not been exceeded.\n\t//\n\t// An idle timeout can be implemented by repeatedly extending\n\t// the deadline after successful Read or Write calls.\n\t//\n\t// A zero value for t means I/O operations will not time out.\n\tSetDeadline(t time.Time) error\n\n\t// SetReadDeadline sets the deadline for future Read calls\n\t// and any currently-blocked Read call.\n\t// A zero value for t means Read will not time out.\n\tSetReadDeadline(t time.Time) error\n\n\t// SetWriteDeadline sets the deadline for future Write calls\n\t// and any currently-blocked Write call.\n\t// Even if write times out, it may return n \u003e 0, indicating that\n\t// some of the data was successfully written.\n\t// A zero value for t means Write will not time out.\n\tSetWriteDeadline(t time.Time) error\n}","type PacketConn interface {\n\t// ReadFrom reads a packet from the connection,\n\t// copying the payload into p. It returns the number of\n\t// bytes copied into p and the return address that\n\t// was on the packet.\n\t// It returns the number of bytes read (0 \u003c= n \u003c= len(p))\n\t// and any error encountered. Callers should always process\n\t// the n \u003e 0 bytes returned before considering the error err.\n\t// ReadFrom can be made to time out and return an error after a\n\t// fixed time limit; see SetDeadline and SetReadDeadline.\n\tReadFrom(p []byte) (n int, addr Addr, err error)\n\n\t// WriteTo writes a packet with payload p to addr.\n\t// WriteTo can be made to time out and return an Error after a\n\t// fixed time limit; see SetDeadline and SetWriteDeadline.\n\t// On packet-oriented connections, write timeouts are rare.\n\tWriteTo(p []byte, addr Addr) (n int, err error)\n\n\t// Close closes the connection.\n\t// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n\tClose() error\n\n\t// LocalAddr returns the local network address, if known.\n\tLocalAddr() Addr\n\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\t//\n\t// A deadline is an absolute time after which I/O operations\n\t// fail instead of blocking. The deadline applies to all future\n\t// and pending I/O, not just the immediately following call to\n\t// Read or Write. After a deadline has been exceeded, the\n\t// connection can be refreshed by setting a deadline in the future.\n\t//\n\t// If the deadline is exceeded a call to Read or Write or to other\n\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\n\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\n\t// The error's Timeout method will return true, but note that there\n\t// are other possible errors for which the Timeout method will\n\t// return true even if the deadline has not been exceeded.\n\t//\n\t// An idle timeout can be implemented by repeatedly extending\n\t// the deadline after successful ReadFrom or WriteTo calls.\n\t//\n\t// A zero value for t means I/O operations will not time out.\n\tSetDeadline(t time.Time) error\n\n\t// SetReadDeadline sets the deadline for future ReadFrom calls\n\t// and any currently-blocked ReadFrom call.\n\t// A zero value for t means ReadFrom will not time out.\n\tSetReadDeadline(t time.Time) error\n\n\t// SetWriteDeadline sets the deadline for future WriteTo calls\n\t// and any currently-blocked WriteTo call.\n\t// Even if write times out, it may return n \u003e 0, indicating that\n\t// some of the data was successfully written.\n\t// A zero value for t means WriteTo will not time out.\n\tSetWriteDeadline(t time.Time) error\n}","type Listener interface {\n\t// Accept waits for and returns the next connection to the listener.\n\tAccept() (Conn, error)\n\n\t// Close closes the listener.\n\t// Any blocked Accept operations will be unblocked and return errors.\n\tClose() error\n\n\t// Addr returns the listener's network address.\n\tAddr() Addr\n}","type Error interface {\n\terror\n\tTimeout() bool\t// Is the error a timeout?\n\n\t// Deprecated: Temporary errors are not well-defined.\n\t// Most \"temporary\" errors are timeouts, and the few exceptions are surprising.\n\t// Do not use this method.\n\tTemporary() bool\n}","","type OpError struct {\n\t// Op is the operation which caused the error, such as\n\t// \"read\" or \"write\".\n\tOp\tstring\n\n\t// Net is the network type on which this error occurred,\n\t// such as \"tcp\" or \"udp6\".\n\tNet\tstring\n\n\t// For operations involving a remote network connection, like\n\t// Dial, Read, or Write, Source is the corresponding local\n\t// network address.\n\tSource\tAddr\n\n\t// Addr is the network address for which this error occurred.\n\t// For local operations, like Listen or SetDeadline, Addr is\n\t// the address of the local endpoint being manipulated.\n\t// For operations involving a remote network connection, like\n\t// Dial, Read, or Write, Addr is the remote address of that\n\t// connection.\n\tAddr\tAddr\n\n\t// Err is the error that occurred during the operation.\n\t// The Error method panics if the error is nil.\n\tErr\terror\n}","type ParseError struct {\n\t// Type is the type of string that was expected, such as\n\t// \"IP address\", \"CIDR address\".\n\tType\tstring\n\n\t// Text is the malformed text string.\n\tText\tstring\n}","type AddrError struct {\n\tErr\tstring\n\tAddr\tstring\n}","","","type DNSConfigError struct {\n\tErr error\n}","type DNSError struct {\n\tUnwrapErr\terror\t// error returned by the [DNSError.Unwrap] method, might be nil\n\tErr\t\tstring\t// description of the error\n\tName\t\tstring\t// name looked for\n\tServer\t\tstring\t// server used\n\tIsTimeout\tbool\t// if true, timed out; not all timeouts set this\n\tIsTemporary\tbool\t// if true, error is temporary; not all errors set this\n\n\t// IsNotFound is set to true when the requested name does not\n\t// contain any records of the requested type (data not found),\n\t// or the name itself was not found (NXDOMAIN).\n\tIsNotFound\tbool\n}","var ErrClosed error","type Buffers [][]byte","func Pipe() (Conn, Conn)","type TCPAddr struct {\n\tIP\tIP\n\tPort\tint\n\tZone\tstring\t// IPv6 scoped addressing zone\n}","func ResolveTCPAddr(network, address string) (*TCPAddr, error)","func TCPAddrFromAddrPort(addr netip.AddrPort) *TCPAddr","type TCPConn struct {\n\tconn\n}","type KeepAliveConfig struct {\n\t// If Enable is true, keep-alive probes are enabled.\n\tEnable\tbool\n\n\t// Idle is the time that the connection must be idle before\n\t// the first keep-alive probe is sent.\n\t// If zero, a default value of 15 seconds is used.\n\tIdle\ttime.Duration\n\n\t// Interval is the time between keep-alive probes.\n\t// If zero, a default value of 15 seconds is used.\n\tInterval\ttime.Duration\n\n\t// Count is the maximum number of keep-alive probes that\n\t// can go unanswered before dropping a connection.\n\t// If zero, a default value of 9 is used.\n\tCount\tint\n}","func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)","type TCPListener struct {\n\tfd\t*netFD\n\tlc\tListenConfig\n}","func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)","type UDPAddr struct {\n\tIP\tIP\n\tPort\tint\n\tZone\tstring\t// IPv6 scoped addressing zone\n}","func ResolveUDPAddr(network, address string) (*UDPAddr, error)","func UDPAddrFromAddrPort(addr netip.AddrPort) *UDPAddr","type UDPConn struct {\n\tconn\n}","func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)","func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)","func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)","type UnixAddr struct {\n\tName\tstring\n\tNet\tstring\n}","func ResolveUnixAddr(network, address string) (*UnixAddr, error)","type UnixConn struct {\n\tconn\n}","func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)","type UnixListener struct {\n\tfd\t\t*netFD\n\tpath\t\tstring\n\tunlink\t\tbool\n\tunlinkOnce\tsync.Once\n}","func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)","func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)","type DirEntry = fs.DirEntry","func ReadDir(name string) ([]DirEntry, error)","func CopyFS(dir string, fsys fs.FS) error","func Expand(s string, mapping func(string) string) string","func ExpandEnv(s string) string","func Getenv(key string) string","func LookupEnv(key string) (string, bool)","func Setenv(key, value string) error","func Unsetenv(key string) error","func Clearenv()","func Environ() []string","","","","","","","","type PathError = fs.PathError","type SyscallError struct {\n\tSyscall\tstring\n\tErr\terror\n}","func NewSyscallError(syscall string, err error) error","func IsExist(err error) bool","func IsNotExist(err error) bool","func IsPermission(err error) bool","func IsTimeout(err error) bool","","type Process struct {\n\tPid\tint\n\n\tmode\tprocessMode\n\n\t// State contains the atomic process state.\n\t//\n\t// In modePID, this consists only of the processStatus fields, which\n\t// indicate if the process is done/released.\n\t//\n\t// In modeHandle, the lower bits also contain a reference count for the\n\t// handle field.\n\t//\n\t// The Process itself initially holds 1 persistent reference. Any\n\t// operation that uses the handle with a system call temporarily holds\n\t// an additional transient reference. This prevents the handle from\n\t// being closed prematurely, which could result in the OS allocating a\n\t// different handle with the same value, leading to Process' methods\n\t// operating on the wrong process.\n\t//\n\t// Release and Wait both drop the Process' persistent reference, but\n\t// other concurrent references may delay actually closing the handle\n\t// because they hold a transient reference.\n\t//\n\t// Regardless, we want new method calls to immediately treat the handle\n\t// as unavailable after Release or Wait to avoid extending this delay.\n\t// This is achieved by setting either processStatus flag when the\n\t// Process' persistent reference is dropped. The only difference in the\n\t// flags is the reason the handle is unavailable, which affects the\n\t// errors returned by concurrent calls.\n\tstate\tatomic.Uint64\n\n\t// Used only in modePID.\n\tsigMu\tsync.RWMutex\t// avoid race between wait and signal\n\n\t// handle is the OS handle for process actions, used only in\n\t// modeHandle.\n\t//\n\t// handle must be accessed only via the handleTransientAcquire method\n\t// (or during closeHandle), not directly! handle is immutable.\n\t//\n\t// On Windows, it is a handle from OpenProcess.\n\t// On Linux, it is a pidfd.\n\t// It is unused on other GOOSes.\n\thandle\tuintptr\n}","type ProcAttr struct {\n\t// If Dir is non-empty, the child changes into the directory before\n\t// creating the process.\n\tDir\tstring\n\t// If Env is non-nil, it gives the environment variables for the\n\t// new process in the form returned by Environ.\n\t// If it is nil, the result of Environ will be used.\n\tEnv\t[]string\n\t// Files specifies the open files inherited by the new process. The\n\t// first three entries correspond to standard input, standard output, and\n\t// standard error. An implementation may support additional entries,\n\t// depending on the underlying operating system. A nil entry corresponds\n\t// to that file being closed when the process starts.\n\t// On Unix systems, StartProcess will change these File values\n\t// to blocking mode, which means that SetDeadline will stop working\n\t// and calling Close will not interrupt a Read or Write.\n\tFiles\t[]*File\n\n\t// Operating system-specific process creation attributes.\n\t// Note that setting this field means that your program\n\t// may not execute properly or even compile on some\n\t// operating systems.\n\tSys\t*syscall.SysProcAttr\n}","type Signal interface {\n\tString() string\n\tSignal()\t// to distinguish from other Stringers\n}","func Getpid() int","func Getppid() int","func FindProcess(pid int) (*Process, error)","func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)","var Interrupt Signal","var Kill Signal","type ProcessState struct {\n\tpid\tint\t\t\t// The process's id.\n\tstatus\tsyscall.WaitStatus\t// System-dependent status info.\n\trusage\t*syscall.Rusage\n}","func Executable() (string, error)","","","","const O_RDONLY int","const O_WRONLY int","const O_RDWR int","const O_APPEND int","const O_CREATE int","const O_EXCL int","const O_SYNC int","const O_TRUNC int","const SEEK_SET int = 0","const SEEK_CUR int = 1","const SEEK_END int = 2","type LinkError struct {\n\tOp\tstring\n\tOld\tstring\n\tNew\tstring\n\tErr\terror\n}","func Mkdir(name string, perm FileMode) error","func Chdir(dir string) error","func Open(name string) (*File, error)","func Create(name string) (*File, error)","func OpenFile(name string, flag int, perm FileMode) (*File, error)","func Rename(oldpath, newpath string) error","func Readlink(name string) (string, error)","func TempDir() string","func UserCacheDir() (string, error)","func UserConfigDir() (string, error)","func UserHomeDir() (string, error)","func Chmod(name string, mode FileMode) error","func DirFS(dir string) fs.FS","func ReadFile(name string) ([]byte, error)","func WriteFile(name string, data []byte, perm FileMode) error","func Chown(name string, uid, gid int) error","func Lchown(name string, uid, gid int) error","func Chtimes(name string, atime time.Time, mtime time.Time) error","func NewFile(fd uintptr, name string) *File","const DevNull = \"/dev/null\"","func Truncate(name string, size int64) error","func Remove(name string) error","func Link(oldname, newname string) error","func Symlink(oldname, newname string) error","func Getwd() (dir string, err error)","func MkdirAll(path string, perm FileMode) error","func RemoveAll(path string) error","const PathSeparator = '/'","const PathListSeparator = ':'","func IsPathSeparator(c uint8) bool","func Pipe() (r *File, w *File, err error)","var Args []string","func Getuid() int","func Geteuid() int","func Getgid() int","func Getegid() int","func Getgroups() ([]int, error)","func Exit(code int)","func Stat(name string) (FileInfo, error)","func Lstat(name string) (FileInfo, error)","func Hostname() (name string, err error)","func CreateTemp(dir, pattern string) (*File, error)","func MkdirTemp(dir, pattern string) (string, error)","func Getpagesize() int","type File struct {\n\t*file\t// os specific\n}","type FileInfo = fs.FileInfo","type FileMode = fs.FileMode","","","","","","","","","","","","","","","","func SameFile(fi1, fi2 FileInfo) bool","","func Match(pattern, name string) (matched bool, err error)","func Clean(path string) string","func Split(path string) (dir, file string)","func Join(elem ...string) string","func Ext(path string) string","func Base(path string) string","func IsAbs(path string) bool","func Dir(path string) string","type Plugin struct {\n\tpluginpath\tstring\n\terr\t\tstring\t\t// set if plugin failed to load\n\tloaded\t\tchan struct{}\t// closed when loaded\n\tsyms\t\tmap[string]any\n}","func Open(path string) (*Plugin, error)","","func DeepEqual(x, y any) bool","func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value","func Swapper(slice any) func(i, j int)","type Type interface {\n\n\t// Align returns the alignment in bytes of a value of\n\t// this type when allocated in memory.\n\tAlign() int\n\n\t// FieldAlign returns the alignment in bytes of a value of\n\t// this type when used as a field in a struct.\n\tFieldAlign() int\n\n\t// Method returns the i'th method in the type's method set.\n\t// It panics if i is not in the range [0, NumMethod()).\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver,\n\t// and only exported methods are accessible.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\t//\n\t// Methods are sorted in lexicographic order.\n\tMethod(int) Method\n\n\t// MethodByName returns the method with that name in the type's\n\t// method set and a boolean indicating if the method was found.\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\tMethodByName(string) (Method, bool)\n\n\t// NumMethod returns the number of methods accessible using Method.\n\t//\n\t// For a non-interface type, it returns the number of exported methods.\n\t//\n\t// For an interface type, it returns the number of exported and unexported methods.\n\tNumMethod() int\n\n\t// Name returns the type's name within its package for a defined type.\n\t// For other (non-defined) types it returns the empty string.\n\tName() string\n\n\t// PkgPath returns a defined type's package path, that is, the import path\n\t// that uniquely identifies the package, such as \"encoding/base64\".\n\t// If the type was predeclared (string, error) or not defined (*T, struct{},\n\t// []int, or A where A is an alias for a non-defined type), the package path\n\t// will be the empty string.\n\tPkgPath() string\n\n\t// Size returns the number of bytes needed to store\n\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\tSize() uintptr\n\n\t// String returns a string representation of the type.\n\t// The string representation may use shortened package names\n\t// (e.g., base64 instead of \"encoding/base64\") and is not\n\t// guaranteed to be unique among types. To test for type identity,\n\t// compare the Types directly.\n\tString() string\n\n\t// Kind returns the specific kind of this type.\n\tKind() Kind\n\n\t// Implements reports whether the type implements the interface type u.\n\tImplements(u Type) bool\n\n\t// AssignableTo reports whether a value of the type is assignable to type u.\n\tAssignableTo(u Type) bool\n\n\t// ConvertibleTo reports whether a value of the type is convertible to type u.\n\t// Even if ConvertibleTo returns true, the conversion may still panic.\n\t// For example, a slice of type []T is convertible to *[N]T,\n\t// but the conversion will panic if its length is less than N.\n\tConvertibleTo(u Type) bool\n\n\t// Comparable reports whether values of this type are comparable.\n\t// Even if Comparable returns true, the comparison may still panic.\n\t// For example, values of interface type are comparable,\n\t// but the comparison will panic if their dynamic type is not comparable.\n\tComparable() bool\n\n\t// Bits returns the size of the type in bits.\n\t// It panics if the type's Kind is not one of the\n\t// sized or unsized Int, Uint, Float, or Complex kinds.\n\tBits() int\n\n\t// ChanDir returns a channel type's direction.\n\t// It panics if the type's Kind is not Chan.\n\tChanDir() ChanDir\n\n\t// IsVariadic reports whether a function type's final input parameter\n\t// is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's\n\t// implicit actual type []T.\n\t//\n\t// For concreteness, if t represents func(x int, y ... float64), then\n\t//\n\t//\tt.NumIn() == 2\n\t//\tt.In(0) is the reflect.Type for \"int\"\n\t//\tt.In(1) is the reflect.Type for \"[]float64\"\n\t//\tt.IsVariadic() == true\n\t//\n\t// IsVariadic panics if the type's Kind is not Func.\n\tIsVariadic() bool\n\n\t// Elem returns a type's element type.\n\t// It panics if the type's Kind is not Array, Chan, Map, Pointer, or Slice.\n\tElem() Type\n\n\t// Field returns a struct type's i'th field.\n\t// It panics if the type's Kind is not Struct.\n\t// It panics if i is not in the range [0, NumField()).\n\tField(i int) StructField\n\n\t// FieldByIndex returns the nested field corresponding\n\t// to the index sequence. It is equivalent to calling Field\n\t// successively for each index i.\n\t// It panics if the type's Kind is not Struct.\n\tFieldByIndex(index []int) StructField\n\n\t// FieldByName returns the struct field with the given name\n\t// and a boolean indicating if the field was found.\n\t// If the returned field is promoted from an embedded struct,\n\t// then Offset in the returned StructField is the offset in\n\t// the embedded struct.\n\tFieldByName(name string) (StructField, bool)\n\n\t// FieldByNameFunc returns the struct field with a name\n\t// that satisfies the match function and a boolean indicating if\n\t// the field was found.\n\t//\n\t// FieldByNameFunc considers the fields in the struct itself\n\t// and then the fields in any embedded structs, in breadth first order,\n\t// stopping at the shallowest nesting depth containing one or more\n\t// fields satisfying the match function. If multiple fields at that depth\n\t// satisfy the match function, they cancel each other\n\t// and FieldByNameFunc returns no match.\n\t// This behavior mirrors Go's handling of name lookup in\n\t// structs containing embedded fields.\n\t//\n\t// If the returned field is promoted from an embedded struct,\n\t// then Offset in the returned StructField is the offset in\n\t// the embedded struct.\n\tFieldByNameFunc(match func(string) bool) (StructField, bool)\n\n\t// In returns the type of a function type's i'th input parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumIn()).\n\tIn(i int) Type\n\n\t// Key returns a map type's key type.\n\t// It panics if the type's Kind is not Map.\n\tKey() Type\n\n\t// Len returns an array type's length.\n\t// It panics if the type's Kind is not Array.\n\tLen() int\n\n\t// NumField returns a struct type's field count.\n\t// It panics if the type's Kind is not Struct.\n\tNumField() int\n\n\t// NumIn returns a function type's input parameter count.\n\t// It panics if the type's Kind is not Func.\n\tNumIn() int\n\n\t// NumOut returns a function type's output parameter count.\n\t// It panics if the type's Kind is not Func.\n\tNumOut() int\n\n\t// Out returns the type of a function type's i'th output parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumOut()).\n\tOut(i int) Type\n\n\t// OverflowComplex reports whether the complex128 x cannot be represented by type t.\n\t// It panics if t's Kind is not Complex64 or Complex128.\n\tOverflowComplex(x complex128) bool\n\n\t// OverflowFloat reports whether the float64 x cannot be represented by type t.\n\t// It panics if t's Kind is not Float32 or Float64.\n\tOverflowFloat(x float64) bool\n\n\t// OverflowInt reports whether the int64 x cannot be represented by type t.\n\t// It panics if t's Kind is not Int, Int8, Int16, Int32, or Int64.\n\tOverflowInt(x int64) bool\n\n\t// OverflowUint reports whether the uint64 x cannot be represented by type t.\n\t// It panics if t's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.\n\tOverflowUint(x uint64) bool\n\n\t// CanSeq reports whether a [Value] with this type can be iterated over using [Value.Seq].\n\tCanSeq() bool\n\n\t// CanSeq2 reports whether a [Value] with this type can be iterated over using [Value.Seq2].\n\tCanSeq2() bool\n\n\tcommon() *abi.Type\n\tuncommon() *uncommonType\n}","","const Invalid Kind","const Bool","const Int","const Int8","const Int16","const Int32","const Int64","const Uint","const Uint8","const Uint16","const Uint32","const Uint64","const Uintptr","const Float32","const Float64","const Complex64","const Complex128","const Array","const Chan","const Func","const Interface","const Map","const Pointer","const Slice","const String","const Struct","const UnsafePointer","","","const RecvDir ChanDir","const SendDir","","type Method struct {\n\t// Name is the method name.\n\tName\tstring\n\n\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t// method name. It is empty for upper case (exported) method names.\n\t// The combination of PkgPath and Name uniquely identifies a method\n\t// in a method set.\n\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\tPkgPath\tstring\n\n\tType\tType\t// method type\n\tFunc\tValue\t// func with receiver as first argument\n\tIndex\tint\t// index for Type.Method\n}","type StructField struct {\n\t// Name is the field name.\n\tName\tstring\n\n\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t// field name. It is empty for upper case (exported) field names.\n\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\tPkgPath\tstring\n\n\tType\t\tType\t\t// field type\n\tTag\t\tStructTag\t// field tag string\n\tOffset\t\tuintptr\t\t// offset within struct, in bytes\n\tIndex\t\t[]int\t\t// index sequence for Type.FieldByIndex\n\tAnonymous\tbool\t\t// is an embedded field\n}","","func TypeOf(i any) Type","func PtrTo(t Type) Type","func PointerTo(t Type) Type","func ChanOf(dir ChanDir, t Type) Type","func MapOf(key, elem Type) Type","func FuncOf(in, out []Type, variadic bool) Type","func SliceOf(t Type) Type","func StructOf(fields []StructField) Type","func ArrayOf(length int, elem Type) Type","func TypeFor[T any]() Type","type Value struct {\n\t// typ_ holds the type of the value represented by a Value.\n\t// Access using the typ method to avoid escape of v.\n\ttyp_\t*abi.Type\n\n\t// Pointer-valued data or, if flagIndir is set, pointer to data.\n\t// Valid when either flagIndir is set or typ.pointers() is true.\n\tptr\tunsafe.Pointer\n\n\t// flag holds metadata about the value.\n\t//\n\t// The lowest five bits give the Kind of the value, mirroring typ.Kind().\n\t//\n\t// The next set of bits are flag bits:\n\t//\t- flagStickyRO: obtained via unexported not embedded field, so read-only\n\t//\t- flagEmbedRO: obtained via unexported embedded field, so read-only\n\t//\t- flagIndir: val holds a pointer to the data\n\t//\t- flagAddr: v.CanAddr is true (implies flagIndir and ptr is non-nil)\n\t//\t- flagMethod: v is a method value.\n\t// If ifaceIndir(typ), code can assume that flagIndir is set.\n\t//\n\t// The remaining 22+ bits give a method number for method values.\n\t// If flag.kind() != Func, code can assume that flagMethod is unset.\n\tflag\n}","type ValueError struct {\n\tMethod\tstring\n\tKind\tKind\n}","type MapIter struct {\n\tm\tValue\n\thiter\thiter\n}","type StringHeader struct {\n\tData\tuintptr\n\tLen\tint\n}","type SliceHeader struct {\n\tData\tuintptr\n\tLen\tint\n\tCap\tint\n}","func Append(s Value, x ...Value) Value","func AppendSlice(s, t Value) Value","func Copy(dst, src Value) int","","const SelectSend","const SelectRecv","const SelectDefault","type SelectCase struct {\n\tDir\tSelectDir\t// direction of case\n\tChan\tValue\t\t// channel to use (for send or receive)\n\tSend\tValue\t\t// value to send (for send)\n}","func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)","func MakeSlice(typ Type, len, cap int) Value","func SliceAt(typ Type, p unsafe.Pointer, n int) Value","func MakeChan(typ Type, buffer int) Value","func MakeMap(typ Type) Value","func MakeMapWithSize(typ Type, n int) Value","func Indirect(v Value) Value","func ValueOf(i any) Value","func Zero(typ Type) Value","func New(typ Type) Value","func NewAt(typ Type, p unsafe.Pointer) Value","func VisibleFields(t Type) []StructField","type Regexp struct {\n\texpr\t\tstring\t\t// as passed to Compile\n\tprog\t\t*syntax.Prog\t// compiled program\n\tonepass\t\t*onePassProg\t// onepass program or nil\n\tnumSubexp\tint\n\tmaxBitStateLen\tint\n\tsubexpNames\t[]string\n\tprefix\t\tstring\t\t// required prefix in unanchored matches\n\tprefixBytes\t[]byte\t\t// prefix, as a []byte\n\tprefixRune\trune\t\t// first rune in prefix\n\tprefixEnd\tuint32\t\t// pc for last rune in prefix\n\tmpool\t\tint\t\t// pool for machines\n\tmatchcap\tint\t\t// size of recorded match lengths\n\tprefixComplete\tbool\t\t// prefix is the entire regexp\n\tcond\t\tsyntax.EmptyOp\t// empty-width conditions required at start of match\n\tminInputLen\tint\t\t// minimum length of the input in bytes\n\n\t// This field can be modified by the Longest method,\n\t// but it is otherwise read-only.\n\tlongest\tbool\t// whether regexp prefers leftmost-longest match\n}","func Compile(expr string) (*Regexp, error)","func CompilePOSIX(expr string) (*Regexp, error)","func MustCompile(str string) *Regexp","func MustCompilePOSIX(str string) *Regexp","func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)","func MatchString(pattern string, s string) (matched bool, err error)","func Match(pattern string, b []byte) (matched bool, err error)","func QuoteMeta(s string) string","const Compiler = \"gc\"","func SetCPUProfileRate(hz int)","func CPUProfile() []byte","func GOMAXPROCS(n int) int","func NumCPU() int","func NumCgoCall() int64","func NumGoroutine() int","type Error interface {\n\terror\n\n\t// RuntimeError is a no-op function but\n\t// serves to distinguish types that are run time\n\t// errors from ordinary errors: a type is a\n\t// run time error if it has a RuntimeError method.\n\tRuntimeError()\n}","type TypeAssertionError struct {\n\t_interface\t*_type\n\tconcrete\t*_type\n\tasserted\t*_type\n\tmissingMethod\tstring\t// one method needed by Interface, missing from Concrete\n}","func Caller(skip int) (pc uintptr, file string, line int, ok bool)","func Callers(skip int, pc []uintptr) int","func GOROOT() string","func Version() string","const GOOS string","const GOARCH string","func SetFinalizer(obj any, finalizer any)","func KeepAlive(x any)","func GC()","func SetBlockProfileRate(rate int)","func SetMutexProfileFraction(rate int) int","type StackRecord struct {\n\tStack0 [32]uintptr\t// stack trace for this record; ends at first 0 entry\n}","var MemProfileRate int","type MemProfileRecord struct {\n\tAllocBytes, FreeBytes\t\tint64\t\t// number of bytes allocated, freed\n\tAllocObjects, FreeObjects\tint64\t\t// number of objects allocated, freed\n\tStack0\t\t\t\t[32]uintptr\t// stack trace for this record; ends at first 0 entry\n}","func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)","type BlockProfileRecord struct {\n\tCount\tint64\n\tCycles\tint64\n\tStackRecord\n}","func BlockProfile(p []BlockProfileRecord) (n int, ok bool)","func MutexProfile(p []BlockProfileRecord) (n int, ok bool)","func ThreadCreateProfile(p []StackRecord) (n int, ok bool)","func GoroutineProfile(p []StackRecord) (n int, ok bool)","func Stack(buf []byte, all bool) int","type MemStats struct {\n\n\t// Alloc is bytes of allocated heap objects.\n\t//\n\t// This is the same as HeapAlloc (see below).\n\tAlloc\tuint64\n\n\t// TotalAlloc is cumulative bytes allocated for heap objects.\n\t//\n\t// TotalAlloc increases as heap objects are allocated, but\n\t// unlike Alloc and HeapAlloc, it does not decrease when\n\t// objects are freed.\n\tTotalAlloc\tuint64\n\n\t// Sys is the total bytes of memory obtained from the OS.\n\t//\n\t// Sys is the sum of the XSys fields below. Sys measures the\n\t// virtual address space reserved by the Go runtime for the\n\t// heap, stacks, and other internal data structures. It's\n\t// likely that not all of the virtual address space is backed\n\t// by physical memory at any given moment, though in general\n\t// it all was at some point.\n\tSys\tuint64\n\n\t// Lookups is the number of pointer lookups performed by the\n\t// runtime.\n\t//\n\t// This is primarily useful for debugging runtime internals.\n\tLookups\tuint64\n\n\t// Mallocs is the cumulative count of heap objects allocated.\n\t// The number of live objects is Mallocs - Frees.\n\tMallocs\tuint64\n\n\t// Frees is the cumulative count of heap objects freed.\n\tFrees\tuint64\n\n\t// HeapAlloc is bytes of allocated heap objects.\n\t//\n\t// \"Allocated\" heap objects include all reachable objects, as\n\t// well as unreachable objects that the garbage collector has\n\t// not yet freed. Specifically, HeapAlloc increases as heap\n\t// objects are allocated and decreases as the heap is swept\n\t// and unreachable objects are freed. Sweeping occurs\n\t// incrementally between GC cycles, so these two processes\n\t// occur simultaneously, and as a result HeapAlloc tends to\n\t// change smoothly (in contrast with the sawtooth that is\n\t// typical of stop-the-world garbage collectors).\n\tHeapAlloc\tuint64\n\n\t// HeapSys is bytes of heap memory obtained from the OS.\n\t//\n\t// HeapSys measures the amount of virtual address space\n\t// reserved for the heap. This includes virtual address space\n\t// that has been reserved but not yet used, which consumes no\n\t// physical memory, but tends to be small, as well as virtual\n\t// address space for which the physical memory has been\n\t// returned to the OS after it became unused (see HeapReleased\n\t// for a measure of the latter).\n\t//\n\t// HeapSys estimates the largest size the heap has had.\n\tHeapSys\tuint64\n\n\t// HeapIdle is bytes in idle (unused) spans.\n\t//\n\t// Idle spans have no objects in them. These spans could be\n\t// (and may already have been) returned to the OS, or they can\n\t// be reused for heap allocations, or they can be reused as\n\t// stack memory.\n\t//\n\t// HeapIdle minus HeapReleased estimates the amount of memory\n\t// that could be returned to the OS, but is being retained by\n\t// the runtime so it can grow the heap without requesting more\n\t// memory from the OS. If this difference is significantly\n\t// larger than the heap size, it indicates there was a recent\n\t// transient spike in live heap size.\n\tHeapIdle\tuint64\n\n\t// HeapInuse is bytes in in-use spans.\n\t//\n\t// In-use spans have at least one object in them. These spans\n\t// can only be used for other objects of roughly the same\n\t// size.\n\t//\n\t// HeapInuse minus HeapAlloc estimates the amount of memory\n\t// that has been dedicated to particular size classes, but is\n\t// not currently being used. This is an upper bound on\n\t// fragmentation, but in general this memory can be reused\n\t// efficiently.\n\tHeapInuse\tuint64\n\n\t// HeapReleased is bytes of physical memory returned to the OS.\n\t//\n\t// This counts heap memory from idle spans that was returned\n\t// to the OS and has not yet been reacquired for the heap.\n\tHeapReleased\tuint64\n\n\t// HeapObjects is the number of allocated heap objects.\n\t//\n\t// Like HeapAlloc, this increases as objects are allocated and\n\t// decreases as the heap is swept and unreachable objects are\n\t// freed.\n\tHeapObjects\tuint64\n\n\t// StackInuse is bytes in stack spans.\n\t//\n\t// In-use stack spans have at least one stack in them. These\n\t// spans can only be used for other stacks of the same size.\n\t//\n\t// There is no StackIdle because unused stack spans are\n\t// returned to the heap (and hence counted toward HeapIdle).\n\tStackInuse\tuint64\n\n\t// StackSys is bytes of stack memory obtained from the OS.\n\t//\n\t// StackSys is StackInuse, plus any memory obtained directly\n\t// from the OS for OS thread stacks.\n\t//\n\t// In non-cgo programs this metric is currently equal to StackInuse\n\t// (but this should not be relied upon, and the value may change in\n\t// the future).\n\t//\n\t// In cgo programs this metric includes OS thread stacks allocated\n\t// directly from the OS. Currently, this only accounts for one stack in\n\t// c-shared and c-archive build modes and other sources of stacks from\n\t// the OS (notably, any allocated by C code) are not currently measured.\n\t// Note this too may change in the future.\n\tStackSys\tuint64\n\n\t// MSpanInuse is bytes of allocated mspan structures.\n\tMSpanInuse\tuint64\n\n\t// MSpanSys is bytes of memory obtained from the OS for mspan\n\t// structures.\n\tMSpanSys\tuint64\n\n\t// MCacheInuse is bytes of allocated mcache structures.\n\tMCacheInuse\tuint64\n\n\t// MCacheSys is bytes of memory obtained from the OS for\n\t// mcache structures.\n\tMCacheSys\tuint64\n\n\t// BuckHashSys is bytes of memory in profiling bucket hash tables.\n\tBuckHashSys\tuint64\n\n\t// GCSys is bytes of memory in garbage collection metadata.\n\tGCSys\tuint64\n\n\t// OtherSys is bytes of memory in miscellaneous off-heap\n\t// runtime allocations.\n\tOtherSys\tuint64\n\n\t// NextGC is the target heap size of the next GC cycle.\n\t//\n\t// The garbage collector's goal is to keep HeapAlloc ≤ NextGC.\n\t// At the end of each GC cycle, the target for the next cycle\n\t// is computed based on the amount of reachable data and the\n\t// value of GOGC.\n\tNextGC\tuint64\n\n\t// LastGC is the time the last garbage collection finished, as\n\t// nanoseconds since 1970 (the UNIX epoch).\n\tLastGC\tuint64\n\n\t// PauseTotalNs is the cumulative nanoseconds in GC\n\t// stop-the-world pauses since the program started.\n\t//\n\t// During a stop-the-world pause, all goroutines are paused\n\t// and only the garbage collector can run.\n\tPauseTotalNs\tuint64\n\n\t// PauseNs is a circular buffer of recent GC stop-the-world\n\t// pause times in nanoseconds.\n\t//\n\t// The most recent pause is at PauseNs[(NumGC+255)%256]. In\n\t// general, PauseNs[N%256] records the time paused in the most\n\t// recent N%256th GC cycle. There may be multiple pauses per\n\t// GC cycle; this is the sum of all pauses during a cycle.\n\tPauseNs\t[256]uint64\n\n\t// PauseEnd is a circular buffer of recent GC pause end times,\n\t// as nanoseconds since 1970 (the UNIX epoch).\n\t//\n\t// This buffer is filled the same way as PauseNs. There may be\n\t// multiple pauses per GC cycle; this records the end of the\n\t// last pause in a cycle.\n\tPauseEnd\t[256]uint64\n\n\t// NumGC is the number of completed GC cycles.\n\tNumGC\tuint32\n\n\t// NumForcedGC is the number of GC cycles that were forced by\n\t// the application calling the GC function.\n\tNumForcedGC\tuint32\n\n\t// GCCPUFraction is the fraction of this program's available\n\t// CPU time used by the GC since the program started.\n\t//\n\t// GCCPUFraction is expressed as a number between 0 and 1,\n\t// where 0 means GC has consumed none of this program's CPU. A\n\t// program's available CPU time is defined as the integral of\n\t// GOMAXPROCS since the program started. That is, if\n\t// GOMAXPROCS is 2 and a program has been running for 10\n\t// seconds, its \"available CPU\" is 20 seconds. GCCPUFraction\n\t// does not include CPU time used for write barrier activity.\n\t//\n\t// This is the same as the fraction of CPU reported by\n\t// GODEBUG=gctrace=1.\n\tGCCPUFraction\tfloat64\n\n\t// EnableGC indicates that GC is enabled. It is always true,\n\t// even if GOGC=off.\n\tEnableGC\tbool\n\n\t// DebugGC is currently unused.\n\tDebugGC\tbool\n\n\t// BySize reports per-size class allocation statistics.\n\t//\n\t// BySize[N] gives statistics for allocations of size S where\n\t// BySize[N-1].Size \u003c S ≤ BySize[N].Size.\n\t//\n\t// This does not report allocations larger than BySize[60].Size.\n\tBySize\t[61]struct {\n\t\t// Size is the maximum byte size of an object in this\n\t\t// size class.\n\t\tSize\tuint32\n\n\t\t// Mallocs is the cumulative count of heap objects\n\t\t// allocated in this size class. The cumulative bytes\n\t\t// of allocation is Size*Mallocs. The number of live\n\t\t// objects in this size class is Mallocs - Frees.\n\t\tMallocs\tuint64\n\n\t\t// Frees is the cumulative count of heap objects freed\n\t\t// in this size class.\n\t\tFrees\tuint64\n\t}\n}","func ReadMemStats(m *MemStats)","func Goexit()","type PanicNilError struct {\n\t// This field makes PanicNilError structurally different from\n\t// any other struct in this package, and the _ makes it different\n\t// from any struct in other packages too.\n\t// This avoids any accidental conversions being possible\n\t// between this struct and some other struct sharing the same fields,\n\t// like happened in go.dev/issue/56603.\n\t_ [0]*PanicNilError\n}","type Pinner struct {\n\t*pinner\n}","func Gosched()","func Breakpoint()","func LockOSThread()","func UnlockOSThread()","type Frames struct {\n\t// callers is a slice of PCs that have not yet been expanded to frames.\n\tcallers\t[]uintptr\n\n\t// nextPC is a next PC to expand ahead of processing callers.\n\tnextPC\tuintptr\n\n\t// frames is a slice of Frames that have yet to be returned.\n\tframes\t\t[]Frame\n\tframeStore\t[2]Frame\n}","type Frame struct {\n\t// PC is the program counter for the location in this frame.\n\t// For a frame that calls another frame, this will be the\n\t// program counter of a call instruction. Because of inlining,\n\t// multiple frames may have the same PC value, but different\n\t// symbolic information.\n\tPC\tuintptr\n\n\t// Func is the Func value of this call frame. This may be nil\n\t// for non-Go code or fully inlined functions.\n\tFunc\t*Func\n\n\t// Function is the package path-qualified function name of\n\t// this call frame. If non-empty, this string uniquely\n\t// identifies a single function in the program.\n\t// This may be the empty string if not known.\n\t// If Func is not nil then Function == Func.Name().\n\tFunction\tstring\n\n\t// File and Line are the file name and line number of the\n\t// location in this frame. For non-leaf frames, this will be\n\t// the location of a call. These may be the empty string and\n\t// zero, respectively, if not known.\n\tFile\tstring\n\tLine\tint\n\n\t// startLine is the line number of the beginning of the function in\n\t// this frame. Specifically, it is the line number of the func keyword\n\t// for Go functions. Note that //line directives can change the\n\t// filename and/or line number arbitrarily within a function, meaning\n\t// that the Line - startLine offset is not always meaningful.\n\t//\n\t// This may be zero if not known.\n\tstartLine\tint\n\n\t// Entry point program counter for the function; may be zero\n\t// if not known. If Func is not nil then Entry ==\n\t// Func.Entry().\n\tEntry\tuintptr\n\n\t// The runtime's internal view of the function. This field\n\t// is set (funcInfo.valid() returns true) only for Go functions,\n\t// not for C functions.\n\tfuncInfo\tfuncInfo\n}","func CallersFrames(callers []uintptr) *Frames","type Func struct {\n\topaque struct{}\t// unexported field to disallow conversions\n}","func FuncForPC(pc uintptr) *Func","func StartTrace() error","func StopTrace()","func ReadTrace() []byte","func SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)","func All[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]","func Backward[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]","func Values[Slice ~[]E, E any](s Slice) iter.Seq[E]","func AppendSeq[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice","func Collect[E any](seq iter.Seq[E]) []E","func Sorted[E cmp.Ordered](seq iter.Seq[E]) []E","func SortedFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E","func SortedStableFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E","func Chunk[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice]","func Equal[S ~[]E, E comparable](s1, s2 S) bool","func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool","func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int","func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int","func Index[S ~[]E, E comparable](s S, v E) int","func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int","func Contains[S ~[]E, E comparable](s S, v E) bool","func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool","func Insert[S ~[]E, E any](s S, i int, v ...E) S","func Delete[S ~[]E, E any](s S, i, j int) S","func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S","func Replace[S ~[]E, E any](s S, i, j int, v ...E) S","func Clone[S ~[]E, E any](s S) S","func Compact[S ~[]E, E comparable](s S) S","func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S","func Grow[S ~[]E, E any](s S, n int) S","func Clip[S ~[]E, E any](s S) S","func Reverse[S ~[]E, E any](s S)","func Concat[S ~[]E, E any](slices ...S) S","func Repeat[S ~[]E, E any](x S, count int) S","func Sort[S ~[]E, E cmp.Ordered](x S)","func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)","func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)","func IsSorted[S ~[]E, E cmp.Ordered](x S) bool","func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool","func Min[S ~[]E, E cmp.Ordered](x S) E","func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E","func Max[S ~[]E, E cmp.Ordered](x S) E","func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E","func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)","func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)","func Search(n int, f func(int) bool) int","func Find(n int, cmp func(int) int) (i int, found bool)","func SearchInts(a []int, x int) int","func SearchFloat64s(a []float64, x float64) int","func SearchStrings(a []string, x string) int","func Slice(x any, less func(i, j int) bool)","func SliceStable(x any, less func(i, j int) bool)","func SliceIsSorted(x any, less func(i, j int) bool) bool","type Interface interface {\n\t// Len is the number of elements in the collection.\n\tLen() int\n\n\t// Less reports whether the element with index i\n\t// must sort before the element with index j.\n\t//\n\t// If both Less(i, j) and Less(j, i) are false,\n\t// then the elements at index i and j are considered equal.\n\t// Sort may place equal elements in any order in the final result,\n\t// while Stable preserves the original input order of equal elements.\n\t//\n\t// Less must describe a transitive ordering:\n\t//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.\n\t//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.\n\t//\n\t// Note that floating-point comparison (the \u003c operator on float32 or float64 values)\n\t// is not a transitive ordering when not-a-number (NaN) values are involved.\n\t// See Float64Slice.Less for a correct implementation for floating-point values.\n\tLess(i, j int) bool\n\n\t// Swap swaps the elements with indexes i and j.\n\tSwap(i, j int)\n}","func Sort(data Interface)","func Reverse(data Interface) Interface","func IsSorted(data Interface) bool","type IntSlice []int","type Float64Slice []float64","type StringSlice []string","func Ints(x []int)","func Float64s(x []float64)","func Strings(x []string)","func IntsAreSorted(x []int) bool","func Float64sAreSorted(x []float64) bool","func StringsAreSorted(x []string) bool","func Stable(data Interface)","func ParseBool(str string) (bool, error)","func FormatBool(b bool) string","func AppendBool(dst []byte, b bool) []byte","func ParseComplex(s string, bitSize int) (complex128, error)","func ParseFloat(s string, bitSize int) (float64, error)","","","type NumError struct {\n\tFunc\tstring\t// the failing function (ParseBool, ParseInt, ParseUint, ParseFloat, ParseComplex)\n\tNum\tstring\t// the input\n\tErr\terror\t// the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.)\n}","","func ParseUint(s string, base int, bitSize int) (uint64, error)","func ParseInt(s string, base int, bitSize int) (i int64, err error)","func Atoi(s string) (int, error)","func FormatComplex(c complex128, fmt byte, prec, bitSize int) string","func FormatFloat(f float64, fmt byte, prec, bitSize int) string","func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte","func FormatUint(i uint64, base int) string","func FormatInt(i int64, base int) string","func Itoa(i int) string","func AppendInt(dst []byte, i int64, base int) []byte","func AppendUint(dst []byte, i uint64, base int) []byte","func Quote(s string) string","func AppendQuote(dst []byte, s string) []byte","func QuoteToASCII(s string) string","func AppendQuoteToASCII(dst []byte, s string) []byte","func QuoteToGraphic(s string) string","func AppendQuoteToGraphic(dst []byte, s string) []byte","func QuoteRune(r rune) string","func AppendQuoteRune(dst []byte, r rune) []byte","func QuoteRuneToASCII(r rune) string","func AppendQuoteRuneToASCII(dst []byte, r rune) []byte","func QuoteRuneToGraphic(r rune) string","func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte","func CanBackquote(s string) bool","func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)","func QuotedPrefix(s string) (string, error)","func Unquote(s string) (string, error)","func IsPrint(r rune) bool","func IsGraphic(r rune) bool","type Builder struct {\n\taddr\t*Builder\t// of receiver, to detect copies by value\n\n\t// External users should never get direct access to this buffer, since\n\t// the slice at some point will be converted to a string using unsafe, also\n\t// data between len(buf) and cap(buf) might be uninitialized.\n\tbuf\t[]byte\n}","func Clone(s string) string","func Compare(a, b string) int","type Reader struct {\n\ts\t\tstring\n\ti\t\tint64\t// current reading index\n\tprevRune\tint\t// index of previous rune; or \u003c 0\n}","func NewReader(s string) *Reader","type Replacer struct {\n\tonce\tsync.Once\t// guards buildOnce method\n\tr\treplacer\n\toldnew\t[]string\n}","func NewReplacer(oldnew ...string) *Replacer","func Count(s, substr string) int","func Contains(s, substr string) bool","func ContainsAny(s, chars string) bool","func ContainsRune(s string, r rune) bool","func ContainsFunc(s string, f func(rune) bool) bool","func LastIndex(s, substr string) int","func IndexByte(s string, c byte) int","func IndexRune(s string, r rune) int","func IndexAny(s, chars string) int","func LastIndexAny(s, chars string) int","func LastIndexByte(s string, c byte) int","func SplitN(s, sep string, n int) []string","func SplitAfterN(s, sep string, n int) []string","func Split(s, sep string) []string","func SplitAfter(s, sep string) []string","func Fields(s string) []string","func FieldsFunc(s string, f func(rune) bool) []string","func Join(elems []string, sep string) string","func HasPrefix(s, prefix string) bool","func HasSuffix(s, suffix string) bool","func Map(mapping func(rune) rune, s string) string","func Repeat(s string, count int) string","func ToUpper(s string) string","func ToLower(s string) string","func ToTitle(s string) string","func ToUpperSpecial(c unicode.SpecialCase, s string) string","func ToLowerSpecial(c unicode.SpecialCase, s string) string","func ToTitleSpecial(c unicode.SpecialCase, s string) string","func ToValidUTF8(s, replacement string) string","func Title(s string) string","func TrimLeftFunc(s string, f func(rune) bool) string","func TrimRightFunc(s string, f func(rune) bool) string","func TrimFunc(s string, f func(rune) bool) string","func IndexFunc(s string, f func(rune) bool) int","func LastIndexFunc(s string, f func(rune) bool) int","func Trim(s, cutset string) string","func TrimLeft(s, cutset string) string","func TrimRight(s, cutset string) string","func TrimSpace(s string) string","func TrimPrefix(s, prefix string) string","func TrimSuffix(s, suffix string) string","func Replace(s, old, new string, n int) string","func ReplaceAll(s, old, new string) string","func EqualFold(s, t string) bool","func Index(s, substr string) int","func Cut(s, sep string) (before, after string, found bool)","func CutPrefix(s, prefix string) (after string, found bool)","func CutSuffix(s, suffix string) (before string, found bool)","type HostLayout struct {\n\t_ hostLayout\t// prevent accidental conversion with plain struct{}\n}","type Cond struct {\n\tnoCopy\tnoCopy\n\n\t// L is held while observing or changing the condition\n\tL\tLocker\n\n\tnotify\tnotifyList\n\tchecker\tcopyChecker\n}","func NewCond(l Locker) *Cond","type Map struct {\n\tmu\tMutex\n\n\t// read contains the portion of the map's contents that are safe for\n\t// concurrent access (with or without mu held).\n\t//\n\t// The read field itself is always safe to load, but must only be stored with\n\t// mu held.\n\t//\n\t// Entries stored in read may be updated concurrently without mu, but updating\n\t// a previously-expunged entry requires that the entry be copied to the dirty\n\t// map and unexpunged with mu held.\n\tread\tatomic.Pointer[readOnly]\n\n\t// dirty contains the portion of the map's contents that require mu to be\n\t// held. To ensure that the dirty map can be promoted to the read map quickly,\n\t// it also includes all of the non-expunged entries in the read map.\n\t//\n\t// Expunged entries are not stored in the dirty map. An expunged entry in the\n\t// clean map must be unexpunged and added to the dirty map before a new value\n\t// can be stored to it.\n\t//\n\t// If the dirty map is nil, the next write to the map will initialize it by\n\t// making a shallow copy of the clean map, omitting stale entries.\n\tdirty\tmap[any]*entry\n\n\t// misses counts the number of loads since the read map was last updated that\n\t// needed to lock mu to determine whether the key was present.\n\t//\n\t// Once enough misses have occurred to cover the cost of copying the dirty\n\t// map, the dirty map will be promoted to the read map (in the unamended\n\t// state) and the next store to the map will make a new dirty copy.\n\tmisses\tint\n}","type Mutex struct {\n\tstate\tint32\n\tsema\tuint32\n}","type Locker interface {\n\tLock()\n\tUnlock()\n}","type Once struct {\n\t// done indicates whether the action has been performed.\n\t// It is first in the struct because it is used in the hot path.\n\t// The hot path is inlined at every call site.\n\t// Placing done first allows more compact instructions on some architectures (amd64/386),\n\t// and fewer instructions (to calculate offset) on other architectures.\n\tdone\tatomic.Uint32\n\tm\tMutex\n}","func OnceFunc(f func()) func()","func OnceValue[T any](f func() T) func() T","func OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2)","type Pool struct {\n\tnoCopy\tnoCopy\n\n\tlocal\t\tunsafe.Pointer\t// local fixed-size per-P pool, actual type is [P]poolLocal\n\tlocalSize\tuintptr\t\t// size of the local array\n\n\tvictim\t\tunsafe.Pointer\t// local from previous cycle\n\tvictimSize\tuintptr\t\t// size of victims array\n\n\t// New optionally specifies a function to generate\n\t// a value when Get would otherwise return nil.\n\t// It may not be changed concurrently with calls to Get.\n\tNew\tfunc() any\n}","type RWMutex struct {\n\tw\t\tMutex\t\t// held if there are pending writers\n\twriterSem\tuint32\t\t// semaphore for writers to wait for completing readers\n\treaderSem\tuint32\t\t// semaphore for readers to wait for completing writers\n\treaderCount\tatomic.Int32\t// number of pending readers\n\treaderWait\tatomic.Int32\t// number of departing readers\n}","type WaitGroup struct {\n\tnoCopy\tnoCopy\n\n\tstate\tatomic.Uint64\t// high 32 bits are counter, low 32 bits are waiter count.\n\tsema\tuint32\n}","func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string)","func Unsetenv(key string) error","func Getenv(key string) (value string, found bool)","func Setenv(key, value string) error","func Clearenv()","func Environ() []string","const CLONE_VM = 0x00000100","const CLONE_FS = 0x00000200","const CLONE_FILES = 0x00000400","const CLONE_SIGHAND = 0x00000800","const CLONE_PIDFD = 0x00001000","const CLONE_PTRACE = 0x00002000","const CLONE_VFORK = 0x00004000","const CLONE_PARENT = 0x00008000","const CLONE_THREAD = 0x00010000","const CLONE_NEWNS = 0x00020000","const CLONE_SYSVSEM = 0x00040000","const CLONE_SETTLS = 0x00080000","const CLONE_PARENT_SETTID = 0x00100000","const CLONE_CHILD_CLEARTID = 0x00200000","const CLONE_DETACHED = 0x00400000","const CLONE_UNTRACED = 0x00800000","const CLONE_CHILD_SETTID = 0x01000000","const CLONE_NEWCGROUP = 0x02000000","const CLONE_NEWUTS = 0x04000000","const CLONE_NEWIPC = 0x08000000","const CLONE_NEWUSER = 0x10000000","const CLONE_NEWPID = 0x20000000","const CLONE_NEWNET = 0x40000000","const CLONE_IO = 0x80000000","const CLONE_CLEAR_SIGHAND = 0x100000000","const CLONE_INTO_CGROUP = 0x200000000","const CLONE_NEWTIME = 0x00000080","type SysProcIDMap struct {\n\tContainerID\tint\t// Container ID.\n\tHostID\t\tint\t// Host ID.\n\tSize\t\tint\t// Size.\n}","type SysProcAttr struct {\n\tChroot\t\tstring\t\t// Chroot.\n\tCredential\t*Credential\t// Credential.\n\t// Ptrace tells the child to call ptrace(PTRACE_TRACEME).\n\t// Call runtime.LockOSThread before starting a process with this set,\n\t// and don't call UnlockOSThread until done with PtraceSyscall calls.\n\tPtrace\tbool\n\tSetsid\tbool\t// Create session.\n\t// Setpgid sets the process group ID of the child to Pgid,\n\t// or, if Pgid == 0, to the new child's process ID.\n\tSetpgid\tbool\n\t// Setctty sets the controlling terminal of the child to\n\t// file descriptor Ctty. Ctty must be a descriptor number\n\t// in the child process: an index into ProcAttr.Files.\n\t// This is only meaningful if Setsid is true.\n\tSetctty\tbool\n\tNoctty\tbool\t// Detach fd 0 from controlling terminal.\n\tCtty\tint\t// Controlling TTY fd.\n\t// Foreground places the child process group in the foreground.\n\t// This implies Setpgid. The Ctty field must be set to\n\t// the descriptor of the controlling TTY.\n\t// Unlike Setctty, in this case Ctty must be a descriptor\n\t// number in the parent process.\n\tForeground\tbool\n\tPgid\t\tint\t// Child's process group ID if Setpgid.\n\t// Pdeathsig, if non-zero, is a signal that the kernel will send to\n\t// the child process when the creating thread dies. Note that the signal\n\t// is sent on thread termination, which may happen before process termination.\n\t// There are more details at https://go.dev/issue/27505.\n\tPdeathsig\tSignal\n\tCloneflags\tuintptr\t\t// Flags for clone calls.\n\tUnshareflags\tuintptr\t\t// Flags for unshare calls.\n\tUidMappings\t[]SysProcIDMap\t// User ID mappings for user namespaces.\n\tGidMappings\t[]SysProcIDMap\t// Group ID mappings for user namespaces.\n\t// GidMappingsEnableSetgroups enabling setgroups syscall.\n\t// If false, then setgroups syscall will be disabled for the child process.\n\t// This parameter is no-op if GidMappings == nil. Otherwise for unprivileged\n\t// users this should be set to false for mappings work.\n\tGidMappingsEnableSetgroups\tbool\n\tAmbientCaps\t\t\t[]uintptr\t// Ambient capabilities.\n\tUseCgroupFD\t\t\tbool\t\t// Whether to make use of the CgroupFD field.\n\tCgroupFD\t\t\tint\t\t// File descriptor of a cgroup to put the new process into.\n\t// PidFD, if not nil, is used to store the pidfd of a child, if the\n\t// functionality is supported by the kernel, or -1. Note *PidFD is\n\t// changed only if the process starts successfully.\n\tPidFD\t*int\n}","var ForkLock sync.RWMutex","func StringSlicePtr(ss []string) []*byte","func SlicePtrFromStrings(ss []string) ([]*byte, error)","func CloseOnExec(fd int)","func SetNonblock(fd int, nonblocking bool) (err error)","type Credential struct {\n\tUid\t\tuint32\t\t// User ID.\n\tGid\t\tuint32\t\t// Group ID.\n\tGroups\t\t[]uint32\t// Supplementary group IDs.\n\tNoSetGroups\tbool\t\t// If true, don't set supplementary groups\n}","type ProcAttr struct {\n\tDir\tstring\t\t// Current working directory.\n\tEnv\t[]string\t// Environment.\n\tFiles\t[]uintptr\t// File descriptors.\n\tSys\t*SysProcAttr\n}","func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)","func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)","func Exec(argv0 string, argv []string, envv []string) (err error)","func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error","func LsfStmt(code, k int) *SockFilter","func LsfJump(code, k, jt, jf int) *SockFilter","func LsfSocket(ifindex, proto int) (int, error)","func SetLsfPromisc(name string, m bool) error","func AttachLsf(fd int, i []SockFilter) error","func DetachLsf(fd int) error","type RawConn interface {\n\t// Control invokes f on the underlying connection's file\n\t// descriptor or handle.\n\t// The file descriptor fd is guaranteed to remain valid while\n\t// f executes but not after f returns.\n\tControl(f func(fd uintptr)) error\n\n\t// Read invokes f on the underlying connection's file\n\t// descriptor or handle; f is expected to try to read from the\n\t// file descriptor.\n\t// If f returns true, Read returns. Otherwise Read blocks\n\t// waiting for the connection to be ready for reading and\n\t// tries again repeatedly.\n\t// The file descriptor is guaranteed to remain valid while f\n\t// executes but not after f returns.\n\tRead(f func(fd uintptr) (done bool)) error\n\n\t// Write is like Read but for writing.\n\tWrite(f func(fd uintptr) (done bool)) error\n}","type Conn interface {\n\t// SyscallConn returns a raw network connection.\n\tSyscallConn() (RawConn, error)\n}","type NetlinkRouteRequest struct {\n\tHeader\tNlMsghdr\n\tData\tRtGenmsg\n}","func NetlinkRIB(proto, family int) ([]byte, error)","type NetlinkMessage struct {\n\tHeader\tNlMsghdr\n\tData\t[]byte\n}","func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error)","type NetlinkRouteAttr struct {\n\tAttr\tRtAttr\n\tValue\t[]byte\n}","func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error)","func Setrlimit(resource int, rlim *Rlimit) error","func UnixCredentials(ucred *Ucred) []byte","func ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error)","func CmsgLen(datalen int) int","func CmsgSpace(datalen int) int","type SocketControlMessage struct {\n\tHeader\tCmsghdr\n\tData\t[]byte\n}","func ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error)","func UnixRights(fds ...int) []byte","func ParseUnixRights(m *SocketControlMessage) ([]int, error)","func StringByteSlice(s string) []byte","func ByteSliceFromString(s string) ([]byte, error)","func StringBytePtr(s string) *byte","func BytePtrFromString(s string) (*byte, error)","func Getpagesize() int","func Exit(code int)","func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)","func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)","func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)","func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)","func Access(path string, mode uint32) (err error)","func Chmod(path string, mode uint32) (err error)","func Chown(path string, uid int, gid int) (err error)","func Creat(path string, mode uint32) (fd int, err error)","func EpollCreate(size int) (fd int, err error)","func Faccessat(dirfd int, path string, mode uint32, flags int) (err error)","func Fchmodat(dirfd int, path string, mode uint32, flags int) error","func Link(oldpath string, newpath string) (err error)","func Mkdir(path string, mode uint32) (err error)","func Mknod(path string, mode uint32, dev int) (err error)","func Open(path string, mode int, perm uint32) (fd int, err error)","func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)","func Pipe(p []int) error","func Pipe2(p []int, flags int) error","func Readlink(path string, buf []byte) (n int, err error)","func Rename(oldpath string, newpath string) (err error)","func Rmdir(path string) error","func Symlink(oldpath string, newpath string) (err error)","func Unlink(path string) error","func Unlinkat(dirfd int, path string) error","func Utimes(path string, tv []Timeval) (err error)","func UtimesNano(path string, ts []Timespec) (err error)","func Futimesat(dirfd int, path string, tv []Timeval) (err error)","func Futimes(fd int, tv []Timeval) (err error)","","func Getwd() (wd string, err error)","func Getgroups() (gids []int, err error)","func Setgroups(gids []int) (err error)","","func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)","func Mkfifo(path string, mode uint32) (err error)","type SockaddrLinklayer struct {\n\tProtocol\tuint16\n\tIfindex\t\tint\n\tHatype\t\tuint16\n\tPkttype\t\tuint8\n\tHalen\t\tuint8\n\tAddr\t\t[8]byte\n\traw\t\tRawSockaddrLinklayer\n}","type SockaddrNetlink struct {\n\tFamily\tuint16\n\tPad\tuint16\n\tPid\tuint32\n\tGroups\tuint32\n\traw\tRawSockaddrNetlink\n}","func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error)","func Getsockname(fd int) (sa Sockaddr, err error)","func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error)","func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error)","func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error)","func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error)","func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error)","func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error)","func GetsockoptUcred(fd, level, opt int) (*Ucred, error)","func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error)","func BindToDevice(fd int, device string) (err error)","func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error)","func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error)","func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error)","func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error)","func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error)","func PtraceSetRegs(pid int, regs *PtraceRegs) (err error)","func PtraceSetOptions(pid int, options int) (err error)","func PtraceGetEventMsg(pid int) (msg uint, err error)","func PtraceCont(pid int, signal int) (err error)","func PtraceSyscall(pid int, signal int) (err error)","func PtraceSingleStep(pid int) (err error)","func PtraceAttach(pid int) (err error)","func PtraceDetach(pid int) (err error)","func Reboot(cmd int) (err error)","func ReadDirent(fd int, buf []byte) (n int, err error)","func Mount(source string, target string, fstype string, flags uintptr, data string) (err error)","func Getpgrp() (pid int)","func AllThreadsSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)","func AllThreadsSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)","func Setegid(egid int) (err error)","func Seteuid(euid int) (err error)","func Setgid(gid int) (err error)","func Setregid(rgid, egid int) (err error)","func Setresgid(rgid, egid, sgid int) (err error)","func Setresuid(ruid, euid, suid int) (err error)","func Setreuid(ruid, euid int) (err error)","func Setuid(uid int) (err error)","func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)","func Munmap(b []byte) (err error)","func Accept(fd int) (nfd int, sa Sockaddr, err error)","func Stat(path string, stat *Stat_t) (err error)","func Lchown(path string, uid int, gid int) (err error)","func Lstat(path string, stat *Stat_t) (err error)","func Gettimeofday(tv *Timeval) (err error)","func Time(t *Time_t) (tt Time_t, err error)","var Stdin = 0","var Stdout = 1","var Stderr = 2","","","func Read(fd int, p []byte) (n int, err error)","func Write(fd int, p []byte) (n int, err error)","func Pread(fd int, p []byte, offset int64) (n int, err error)","func Pwrite(fd int, p []byte, offset int64) (n int, err error)","var SocketDisableIPv6 bool","type Sockaddr interface {\n\tsockaddr() (ptr unsafe.Pointer, len _Socklen, err error)\t// lowercase; only we can define Sockaddrs\n}","type SockaddrInet4 struct {\n\tPort\tint\n\tAddr\t[4]byte\n\traw\tRawSockaddrInet4\n}","type SockaddrInet6 struct {\n\tPort\tint\n\tZoneId\tuint32\n\tAddr\t[16]byte\n\traw\tRawSockaddrInet6\n}","type SockaddrUnix struct {\n\tName\tstring\n\traw\tRawSockaddrUnix\n}","func Bind(fd int, sa Sockaddr) (err error)","func Connect(fd int, sa Sockaddr) (err error)","func Getpeername(fd int) (sa Sockaddr, err error)","func GetsockoptInt(fd, level, opt int) (value int, err error)","func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error)","func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)","func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error)","func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)","func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error)","func SetsockoptByte(fd, level, opt int, value byte) (err error)","func SetsockoptInt(fd, level, opt int, value int) (err error)","func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error)","func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error)","func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error)","func SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error","func SetsockoptLinger(fd, level, opt int, l *Linger) (err error)","func SetsockoptString(fd, level, opt int, s string) (err error)","func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error)","func Socket(domain, typ, proto int) (fd int, err error)","func Socketpair(domain, typ, proto int) (fd [2]int, err error)","func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)","func TimespecToNsec(ts Timespec) int64","func NsecToTimespec(nsec int64) Timespec","func TimevalToNsec(tv Timeval) int64","func NsecToTimeval(nsec int64) Timeval","const AF_ALG = 0x26","const AF_APPLETALK = 0x5","const AF_ASH = 0x12","const AF_ATMPVC = 0x8","const AF_ATMSVC = 0x14","const AF_AX25 = 0x3","const AF_BLUETOOTH = 0x1f","const AF_BRIDGE = 0x7","const AF_CAIF = 0x25","const AF_CAN = 0x1d","const AF_DECnet = 0xc","const AF_ECONET = 0x13","const AF_FILE = 0x1","const AF_IEEE802154 = 0x24","const AF_INET = 0x2","const AF_INET6 = 0xa","const AF_IPX = 0x4","const AF_IRDA = 0x17","const AF_ISDN = 0x22","const AF_IUCV = 0x20","const AF_KEY = 0xf","const AF_LLC = 0x1a","const AF_LOCAL = 0x1","const AF_MAX = 0x27","const AF_NETBEUI = 0xd","const AF_NETLINK = 0x10","const AF_NETROM = 0x6","const AF_PACKET = 0x11","const AF_PHONET = 0x23","const AF_PPPOX = 0x18","const AF_RDS = 0x15","const AF_ROSE = 0xb","const AF_ROUTE = 0x10","const AF_RXRPC = 0x21","const AF_SECURITY = 0xe","const AF_SNA = 0x16","const AF_TIPC = 0x1e","const AF_UNIX = 0x1","const AF_UNSPEC = 0x0","const AF_WANPIPE = 0x19","const AF_X25 = 0x9","const ARPHRD_ADAPT = 0x108","const ARPHRD_APPLETLK = 0x8","const ARPHRD_ARCNET = 0x7","const ARPHRD_ASH = 0x30d","const ARPHRD_ATM = 0x13","const ARPHRD_AX25 = 0x3","const ARPHRD_BIF = 0x307","const ARPHRD_CHAOS = 0x5","const ARPHRD_CISCO = 0x201","const ARPHRD_CSLIP = 0x101","const ARPHRD_CSLIP6 = 0x103","const ARPHRD_DDCMP = 0x205","const ARPHRD_DLCI = 0xf","const ARPHRD_ECONET = 0x30e","const ARPHRD_EETHER = 0x2","const ARPHRD_ETHER = 0x1","const ARPHRD_EUI64 = 0x1b","const ARPHRD_FCAL = 0x311","const ARPHRD_FCFABRIC = 0x313","const ARPHRD_FCPL = 0x312","const ARPHRD_FCPP = 0x310","const ARPHRD_FDDI = 0x306","const ARPHRD_FRAD = 0x302","const ARPHRD_HDLC = 0x201","const ARPHRD_HIPPI = 0x30c","const ARPHRD_HWX25 = 0x110","const ARPHRD_IEEE1394 = 0x18","const ARPHRD_IEEE802 = 0x6","const ARPHRD_IEEE80211 = 0x321","const ARPHRD_IEEE80211_PRISM = 0x322","const ARPHRD_IEEE80211_RADIOTAP = 0x323","const ARPHRD_IEEE802154 = 0x324","const ARPHRD_IEEE802154_PHY = 0x325","const ARPHRD_IEEE802_TR = 0x320","const ARPHRD_INFINIBAND = 0x20","const ARPHRD_IPDDP = 0x309","const ARPHRD_IPGRE = 0x30a","const ARPHRD_IRDA = 0x30f","const ARPHRD_LAPB = 0x204","const ARPHRD_LOCALTLK = 0x305","const ARPHRD_LOOPBACK = 0x304","const ARPHRD_METRICOM = 0x17","const ARPHRD_NETROM = 0x0","const ARPHRD_NONE = 0xfffe","const ARPHRD_PIMREG = 0x30b","const ARPHRD_PPP = 0x200","const ARPHRD_PRONET = 0x4","const ARPHRD_RAWHDLC = 0x206","const ARPHRD_ROSE = 0x10e","const ARPHRD_RSRVD = 0x104","const ARPHRD_SIT = 0x308","const ARPHRD_SKIP = 0x303","const ARPHRD_SLIP = 0x100","const ARPHRD_SLIP6 = 0x102","const ARPHRD_TUNNEL = 0x300","const ARPHRD_TUNNEL6 = 0x301","const ARPHRD_VOID = 0xffff","const ARPHRD_X25 = 0x10f","const BPF_A = 0x10","const BPF_ABS = 0x20","const BPF_ADD = 0x0","const BPF_ALU = 0x4","const BPF_AND = 0x50","const BPF_B = 0x10","const BPF_DIV = 0x30","const BPF_H = 0x8","const BPF_IMM = 0x0","const BPF_IND = 0x40","const BPF_JA = 0x0","const BPF_JEQ = 0x10","const BPF_JGE = 0x30","const BPF_JGT = 0x20","const BPF_JMP = 0x5","const BPF_JSET = 0x40","const BPF_K = 0x0","const BPF_LD = 0x0","const BPF_LDX = 0x1","const BPF_LEN = 0x80","const BPF_LSH = 0x60","const BPF_MAJOR_VERSION = 0x1","const BPF_MAXINSNS = 0x1000","const BPF_MEM = 0x60","const BPF_MEMWORDS = 0x10","const BPF_MINOR_VERSION = 0x1","const BPF_MISC = 0x7","const BPF_MSH = 0xa0","const BPF_MUL = 0x20","const BPF_NEG = 0x80","const BPF_OR = 0x40","const BPF_RET = 0x6","const BPF_RSH = 0x70","const BPF_ST = 0x2","const BPF_STX = 0x3","const BPF_SUB = 0x10","const BPF_TAX = 0x0","const BPF_TXA = 0x80","const BPF_W = 0x0","const BPF_X = 0x8","const DT_BLK = 0x6","const DT_CHR = 0x2","const DT_DIR = 0x4","const DT_FIFO = 0x1","const DT_LNK = 0xa","const DT_REG = 0x8","const DT_SOCK = 0xc","const DT_UNKNOWN = 0x0","const DT_WHT = 0xe","const EPOLLERR = 0x8","","const EPOLLHUP = 0x10","const EPOLLIN = 0x1","const EPOLLMSG = 0x400","const EPOLLONESHOT = 0x40000000","const EPOLLOUT = 0x4","const EPOLLPRI = 0x2","const EPOLLRDBAND = 0x80","const EPOLLRDHUP = 0x2000","const EPOLLRDNORM = 0x40","const EPOLLWRBAND = 0x200","const EPOLLWRNORM = 0x100","const EPOLL_CLOEXEC = 0x80000","const EPOLL_CTL_ADD = 0x1","const EPOLL_CTL_DEL = 0x2","const EPOLL_CTL_MOD = 0x3","const EPOLL_NONBLOCK = 0x800","const ETH_P_1588 = 0x88f7","const ETH_P_8021Q = 0x8100","const ETH_P_802_2 = 0x4","const ETH_P_802_3 = 0x1","const ETH_P_AARP = 0x80f3","const ETH_P_ALL = 0x3","const ETH_P_AOE = 0x88a2","const ETH_P_ARCNET = 0x1a","const ETH_P_ARP = 0x806","const ETH_P_ATALK = 0x809b","const ETH_P_ATMFATE = 0x8884","const ETH_P_ATMMPOA = 0x884c","const ETH_P_AX25 = 0x2","const ETH_P_BPQ = 0x8ff","const ETH_P_CAIF = 0xf7","const ETH_P_CAN = 0xc","const ETH_P_CONTROL = 0x16","const ETH_P_CUST = 0x6006","const ETH_P_DDCMP = 0x6","const ETH_P_DEC = 0x6000","const ETH_P_DIAG = 0x6005","const ETH_P_DNA_DL = 0x6001","const ETH_P_DNA_RC = 0x6002","const ETH_P_DNA_RT = 0x6003","const ETH_P_DSA = 0x1b","const ETH_P_ECONET = 0x18","const ETH_P_EDSA = 0xdada","const ETH_P_FCOE = 0x8906","const ETH_P_FIP = 0x8914","const ETH_P_HDLC = 0x19","const ETH_P_IEEE802154 = 0xf6","const ETH_P_IEEEPUP = 0xa00","const ETH_P_IEEEPUPAT = 0xa01","const ETH_P_IP = 0x800","const ETH_P_IPV6 = 0x86dd","const ETH_P_IPX = 0x8137","const ETH_P_IRDA = 0x17","const ETH_P_LAT = 0x6004","const ETH_P_LINK_CTL = 0x886c","const ETH_P_LOCALTALK = 0x9","const ETH_P_LOOP = 0x60","const ETH_P_MOBITEX = 0x15","const ETH_P_MPLS_MC = 0x8848","const ETH_P_MPLS_UC = 0x8847","const ETH_P_PAE = 0x888e","const ETH_P_PAUSE = 0x8808","const ETH_P_PHONET = 0xf5","const ETH_P_PPPTALK = 0x10","const ETH_P_PPP_DISC = 0x8863","const ETH_P_PPP_MP = 0x8","const ETH_P_PPP_SES = 0x8864","const ETH_P_PUP = 0x200","const ETH_P_PUPAT = 0x201","const ETH_P_RARP = 0x8035","const ETH_P_SCA = 0x6007","const ETH_P_SLOW = 0x8809","const ETH_P_SNAP = 0x5","const ETH_P_TEB = 0x6558","const ETH_P_TIPC = 0x88ca","const ETH_P_TRAILER = 0x1c","const ETH_P_TR_802_2 = 0x11","const ETH_P_WAN_PPP = 0x7","const ETH_P_WCCP = 0x883e","const ETH_P_X25 = 0x805","const FD_CLOEXEC = 0x1","const FD_SETSIZE = 0x400","const F_DUPFD = 0x0","const F_DUPFD_CLOEXEC = 0x406","const F_EXLCK = 0x4","const F_GETFD = 0x1","const F_GETFL = 0x3","const F_GETLEASE = 0x401","const F_GETLK = 0x5","const F_GETLK64 = 0x5","const F_GETOWN = 0x9","const F_GETOWN_EX = 0x10","const F_GETPIPE_SZ = 0x408","const F_GETSIG = 0xb","const F_LOCK = 0x1","const F_NOTIFY = 0x402","const F_OK = 0x0","const F_RDLCK = 0x0","const F_SETFD = 0x2","const F_SETFL = 0x4","const F_SETLEASE = 0x400","const F_SETLK = 0x6","const F_SETLK64 = 0x6","const F_SETLKW = 0x7","const F_SETLKW64 = 0x7","const F_SETOWN = 0x8","const F_SETOWN_EX = 0xf","const F_SETPIPE_SZ = 0x407","const F_SETSIG = 0xa","const F_SHLCK = 0x8","const F_TEST = 0x3","const F_TLOCK = 0x2","const F_ULOCK = 0x0","const F_UNLCK = 0x2","const F_WRLCK = 0x1","const ICMPV6_FILTER = 0x1","const IFA_F_DADFAILED = 0x8","const IFA_F_DEPRECATED = 0x20","const IFA_F_HOMEADDRESS = 0x10","const IFA_F_NODAD = 0x2","const IFA_F_OPTIMISTIC = 0x4","const IFA_F_PERMANENT = 0x80","const IFA_F_SECONDARY = 0x1","const IFA_F_TEMPORARY = 0x1","const IFA_F_TENTATIVE = 0x40","const IFA_MAX = 0x7","const IFF_ALLMULTI = 0x200","const IFF_AUTOMEDIA = 0x4000","const IFF_BROADCAST = 0x2","const IFF_DEBUG = 0x4","const IFF_DYNAMIC = 0x8000","const IFF_LOOPBACK = 0x8","const IFF_MASTER = 0x400","const IFF_MULTICAST = 0x1000","const IFF_NOARP = 0x80","const IFF_NOTRAILERS = 0x20","const IFF_NO_PI = 0x1000","const IFF_ONE_QUEUE = 0x2000","const IFF_POINTOPOINT = 0x10","const IFF_PORTSEL = 0x2000","const IFF_PROMISC = 0x100","const IFF_RUNNING = 0x40","const IFF_SLAVE = 0x800","const IFF_TAP = 0x2","const IFF_TUN = 0x1","const IFF_TUN_EXCL = 0x8000","const IFF_UP = 0x1","const IFF_VNET_HDR = 0x4000","const IFNAMSIZ = 0x10","const IN_ACCESS = 0x1","const IN_ALL_EVENTS = 0xfff","const IN_ATTRIB = 0x4","const IN_CLASSA_HOST = 0xffffff","const IN_CLASSA_MAX = 0x80","const IN_CLASSA_NET = 0xff000000","const IN_CLASSA_NSHIFT = 0x18","const IN_CLASSB_HOST = 0xffff","const IN_CLASSB_MAX = 0x10000","const IN_CLASSB_NET = 0xffff0000","const IN_CLASSB_NSHIFT = 0x10","const IN_CLASSC_HOST = 0xff","const IN_CLASSC_NET = 0xffffff00","const IN_CLASSC_NSHIFT = 0x8","const IN_CLOEXEC = 0x80000","const IN_CLOSE = 0x18","const IN_CLOSE_NOWRITE = 0x10","const IN_CLOSE_WRITE = 0x8","const IN_CREATE = 0x100","const IN_DELETE = 0x200","const IN_DELETE_SELF = 0x400","const IN_DONT_FOLLOW = 0x2000000","const IN_EXCL_UNLINK = 0x4000000","const IN_IGNORED = 0x8000","const IN_ISDIR = 0x40000000","const IN_LOOPBACKNET = 0x7f","const IN_MASK_ADD = 0x20000000","const IN_MODIFY = 0x2","const IN_MOVE = 0xc0","const IN_MOVED_FROM = 0x40","const IN_MOVED_TO = 0x80","const IN_MOVE_SELF = 0x800","const IN_NONBLOCK = 0x800","const IN_ONESHOT = 0x80000000","const IN_ONLYDIR = 0x1000000","const IN_OPEN = 0x20","const IN_Q_OVERFLOW = 0x4000","const IN_UNMOUNT = 0x2000","const IPPROTO_AH = 0x33","const IPPROTO_COMP = 0x6c","const IPPROTO_DCCP = 0x21","const IPPROTO_DSTOPTS = 0x3c","const IPPROTO_EGP = 0x8","const IPPROTO_ENCAP = 0x62","const IPPROTO_ESP = 0x32","const IPPROTO_FRAGMENT = 0x2c","const IPPROTO_GRE = 0x2f","const IPPROTO_HOPOPTS = 0x0","const IPPROTO_ICMP = 0x1","const IPPROTO_ICMPV6 = 0x3a","const IPPROTO_IDP = 0x16","const IPPROTO_IGMP = 0x2","const IPPROTO_IP = 0x0","const IPPROTO_IPIP = 0x4","const IPPROTO_IPV6 = 0x29","const IPPROTO_MTP = 0x5c","const IPPROTO_NONE = 0x3b","const IPPROTO_PIM = 0x67","const IPPROTO_PUP = 0xc","const IPPROTO_RAW = 0xff","const IPPROTO_ROUTING = 0x2b","const IPPROTO_RSVP = 0x2e","const IPPROTO_SCTP = 0x84","const IPPROTO_TCP = 0x6","const IPPROTO_TP = 0x1d","const IPPROTO_UDP = 0x11","const IPPROTO_UDPLITE = 0x88","const IPV6_2292DSTOPTS = 0x4","const IPV6_2292HOPLIMIT = 0x8","const IPV6_2292HOPOPTS = 0x3","const IPV6_2292PKTINFO = 0x2","const IPV6_2292PKTOPTIONS = 0x6","const IPV6_2292RTHDR = 0x5","const IPV6_ADDRFORM = 0x1","const IPV6_ADD_MEMBERSHIP = 0x14","const IPV6_AUTHHDR = 0xa","const IPV6_CHECKSUM = 0x7","const IPV6_DROP_MEMBERSHIP = 0x15","const IPV6_DSTOPTS = 0x3b","const IPV6_HOPLIMIT = 0x34","const IPV6_HOPOPTS = 0x36","const IPV6_IPSEC_POLICY = 0x22","const IPV6_JOIN_ANYCAST = 0x1b","const IPV6_JOIN_GROUP = 0x14","const IPV6_LEAVE_ANYCAST = 0x1c","const IPV6_LEAVE_GROUP = 0x15","const IPV6_MTU = 0x18","const IPV6_MTU_DISCOVER = 0x17","const IPV6_MULTICAST_HOPS = 0x12","const IPV6_MULTICAST_IF = 0x11","const IPV6_MULTICAST_LOOP = 0x13","const IPV6_NEXTHOP = 0x9","const IPV6_PKTINFO = 0x32","const IPV6_PMTUDISC_DO = 0x2","const IPV6_PMTUDISC_DONT = 0x0","const IPV6_PMTUDISC_PROBE = 0x3","const IPV6_PMTUDISC_WANT = 0x1","const IPV6_RECVDSTOPTS = 0x3a","const IPV6_RECVERR = 0x19","const IPV6_RECVHOPLIMIT = 0x33","const IPV6_RECVHOPOPTS = 0x35","const IPV6_RECVPKTINFO = 0x31","const IPV6_RECVRTHDR = 0x38","const IPV6_RECVTCLASS = 0x42","const IPV6_ROUTER_ALERT = 0x16","const IPV6_RTHDR = 0x39","const IPV6_RTHDRDSTOPTS = 0x37","const IPV6_RTHDR_LOOSE = 0x0","const IPV6_RTHDR_STRICT = 0x1","const IPV6_RTHDR_TYPE_0 = 0x0","const IPV6_RXDSTOPTS = 0x3b","const IPV6_RXHOPOPTS = 0x36","const IPV6_TCLASS = 0x43","const IPV6_UNICAST_HOPS = 0x10","const IPV6_V6ONLY = 0x1a","const IPV6_XFRM_POLICY = 0x23","const IP_ADD_MEMBERSHIP = 0x23","const IP_ADD_SOURCE_MEMBERSHIP = 0x27","const IP_BLOCK_SOURCE = 0x26","const IP_DEFAULT_MULTICAST_LOOP = 0x1","const IP_DEFAULT_MULTICAST_TTL = 0x1","const IP_DF = 0x4000","const IP_DROP_MEMBERSHIP = 0x24","const IP_DROP_SOURCE_MEMBERSHIP = 0x28","const IP_FREEBIND = 0xf","const IP_HDRINCL = 0x3","const IP_IPSEC_POLICY = 0x10","const IP_MAXPACKET = 0xffff","const IP_MAX_MEMBERSHIPS = 0x14","const IP_MF = 0x2000","const IP_MINTTL = 0x15","const IP_MSFILTER = 0x29","const IP_MSS = 0x240","const IP_MTU = 0xe","const IP_MTU_DISCOVER = 0xa","const IP_MULTICAST_IF = 0x20","const IP_MULTICAST_LOOP = 0x22","const IP_MULTICAST_TTL = 0x21","const IP_OFFMASK = 0x1fff","const IP_OPTIONS = 0x4","const IP_ORIGDSTADDR = 0x14","const IP_PASSSEC = 0x12","const IP_PKTINFO = 0x8","const IP_PKTOPTIONS = 0x9","const IP_PMTUDISC = 0xa","const IP_PMTUDISC_DO = 0x2","const IP_PMTUDISC_DONT = 0x0","const IP_PMTUDISC_PROBE = 0x3","const IP_PMTUDISC_WANT = 0x1","const IP_RECVERR = 0xb","const IP_RECVOPTS = 0x6","const IP_RECVORIGDSTADDR = 0x14","const IP_RECVRETOPTS = 0x7","const IP_RECVTOS = 0xd","const IP_RECVTTL = 0xc","const IP_RETOPTS = 0x7","const IP_RF = 0x8000","const IP_ROUTER_ALERT = 0x5","const IP_TOS = 0x1","const IP_TRANSPARENT = 0x13","const IP_TTL = 0x2","const IP_UNBLOCK_SOURCE = 0x25","const IP_XFRM_POLICY = 0x11","const LINUX_REBOOT_CMD_CAD_OFF = 0x0","const LINUX_REBOOT_CMD_CAD_ON = 0x89abcdef","const LINUX_REBOOT_CMD_HALT = 0xcdef0123","const LINUX_REBOOT_CMD_KEXEC = 0x45584543","const LINUX_REBOOT_CMD_POWER_OFF = 0x4321fedc","const LINUX_REBOOT_CMD_RESTART = 0x1234567","const LINUX_REBOOT_CMD_RESTART2 = 0xa1b2c3d4","const LINUX_REBOOT_CMD_SW_SUSPEND = 0xd000fce2","const LINUX_REBOOT_MAGIC1 = 0xfee1dead","const LINUX_REBOOT_MAGIC2 = 0x28121969","const LOCK_EX = 0x2","const LOCK_NB = 0x4","const LOCK_SH = 0x1","const LOCK_UN = 0x8","const MADV_DOFORK = 0xb","const MADV_DONTFORK = 0xa","const MADV_DONTNEED = 0x4","const MADV_HUGEPAGE = 0xe","const MADV_HWPOISON = 0x64","const MADV_MERGEABLE = 0xc","const MADV_NOHUGEPAGE = 0xf","const MADV_NORMAL = 0x0","const MADV_RANDOM = 0x1","const MADV_REMOVE = 0x9","const MADV_SEQUENTIAL = 0x2","const MADV_UNMERGEABLE = 0xd","const MADV_WILLNEED = 0x3","const MAP_32BIT = 0x40","const MAP_ANON = 0x20","const MAP_ANONYMOUS = 0x20","const MAP_DENYWRITE = 0x800","const MAP_EXECUTABLE = 0x1000","const MAP_FILE = 0x0","const MAP_FIXED = 0x10","const MAP_GROWSDOWN = 0x100","const MAP_HUGETLB = 0x40000","const MAP_LOCKED = 0x2000","const MAP_NONBLOCK = 0x10000","const MAP_NORESERVE = 0x4000","const MAP_POPULATE = 0x8000","const MAP_PRIVATE = 0x2","const MAP_SHARED = 0x1","const MAP_STACK = 0x20000","const MAP_TYPE = 0xf","const MCL_CURRENT = 0x1","const MCL_FUTURE = 0x2","const MNT_DETACH = 0x2","const MNT_EXPIRE = 0x4","const MNT_FORCE = 0x1","const MSG_CMSG_CLOEXEC = 0x40000000","const MSG_CONFIRM = 0x800","const MSG_CTRUNC = 0x8","const MSG_DONTROUTE = 0x4","const MSG_DONTWAIT = 0x40","const MSG_EOR = 0x80","const MSG_ERRQUEUE = 0x2000","const MSG_FASTOPEN = 0x20000000","const MSG_FIN = 0x200","const MSG_MORE = 0x8000","const MSG_NOSIGNAL = 0x4000","const MSG_OOB = 0x1","const MSG_PEEK = 0x2","const MSG_PROXY = 0x10","const MSG_RST = 0x1000","const MSG_SYN = 0x400","const MSG_TRUNC = 0x20","const MSG_TRYHARD = 0x4","const MSG_WAITALL = 0x100","const MSG_WAITFORONE = 0x10000","const MS_ACTIVE = 0x40000000","const MS_ASYNC = 0x1","const MS_BIND = 0x1000","const MS_DIRSYNC = 0x80","const MS_INVALIDATE = 0x2","const MS_I_VERSION = 0x800000","const MS_KERNMOUNT = 0x400000","const MS_MANDLOCK = 0x40","const MS_MGC_MSK = 0xffff0000","const MS_MGC_VAL = 0xc0ed0000","const MS_MOVE = 0x2000","const MS_NOATIME = 0x400","const MS_NODEV = 0x4","const MS_NODIRATIME = 0x800","const MS_NOEXEC = 0x8","const MS_NOSUID = 0x2","","const MS_POSIXACL = 0x10000","const MS_PRIVATE = 0x40000","const MS_RDONLY = 0x1","const MS_REC = 0x4000","const MS_RELATIME = 0x200000","const MS_REMOUNT = 0x20","const MS_RMT_MASK = 0x800051","const MS_SHARED = 0x100000","const MS_SILENT = 0x8000","const MS_SLAVE = 0x80000","const MS_STRICTATIME = 0x1000000","const MS_SYNC = 0x4","const MS_SYNCHRONOUS = 0x10","const MS_UNBINDABLE = 0x20000","const NAME_MAX = 0xff","const NETLINK_ADD_MEMBERSHIP = 0x1","const NETLINK_AUDIT = 0x9","const NETLINK_BROADCAST_ERROR = 0x4","const NETLINK_CONNECTOR = 0xb","const NETLINK_DNRTMSG = 0xe","const NETLINK_DROP_MEMBERSHIP = 0x2","const NETLINK_ECRYPTFS = 0x13","const NETLINK_FIB_LOOKUP = 0xa","const NETLINK_FIREWALL = 0x3","const NETLINK_GENERIC = 0x10","const NETLINK_INET_DIAG = 0x4","const NETLINK_IP6_FW = 0xd","const NETLINK_ISCSI = 0x8","const NETLINK_KOBJECT_UEVENT = 0xf","const NETLINK_NETFILTER = 0xc","const NETLINK_NFLOG = 0x5","const NETLINK_NO_ENOBUFS = 0x5","const NETLINK_PKTINFO = 0x3","const NETLINK_ROUTE = 0x0","const NETLINK_SCSITRANSPORT = 0x12","const NETLINK_SELINUX = 0x7","const NETLINK_UNUSED = 0x1","const NETLINK_USERSOCK = 0x2","const NETLINK_XFRM = 0x6","const NLA_ALIGNTO = 0x4","const NLA_F_NESTED = 0x8000","const NLA_F_NET_BYTEORDER = 0x4000","const NLA_HDRLEN = 0x4","const NLMSG_ALIGNTO = 0x4","const NLMSG_DONE = 0x3","const NLMSG_ERROR = 0x2","const NLMSG_HDRLEN = 0x10","const NLMSG_MIN_TYPE = 0x10","const NLMSG_NOOP = 0x1","const NLMSG_OVERRUN = 0x4","const NLM_F_ACK = 0x4","const NLM_F_APPEND = 0x800","const NLM_F_ATOMIC = 0x400","const NLM_F_CREATE = 0x400","const NLM_F_DUMP = 0x300","const NLM_F_ECHO = 0x8","const NLM_F_EXCL = 0x200","const NLM_F_MATCH = 0x200","const NLM_F_MULTI = 0x2","const NLM_F_REPLACE = 0x100","const NLM_F_REQUEST = 0x1","const NLM_F_ROOT = 0x100","const O_ACCMODE = 0x3","const O_APPEND = 0x400","const O_ASYNC = 0x2000","const O_CLOEXEC = 0x80000","const O_CREAT = 0x40","const O_DIRECT = 0x4000","const O_DIRECTORY = 0x10000","const O_DSYNC = 0x1000","const O_EXCL = 0x80","const O_FSYNC = 0x101000","const O_LARGEFILE = 0x0","const O_NDELAY = 0x800","const O_NOATIME = 0x40000","const O_NOCTTY = 0x100","const O_NOFOLLOW = 0x20000","const O_NONBLOCK = 0x800","const O_RDONLY = 0x0","const O_RDWR = 0x2","const O_RSYNC = 0x101000","const O_SYNC = 0x101000","const O_TRUNC = 0x200","const O_WRONLY = 0x1","const PACKET_ADD_MEMBERSHIP = 0x1","const PACKET_BROADCAST = 0x1","const PACKET_DROP_MEMBERSHIP = 0x2","const PACKET_FASTROUTE = 0x6","const PACKET_HOST = 0x0","const PACKET_LOOPBACK = 0x5","const PACKET_MR_ALLMULTI = 0x2","const PACKET_MR_MULTICAST = 0x0","const PACKET_MR_PROMISC = 0x1","const PACKET_MULTICAST = 0x2","const PACKET_OTHERHOST = 0x3","const PACKET_OUTGOING = 0x4","const PACKET_RECV_OUTPUT = 0x3","const PACKET_RX_RING = 0x5","const PACKET_STATISTICS = 0x6","const PRIO_PGRP = 0x1","const PRIO_PROCESS = 0x0","const PRIO_USER = 0x2","const PROT_EXEC = 0x4","const PROT_GROWSDOWN = 0x1000000","const PROT_GROWSUP = 0x2000000","const PROT_NONE = 0x0","const PROT_READ = 0x1","const PROT_WRITE = 0x2","const PR_CAPBSET_DROP = 0x18","const PR_CAPBSET_READ = 0x17","const PR_ENDIAN_BIG = 0x0","const PR_ENDIAN_LITTLE = 0x1","const PR_ENDIAN_PPC_LITTLE = 0x2","const PR_FPEMU_NOPRINT = 0x1","const PR_FPEMU_SIGFPE = 0x2","const PR_FP_EXC_ASYNC = 0x2","const PR_FP_EXC_DISABLED = 0x0","const PR_FP_EXC_DIV = 0x10000","const PR_FP_EXC_INV = 0x100000","const PR_FP_EXC_NONRECOV = 0x1","const PR_FP_EXC_OVF = 0x20000","const PR_FP_EXC_PRECISE = 0x3","const PR_FP_EXC_RES = 0x80000","const PR_FP_EXC_SW_ENABLE = 0x80","const PR_FP_EXC_UND = 0x40000","const PR_GET_DUMPABLE = 0x3","const PR_GET_ENDIAN = 0x13","const PR_GET_FPEMU = 0x9","const PR_GET_FPEXC = 0xb","const PR_GET_KEEPCAPS = 0x7","const PR_GET_NAME = 0x10","const PR_GET_PDEATHSIG = 0x2","const PR_GET_SECCOMP = 0x15","const PR_GET_SECUREBITS = 0x1b","const PR_GET_TIMERSLACK = 0x1e","const PR_GET_TIMING = 0xd","const PR_GET_TSC = 0x19","const PR_GET_UNALIGN = 0x5","const PR_MCE_KILL = 0x21","const PR_MCE_KILL_CLEAR = 0x0","const PR_MCE_KILL_DEFAULT = 0x2","const PR_MCE_KILL_EARLY = 0x1","const PR_MCE_KILL_GET = 0x22","const PR_MCE_KILL_LATE = 0x0","const PR_MCE_KILL_SET = 0x1","const PR_SET_DUMPABLE = 0x4","const PR_SET_ENDIAN = 0x14","const PR_SET_FPEMU = 0xa","const PR_SET_FPEXC = 0xc","const PR_SET_KEEPCAPS = 0x8","const PR_SET_NAME = 0xf","const PR_SET_PDEATHSIG = 0x1","const PR_SET_PTRACER = 0x59616d61","const PR_SET_SECCOMP = 0x16","const PR_SET_SECUREBITS = 0x1c","const PR_SET_TIMERSLACK = 0x1d","const PR_SET_TIMING = 0xe","const PR_SET_TSC = 0x1a","const PR_SET_UNALIGN = 0x6","const PR_TASK_PERF_EVENTS_DISABLE = 0x1f","const PR_TASK_PERF_EVENTS_ENABLE = 0x20","const PR_TIMING_STATISTICAL = 0x0","const PR_TIMING_TIMESTAMP = 0x1","const PR_TSC_ENABLE = 0x1","const PR_TSC_SIGSEGV = 0x2","const PR_UNALIGN_NOPRINT = 0x1","const PR_UNALIGN_SIGBUS = 0x2","const PTRACE_ARCH_PRCTL = 0x1e","const PTRACE_ATTACH = 0x10","const PTRACE_CONT = 0x7","const PTRACE_DETACH = 0x11","const PTRACE_EVENT_CLONE = 0x3","const PTRACE_EVENT_EXEC = 0x4","const PTRACE_EVENT_EXIT = 0x6","const PTRACE_EVENT_FORK = 0x1","const PTRACE_EVENT_VFORK = 0x2","const PTRACE_EVENT_VFORK_DONE = 0x5","const PTRACE_GETEVENTMSG = 0x4201","const PTRACE_GETFPREGS = 0xe","const PTRACE_GETFPXREGS = 0x12","const PTRACE_GETREGS = 0xc","const PTRACE_GETREGSET = 0x4204","const PTRACE_GETSIGINFO = 0x4202","const PTRACE_GET_THREAD_AREA = 0x19","const PTRACE_KILL = 0x8","const PTRACE_OLDSETOPTIONS = 0x15","const PTRACE_O_MASK = 0x7f","const PTRACE_O_TRACECLONE = 0x8","const PTRACE_O_TRACEEXEC = 0x10","const PTRACE_O_TRACEEXIT = 0x40","const PTRACE_O_TRACEFORK = 0x2","const PTRACE_O_TRACESYSGOOD = 0x1","const PTRACE_O_TRACEVFORK = 0x4","const PTRACE_O_TRACEVFORKDONE = 0x20","const PTRACE_PEEKDATA = 0x2","const PTRACE_PEEKTEXT = 0x1","const PTRACE_PEEKUSR = 0x3","const PTRACE_POKEDATA = 0x5","const PTRACE_POKETEXT = 0x4","const PTRACE_POKEUSR = 0x6","const PTRACE_SETFPREGS = 0xf","const PTRACE_SETFPXREGS = 0x13","const PTRACE_SETOPTIONS = 0x4200","const PTRACE_SETREGS = 0xd","const PTRACE_SETREGSET = 0x4205","const PTRACE_SETSIGINFO = 0x4203","const PTRACE_SET_THREAD_AREA = 0x1a","const PTRACE_SINGLEBLOCK = 0x21","const PTRACE_SINGLESTEP = 0x9","const PTRACE_SYSCALL = 0x18","const PTRACE_SYSEMU = 0x1f","const PTRACE_SYSEMU_SINGLESTEP = 0x20","const PTRACE_TRACEME = 0x0","const RLIMIT_AS = 0x9","const RLIMIT_CORE = 0x4","const RLIMIT_CPU = 0x0","const RLIMIT_DATA = 0x2","const RLIMIT_FSIZE = 0x1","const RLIMIT_NOFILE = 0x7","const RLIMIT_STACK = 0x3","","const RTAX_ADVMSS = 0x8","const RTAX_CWND = 0x7","const RTAX_FEATURES = 0xc","const RTAX_FEATURE_ALLFRAG = 0x8","const RTAX_FEATURE_ECN = 0x1","const RTAX_FEATURE_SACK = 0x2","const RTAX_FEATURE_TIMESTAMP = 0x4","const RTAX_HOPLIMIT = 0xa","const RTAX_INITCWND = 0xb","const RTAX_INITRWND = 0xe","const RTAX_LOCK = 0x1","const RTAX_MAX = 0xe","const RTAX_MTU = 0x2","const RTAX_REORDERING = 0x9","const RTAX_RTO_MIN = 0xd","const RTAX_RTT = 0x4","const RTAX_RTTVAR = 0x5","const RTAX_SSTHRESH = 0x6","const RTAX_UNSPEC = 0x0","const RTAX_WINDOW = 0x3","const RTA_ALIGNTO = 0x4","const RTA_MAX = 0x10","const RTCF_DIRECTSRC = 0x4000000","const RTCF_DOREDIRECT = 0x1000000","const RTCF_LOG = 0x2000000","const RTCF_MASQ = 0x400000","const RTCF_NAT = 0x800000","const RTCF_VALVE = 0x200000","const RTF_ADDRCLASSMASK = 0xf8000000","const RTF_ADDRCONF = 0x40000","const RTF_ALLONLINK = 0x20000","const RTF_BROADCAST = 0x10000000","const RTF_CACHE = 0x1000000","const RTF_DEFAULT = 0x10000","const RTF_DYNAMIC = 0x10","const RTF_FLOW = 0x2000000","const RTF_GATEWAY = 0x2","const RTF_HOST = 0x4","const RTF_INTERFACE = 0x40000000","const RTF_IRTT = 0x100","const RTF_LINKRT = 0x100000","const RTF_LOCAL = 0x80000000","const RTF_MODIFIED = 0x20","const RTF_MSS = 0x40","const RTF_MTU = 0x40","const RTF_MULTICAST = 0x20000000","const RTF_NAT = 0x8000000","const RTF_NOFORWARD = 0x1000","const RTF_NONEXTHOP = 0x200000","const RTF_NOPMTUDISC = 0x4000","const RTF_POLICY = 0x4000000","const RTF_REINSTATE = 0x8","const RTF_REJECT = 0x200","const RTF_STATIC = 0x400","const RTF_THROW = 0x2000","const RTF_UP = 0x1","const RTF_WINDOW = 0x80","const RTF_XRESOLVE = 0x800","const RTM_BASE = 0x10","const RTM_DELACTION = 0x31","const RTM_DELADDR = 0x15","const RTM_DELADDRLABEL = 0x49","const RTM_DELLINK = 0x11","const RTM_DELNEIGH = 0x1d","const RTM_DELQDISC = 0x25","const RTM_DELROUTE = 0x19","const RTM_DELRULE = 0x21","const RTM_DELTCLASS = 0x29","const RTM_DELTFILTER = 0x2d","const RTM_F_CLONED = 0x200","const RTM_F_EQUALIZE = 0x400","const RTM_F_NOTIFY = 0x100","const RTM_F_PREFIX = 0x800","const RTM_GETACTION = 0x32","const RTM_GETADDR = 0x16","const RTM_GETADDRLABEL = 0x4a","const RTM_GETANYCAST = 0x3e","const RTM_GETDCB = 0x4e","const RTM_GETLINK = 0x12","const RTM_GETMULTICAST = 0x3a","const RTM_GETNEIGH = 0x1e","const RTM_GETNEIGHTBL = 0x42","const RTM_GETQDISC = 0x26","const RTM_GETROUTE = 0x1a","const RTM_GETRULE = 0x22","const RTM_GETTCLASS = 0x2a","const RTM_GETTFILTER = 0x2e","const RTM_MAX = 0x4f","const RTM_NEWACTION = 0x30","const RTM_NEWADDR = 0x14","const RTM_NEWADDRLABEL = 0x48","const RTM_NEWLINK = 0x10","const RTM_NEWNDUSEROPT = 0x44","const RTM_NEWNEIGH = 0x1c","const RTM_NEWNEIGHTBL = 0x40","const RTM_NEWPREFIX = 0x34","const RTM_NEWQDISC = 0x24","const RTM_NEWROUTE = 0x18","const RTM_NEWRULE = 0x20","const RTM_NEWTCLASS = 0x28","const RTM_NEWTFILTER = 0x2c","const RTM_NR_FAMILIES = 0x10","const RTM_NR_MSGTYPES = 0x40","const RTM_SETDCB = 0x4f","const RTM_SETLINK = 0x13","const RTM_SETNEIGHTBL = 0x43","const RTNH_ALIGNTO = 0x4","const RTNH_F_DEAD = 0x1","const RTNH_F_ONLINK = 0x4","const RTNH_F_PERVASIVE = 0x2","const RTN_MAX = 0xb","const RTPROT_BIRD = 0xc","const RTPROT_BOOT = 0x3","const RTPROT_DHCP = 0x10","const RTPROT_DNROUTED = 0xd","const RTPROT_GATED = 0x8","const RTPROT_KERNEL = 0x2","const RTPROT_MRT = 0xa","const RTPROT_NTK = 0xf","const RTPROT_RA = 0x9","const RTPROT_REDIRECT = 0x1","const RTPROT_STATIC = 0x4","const RTPROT_UNSPEC = 0x0","const RTPROT_XORP = 0xe","const RTPROT_ZEBRA = 0xb","const RT_CLASS_DEFAULT = 0xfd","const RT_CLASS_LOCAL = 0xff","const RT_CLASS_MAIN = 0xfe","const RT_CLASS_MAX = 0xff","const RT_CLASS_UNSPEC = 0x0","","const RUSAGE_SELF = 0x0","const RUSAGE_THREAD = 0x1","const SCM_CREDENTIALS = 0x2","const SCM_RIGHTS = 0x1","const SCM_TIMESTAMP = 0x1d","const SCM_TIMESTAMPING = 0x25","const SCM_TIMESTAMPNS = 0x23","const SHUT_RD = 0x0","const SHUT_RDWR = 0x2","const SHUT_WR = 0x1","const SIOCADDDLCI = 0x8980","const SIOCADDMULTI = 0x8931","const SIOCADDRT = 0x890b","const SIOCATMARK = 0x8905","const SIOCDARP = 0x8953","const SIOCDELDLCI = 0x8981","const SIOCDELMULTI = 0x8932","const SIOCDELRT = 0x890c","const SIOCDEVPRIVATE = 0x89f0","const SIOCDIFADDR = 0x8936","const SIOCDRARP = 0x8960","const SIOCGARP = 0x8954","const SIOCGIFADDR = 0x8915","const SIOCGIFBR = 0x8940","const SIOCGIFBRDADDR = 0x8919","const SIOCGIFCONF = 0x8912","const SIOCGIFCOUNT = 0x8938","const SIOCGIFDSTADDR = 0x8917","const SIOCGIFENCAP = 0x8925","const SIOCGIFFLAGS = 0x8913","const SIOCGIFHWADDR = 0x8927","const SIOCGIFINDEX = 0x8933","const SIOCGIFMAP = 0x8970","const SIOCGIFMEM = 0x891f","const SIOCGIFMETRIC = 0x891d","const SIOCGIFMTU = 0x8921","const SIOCGIFNAME = 0x8910","const SIOCGIFNETMASK = 0x891b","const SIOCGIFPFLAGS = 0x8935","const SIOCGIFSLAVE = 0x8929","const SIOCGIFTXQLEN = 0x8942","const SIOCGPGRP = 0x8904","const SIOCGRARP = 0x8961","const SIOCGSTAMP = 0x8906","const SIOCGSTAMPNS = 0x8907","const SIOCPROTOPRIVATE = 0x89e0","const SIOCRTMSG = 0x890d","const SIOCSARP = 0x8955","const SIOCSIFADDR = 0x8916","const SIOCSIFBR = 0x8941","const SIOCSIFBRDADDR = 0x891a","const SIOCSIFDSTADDR = 0x8918","const SIOCSIFENCAP = 0x8926","const SIOCSIFFLAGS = 0x8914","const SIOCSIFHWADDR = 0x8924","const SIOCSIFHWBROADCAST = 0x8937","const SIOCSIFLINK = 0x8911","const SIOCSIFMAP = 0x8971","const SIOCSIFMEM = 0x8920","const SIOCSIFMETRIC = 0x891e","const SIOCSIFMTU = 0x8922","const SIOCSIFNAME = 0x8923","const SIOCSIFNETMASK = 0x891c","const SIOCSIFPFLAGS = 0x8934","const SIOCSIFSLAVE = 0x8930","const SIOCSIFTXQLEN = 0x8943","const SIOCSPGRP = 0x8902","const SIOCSRARP = 0x8962","const SOCK_CLOEXEC = 0x80000","const SOCK_DCCP = 0x6","const SOCK_DGRAM = 0x2","const SOCK_NONBLOCK = 0x800","const SOCK_PACKET = 0xa","const SOCK_RAW = 0x3","const SOCK_RDM = 0x4","const SOCK_SEQPACKET = 0x5","const SOCK_STREAM = 0x1","const SOL_AAL = 0x109","const SOL_ATM = 0x108","const SOL_DECNET = 0x105","const SOL_ICMPV6 = 0x3a","const SOL_IP = 0x0","const SOL_IPV6 = 0x29","const SOL_IRDA = 0x10a","const SOL_PACKET = 0x107","const SOL_RAW = 0xff","const SOL_SOCKET = 0x1","const SOL_TCP = 0x6","const SOL_X25 = 0x106","const SOMAXCONN = 0x80","const SO_ACCEPTCONN = 0x1e","const SO_ATTACH_FILTER = 0x1a","const SO_BINDTODEVICE = 0x19","const SO_BROADCAST = 0x6","const SO_BSDCOMPAT = 0xe","const SO_DEBUG = 0x1","const SO_DETACH_FILTER = 0x1b","const SO_DOMAIN = 0x27","const SO_DONTROUTE = 0x5","const SO_ERROR = 0x4","const SO_KEEPALIVE = 0x9","const SO_LINGER = 0xd","const SO_MARK = 0x24","const SO_NO_CHECK = 0xb","const SO_OOBINLINE = 0xa","const SO_PASSCRED = 0x10","const SO_PASSSEC = 0x22","const SO_PEERCRED = 0x11","const SO_PEERNAME = 0x1c","const SO_PEERSEC = 0x1f","const SO_PRIORITY = 0xc","const SO_PROTOCOL = 0x26","const SO_RCVBUF = 0x8","const SO_RCVBUFFORCE = 0x21","const SO_RCVLOWAT = 0x12","const SO_RCVTIMEO = 0x14","const SO_REUSEADDR = 0x2","const SO_RXQ_OVFL = 0x28","const SO_SECURITY_AUTHENTICATION = 0x16","const SO_SECURITY_ENCRYPTION_NETWORK = 0x18","const SO_SECURITY_ENCRYPTION_TRANSPORT = 0x17","const SO_SNDBUF = 0x7","const SO_SNDBUFFORCE = 0x20","const SO_SNDLOWAT = 0x13","const SO_SNDTIMEO = 0x15","const SO_TIMESTAMP = 0x1d","const SO_TIMESTAMPING = 0x25","const SO_TIMESTAMPNS = 0x23","const SO_TYPE = 0x3","const S_BLKSIZE = 0x200","const S_IEXEC = 0x40","const S_IFBLK = 0x6000","const S_IFCHR = 0x2000","const S_IFDIR = 0x4000","const S_IFIFO = 0x1000","const S_IFLNK = 0xa000","const S_IFMT = 0xf000","const S_IFREG = 0x8000","const S_IFSOCK = 0xc000","const S_IREAD = 0x100","const S_IRGRP = 0x20","const S_IROTH = 0x4","const S_IRUSR = 0x100","const S_IRWXG = 0x38","const S_IRWXO = 0x7","const S_IRWXU = 0x1c0","const S_ISGID = 0x400","const S_ISUID = 0x800","const S_ISVTX = 0x200","const S_IWGRP = 0x10","const S_IWOTH = 0x2","const S_IWRITE = 0x80","const S_IWUSR = 0x80","const S_IXGRP = 0x8","const S_IXOTH = 0x1","const S_IXUSR = 0x40","const TCIFLUSH = 0x0","const TCIOFLUSH = 0x2","const TCOFLUSH = 0x1","const TCP_CONGESTION = 0xd","const TCP_CORK = 0x3","const TCP_DEFER_ACCEPT = 0x9","const TCP_INFO = 0xb","const TCP_KEEPCNT = 0x6","const TCP_KEEPIDLE = 0x4","const TCP_KEEPINTVL = 0x5","const TCP_LINGER2 = 0x8","const TCP_MAXSEG = 0x2","const TCP_MAXWIN = 0xffff","const TCP_MAX_WINSHIFT = 0xe","const TCP_MD5SIG = 0xe","const TCP_MD5SIG_MAXKEYLEN = 0x50","const TCP_MSS = 0x200","const TCP_NODELAY = 0x1","const TCP_QUICKACK = 0xc","const TCP_SYNCNT = 0x7","const TCP_WINDOW_CLAMP = 0xa","const TIOCCBRK = 0x5428","const TIOCCONS = 0x541d","const TIOCEXCL = 0x540c","const TIOCGDEV = 0x80045432","const TIOCGETD = 0x5424","const TIOCGICOUNT = 0x545d","const TIOCGLCKTRMIOS = 0x5456","const TIOCGPGRP = 0x540f","const TIOCGPTN = 0x80045430","const TIOCGRS485 = 0x542e","const TIOCGSERIAL = 0x541e","const TIOCGSID = 0x5429","const TIOCGSOFTCAR = 0x5419","const TIOCGWINSZ = 0x5413","const TIOCINQ = 0x541b","const TIOCLINUX = 0x541c","const TIOCMBIC = 0x5417","const TIOCMBIS = 0x5416","const TIOCMGET = 0x5415","const TIOCMIWAIT = 0x545c","const TIOCMSET = 0x5418","const TIOCM_CAR = 0x40","const TIOCM_CD = 0x40","const TIOCM_CTS = 0x20","const TIOCM_DSR = 0x100","const TIOCM_DTR = 0x2","const TIOCM_LE = 0x1","const TIOCM_RI = 0x80","const TIOCM_RNG = 0x80","const TIOCM_RTS = 0x4","const TIOCM_SR = 0x10","const TIOCM_ST = 0x8","const TIOCNOTTY = 0x5422","const TIOCNXCL = 0x540d","const TIOCOUTQ = 0x5411","const TIOCPKT = 0x5420","const TIOCPKT_DATA = 0x0","const TIOCPKT_DOSTOP = 0x20","const TIOCPKT_FLUSHREAD = 0x1","const TIOCPKT_FLUSHWRITE = 0x2","const TIOCPKT_IOCTL = 0x40","const TIOCPKT_NOSTOP = 0x10","const TIOCPKT_START = 0x8","const TIOCPKT_STOP = 0x4","const TIOCSBRK = 0x5427","const TIOCSCTTY = 0x540e","const TIOCSERCONFIG = 0x5453","const TIOCSERGETLSR = 0x5459","const TIOCSERGETMULTI = 0x545a","const TIOCSERGSTRUCT = 0x5458","const TIOCSERGWILD = 0x5454","const TIOCSERSETMULTI = 0x545b","const TIOCSERSWILD = 0x5455","const TIOCSER_TEMT = 0x1","const TIOCSETD = 0x5423","const TIOCSIG = 0x40045436","const TIOCSLCKTRMIOS = 0x5457","const TIOCSPGRP = 0x5410","const TIOCSPTLCK = 0x40045431","const TIOCSRS485 = 0x542f","const TIOCSSERIAL = 0x541f","const TIOCSSOFTCAR = 0x541a","const TIOCSTI = 0x5412","const TIOCSWINSZ = 0x5414","const TUNATTACHFILTER = 0x401054d5","const TUNDETACHFILTER = 0x401054d6","const TUNGETFEATURES = 0x800454cf","const TUNGETIFF = 0x800454d2","const TUNGETSNDBUF = 0x800454d3","const TUNGETVNETHDRSZ = 0x800454d7","const TUNSETDEBUG = 0x400454c9","const TUNSETGROUP = 0x400454ce","const TUNSETIFF = 0x400454ca","const TUNSETLINK = 0x400454cd","const TUNSETNOCSUM = 0x400454c8","const TUNSETOFFLOAD = 0x400454d0","const TUNSETOWNER = 0x400454cc","const TUNSETPERSIST = 0x400454cb","const TUNSETSNDBUF = 0x400454d4","const TUNSETTXFILTER = 0x400454d1","const TUNSETVNETHDRSZ = 0x400454d8","const WALL = 0x40000000","const WCLONE = 0x80000000","const WCONTINUED = 0x8","const WEXITED = 0x4","const WNOHANG = 0x1","const WNOTHREAD = 0x20000000","const WNOWAIT = 0x1000000","const WORDSIZE = 0x40","const WSTOPPED = 0x2","const WUNTRACED = 0x2","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","func Getcwd(buf []byte) (n int, err error)","func Acct(path string) (err error)","func Adjtimex(buf *Timex) (state int, err error)","func Chdir(path string) (err error)","func Chroot(path string) (err error)","func Close(fd int) (err error)","func Dup(oldfd int) (fd int, err error)","func Dup3(oldfd int, newfd int, flags int) (err error)","func EpollCreate1(flag int) (fd int, err error)","func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)","func Fallocate(fd int, mode uint32, off int64, len int64) (err error)","func Fchdir(fd int) (err error)","func Fchmod(fd int, mode uint32) (err error)","func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)","func Fdatasync(fd int) (err error)","func Flock(fd int, how int) (err error)","func Fsync(fd int) (err error)","func Getdents(fd int, buf []byte) (n int, err error)","func Getpgid(pid int) (pgid int, err error)","func Getpid() (pid int)","func Getppid() (ppid int)","func Getpriority(which int, who int) (prio int, err error)","func Getrusage(who int, rusage *Rusage) (err error)","func Gettid() (tid int)","func Getxattr(path string, attr string, dest []byte) (sz int, err error)","func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)","func InotifyInit1(flags int) (fd int, err error)","func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)","func Kill(pid int, sig Signal) (err error)","func Klogctl(typ int, buf []byte) (n int, err error)","func Listxattr(path string, dest []byte) (sz int, err error)","func Mkdirat(dirfd int, path string, mode uint32) (err error)","func Mknodat(dirfd int, path string, mode uint32, dev int) (err error)","func Nanosleep(time *Timespec, leftover *Timespec) (err error)","func PivotRoot(newroot string, putold string) (err error)","func Removexattr(path string, attr string) (err error)","func Setdomainname(p []byte) (err error)","func Sethostname(p []byte) (err error)","func Setpgid(pid int, pgid int) (err error)","func Setsid() (pid int, err error)","func Settimeofday(tv *Timeval) (err error)","func Setpriority(which int, who int, prio int) (err error)","func Setxattr(path string, attr string, data []byte, flags int) (err error)","func Sync()","func Sysinfo(info *Sysinfo_t) (err error)","func Tee(rfd int, wfd int, len int, flags int) (n int64, err error)","func Tgkill(tgid int, tid int, sig Signal) (err error)","func Times(tms *Tms) (ticks uintptr, err error)","func Umask(mask int) (oldmask int)","func Uname(buf *Utsname) (err error)","func Unmount(target string, flags int) (err error)","func Unshare(flags int) (err error)","func Madvise(b []byte, advice int) (err error)","func Mprotect(b []byte, prot int) (err error)","func Mlock(b []byte) (err error)","func Munlock(b []byte) (err error)","func Mlockall(flags int) (err error)","func Munlockall() (err error)","func Dup2(oldfd int, newfd int) (err error)","func Fchown(fd int, uid int, gid int) (err error)","func Fstat(fd int, stat *Stat_t) (err error)","func Fstatfs(fd int, buf *Statfs_t) (err error)","func Ftruncate(fd int, length int64) (err error)","func Getegid() (egid int)","func Geteuid() (euid int)","func Getgid() (gid int)","func Getrlimit(resource int, rlim *Rlimit) (err error)","func Getuid() (uid int)","func InotifyInit() (fd int, err error)","func Ioperm(from int, num int, on int) (err error)","func Iopl(level int) (err error)","func Listen(s int, n int) (err error)","func Pause() (err error)","func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)","func Seek(fd int, offset int64, whence int) (off int64, err error)","func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)","func Setfsgid(gid int) (err error)","func Setfsuid(uid int) (err error)","func Shutdown(fd int, how int) (err error)","func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)","func Statfs(path string, buf *Statfs_t) (err error)","func SyncFileRange(fd int, off int64, n int64, flags int) (err error)","func Truncate(path string, length int64) (err error)","func Ustat(dev int, ubuf *Ustat_t) (err error)","func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)","func Utime(path string, buf *Utimbuf) (err error)","const SYS_READ = 0","const SYS_WRITE = 1","const SYS_OPEN = 2","const SYS_CLOSE = 3","const SYS_STAT = 4","const SYS_FSTAT = 5","const SYS_LSTAT = 6","const SYS_POLL = 7","const SYS_LSEEK = 8","const SYS_MMAP = 9","const SYS_MPROTECT = 10","const SYS_MUNMAP = 11","const SYS_BRK = 12","const SYS_RT_SIGACTION = 13","const SYS_RT_SIGPROCMASK = 14","const SYS_RT_SIGRETURN = 15","const SYS_IOCTL = 16","const SYS_PREAD64 = 17","const SYS_PWRITE64 = 18","const SYS_READV = 19","const SYS_WRITEV = 20","const SYS_ACCESS = 21","const SYS_PIPE = 22","const SYS_SELECT = 23","const SYS_SCHED_YIELD = 24","const SYS_MREMAP = 25","const SYS_MSYNC = 26","const SYS_MINCORE = 27","const SYS_MADVISE = 28","const SYS_SHMGET = 29","const SYS_SHMAT = 30","const SYS_SHMCTL = 31","const SYS_DUP = 32","const SYS_DUP2 = 33","const SYS_PAUSE = 34","const SYS_NANOSLEEP = 35","const SYS_GETITIMER = 36","const SYS_ALARM = 37","const SYS_SETITIMER = 38","const SYS_GETPID = 39","const SYS_SENDFILE = 40","const SYS_SOCKET = 41","const SYS_CONNECT = 42","const SYS_ACCEPT = 43","const SYS_SENDTO = 44","const SYS_RECVFROM = 45","const SYS_SENDMSG = 46","const SYS_RECVMSG = 47","const SYS_SHUTDOWN = 48","const SYS_BIND = 49","const SYS_LISTEN = 50","const SYS_GETSOCKNAME = 51","const SYS_GETPEERNAME = 52","const SYS_SOCKETPAIR = 53","const SYS_SETSOCKOPT = 54","const SYS_GETSOCKOPT = 55","const SYS_CLONE = 56","const SYS_FORK = 57","const SYS_VFORK = 58","const SYS_EXECVE = 59","const SYS_EXIT = 60","const SYS_WAIT4 = 61","const SYS_KILL = 62","const SYS_UNAME = 63","const SYS_SEMGET = 64","const SYS_SEMOP = 65","const SYS_SEMCTL = 66","const SYS_SHMDT = 67","const SYS_MSGGET = 68","const SYS_MSGSND = 69","const SYS_MSGRCV = 70","const SYS_MSGCTL = 71","const SYS_FCNTL = 72","const SYS_FLOCK = 73","const SYS_FSYNC = 74","const SYS_FDATASYNC = 75","const SYS_TRUNCATE = 76","const SYS_FTRUNCATE = 77","const SYS_GETDENTS = 78","const SYS_GETCWD = 79","const SYS_CHDIR = 80","const SYS_FCHDIR = 81","const SYS_RENAME = 82","const SYS_MKDIR = 83","const SYS_RMDIR = 84","const SYS_CREAT = 85","const SYS_LINK = 86","const SYS_UNLINK = 87","const SYS_SYMLINK = 88","const SYS_READLINK = 89","const SYS_CHMOD = 90","const SYS_FCHMOD = 91","const SYS_CHOWN = 92","const SYS_FCHOWN = 93","const SYS_LCHOWN = 94","const SYS_UMASK = 95","const SYS_GETTIMEOFDAY = 96","const SYS_GETRLIMIT = 97","const SYS_GETRUSAGE = 98","const SYS_SYSINFO = 99","const SYS_TIMES = 100","const SYS_PTRACE = 101","const SYS_GETUID = 102","const SYS_SYSLOG = 103","const SYS_GETGID = 104","const SYS_SETUID = 105","const SYS_SETGID = 106","const SYS_GETEUID = 107","const SYS_GETEGID = 108","const SYS_SETPGID = 109","const SYS_GETPPID = 110","const SYS_GETPGRP = 111","const SYS_SETSID = 112","const SYS_SETREUID = 113","const SYS_SETREGID = 114","const SYS_GETGROUPS = 115","const SYS_SETGROUPS = 116","const SYS_SETRESUID = 117","const SYS_GETRESUID = 118","const SYS_SETRESGID = 119","const SYS_GETRESGID = 120","const SYS_GETPGID = 121","const SYS_SETFSUID = 122","const SYS_SETFSGID = 123","const SYS_GETSID = 124","const SYS_CAPGET = 125","const SYS_CAPSET = 126","const SYS_RT_SIGPENDING = 127","const SYS_RT_SIGTIMEDWAIT = 128","const SYS_RT_SIGQUEUEINFO = 129","const SYS_RT_SIGSUSPEND = 130","const SYS_SIGALTSTACK = 131","const SYS_UTIME = 132","const SYS_MKNOD = 133","const SYS_USELIB = 134","const SYS_PERSONALITY = 135","const SYS_USTAT = 136","const SYS_STATFS = 137","const SYS_FSTATFS = 138","const SYS_SYSFS = 139","const SYS_GETPRIORITY = 140","const SYS_SETPRIORITY = 141","const SYS_SCHED_SETPARAM = 142","const SYS_SCHED_GETPARAM = 143","const SYS_SCHED_SETSCHEDULER = 144","const SYS_SCHED_GETSCHEDULER = 145","const SYS_SCHED_GET_PRIORITY_MAX = 146","const SYS_SCHED_GET_PRIORITY_MIN = 147","const SYS_SCHED_RR_GET_INTERVAL = 148","const SYS_MLOCK = 149","const SYS_MUNLOCK = 150","const SYS_MLOCKALL = 151","const SYS_MUNLOCKALL = 152","const SYS_VHANGUP = 153","const SYS_MODIFY_LDT = 154","const SYS_PIVOT_ROOT = 155","const SYS__SYSCTL = 156","const SYS_PRCTL = 157","const SYS_ARCH_PRCTL = 158","const SYS_ADJTIMEX = 159","const SYS_SETRLIMIT = 160","const SYS_CHROOT = 161","const SYS_SYNC = 162","const SYS_ACCT = 163","const SYS_SETTIMEOFDAY = 164","const SYS_MOUNT = 165","const SYS_UMOUNT2 = 166","const SYS_SWAPON = 167","const SYS_SWAPOFF = 168","const SYS_REBOOT = 169","const SYS_SETHOSTNAME = 170","const SYS_SETDOMAINNAME = 171","const SYS_IOPL = 172","const SYS_IOPERM = 173","const SYS_CREATE_MODULE = 174","const SYS_INIT_MODULE = 175","const SYS_DELETE_MODULE = 176","const SYS_GET_KERNEL_SYMS = 177","const SYS_QUERY_MODULE = 178","const SYS_QUOTACTL = 179","const SYS_NFSSERVCTL = 180","const SYS_GETPMSG = 181","const SYS_PUTPMSG = 182","const SYS_AFS_SYSCALL = 183","const SYS_TUXCALL = 184","const SYS_SECURITY = 185","const SYS_GETTID = 186","const SYS_READAHEAD = 187","const SYS_SETXATTR = 188","const SYS_LSETXATTR = 189","const SYS_FSETXATTR = 190","const SYS_GETXATTR = 191","const SYS_LGETXATTR = 192","const SYS_FGETXATTR = 193","const SYS_LISTXATTR = 194","const SYS_LLISTXATTR = 195","const SYS_FLISTXATTR = 196","const SYS_REMOVEXATTR = 197","const SYS_LREMOVEXATTR = 198","const SYS_FREMOVEXATTR = 199","const SYS_TKILL = 200","const SYS_TIME = 201","const SYS_FUTEX = 202","const SYS_SCHED_SETAFFINITY = 203","const SYS_SCHED_GETAFFINITY = 204","const SYS_SET_THREAD_AREA = 205","const SYS_IO_SETUP = 206","const SYS_IO_DESTROY = 207","const SYS_IO_GETEVENTS = 208","const SYS_IO_SUBMIT = 209","const SYS_IO_CANCEL = 210","const SYS_GET_THREAD_AREA = 211","const SYS_LOOKUP_DCOOKIE = 212","const SYS_EPOLL_CREATE = 213","const SYS_EPOLL_CTL_OLD = 214","const SYS_EPOLL_WAIT_OLD = 215","const SYS_REMAP_FILE_PAGES = 216","const SYS_GETDENTS64 = 217","const SYS_SET_TID_ADDRESS = 218","const SYS_RESTART_SYSCALL = 219","const SYS_SEMTIMEDOP = 220","const SYS_FADVISE64 = 221","const SYS_TIMER_CREATE = 222","const SYS_TIMER_SETTIME = 223","const SYS_TIMER_GETTIME = 224","const SYS_TIMER_GETOVERRUN = 225","const SYS_TIMER_DELETE = 226","const SYS_CLOCK_SETTIME = 227","const SYS_CLOCK_GETTIME = 228","const SYS_CLOCK_GETRES = 229","const SYS_CLOCK_NANOSLEEP = 230","const SYS_EXIT_GROUP = 231","const SYS_EPOLL_WAIT = 232","const SYS_EPOLL_CTL = 233","const SYS_TGKILL = 234","const SYS_UTIMES = 235","const SYS_VSERVER = 236","const SYS_MBIND = 237","const SYS_SET_MEMPOLICY = 238","const SYS_GET_MEMPOLICY = 239","const SYS_MQ_OPEN = 240","const SYS_MQ_UNLINK = 241","const SYS_MQ_TIMEDSEND = 242","const SYS_MQ_TIMEDRECEIVE = 243","const SYS_MQ_NOTIFY = 244","const SYS_MQ_GETSETATTR = 245","const SYS_KEXEC_LOAD = 246","const SYS_WAITID = 247","const SYS_ADD_KEY = 248","const SYS_REQUEST_KEY = 249","const SYS_KEYCTL = 250","const SYS_IOPRIO_SET = 251","const SYS_IOPRIO_GET = 252","const SYS_INOTIFY_INIT = 253","const SYS_INOTIFY_ADD_WATCH = 254","const SYS_INOTIFY_RM_WATCH = 255","const SYS_MIGRATE_PAGES = 256","const SYS_OPENAT = 257","const SYS_MKDIRAT = 258","const SYS_MKNODAT = 259","const SYS_FCHOWNAT = 260","const SYS_FUTIMESAT = 261","const SYS_NEWFSTATAT = 262","const SYS_UNLINKAT = 263","const SYS_RENAMEAT = 264","const SYS_LINKAT = 265","const SYS_SYMLINKAT = 266","const SYS_READLINKAT = 267","const SYS_FCHMODAT = 268","const SYS_FACCESSAT = 269","const SYS_PSELECT6 = 270","const SYS_PPOLL = 271","const SYS_UNSHARE = 272","const SYS_SET_ROBUST_LIST = 273","const SYS_GET_ROBUST_LIST = 274","const SYS_SPLICE = 275","const SYS_TEE = 276","const SYS_SYNC_FILE_RANGE = 277","const SYS_VMSPLICE = 278","const SYS_MOVE_PAGES = 279","const SYS_UTIMENSAT = 280","const SYS_EPOLL_PWAIT = 281","const SYS_SIGNALFD = 282","const SYS_TIMERFD_CREATE = 283","const SYS_EVENTFD = 284","const SYS_FALLOCATE = 285","const SYS_TIMERFD_SETTIME = 286","const SYS_TIMERFD_GETTIME = 287","const SYS_ACCEPT4 = 288","const SYS_SIGNALFD4 = 289","const SYS_EVENTFD2 = 290","const SYS_EPOLL_CREATE1 = 291","const SYS_DUP3 = 292","const SYS_PIPE2 = 293","const SYS_INOTIFY_INIT1 = 294","const SYS_PREADV = 295","const SYS_PWRITEV = 296","const SYS_RT_TGSIGQUEUEINFO = 297","const SYS_PERF_EVENT_OPEN = 298","const SYS_RECVMMSG = 299","const SYS_FANOTIFY_INIT = 300","const SYS_FANOTIFY_MARK = 301","const SYS_PRLIMIT64 = 302","const PathMax = 0x1000","type Timespec struct {\n\tSec\tint64\n\tNsec\tint64\n}","type Timeval struct {\n\tSec\tint64\n\tUsec\tint64\n}","type Timex struct {\n\tModes\t\tuint32\n\tPad_cgo_0\t[4]byte\n\tOffset\t\tint64\n\tFreq\t\tint64\n\tMaxerror\tint64\n\tEsterror\tint64\n\tStatus\t\tint32\n\tPad_cgo_1\t[4]byte\n\tConstant\tint64\n\tPrecision\tint64\n\tTolerance\tint64\n\tTime\t\tTimeval\n\tTick\t\tint64\n\tPpsfreq\t\tint64\n\tJitter\t\tint64\n\tShift\t\tint32\n\tPad_cgo_2\t[4]byte\n\tStabil\t\tint64\n\tJitcnt\t\tint64\n\tCalcnt\t\tint64\n\tErrcnt\t\tint64\n\tStbcnt\t\tint64\n\tTai\t\tint32\n\tPad_cgo_3\t[44]byte\n}","","type Tms struct {\n\tUtime\tint64\n\tStime\tint64\n\tCutime\tint64\n\tCstime\tint64\n}","type Utimbuf struct {\n\tActime\tint64\n\tModtime\tint64\n}","type Rusage struct {\n\tUtime\t\tTimeval\n\tStime\t\tTimeval\n\tMaxrss\t\tint64\n\tIxrss\t\tint64\n\tIdrss\t\tint64\n\tIsrss\t\tint64\n\tMinflt\t\tint64\n\tMajflt\t\tint64\n\tNswap\t\tint64\n\tInblock\t\tint64\n\tOublock\t\tint64\n\tMsgsnd\t\tint64\n\tMsgrcv\t\tint64\n\tNsignals\tint64\n\tNvcsw\t\tint64\n\tNivcsw\t\tint64\n}","type Rlimit struct {\n\tCur\tuint64\n\tMax\tuint64\n}","type Stat_t struct {\n\tDev\t\tuint64\n\tIno\t\tuint64\n\tNlink\t\tuint64\n\tMode\t\tuint32\n\tUid\t\tuint32\n\tGid\t\tuint32\n\tX__pad0\t\tint32\n\tRdev\t\tuint64\n\tSize\t\tint64\n\tBlksize\t\tint64\n\tBlocks\t\tint64\n\tAtim\t\tTimespec\n\tMtim\t\tTimespec\n\tCtim\t\tTimespec\n\tX__unused\t[3]int64\n}","type Statfs_t struct {\n\tType\tint64\n\tBsize\tint64\n\tBlocks\tuint64\n\tBfree\tuint64\n\tBavail\tuint64\n\tFiles\tuint64\n\tFfree\tuint64\n\tFsid\tFsid\n\tNamelen\tint64\n\tFrsize\tint64\n\tFlags\tint64\n\tSpare\t[4]int64\n}","type Dirent struct {\n\tIno\t\tuint64\n\tOff\t\tint64\n\tReclen\t\tuint16\n\tType\t\tuint8\n\tName\t\t[256]int8\n\tPad_cgo_0\t[5]byte\n}","type Fsid struct {\n\tX__val [2]int32\n}","type Flock_t struct {\n\tType\t\tint16\n\tWhence\t\tint16\n\tPad_cgo_0\t[4]byte\n\tStart\t\tint64\n\tLen\t\tint64\n\tPid\t\tint32\n\tPad_cgo_1\t[4]byte\n}","type RawSockaddrInet4 struct {\n\tFamily\tuint16\n\tPort\tuint16\n\tAddr\t[4]byte\t/* in_addr */\n\tZero\t[8]uint8\n}","type RawSockaddrInet6 struct {\n\tFamily\t\tuint16\n\tPort\t\tuint16\n\tFlowinfo\tuint32\n\tAddr\t\t[16]byte\t/* in6_addr */\n\tScope_id\tuint32\n}","type RawSockaddrUnix struct {\n\tFamily\tuint16\n\tPath\t[108]int8\n}","type RawSockaddrLinklayer struct {\n\tFamily\t\tuint16\n\tProtocol\tuint16\n\tIfindex\t\tint32\n\tHatype\t\tuint16\n\tPkttype\t\tuint8\n\tHalen\t\tuint8\n\tAddr\t\t[8]uint8\n}","type RawSockaddrNetlink struct {\n\tFamily\tuint16\n\tPad\tuint16\n\tPid\tuint32\n\tGroups\tuint32\n}","type RawSockaddr struct {\n\tFamily\tuint16\n\tData\t[14]int8\n}","type RawSockaddrAny struct {\n\tAddr\tRawSockaddr\n\tPad\t[96]int8\n}","type Linger struct {\n\tOnoff\tint32\n\tLinger\tint32\n}","type Iovec struct {\n\tBase\t*byte\n\tLen\tuint64\n}","type IPMreq struct {\n\tMultiaddr\t[4]byte\t/* in_addr */\n\tInterface\t[4]byte\t/* in_addr */\n}","type IPMreqn struct {\n\tMultiaddr\t[4]byte\t/* in_addr */\n\tAddress\t\t[4]byte\t/* in_addr */\n\tIfindex\t\tint32\n}","type IPv6Mreq struct {\n\tMultiaddr\t[16]byte\t/* in6_addr */\n\tInterface\tuint32\n}","type Msghdr struct {\n\tName\t\t*byte\n\tNamelen\t\tuint32\n\tPad_cgo_0\t[4]byte\n\tIov\t\t*Iovec\n\tIovlen\t\tuint64\n\tControl\t\t*byte\n\tControllen\tuint64\n\tFlags\t\tint32\n\tPad_cgo_1\t[4]byte\n}","type Cmsghdr struct {\n\tLen\tuint64\n\tLevel\tint32\n\tType\tint32\n}","type Inet4Pktinfo struct {\n\tIfindex\t\tint32\n\tSpec_dst\t[4]byte\t/* in_addr */\n\tAddr\t\t[4]byte\t/* in_addr */\n}","type Inet6Pktinfo struct {\n\tAddr\t[16]byte\t/* in6_addr */\n\tIfindex\tuint32\n}","type IPv6MTUInfo struct {\n\tAddr\tRawSockaddrInet6\n\tMtu\tuint32\n}","type ICMPv6Filter struct {\n\tData [8]uint32\n}","type Ucred struct {\n\tPid\tint32\n\tUid\tuint32\n\tGid\tuint32\n}","type TCPInfo struct {\n\tState\t\tuint8\n\tCa_state\tuint8\n\tRetransmits\tuint8\n\tProbes\t\tuint8\n\tBackoff\t\tuint8\n\tOptions\t\tuint8\n\tPad_cgo_0\t[2]byte\n\tRto\t\tuint32\n\tAto\t\tuint32\n\tSnd_mss\t\tuint32\n\tRcv_mss\t\tuint32\n\tUnacked\t\tuint32\n\tSacked\t\tuint32\n\tLost\t\tuint32\n\tRetrans\t\tuint32\n\tFackets\t\tuint32\n\tLast_data_sent\tuint32\n\tLast_ack_sent\tuint32\n\tLast_data_recv\tuint32\n\tLast_ack_recv\tuint32\n\tPmtu\t\tuint32\n\tRcv_ssthresh\tuint32\n\tRtt\t\tuint32\n\tRttvar\t\tuint32\n\tSnd_ssthresh\tuint32\n\tSnd_cwnd\tuint32\n\tAdvmss\t\tuint32\n\tReordering\tuint32\n\tRcv_rtt\t\tuint32\n\tRcv_space\tuint32\n\tTotal_retrans\tuint32\n}","const SizeofSockaddrInet4 = 0x10","const SizeofSockaddrInet6 = 0x1c","const SizeofSockaddrAny = 0x70","const SizeofSockaddrUnix = 0x6e","const SizeofSockaddrLinklayer = 0x14","const SizeofSockaddrNetlink = 0xc","const SizeofLinger = 0x8","const SizeofIPMreq = 0x8","const SizeofIPMreqn = 0xc","const SizeofIPv6Mreq = 0x14","const SizeofMsghdr = 0x38","const SizeofCmsghdr = 0x10","const SizeofInet4Pktinfo = 0xc","const SizeofInet6Pktinfo = 0x14","const SizeofIPv6MTUInfo = 0x20","const SizeofICMPv6Filter = 0x20","const SizeofUcred = 0xc","const SizeofTCPInfo = 0x68","const IFA_UNSPEC = 0x0","const IFA_ADDRESS = 0x1","const IFA_LOCAL = 0x2","const IFA_LABEL = 0x3","const IFA_BROADCAST = 0x4","const IFA_ANYCAST = 0x5","const IFA_CACHEINFO = 0x6","const IFA_MULTICAST = 0x7","const IFLA_UNSPEC = 0x0","const IFLA_ADDRESS = 0x1","const IFLA_BROADCAST = 0x2","const IFLA_IFNAME = 0x3","const IFLA_MTU = 0x4","const IFLA_LINK = 0x5","const IFLA_QDISC = 0x6","const IFLA_STATS = 0x7","const IFLA_COST = 0x8","const IFLA_PRIORITY = 0x9","const IFLA_MASTER = 0xa","const IFLA_WIRELESS = 0xb","const IFLA_PROTINFO = 0xc","const IFLA_TXQLEN = 0xd","const IFLA_MAP = 0xe","const IFLA_WEIGHT = 0xf","const IFLA_OPERSTATE = 0x10","const IFLA_LINKMODE = 0x11","const IFLA_LINKINFO = 0x12","const IFLA_NET_NS_PID = 0x13","const IFLA_IFALIAS = 0x14","const IFLA_MAX = 0x1d","const RT_SCOPE_UNIVERSE = 0x0","const RT_SCOPE_SITE = 0xc8","const RT_SCOPE_LINK = 0xfd","const RT_SCOPE_HOST = 0xfe","const RT_SCOPE_NOWHERE = 0xff","const RT_TABLE_UNSPEC = 0x0","const RT_TABLE_COMPAT = 0xfc","const RT_TABLE_DEFAULT = 0xfd","const RT_TABLE_MAIN = 0xfe","const RT_TABLE_LOCAL = 0xff","const RT_TABLE_MAX = 0xffffffff","const RTA_UNSPEC = 0x0","const RTA_DST = 0x1","const RTA_SRC = 0x2","const RTA_IIF = 0x3","const RTA_OIF = 0x4","const RTA_GATEWAY = 0x5","const RTA_PRIORITY = 0x6","const RTA_PREFSRC = 0x7","const RTA_METRICS = 0x8","const RTA_MULTIPATH = 0x9","const RTA_FLOW = 0xb","const RTA_CACHEINFO = 0xc","const RTA_TABLE = 0xf","const RTN_UNSPEC = 0x0","const RTN_UNICAST = 0x1","const RTN_LOCAL = 0x2","const RTN_BROADCAST = 0x3","const RTN_ANYCAST = 0x4","const RTN_MULTICAST = 0x5","const RTN_BLACKHOLE = 0x6","const RTN_UNREACHABLE = 0x7","const RTN_PROHIBIT = 0x8","const RTN_THROW = 0x9","const RTN_NAT = 0xa","const RTN_XRESOLVE = 0xb","const RTNLGRP_NONE = 0x0","const RTNLGRP_LINK = 0x1","const RTNLGRP_NOTIFY = 0x2","const RTNLGRP_NEIGH = 0x3","const RTNLGRP_TC = 0x4","const RTNLGRP_IPV4_IFADDR = 0x5","const RTNLGRP_IPV4_MROUTE = 0x6","const RTNLGRP_IPV4_ROUTE = 0x7","const RTNLGRP_IPV4_RULE = 0x8","const RTNLGRP_IPV6_IFADDR = 0x9","const RTNLGRP_IPV6_MROUTE = 0xa","const RTNLGRP_IPV6_ROUTE = 0xb","const RTNLGRP_IPV6_IFINFO = 0xc","const RTNLGRP_IPV6_PREFIX = 0x12","const RTNLGRP_IPV6_RULE = 0x13","const RTNLGRP_ND_USEROPT = 0x14","const SizeofNlMsghdr = 0x10","const SizeofNlMsgerr = 0x14","const SizeofRtGenmsg = 0x1","const SizeofNlAttr = 0x4","const SizeofRtAttr = 0x4","const SizeofIfInfomsg = 0x10","const SizeofIfAddrmsg = 0x8","const SizeofRtMsg = 0xc","const SizeofRtNexthop = 0x8","type NlMsghdr struct {\n\tLen\tuint32\n\tType\tuint16\n\tFlags\tuint16\n\tSeq\tuint32\n\tPid\tuint32\n}","type NlMsgerr struct {\n\tError\tint32\n\tMsg\tNlMsghdr\n}","type RtGenmsg struct {\n\tFamily uint8\n}","type NlAttr struct {\n\tLen\tuint16\n\tType\tuint16\n}","type RtAttr struct {\n\tLen\tuint16\n\tType\tuint16\n}","type IfInfomsg struct {\n\tFamily\t\tuint8\n\tX__ifi_pad\tuint8\n\tType\t\tuint16\n\tIndex\t\tint32\n\tFlags\t\tuint32\n\tChange\t\tuint32\n}","type IfAddrmsg struct {\n\tFamily\t\tuint8\n\tPrefixlen\tuint8\n\tFlags\t\tuint8\n\tScope\t\tuint8\n\tIndex\t\tuint32\n}","type RtMsg struct {\n\tFamily\t\tuint8\n\tDst_len\t\tuint8\n\tSrc_len\t\tuint8\n\tTos\t\tuint8\n\tTable\t\tuint8\n\tProtocol\tuint8\n\tScope\t\tuint8\n\tType\t\tuint8\n\tFlags\t\tuint32\n}","type RtNexthop struct {\n\tLen\tuint16\n\tFlags\tuint8\n\tHops\tuint8\n\tIfindex\tint32\n}","const SizeofSockFilter = 0x8","const SizeofSockFprog = 0x10","type SockFilter struct {\n\tCode\tuint16\n\tJt\tuint8\n\tJf\tuint8\n\tK\tuint32\n}","type SockFprog struct {\n\tLen\t\tuint16\n\tPad_cgo_0\t[6]byte\n\tFilter\t\t*SockFilter\n}","type InotifyEvent struct {\n\tWd\tint32\n\tMask\tuint32\n\tCookie\tuint32\n\tLen\tuint32\n\tName\t[0]uint8\n}","const SizeofInotifyEvent = 0x10","type PtraceRegs struct {\n\tR15\t\tuint64\n\tR14\t\tuint64\n\tR13\t\tuint64\n\tR12\t\tuint64\n\tRbp\t\tuint64\n\tRbx\t\tuint64\n\tR11\t\tuint64\n\tR10\t\tuint64\n\tR9\t\tuint64\n\tR8\t\tuint64\n\tRax\t\tuint64\n\tRcx\t\tuint64\n\tRdx\t\tuint64\n\tRsi\t\tuint64\n\tRdi\t\tuint64\n\tOrig_rax\tuint64\n\tRip\t\tuint64\n\tCs\t\tuint64\n\tEflags\t\tuint64\n\tRsp\t\tuint64\n\tSs\t\tuint64\n\tFs_base\t\tuint64\n\tGs_base\t\tuint64\n\tDs\t\tuint64\n\tEs\t\tuint64\n\tFs\t\tuint64\n\tGs\t\tuint64\n}","type FdSet struct {\n\tBits [16]int64\n}","type Sysinfo_t struct {\n\tUptime\t\tint64\n\tLoads\t\t[3]uint64\n\tTotalram\tuint64\n\tFreeram\t\tuint64\n\tSharedram\tuint64\n\tBufferram\tuint64\n\tTotalswap\tuint64\n\tFreeswap\tuint64\n\tProcs\t\tuint16\n\tPad\t\tuint16\n\tPad_cgo_0\t[4]byte\n\tTotalhigh\tuint64\n\tFreehigh\tuint64\n\tUnit\t\tuint32\n\tX_f\t\t[0]byte\n\tPad_cgo_1\t[4]byte\n}","type Utsname struct {\n\tSysname\t\t[65]int8\n\tNodename\t[65]int8\n\tRelease\t\t[65]int8\n\tVersion\t\t[65]int8\n\tMachine\t\t[65]int8\n\tDomainname\t[65]int8\n}","type Ustat_t struct {\n\tTfree\t\tint32\n\tPad_cgo_0\t[4]byte\n\tTinode\t\tuint64\n\tFname\t\t[6]int8\n\tFpack\t\t[6]int8\n\tPad_cgo_1\t[4]byte\n}","type EpollEvent struct {\n\tEvents\tuint32\n\tFd\tint32\n\tPad\tint32\n}","type Termios struct {\n\tIflag\t\tuint32\n\tOflag\t\tuint32\n\tCflag\t\tuint32\n\tLflag\t\tuint32\n\tLine\t\tuint8\n\tCc\t\t[32]uint8\n\tPad_cgo_0\t[3]byte\n\tIspeed\t\tuint32\n\tOspeed\t\tuint32\n}","const VINTR = 0x0","const VQUIT = 0x1","const VERASE = 0x2","const VKILL = 0x3","const VEOF = 0x4","const VTIME = 0x5","const VMIN = 0x6","const VSWTC = 0x7","const VSTART = 0x8","const VSTOP = 0x9","const VSUSP = 0xa","const VEOL = 0xb","const VREPRINT = 0xc","const VDISCARD = 0xd","const VWERASE = 0xe","const VLNEXT = 0xf","const VEOL2 = 0x10","const IGNBRK = 0x1","const BRKINT = 0x2","const IGNPAR = 0x4","const PARMRK = 0x8","const INPCK = 0x10","const ISTRIP = 0x20","const INLCR = 0x40","const IGNCR = 0x80","const ICRNL = 0x100","const IUCLC = 0x200","const IXON = 0x400","const IXANY = 0x800","const IXOFF = 0x1000","const IMAXBEL = 0x2000","const IUTF8 = 0x4000","const OPOST = 0x1","const OLCUC = 0x2","const ONLCR = 0x4","const OCRNL = 0x8","const ONOCR = 0x10","const ONLRET = 0x20","const OFILL = 0x40","const OFDEL = 0x80","const B0 = 0x0","const B50 = 0x1","const B75 = 0x2","const B110 = 0x3","const B134 = 0x4","const B150 = 0x5","const B200 = 0x6","const B300 = 0x7","const B600 = 0x8","const B1200 = 0x9","const B1800 = 0xa","const B2400 = 0xb","const B4800 = 0xc","const B9600 = 0xd","const B19200 = 0xe","const B38400 = 0xf","const CSIZE = 0x30","const CS5 = 0x0","const CS6 = 0x10","const CS7 = 0x20","const CS8 = 0x30","const CSTOPB = 0x40","const CREAD = 0x80","const PARENB = 0x100","const PARODD = 0x200","const HUPCL = 0x400","const CLOCAL = 0x800","const B57600 = 0x1001","const B115200 = 0x1002","const B230400 = 0x1003","const B460800 = 0x1004","const B500000 = 0x1005","const B576000 = 0x1006","const B921600 = 0x1007","const B1000000 = 0x1008","const B1152000 = 0x1009","const B1500000 = 0x100a","const B2000000 = 0x100b","const B2500000 = 0x100c","const B3000000 = 0x100d","const B3500000 = 0x100e","const B4000000 = 0x100f","const ISIG = 0x1","const ICANON = 0x2","const XCASE = 0x4","const ECHO = 0x8","const ECHOE = 0x10","const ECHOK = 0x20","const ECHONL = 0x40","const NOFLSH = 0x80","const TOSTOP = 0x100","const ECHOCTL = 0x200","const ECHOPRT = 0x400","const ECHOKE = 0x800","const FLUSHO = 0x1000","const PENDIN = 0x4000","const IEXTEN = 0x8000","const TCGETS = 0x5401","const TCSETS = 0x5402","func AllocsPerRun(runs int, f func()) (avg float64)","type InternalBenchmark struct {\n\tName\tstring\n\tF\tfunc(b *B)\n}","type B struct {\n\tcommon\n\timportPath\t\tstring\t// import path of the package containing the benchmark\n\tcontext\t\t\t*benchContext\n\tN\t\t\tint\n\tpreviousN\t\tint\t\t// number of iterations in the previous run\n\tpreviousDuration\ttime.Duration\t// total duration of the previous run\n\tbenchFunc\t\tfunc(b *B)\n\tbenchTime\t\tdurationOrCountFlag\n\tbytes\t\t\tint64\n\tmissingBytes\t\tbool\t// one of the subbenchmarks does not have bytes set.\n\ttimerOn\t\t\tbool\n\tshowAllocResult\t\tbool\n\tresult\t\t\tBenchmarkResult\n\tparallelism\t\tint\t// RunParallel creates parallelism*GOMAXPROCS goroutines\n\t// The initial states of memStats.Mallocs and memStats.TotalAlloc.\n\tstartAllocs\tuint64\n\tstartBytes\tuint64\n\t// The net total of this test after being run.\n\tnetAllocs\tuint64\n\tnetBytes\tuint64\n\t// Extra metrics collected by ReportMetric.\n\textra\tmap[string]float64\n}","type BenchmarkResult struct {\n\tN\t\tint\t\t// The number of iterations.\n\tT\t\ttime.Duration\t// The total time taken.\n\tBytes\t\tint64\t\t// Bytes processed in one iteration.\n\tMemAllocs\tuint64\t\t// The total number of memory allocations.\n\tMemBytes\tuint64\t\t// The total number of bytes allocated.\n\n\t// Extra records additional metrics reported by ReportMetric.\n\tExtra\tmap[string]float64\n}","func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)","type PB struct {\n\tglobalN\t*atomic.Uint64\t// shared between all worker goroutines iteration counter\n\tgrain\tuint64\t\t// acquire that many iterations from globalN at once\n\tcache\tuint64\t\t// local cache of acquired iterations\n\tbN\tuint64\t\t// total number of iterations to execute (b.N)\n}","func Benchmark(f func(b *B)) BenchmarkResult","type CoverBlock struct {\n\tLine0\tuint32\t// Line number for block start.\n\tCol0\tuint16\t// Column number for block start.\n\tLine1\tuint32\t// Line number for block end.\n\tCol1\tuint16\t// Column number for block end.\n\tStmts\tuint16\t// Number of statements included in this block.\n}","type Cover struct {\n\tMode\t\tstring\n\tCounters\tmap[string][]uint32\n\tBlocks\t\tmap[string][]CoverBlock\n\tCoveredPackages\tstring\n}","func Coverage() float64","func RegisterCover(c Cover)","type InternalExample struct {\n\tName\t\tstring\n\tF\t\tfunc()\n\tOutput\t\tstring\n\tUnordered\tbool\n}","func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)","type InternalFuzzTarget struct {\n\tName\tstring\n\tFn\tfunc(f *F)\n}","type F struct {\n\tcommon\n\tfuzzContext\t*fuzzContext\n\ttestContext\t*testContext\n\n\t// inFuzzFn is true when the fuzz function is running. Most F methods cannot\n\t// be called when inFuzzFn is true.\n\tinFuzzFn\tbool\n\n\t// corpus is a set of seed corpus entries, added with F.Add and loaded\n\t// from testdata.\n\tcorpus\t[]corpusEntry\n\n\tresult\t\tfuzzResult\n\tfuzzCalled\tbool\n}","func Init()","func Short() bool","func Testing() bool","func CoverMode() string","func Verbose() bool","type TB interface {\n\tCleanup(func())\n\tError(args ...any)\n\tErrorf(format string, args ...any)\n\tFail()\n\tFailNow()\n\tFailed() bool\n\tFatal(args ...any)\n\tFatalf(format string, args ...any)\n\tHelper()\n\tLog(args ...any)\n\tLogf(format string, args ...any)\n\tName() string\n\tSetenv(key, value string)\n\tSkip(args ...any)\n\tSkipNow()\n\tSkipf(format string, args ...any)\n\tSkipped() bool\n\tTempDir() string\n\n\t// A private method to prevent users implementing the\n\t// interface and so future additions to it will not\n\t// violate Go 1 compatibility.\n\tprivate()\n}","type T struct {\n\tcommon\n\tisEnvSet\tbool\n\tcontext\t\t*testContext\t// For running tests and subtests.\n}","type InternalTest struct {\n\tName\tstring\n\tF\tfunc(*T)\n}","func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)","type M struct {\n\tdeps\t\ttestDeps\n\ttests\t\t[]InternalTest\n\tbenchmarks\t[]InternalBenchmark\n\tfuzzTargets\t[]InternalFuzzTarget\n\texamples\t[]InternalExample\n\n\ttimer\t\t*time.Timer\n\tafterOnce\tsync.Once\n\n\tnumRun\tint\n\n\t// value to pass to os.Exit, the outer test func main\n\t// harness calls os.Exit with this code. See #34129.\n\texitCode\tint\n}","func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M","func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)","const Layout = \"01/02 03:04:05PM '06 -0700\"","const ANSIC = \"Mon Jan _2 15:04:05 2006\"","const UnixDate = \"Mon Jan _2 15:04:05 MST 2006\"","const RubyDate = \"Mon Jan 02 15:04:05 -0700 2006\"","const RFC822 = \"02 Jan 06 15:04 MST\"","const RFC822Z = \"02 Jan 06 15:04 -0700\"","const RFC850 = \"Monday, 02-Jan-06 15:04:05 MST\"","const RFC1123 = \"Mon, 02 Jan 2006 15:04:05 MST\"","const RFC1123Z = \"Mon, 02 Jan 2006 15:04:05 -0700\"","const RFC3339 = \"2006-01-02T15:04:05Z07:00\"","const RFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"","const Kitchen = \"3:04PM\"","const Stamp = \"Jan _2 15:04:05\"","const StampMilli = \"Jan _2 15:04:05.000\"","const StampMicro = \"Jan _2 15:04:05.000000\"","const StampNano = \"Jan _2 15:04:05.000000000\"","const DateTime = \"2006-01-02 15:04:05\"","const DateOnly = \"2006-01-02\"","const TimeOnly = \"15:04:05\"","type ParseError struct {\n\tLayout\t\tstring\n\tValue\t\tstring\n\tLayoutElem\tstring\n\tValueElem\tstring\n\tMessage\t\tstring\n}","func Parse(layout, value string) (Time, error)","func ParseInLocation(layout, value string, loc *Location) (Time, error)","func ParseDuration(s string) (Duration, error)","func Sleep(d Duration)","type Timer struct {\n\tC\t\t\u003c-chan Time\n\tinitTimer\tbool\n}","func NewTimer(d Duration) *Timer","func After(d Duration) \u003c-chan Time","func AfterFunc(d Duration, f func()) *Timer","type Ticker struct {\n\tC\t\t\u003c-chan Time\t// The channel on which the ticks are delivered.\n\tinitTicker\tbool\n}","func NewTicker(d Duration) *Ticker","func Tick(d Duration) \u003c-chan Time","type Time struct {\n\t// wall and ext encode the wall time seconds, wall time nanoseconds,\n\t// and optional monotonic clock reading in nanoseconds.\n\t//\n\t// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),\n\t// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.\n\t// The nanoseconds field is in the range [0, 999999999].\n\t// If the hasMonotonic bit is 0, then the 33-bit field must be zero\n\t// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.\n\t// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit\n\t// unsigned wall seconds since Jan 1 year 1885, and ext holds a\n\t// signed 64-bit monotonic clock reading, nanoseconds since process start.\n\twall\tuint64\n\text\tint64\n\n\t// loc specifies the Location that should be used to\n\t// determine the minute, hour, month, day, and year\n\t// that correspond to this Time.\n\t// The nil location means UTC.\n\t// All UTC times are represented with loc==nil, never loc==\u0026utcLoc.\n\tloc\t*Location\n}","","const January Month","const February","const March","const April","const May","const June","const July","const August","const September","const October","const November","const December","","const Sunday Weekday","const Monday","const Tuesday","const Wednesday","const Thursday","const Friday","const Saturday","","const Nanosecond Duration = 1","","","","","","func Since(t Time) Duration","func Until(t Time) Duration","func Now() Time","func Unix(sec int64, nsec int64) Time","func UnixMilli(msec int64) Time","func UnixMicro(usec int64) Time","func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time","type Location struct {\n\tname\tstring\n\tzone\t[]zone\n\ttx\t[]zoneTrans\n\n\t// The tzdata information can be followed by a string that describes\n\t// how to handle DST transitions not recorded in zoneTrans.\n\t// The format is the TZ environment variable without a colon; see\n\t// https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html.\n\t// Example string, for America/Los_Angeles: PST8PDT,M3.2.0,M11.1.0\n\textend\tstring\n\n\t// Most lookups will be for the current time.\n\t// To avoid the binary search through tx, keep a\n\t// static one-element cache that gives the correct\n\t// zone for the time when the Location was created.\n\t// if cacheStart \u003c= t \u003c cacheEnd,\n\t// lookup can return cacheZone.\n\t// The units for cacheStart and cacheEnd are seconds\n\t// since January 1, 1970 UTC, to match the argument\n\t// to lookup.\n\tcacheStart\tint64\n\tcacheEnd\tint64\n\tcacheZone\t*zone\n}","var UTC *Location","var Local *Location","func FixedZone(name string, offset int) *Location","func LoadLocation(name string) (*Location, error)","func LoadLocationFromTZData(name string, data []byte) (*Location, error)","var TurkishCase SpecialCase","var AzeriCase SpecialCase","func IsDigit(r rune) bool","","","func IsGraphic(r rune) bool","func IsPrint(r rune) bool","func IsOneOf(ranges []*RangeTable, r rune) bool","func In(r rune, ranges ...*RangeTable) bool","func IsControl(r rune) bool","func IsLetter(r rune) bool","func IsMark(r rune) bool","func IsNumber(r rune) bool","func IsPunct(r rune) bool","func IsSpace(r rune) bool","func IsSymbol(r rune) bool","const MaxRune = '\\U0010FFFF'","const ReplacementChar = '\\uFFFD'","const MaxASCII = '\\u007F'","const MaxLatin1 = '\\u00FF'","type RangeTable struct {\n\tR16\t\t[]Range16\n\tR32\t\t[]Range32\n\tLatinOffset\tint\t// number of entries in R16 with Hi \u003c= MaxLatin1\n}","type Range16 struct {\n\tLo\tuint16\n\tHi\tuint16\n\tStride\tuint16\n}","type Range32 struct {\n\tLo\tuint32\n\tHi\tuint32\n\tStride\tuint32\n}","type CaseRange struct {\n\tLo\tuint32\n\tHi\tuint32\n\tDelta\td\n}","type SpecialCase []CaseRange","","const LowerCase","const TitleCase","const MaxCase","","func Is(rangeTab *RangeTable, r rune) bool","func IsUpper(r rune) bool","func IsLower(r rune) bool","func IsTitle(r rune) bool","func To(_case int, r rune) rune","func ToUpper(r rune) rune","func ToLower(r rune) rune","func ToTitle(r rune) rune","func SimpleFold(r rune) rune","const Version = \"15.0.0\"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","type Handle[T comparable] struct {\n\tvalue *T\n}","func Make[T comparable](value T) Handle[T]","","","type Pointer *ArbitraryType","func Sizeof(x ArbitraryType) uintptr","func Offsetof(x ArbitraryType) uintptr","func Alignof(x ArbitraryType) uintptr","func Add(ptr Pointer, len IntegerType) Pointer","func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType","func SliceData(slice []ArbitraryType) *ArbitraryType","func String(ptr *byte, len IntegerType) string","func StringData(str string) *byte","","","","","","const TypeReg = '0'","const TypeRegA = '\\x00'","const TypeLink = '1'","const TypeSymlink = '2'","const TypeChar = '3'","const TypeBlock = '4'","const TypeDir = '5'","const TypeFifo = '6'","const TypeCont = '7'","const TypeXHeader = 'x'","const TypeXGlobalHeader = 'g'","const TypeGNUSparse = 'S'","const TypeGNULongName = 'L'","const TypeGNULongLink = 'K'","type Header struct {\n\t// Typeflag is the type of header entry.\n\t// The zero value is automatically promoted to either TypeReg or TypeDir\n\t// depending on the presence of a trailing slash in Name.\n\tTypeflag\tbyte\n\n\tName\t\tstring\t// Name of file entry\n\tLinkname\tstring\t// Target name of link (valid for TypeLink or TypeSymlink)\n\n\tSize\tint64\t// Logical file size in bytes\n\tMode\tint64\t// Permission and mode bits\n\tUid\tint\t// User ID of owner\n\tGid\tint\t// Group ID of owner\n\tUname\tstring\t// User name of owner\n\tGname\tstring\t// Group name of owner\n\n\t// If the Format is unspecified, then Writer.WriteHeader rounds ModTime\n\t// to the nearest second and ignores the AccessTime and ChangeTime fields.\n\t//\n\t// To use AccessTime or ChangeTime, specify the Format as PAX or GNU.\n\t// To use sub-second resolution, specify the Format as PAX.\n\tModTime\t\ttime.Time\t// Modification time\n\tAccessTime\ttime.Time\t// Access time (requires either PAX or GNU support)\n\tChangeTime\ttime.Time\t// Change time (requires either PAX or GNU support)\n\n\tDevmajor\tint64\t// Major device number (valid for TypeChar or TypeBlock)\n\tDevminor\tint64\t// Minor device number (valid for TypeChar or TypeBlock)\n\n\t// Xattrs stores extended attributes as PAX records under the\n\t// \"SCHILY.xattr.\" namespace.\n\t//\n\t// The following are semantically equivalent:\n\t//  h.Xattrs[key] = value\n\t//  h.PAXRecords[\"SCHILY.xattr.\"+key] = value\n\t//\n\t// When Writer.WriteHeader is called, the contents of Xattrs will take\n\t// precedence over those in PAXRecords.\n\t//\n\t// Deprecated: Use PAXRecords instead.\n\tXattrs\tmap[string]string\n\n\t// PAXRecords is a map of PAX extended header records.\n\t//\n\t// User-defined records should have keys of the following form:\n\t//\tVENDOR.keyword\n\t// Where VENDOR is some namespace in all uppercase, and keyword may\n\t// not contain the '=' character (e.g., \"GOLANG.pkg.version\").\n\t// The key and value should be non-empty UTF-8 strings.\n\t//\n\t// When Writer.WriteHeader is called, PAX records derived from the\n\t// other fields in Header take precedence over PAXRecords.\n\tPAXRecords\tmap[string]string\n\n\t// Format specifies the format of the tar header.\n\t//\n\t// This is set by Reader.Next as a best-effort guess at the format.\n\t// Since the Reader liberally reads some non-compliant files,\n\t// it is possible for this to be FormatUnknown.\n\t//\n\t// If the format is unspecified when Writer.WriteHeader is called,\n\t// then it uses the first format (in the order of USTAR, PAX, GNU)\n\t// capable of encoding this Header (see Format).\n\tFormat\tFormat\n}","func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)","type FileInfoNames interface {\n\tfs.FileInfo\n\t// Uname should give a user name.\n\tUname() (string, error)\n\t// Gname should give a group name.\n\tGname() (string, error)\n}","","const FormatUnknown","const FormatUSTAR","const FormatPAX","const FormatGNU","type Reader struct {\n\tr\tio.Reader\n\tpad\tint64\t\t// Amount of padding (ignored) after current file entry\n\tcurr\tfileReader\t// Reader for current file entry\n\tblk\tblock\t\t// Buffer to use as temporary local storage\n\n\t// err is a persistent error.\n\t// It is only the responsibility of every exported method of Reader to\n\t// ensure that this error is sticky.\n\terr\terror\n}","func NewReader(r io.Reader) *Reader","type Writer struct {\n\tw\tio.Writer\n\tpad\tint64\t\t// Amount of padding to write after current file entry\n\tcurr\tfileWriter\t// Writer for current file entry\n\thdr\tHeader\t\t// Shallow copy of Header that is safe for mutations\n\tblk\tblock\t\t// Buffer to use as temporary local storage\n\n\t// err is a persistent error.\n\t// It is only the responsibility of every exported method of Writer to\n\t// ensure that this error is sticky.\n\terr\terror\n}","func NewWriter(w io.Writer) *Writer","","","","","type Reader struct {\n\tr\t\tio.ReaderAt\n\tFile\t\t[]*File\n\tComment\t\tstring\n\tdecompressors\tmap[uint16]Decompressor\n\n\t// Some JAR files are zip files with a prefix that is a bash script.\n\t// The baseOffset field is the start of the zip file proper.\n\tbaseOffset\tint64\n\n\t// fileList is a list of files sorted by ename,\n\t// for use by the Open method.\n\tfileListOnce\tsync.Once\n\tfileList\t[]fileListEntry\n}","type ReadCloser struct {\n\tf\t*os.File\n\tReader\n}","type File struct {\n\tFileHeader\n\tzip\t\t*Reader\n\tzipr\t\tio.ReaderAt\n\theaderOffset\tint64\t// includes overall ZIP archive baseOffset\n\tzip64\t\tbool\t// zip64 extended information extra field presence\n}","func OpenReader(name string) (*ReadCloser, error)","func NewReader(r io.ReaderAt, size int64) (*Reader, error)","type Compressor func(w io.Writer) (io.WriteCloser, error)","type Decompressor func(r io.Reader) io.ReadCloser","func RegisterDecompressor(method uint16, dcomp Decompressor)","func RegisterCompressor(method uint16, comp Compressor)","const Store uint16 = 0","const Deflate uint16 = 8","type FileHeader struct {\n\t// Name is the name of the file.\n\t//\n\t// It must be a relative path, not start with a drive letter (such as \"C:\"),\n\t// and must use forward slashes instead of back slashes. A trailing slash\n\t// indicates that this file is a directory and should have no data.\n\tName\tstring\n\n\t// Comment is any arbitrary user-defined string shorter than 64KiB.\n\tComment\tstring\n\n\t// NonUTF8 indicates that Name and Comment are not encoded in UTF-8.\n\t//\n\t// By specification, the only other encoding permitted should be CP-437,\n\t// but historically many ZIP readers interpret Name and Comment as whatever\n\t// the system's local character encoding happens to be.\n\t//\n\t// This flag should only be set if the user intends to encode a non-portable\n\t// ZIP file for a specific localized region. Otherwise, the Writer\n\t// automatically sets the ZIP format's UTF-8 flag for valid UTF-8 strings.\n\tNonUTF8\tbool\n\n\tCreatorVersion\tuint16\n\tReaderVersion\tuint16\n\tFlags\t\tuint16\n\n\t// Method is the compression method. If zero, Store is used.\n\tMethod\tuint16\n\n\t// Modified is the modified time of the file.\n\t//\n\t// When reading, an extended timestamp is preferred over the legacy MS-DOS\n\t// date field, and the offset between the times is used as the timezone.\n\t// If only the MS-DOS date is present, the timezone is assumed to be UTC.\n\t//\n\t// When writing, an extended timestamp (which is timezone-agnostic) is\n\t// always emitted. The legacy MS-DOS date field is encoded according to the\n\t// location of the Modified time.\n\tModified\ttime.Time\n\n\t// ModifiedTime is an MS-DOS-encoded time.\n\t//\n\t// Deprecated: Use Modified instead.\n\tModifiedTime\tuint16\n\n\t// ModifiedDate is an MS-DOS-encoded date.\n\t//\n\t// Deprecated: Use Modified instead.\n\tModifiedDate\tuint16\n\n\t// CRC32 is the CRC32 checksum of the file content.\n\tCRC32\tuint32\n\n\t// CompressedSize is the compressed size of the file in bytes.\n\t// If either the uncompressed or compressed size of the file\n\t// does not fit in 32 bits, CompressedSize is set to ^uint32(0).\n\t//\n\t// Deprecated: Use CompressedSize64 instead.\n\tCompressedSize\tuint32\n\n\t// UncompressedSize is the uncompressed size of the file in bytes.\n\t// If either the uncompressed or compressed size of the file\n\t// does not fit in 32 bits, UncompressedSize is set to ^uint32(0).\n\t//\n\t// Deprecated: Use UncompressedSize64 instead.\n\tUncompressedSize\tuint32\n\n\t// CompressedSize64 is the compressed size of the file in bytes.\n\tCompressedSize64\tuint64\n\n\t// UncompressedSize64 is the uncompressed size of the file in bytes.\n\tUncompressedSize64\tuint64\n\n\tExtra\t\t[]byte\n\tExternalAttrs\tuint32\t// Meaning depends on CreatorVersion\n}","func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)","type Writer struct {\n\tcw\t\t*countWriter\n\tdir\t\t[]*header\n\tlast\t\t*fileWriter\n\tclosed\t\tbool\n\tcompressors\tmap[uint16]Compressor\n\tcomment\t\tstring\n\n\t// testHookCloseSizeOffset if non-nil is called with the size\n\t// of offset of the central directory at Close.\n\ttestHookCloseSizeOffset\tfunc(size, offset uint64)\n}","func NewWriter(w io.Writer) *Writer","","func NewReader(r io.Reader) io.Reader","const NoCompression = 0","const BestSpeed = 1","const BestCompression = 9","","","func NewWriter(w io.Writer, level int) (*Writer, error)","func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)","type Writer struct {\n\td\tcompressor\n\tdict\t[]byte\n}","","","type ReadError struct {\n\tOffset\tint64\t// byte offset where error occurred\n\tErr\terror\t// error returned by underlying Read\n}","type WriteError struct {\n\tOffset\tint64\t// byte offset where error occurred\n\tErr\terror\t// error returned by underlying Write\n}","type Resetter interface {\n\t// Reset discards any buffered data and resets the Resetter as if it was\n\t// newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n}","type Reader interface {\n\tio.Reader\n\tio.ByteReader\n}","func NewReader(r io.Reader) io.ReadCloser","func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser","","","type Header struct {\n\tComment\tstring\t\t// comment\n\tExtra\t[]byte\t\t// \"extra data\"\n\tModTime\ttime.Time\t// modification time\n\tName\tstring\t\t// file name\n\tOS\tbyte\t\t// operating system type\n}","type Reader struct {\n\tHeader\t\t// valid after NewReader or Reader.Reset\n\tr\t\tflate.Reader\n\tdecompressor\tio.ReadCloser\n\tdigest\t\tuint32\t// CRC-32, IEEE polynomial (section 8)\n\tsize\t\tuint32\t// Uncompressed size (section 2.3.1)\n\tbuf\t\t[512]byte\n\terr\t\terror\n\tmultistream\tbool\n}","func NewReader(r io.Reader) (*Reader, error)","","","","","","type Writer struct {\n\tHeader\t\t// written at first call to Write, Flush, or Close\n\tw\t\tio.Writer\n\tlevel\t\tint\n\twroteHeader\tbool\n\tclosed\t\tbool\n\tbuf\t\t[10]byte\n\tcompressor\t*flate.Writer\n\tdigest\t\tuint32\t// CRC-32, IEEE polynomial (section 8)\n\tsize\t\tuint32\t// Uncompressed size (section 2.3.1)\n\terr\t\terror\n}","func NewWriter(w io.Writer) *Writer","func NewWriterLevel(w io.Writer, level int) (*Writer, error)","","const LSB Order","const MSB","type Reader struct {\n\tr\t\tio.ByteReader\n\tbits\t\tuint32\n\tnBits\t\tuint\n\twidth\t\tuint\n\tread\t\tfunc(*Reader) (uint16, error)\t// readLSB or readMSB\n\tlitWidth\tint\t\t\t\t// width in bits of literal codes\n\terr\t\terror\n\n\t// The first 1\u003c\u003clitWidth codes are literal codes.\n\t// The next two codes mean clear and EOF.\n\t// Other valid codes are in the range [lo, hi] where lo := clear + 2,\n\t// with the upper bound incrementing on each code seen.\n\t//\n\t// overflow is the code at which hi overflows the code width. It always\n\t// equals 1 \u003c\u003c width.\n\t//\n\t// last is the most recently seen code, or decoderInvalidCode.\n\t//\n\t// An invariant is that hi \u003c overflow.\n\tclear, eof, hi, overflow, last\tuint16\n\n\t// Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n\t//   suffix[c] is the last of these bytes.\n\t//   prefix[c] is the code for all but the last byte.\n\t//   This code can either be a literal code or another code in [lo, c).\n\t// The c == hi case is a special case.\n\tsuffix\t[1 \u003c\u003c maxWidth]uint8\n\tprefix\t[1 \u003c\u003c maxWidth]uint16\n\n\t// output is the temporary output buffer.\n\t// Literal codes are accumulated from the start of the buffer.\n\t// Non-literal codes decode to a sequence of suffixes that are first\n\t// written right-to-left from the end of the buffer before being copied\n\t// to the start of the buffer.\n\t// It is flushed when it contains \u003e= 1\u003c\u003cmaxWidth bytes,\n\t// so that there is always room to decode an entire code.\n\toutput\t[2 * 1 \u003c\u003c maxWidth]byte\n\to\tint\t// write index into output\n\ttoRead\t[]byte\t// bytes to return from Read\n}","func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser","type Writer struct {\n\t// w is the writer that compressed bytes are written to.\n\tw\twriter\n\t// litWidth is the width in bits of literal codes.\n\tlitWidth\tuint\n\t// order, write, bits, nBits and width are the state for\n\t// converting a code stream into a byte stream.\n\torder\tOrder\n\twrite\tfunc(*Writer, uint32) error\n\tnBits\tuint\n\twidth\tuint\n\tbits\tuint32\n\t// hi is the code implied by the next code emission.\n\t// overflow is the code at which hi overflows the code width.\n\thi, overflow\tuint32\n\t// savedCode is the accumulated code at the end of the most recent Write\n\t// call. It is equal to invalidCode if there was no such call.\n\tsavedCode\tuint32\n\t// err is the first error encountered during writing. Closing the writer\n\t// will make any future Write calls return errClosed\n\terr\terror\n\t// table is the hash table from 20-bit keys to 12-bit values. Each table\n\t// entry contains key\u003c\u003c12|val and collisions resolve by linear probing.\n\t// The keys consist of a 12-bit code prefix and an 8-bit byte suffix.\n\t// The values are a 12-bit code.\n\ttable\t[tableSize]uint32\n}","func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser","","","","type Resetter interface {\n\t// Reset discards any buffered data and resets the Resetter as if it was\n\t// newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n}","func NewReader(r io.Reader) (io.ReadCloser, error)","func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)","","","","","","type Writer struct {\n\tw\t\tio.Writer\n\tlevel\t\tint\n\tdict\t\t[]byte\n\tcompressor\t*flate.Writer\n\tdigest\t\thash.Hash32\n\terr\t\terror\n\tscratch\t\t[4]byte\n\twroteHeader\tbool\n}","func NewWriter(w io.Writer) *Writer","func NewWriterLevel(w io.Writer, level int) (*Writer, error)","func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)","type Interface interface {\n\tsort.Interface\n\tPush(x any)\t// add x as element Len()\n\tPop() any\t// remove and return element Len() - 1.\n}","func Init(h Interface)","func Push(h Interface, x any)","func Pop(h Interface) any","func Remove(h Interface, i int) any","func Fix(h Interface, i int)","type Element struct {\n\t// Next and previous pointers in the doubly-linked list of elements.\n\t// To simplify the implementation, internally a list l is implemented\n\t// as a ring, such that \u0026l.root is both the next element of the last\n\t// list element (l.Back()) and the previous element of the first list\n\t// element (l.Front()).\n\tnext, prev\t*Element\n\n\t// The list to which this element belongs.\n\tlist\t*List\n\n\t// The value stored with this element.\n\tValue\tany\n}","type List struct {\n\troot\tElement\t// sentinel list element, only \u0026root, root.prev, and root.next are used\n\tlen\tint\t// current list length excluding (this) sentinel element\n}","func New() *List","type Ring struct {\n\tnext, prev\t*Ring\n\tValue\t\tany\t// for use by client; untouched by this library\n}","func New(n int) *Ring","const BlockSize = 16","","func NewCipher(key []byte) (cipher.Block, error)","func NewCBCEncrypter(b Block, iv []byte) BlockMode","func NewCBCDecrypter(b Block, iv []byte) BlockMode","func NewCFBEncrypter(block Block, iv []byte) Stream","func NewCFBDecrypter(block Block, iv []byte) Stream","type Block interface {\n\t// BlockSize returns the cipher's block size.\n\tBlockSize() int\n\n\t// Encrypt encrypts the first block in src into dst.\n\t// Dst and src must overlap entirely or not at all.\n\tEncrypt(dst, src []byte)\n\n\t// Decrypt decrypts the first block in src into dst.\n\t// Dst and src must overlap entirely or not at all.\n\tDecrypt(dst, src []byte)\n}","type Stream interface {\n\t// XORKeyStream XORs each byte in the given slice with a byte from the\n\t// cipher's key stream. Dst and src must overlap entirely or not at all.\n\t//\n\t// If len(dst) \u003c len(src), XORKeyStream should panic. It is acceptable\n\t// to pass a dst bigger than src, and in that case, XORKeyStream will\n\t// only update dst[:len(src)] and will not touch the rest of dst.\n\t//\n\t// Multiple calls to XORKeyStream behave as if the concatenation of\n\t// the src buffers was passed in a single run. That is, Stream\n\t// maintains state and does not reset at each XORKeyStream call.\n\tXORKeyStream(dst, src []byte)\n}","type BlockMode interface {\n\t// BlockSize returns the mode's block size.\n\tBlockSize() int\n\n\t// CryptBlocks encrypts or decrypts a number of blocks. The length of\n\t// src must be a multiple of the block size. Dst and src must overlap\n\t// entirely or not at all.\n\t//\n\t// If len(dst) \u003c len(src), CryptBlocks should panic. It is acceptable\n\t// to pass a dst bigger than src, and in that case, CryptBlocks will\n\t// only update dst[:len(src)] and will not touch the rest of dst.\n\t//\n\t// Multiple calls to CryptBlocks behave as if the concatenation of\n\t// the src buffers was passed in a single run. That is, BlockMode\n\t// maintains state and does not reset at each CryptBlocks call.\n\tCryptBlocks(dst, src []byte)\n}","func NewCTR(block Block, iv []byte) Stream","type AEAD interface {\n\t// NonceSize returns the size of the nonce that must be passed to Seal\n\t// and Open.\n\tNonceSize() int\n\n\t// Overhead returns the maximum difference between the lengths of a\n\t// plaintext and its ciphertext.\n\tOverhead() int\n\n\t// Seal encrypts and authenticates plaintext, authenticates the\n\t// additional data and appends the result to dst, returning the updated\n\t// slice. The nonce must be NonceSize() bytes long and unique for all\n\t// time, for a given key.\n\t//\n\t// To reuse plaintext's storage for the encrypted output, use plaintext[:0]\n\t// as dst. Otherwise, the remaining capacity of dst must not overlap plaintext.\n\tSeal(dst, nonce, plaintext, additionalData []byte) []byte\n\n\t// Open decrypts and authenticates ciphertext, authenticates the\n\t// additional data and, if successful, appends the resulting plaintext\n\t// to dst, returning the updated slice. The nonce must be NonceSize()\n\t// bytes long and both it and the additional data must match the\n\t// value passed to Seal.\n\t//\n\t// To reuse ciphertext's storage for the decrypted output, use ciphertext[:0]\n\t// as dst. Otherwise, the remaining capacity of dst must not overlap plaintext.\n\t//\n\t// Even if the function fails, the contents of dst, up to its capacity,\n\t// may be overwritten.\n\tOpen(dst, nonce, ciphertext, additionalData []byte) ([]byte, error)\n}","func NewGCM(cipher Block) (AEAD, error)","func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)","func NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)","type StreamReader struct {\n\tS\tStream\n\tR\tio.Reader\n}","type StreamWriter struct {\n\tS\tStream\n\tW\tio.Writer\n\tErr\terror\t// unused\n}","func NewOFB(b Block, iv []byte) Stream","const BlockSize = 8","","func NewCipher(key []byte) (cipher.Block, error)","func NewTripleDESCipher(key []byte) (cipher.Block, error)","type Parameters struct {\n\tP, Q, G *big.Int\n}","type PublicKey struct {\n\tParameters\n\tY\t*big.Int\n}","type PrivateKey struct {\n\tPublicKey\n\tX\t*big.Int\n}","","","const L1024N160 ParameterSizes","const L2048N224","const L2048N256","const L3072N256","func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error","func GenerateKey(priv *PrivateKey, rand io.Reader) error","func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)","func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool","type Curve interface {\n\t// GenerateKey generates a random PrivateKey.\n\t//\n\t// Most applications should use [crypto/rand.Reader] as rand. Note that the\n\t// returned key does not depend deterministically on the bytes read from rand,\n\t// and may change between calls and/or between versions.\n\tGenerateKey(rand io.Reader) (*PrivateKey, error)\n\n\t// NewPrivateKey checks that key is valid and returns a PrivateKey.\n\t//\n\t// For NIST curves, this follows SEC 1, Version 2.0, Section 2.3.6, which\n\t// amounts to decoding the bytes as a fixed length big endian integer and\n\t// checking that the result is lower than the order of the curve. The zero\n\t// private key is also rejected, as the encoding of the corresponding public\n\t// key would be irregular.\n\t//\n\t// For X25519, this only checks the scalar length.\n\tNewPrivateKey(key []byte) (*PrivateKey, error)\n\n\t// NewPublicKey checks that key is valid and returns a PublicKey.\n\t//\n\t// For NIST curves, this decodes an uncompressed point according to SEC 1,\n\t// Version 2.0, Section 2.3.4. Compressed encodings and the point at\n\t// infinity are rejected.\n\t//\n\t// For X25519, this only checks the u-coordinate length. Adversarially\n\t// selected public keys can cause ECDH to return an error.\n\tNewPublicKey(key []byte) (*PublicKey, error)\n\n\t// ecdh performs an ECDH exchange and returns the shared secret. It's exposed\n\t// as the PrivateKey.ECDH method.\n\t//\n\t// The private method also allow us to expand the ECDH interface with more\n\t// methods in the future without breaking backwards compatibility.\n\tecdh(local *PrivateKey, remote *PublicKey) ([]byte, error)\n\n\t// privateKeyToPublicKey converts a PrivateKey to a PublicKey. It's exposed\n\t// as the PrivateKey.PublicKey method.\n\t//\n\t// This method always succeeds: for X25519, the zero key can't be\n\t// constructed due to clamping; for NIST curves, it is rejected by\n\t// NewPrivateKey.\n\tprivateKeyToPublicKey(*PrivateKey) *PublicKey\n}","type PublicKey struct {\n\tcurve\t\tCurve\n\tpublicKey\t[]byte\n\tboring\t\t*boring.PublicKeyECDH\n}","type PrivateKey struct {\n\tcurve\t\tCurve\n\tprivateKey\t[]byte\n\tboring\t\t*boring.PrivateKeyECDH\n\t// publicKey is set under publicKeyOnce, to allow loading private keys with\n\t// NewPrivateKey without having to perform a scalar multiplication.\n\tpublicKey\t*PublicKey\n\tpublicKeyOnce\tsync.Once\n}","func P256() Curve","func P384() Curve","func P521() Curve","func X25519() Curve","type PublicKey struct {\n\telliptic.Curve\n\tX, Y\t*big.Int\n}","type PrivateKey struct {\n\tPublicKey\n\tD\t*big.Int\n}","func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)","func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)","func VerifyASN1(pub *PublicKey, hash, sig []byte) bool","func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)","func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool","const PublicKeySize = 32","const PrivateKeySize = 64","const SignatureSize = 64","const SeedSize = 32","type PublicKey []byte","type PrivateKey []byte","type Options struct {\n\t// Hash can be zero for regular Ed25519, or crypto.SHA512 for Ed25519ph.\n\tHash\tcrypto.Hash\n\n\t// Context, if not empty, selects Ed25519ctx or provides the context string\n\t// for Ed25519ph. It can be at most 255 bytes in length.\n\tContext\tstring\n}","func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error)","func NewKeyFromSeed(seed []byte) PrivateKey","func Sign(privateKey PrivateKey, message []byte) []byte","func Verify(publicKey PublicKey, message, sig []byte) bool","func VerifyWithOptions(publicKey PublicKey, message, sig []byte, opts *Options) error","type Curve interface {\n\t// Params returns the parameters for the curve.\n\tParams() *CurveParams\n\n\t// IsOnCurve reports whether the given (x,y) lies on the curve.\n\t//\n\t// Deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh\n\t// package. The NewPublicKey methods of NIST curves in crypto/ecdh accept\n\t// the same encoding as the Unmarshal function, and perform on-curve checks.\n\tIsOnCurve(x, y *big.Int) bool\n\n\t// Add returns the sum of (x1,y1) and (x2,y2).\n\t//\n\t// Deprecated: this is a low-level unsafe API.\n\tAdd(x1, y1, x2, y2 *big.Int) (x, y *big.Int)\n\n\t// Double returns 2*(x,y).\n\t//\n\t// Deprecated: this is a low-level unsafe API.\n\tDouble(x1, y1 *big.Int) (x, y *big.Int)\n\n\t// ScalarMult returns k*(x,y) where k is an integer in big-endian form.\n\t//\n\t// Deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh\n\t// package. Most uses of ScalarMult can be replaced by a call to the ECDH\n\t// methods of NIST curves in crypto/ecdh.\n\tScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int)\n\n\t// ScalarBaseMult returns k*G, where G is the base point of the group\n\t// and k is an integer in big-endian form.\n\t//\n\t// Deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh\n\t// package. Most uses of ScalarBaseMult can be replaced by a call to the\n\t// PrivateKey.PublicKey method in crypto/ecdh.\n\tScalarBaseMult(k []byte) (x, y *big.Int)\n}","func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)","func Marshal(curve Curve, x, y *big.Int) []byte","func MarshalCompressed(curve Curve, x, y *big.Int) []byte","func Unmarshal(curve Curve, data []byte) (x, y *big.Int)","func UnmarshalCompressed(curve Curve, data []byte) (x, y *big.Int)","func P224() Curve","func P256() Curve","func P384() Curve","func P521() Curve","type CurveParams struct {\n\tP\t*big.Int\t// the order of the underlying field\n\tN\t*big.Int\t// the order of the base point\n\tB\t*big.Int\t// the constant of the curve equation\n\tGx, Gy\t*big.Int\t// (x,y) of the base point\n\tBitSize\tint\t\t// the size of the underlying field\n\tName\tstring\t\t// the canonical name of the curve\n}","func New(h func() hash.Hash, key []byte) hash.Hash","func Equal(mac1, mac2 []byte) bool","const Size = 16","const BlockSize = 64","func New() hash.Hash","func Sum(data []byte) [Size]byte","var Reader io.Reader","func Read(b []byte) (n int, err error)","func Prime(rand io.Reader, bits int) (*big.Int, error)","func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)","type Cipher struct {\n\ts\t[256]uint32\n\ti, j\tuint8\n}","","func NewCipher(key []byte) (*Cipher, error)","type PKCS1v15DecryptOptions struct {\n\t// SessionKeyLen is the length of the session key that is being\n\t// decrypted. If not zero, then a padding error during decryption will\n\t// cause a random plaintext of this length to be returned rather than\n\t// an error. These alternatives happen in constant time.\n\tSessionKeyLen int\n}","func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, error)","func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)","func DecryptPKCS1v15SessionKey(random io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error","func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)","func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error","const PSSSaltLengthAuto = 0","","type PSSOptions struct {\n\t// SaltLength controls the length of the salt used in the PSS signature. It\n\t// can either be a positive number of bytes, or one of the special\n\t// PSSSaltLength constants.\n\tSaltLength\tint\n\n\t// Hash is the hash function used to generate the message digest. If not\n\t// zero, it overrides the hash function passed to SignPSS. It's required\n\t// when using PrivateKey.Sign.\n\tHash\tcrypto.Hash\n}","func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error)","func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error","type PublicKey struct {\n\tN\t*big.Int\t// modulus\n\tE\tint\t\t// public exponent\n}","type OAEPOptions struct {\n\t// Hash is the hash function that will be used when generating the mask.\n\tHash\tcrypto.Hash\n\n\t// MGFHash is the hash function used for MGF1.\n\t// If zero, Hash is used instead.\n\tMGFHash\tcrypto.Hash\n\n\t// Label is an arbitrary byte string that must be equal to the value\n\t// used when encrypting.\n\tLabel\t[]byte\n}","type PrivateKey struct {\n\tPublicKey\t\t\t// public part.\n\tD\t\t*big.Int\t// private exponent\n\tPrimes\t\t[]*big.Int\t// prime factors of N, has \u003e= 2 elements.\n\n\t// Precomputed contains precomputed values that speed up RSA operations,\n\t// if available. It must be generated by calling PrivateKey.Precompute and\n\t// must not be modified.\n\tPrecomputed\tPrecomputedValues\n}","type PrecomputedValues struct {\n\tDp, Dq\t*big.Int\t// D mod (P-1) (or mod Q-1)\n\tQinv\t*big.Int\t// Q^-1 mod P\n\n\t// CRTValues is used for the 3rd and subsequent primes. Due to a\n\t// historical accident, the CRT for the first two primes is handled\n\t// differently in PKCS #1 and interoperability is sufficiently\n\t// important that we mirror this.\n\t//\n\t// Deprecated: These values are still filled in by Precompute for\n\t// backwards compatibility but are not used. Multi-prime RSA is very rare,\n\t// and is implemented by this package without CRT optimizations to limit\n\t// complexity.\n\tCRTValues\t[]CRTValue\n\n\tn, p, q\t*bigmod.Modulus\t// moduli for CRT with Montgomery precomputed constants\n}","type CRTValue struct {\n\tExp\t*big.Int\t// D mod (prime-1).\n\tCoeff\t*big.Int\t// R·Coeff ≡ 1 mod Prime.\n\tR\t*big.Int\t// product of primes prior to this (inc p and q).\n}","func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)","func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)","","func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)","","","func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)","const Size = 20","const BlockSize = 64","func New() hash.Hash","func Sum(data []byte) [Size]byte","const Size = 32","const Size224 = 28","const BlockSize = 64","func New() hash.Hash","func New224() hash.Hash","func Sum256(data []byte) [Size]byte","func Sum224(data []byte) [Size224]byte","const Size = 64","const Size224 = 28","const Size256 = 32","const Size384 = 48","const BlockSize = 128","func New() hash.Hash","func New512_224() hash.Hash","func New512_256() hash.Hash","func New384() hash.Hash","func Sum512(data []byte) [Size]byte","func Sum384(data []byte) [Size384]byte","func Sum512_224(data []byte) [Size224]byte","func Sum512_256(data []byte) [Size256]byte","func ConstantTimeCompare(x, y []byte) int","func ConstantTimeSelect(v, x, y int) int","func ConstantTimeByteEq(x, y uint8) int","func ConstantTimeEq(x, y int32) int","func ConstantTimeCopy(v int, x, y []byte)","func ConstantTimeLessOrEq(x, y int) int","func XORBytes(dst, x, y []byte) int","","type CipherSuite struct {\n\tID\tuint16\n\tName\tstring\n\n\t// Supported versions is the list of TLS protocol versions that can\n\t// negotiate this cipher suite.\n\tSupportedVersions\t[]uint16\n\n\t// Insecure is true if the cipher suite has known security issues\n\t// due to its primitives, design, or implementation.\n\tInsecure\tbool\n}","func CipherSuites() []*CipherSuite","func InsecureCipherSuites() []*CipherSuite","func CipherSuiteName(id uint16) string","const TLS_RSA_WITH_RC4_128_SHA uint16 = 0x0005","const TLS_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x000a","const TLS_RSA_WITH_AES_128_CBC_SHA uint16 = 0x002f","const TLS_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0035","const TLS_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x003c","const TLS_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x009c","const TLS_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x009d","const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA uint16 = 0xc007","const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA uint16 = 0xc009","const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA uint16 = 0xc00a","const TLS_ECDHE_RSA_WITH_RC4_128_SHA uint16 = 0xc011","const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xc012","const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0xc013","const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA uint16 = 0xc014","const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xc023","const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0xc027","const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02f","const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b","const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc030","const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c","const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca8","const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca9","const TLS_AES_128_GCM_SHA256 uint16 = 0x1301","const TLS_AES_256_GCM_SHA384 uint16 = 0x1302","const TLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303","const TLS_FALLBACK_SCSV uint16 = 0x5600","","","const VersionTLS10 = 0x0301","const VersionTLS11 = 0x0302","const VersionTLS12 = 0x0303","const VersionTLS13 = 0x0304","const VersionSSL30 = 0x0300","func VersionName(version uint16) string","","const CurveP256 CurveID = 23","const CurveP384 CurveID = 24","const CurveP521 CurveID = 25","const X25519 CurveID = 29","type ConnectionState struct {\n\t// Version is the TLS version used by the connection (e.g. VersionTLS12).\n\tVersion\tuint16\n\n\t// HandshakeComplete is true if the handshake has concluded.\n\tHandshakeComplete\tbool\n\n\t// DidResume is true if this connection was successfully resumed from a\n\t// previous session with a session ticket or similar mechanism.\n\tDidResume\tbool\n\n\t// CipherSuite is the cipher suite negotiated for the connection (e.g.\n\t// TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).\n\tCipherSuite\tuint16\n\n\t// NegotiatedProtocol is the application protocol negotiated with ALPN.\n\tNegotiatedProtocol\tstring\n\n\t// NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.\n\t//\n\t// Deprecated: this value is always true.\n\tNegotiatedProtocolIsMutual\tbool\n\n\t// ServerName is the value of the Server Name Indication extension sent by\n\t// the client. It's available both on the server and on the client side.\n\tServerName\tstring\n\n\t// PeerCertificates are the parsed certificates sent by the peer, in the\n\t// order in which they were sent. The first element is the leaf certificate\n\t// that the connection is verified against.\n\t//\n\t// On the client side, it can't be empty. On the server side, it can be\n\t// empty if Config.ClientAuth is not RequireAnyClientCert or\n\t// RequireAndVerifyClientCert.\n\t//\n\t// PeerCertificates and its contents should not be modified.\n\tPeerCertificates\t[]*x509.Certificate\n\n\t// VerifiedChains is a list of one or more chains where the first element is\n\t// PeerCertificates[0] and the last element is from Config.RootCAs (on the\n\t// client side) or Config.ClientCAs (on the server side).\n\t//\n\t// On the client side, it's set if Config.InsecureSkipVerify is false. On\n\t// the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven\n\t// (and the peer provided a certificate) or RequireAndVerifyClientCert.\n\t//\n\t// VerifiedChains and its contents should not be modified.\n\tVerifiedChains\t[][]*x509.Certificate\n\n\t// SignedCertificateTimestamps is a list of SCTs provided by the peer\n\t// through the TLS handshake for the leaf certificate, if any.\n\tSignedCertificateTimestamps\t[][]byte\n\n\t// OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)\n\t// response provided by the peer for the leaf certificate, if any.\n\tOCSPResponse\t[]byte\n\n\t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC 5929,\n\t// Section 3). This value will be nil for TLS 1.3 connections and for\n\t// resumed connections that don't support Extended Master Secret (RFC 7627).\n\tTLSUnique\t[]byte\n\n\t// ECHAccepted indicates if Encrypted Client Hello was offered by the client\n\t// and accepted by the server. Currently, ECH is supported only on the\n\t// client side.\n\tECHAccepted\tbool\n\n\t// ekm is a closure exposed via ExportKeyingMaterial.\n\tekm\tfunc(label string, context []byte, length int) ([]byte, error)\n\n\t// testingOnlyDidHRR is true if a HelloRetryRequest was sent/received.\n\ttestingOnlyDidHRR\tbool\n\n\t// testingOnlyCurveID is the selected CurveID, or zero if an RSA exchanges\n\t// is performed.\n\ttestingOnlyCurveID\tCurveID\n}","","const NoClientCert ClientAuthType","const RequestClientCert","const RequireAnyClientCert","const VerifyClientCertIfGiven","const RequireAndVerifyClientCert","type ClientSessionCache interface {\n\t// Get searches for a ClientSessionState associated with the given key.\n\t// On return, ok is true if one was found.\n\tGet(sessionKey string) (session *ClientSessionState, ok bool)\n\n\t// Put adds the ClientSessionState to the cache with the given key. It might\n\t// get called multiple times in a connection if a TLS 1.3 server provides\n\t// more than one session ticket. If called with a nil *ClientSessionState,\n\t// it should remove the cache entry.\n\tPut(sessionKey string, cs *ClientSessionState)\n}","","const PKCS1WithSHA256 SignatureScheme = 0x0401","const PKCS1WithSHA384 SignatureScheme = 0x0501","const PKCS1WithSHA512 SignatureScheme = 0x0601","const PSSWithSHA256 SignatureScheme = 0x0804","const PSSWithSHA384 SignatureScheme = 0x0805","const PSSWithSHA512 SignatureScheme = 0x0806","const ECDSAWithP256AndSHA256 SignatureScheme = 0x0403","const ECDSAWithP384AndSHA384 SignatureScheme = 0x0503","const ECDSAWithP521AndSHA512 SignatureScheme = 0x0603","const Ed25519 SignatureScheme = 0x0807","const PKCS1WithSHA1 SignatureScheme = 0x0201","const ECDSAWithSHA1 SignatureScheme = 0x0203","type ClientHelloInfo struct {\n\t// CipherSuites lists the CipherSuites supported by the client (e.g.\n\t// TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).\n\tCipherSuites\t[]uint16\n\n\t// ServerName indicates the name of the server requested by the client\n\t// in order to support virtual hosting. ServerName is only set if the\n\t// client is using SNI (see RFC 4366, Section 3.1).\n\tServerName\tstring\n\n\t// SupportedCurves lists the elliptic curves supported by the client.\n\t// SupportedCurves is set only if the Supported Elliptic Curves\n\t// Extension is being used (see RFC 4492, Section 5.1.1).\n\tSupportedCurves\t[]CurveID\n\n\t// SupportedPoints lists the point formats supported by the client.\n\t// SupportedPoints is set only if the Supported Point Formats Extension\n\t// is being used (see RFC 4492, Section 5.1.2).\n\tSupportedPoints\t[]uint8\n\n\t// SignatureSchemes lists the signature and hash schemes that the client\n\t// is willing to verify. SignatureSchemes is set only if the Signature\n\t// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).\n\tSignatureSchemes\t[]SignatureScheme\n\n\t// SupportedProtos lists the application protocols supported by the client.\n\t// SupportedProtos is set only if the Application-Layer Protocol\n\t// Negotiation Extension is being used (see RFC 7301, Section 3.1).\n\t//\n\t// Servers can select a protocol by setting Config.NextProtos in a\n\t// GetConfigForClient return value.\n\tSupportedProtos\t[]string\n\n\t// SupportedVersions lists the TLS versions supported by the client.\n\t// For TLS versions less than 1.3, this is extrapolated from the max\n\t// version advertised by the client, so values other than the greatest\n\t// might be rejected if used.\n\tSupportedVersions\t[]uint16\n\n\t// Conn is the underlying net.Conn for the connection. Do not read\n\t// from, or write to, this connection; that will cause the TLS\n\t// connection to fail.\n\tConn\tnet.Conn\n\n\t// config is embedded by the GetCertificate or GetConfigForClient caller,\n\t// for use with SupportsCertificate.\n\tconfig\t*Config\n\n\t// ctx is the context of the handshake that is in progress.\n\tctx\tcontext.Context\n}","type CertificateRequestInfo struct {\n\t// AcceptableCAs contains zero or more, DER-encoded, X.501\n\t// Distinguished Names. These are the names of root or intermediate CAs\n\t// that the server wishes the returned certificate to be signed by. An\n\t// empty slice indicates that the server has no preference.\n\tAcceptableCAs\t[][]byte\n\n\t// SignatureSchemes lists the signature schemes that the server is\n\t// willing to verify.\n\tSignatureSchemes\t[]SignatureScheme\n\n\t// Version is the TLS version that was negotiated for this connection.\n\tVersion\tuint16\n\n\t// ctx is the context of the handshake that is in progress.\n\tctx\tcontext.Context\n}","","const RenegotiateNever RenegotiationSupport","const RenegotiateOnceAsClient","const RenegotiateFreelyAsClient","type Config struct {\n\t// Rand provides the source of entropy for nonces and RSA blinding.\n\t// If Rand is nil, TLS uses the cryptographic random reader in package\n\t// crypto/rand.\n\t// The Reader must be safe for use by multiple goroutines.\n\tRand\tio.Reader\n\n\t// Time returns the current time as the number of seconds since the epoch.\n\t// If Time is nil, TLS uses time.Now.\n\tTime\tfunc() time.Time\n\n\t// Certificates contains one or more certificate chains to present to the\n\t// other side of the connection. The first certificate compatible with the\n\t// peer's requirements is selected automatically.\n\t//\n\t// Server configurations must set one of Certificates, GetCertificate or\n\t// GetConfigForClient. Clients doing client-authentication may set either\n\t// Certificates or GetClientCertificate.\n\t//\n\t// Note: if there are multiple Certificates, and they don't have the\n\t// optional field Leaf set, certificate selection will incur a significant\n\t// per-handshake performance cost.\n\tCertificates\t[]Certificate\n\n\t// NameToCertificate maps from a certificate name to an element of\n\t// Certificates. Note that a certificate name can be of the form\n\t// '*.example.com' and so doesn't have to be a domain name as such.\n\t//\n\t// Deprecated: NameToCertificate only allows associating a single\n\t// certificate with a given name. Leave this field nil to let the library\n\t// select the first compatible chain from Certificates.\n\tNameToCertificate\tmap[string]*Certificate\n\n\t// GetCertificate returns a Certificate based on the given\n\t// ClientHelloInfo. It will only be called if the client supplies SNI\n\t// information or if Certificates is empty.\n\t//\n\t// If GetCertificate is nil or returns nil, then the certificate is\n\t// retrieved from NameToCertificate. If NameToCertificate is nil, the\n\t// best element of Certificates will be used.\n\t//\n\t// Once a Certificate is returned it should not be modified.\n\tGetCertificate\tfunc(*ClientHelloInfo) (*Certificate, error)\n\n\t// GetClientCertificate, if not nil, is called when a server requests a\n\t// certificate from a client. If set, the contents of Certificates will\n\t// be ignored.\n\t//\n\t// If GetClientCertificate returns an error, the handshake will be\n\t// aborted and that error will be returned. Otherwise\n\t// GetClientCertificate must return a non-nil Certificate. If\n\t// Certificate.Certificate is empty then no certificate will be sent to\n\t// the server. If this is unacceptable to the server then it may abort\n\t// the handshake.\n\t//\n\t// GetClientCertificate may be called multiple times for the same\n\t// connection if renegotiation occurs or if TLS 1.3 is in use.\n\t//\n\t// Once a Certificate is returned it should not be modified.\n\tGetClientCertificate\tfunc(*CertificateRequestInfo) (*Certificate, error)\n\n\t// GetConfigForClient, if not nil, is called after a ClientHello is\n\t// received from a client. It may return a non-nil Config in order to\n\t// change the Config that will be used to handle this connection. If\n\t// the returned Config is nil, the original Config will be used. The\n\t// Config returned by this callback may not be subsequently modified.\n\t//\n\t// If GetConfigForClient is nil, the Config passed to Server() will be\n\t// used for all connections.\n\t//\n\t// If SessionTicketKey was explicitly set on the returned Config, or if\n\t// SetSessionTicketKeys was called on the returned Config, those keys will\n\t// be used. Otherwise, the original Config keys will be used (and possibly\n\t// rotated if they are automatically managed).\n\tGetConfigForClient\tfunc(*ClientHelloInfo) (*Config, error)\n\n\t// VerifyPeerCertificate, if not nil, is called after normal\n\t// certificate verification by either a TLS client or server. It\n\t// receives the raw ASN.1 certificates provided by the peer and also\n\t// any verified chains that normal processing found. If it returns a\n\t// non-nil error, the handshake is aborted and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. If normal verification is disabled (on the\n\t// client when InsecureSkipVerify is set, or on a server when ClientAuth is\n\t// RequestClientCert or RequireAnyClientCert), then this callback will be\n\t// considered but the verifiedChains argument will always be nil. When\n\t// ClientAuth is NoClientCert, this callback is not called on the server.\n\t// rawCerts may be empty on the server if ClientAuth is RequestClientCert or\n\t// VerifyClientCertIfGiven.\n\t//\n\t// This callback is not invoked on resumed connections, as certificates are\n\t// not re-verified on resumption.\n\t//\n\t// verifiedChains and its contents should not be modified.\n\tVerifyPeerCertificate\tfunc(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n\n\t// VerifyConnection, if not nil, is called after normal certificate\n\t// verification and after VerifyPeerCertificate by either a TLS client\n\t// or server. If it returns a non-nil error, the handshake is aborted\n\t// and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. This callback will run for all connections,\n\t// including resumptions, regardless of InsecureSkipVerify or ClientAuth\n\t// settings.\n\tVerifyConnection\tfunc(ConnectionState) error\n\n\t// RootCAs defines the set of root certificate authorities\n\t// that clients use when verifying server certificates.\n\t// If RootCAs is nil, TLS uses the host's root CA set.\n\tRootCAs\t*x509.CertPool\n\n\t// NextProtos is a list of supported application level protocols, in\n\t// order of preference. If both peers support ALPN, the selected\n\t// protocol will be one from this list, and the connection will fail\n\t// if there is no mutually supported protocol. If NextProtos is empty\n\t// or the peer doesn't support ALPN, the connection will succeed and\n\t// ConnectionState.NegotiatedProtocol will be empty.\n\tNextProtos\t[]string\n\n\t// ServerName is used to verify the hostname on the returned\n\t// certificates unless InsecureSkipVerify is given. It is also included\n\t// in the client's handshake to support virtual hosting unless it is\n\t// an IP address.\n\tServerName\tstring\n\n\t// ClientAuth determines the server's policy for\n\t// TLS Client Authentication. The default is NoClientCert.\n\tClientAuth\tClientAuthType\n\n\t// ClientCAs defines the set of root certificate authorities\n\t// that servers use if required to verify a client certificate\n\t// by the policy in ClientAuth.\n\tClientCAs\t*x509.CertPool\n\n\t// InsecureSkipVerify controls whether a client verifies the server's\n\t// certificate chain and host name. If InsecureSkipVerify is true, crypto/tls\n\t// accepts any certificate presented by the server and any host name in that\n\t// certificate. In this mode, TLS is susceptible to machine-in-the-middle\n\t// attacks unless custom verification is used. This should be used only for\n\t// testing or in combination with VerifyConnection or VerifyPeerCertificate.\n\tInsecureSkipVerify\tbool\n\n\t// CipherSuites is a list of enabled TLS 1.0–1.2 cipher suites. The order of\n\t// the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.\n\t//\n\t// If CipherSuites is nil, a safe default list is used. The default cipher\n\t// suites might change over time. In Go 1.22 RSA key exchange based cipher\n\t// suites were removed from the default list, but can be re-added with the\n\t// GODEBUG setting tlsrsakex=1. In Go 1.23 3DES cipher suites were removed\n\t// from the default list, but can be re-added with the GODEBUG setting\n\t// tls3des=1.\n\tCipherSuites\t[]uint16\n\n\t// PreferServerCipherSuites is a legacy field and has no effect.\n\t//\n\t// It used to control whether the server would follow the client's or the\n\t// server's preference. Servers now select the best mutually supported\n\t// cipher suite based on logic that takes into account inferred client\n\t// hardware, server hardware, and security.\n\t//\n\t// Deprecated: PreferServerCipherSuites is ignored.\n\tPreferServerCipherSuites\tbool\n\n\t// SessionTicketsDisabled may be set to true to disable session ticket and\n\t// PSK (resumption) support. Note that on clients, session ticket support is\n\t// also disabled if ClientSessionCache is nil.\n\tSessionTicketsDisabled\tbool\n\n\t// SessionTicketKey is used by TLS servers to provide session resumption.\n\t// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled\n\t// with random data before the first server handshake.\n\t//\n\t// Deprecated: if this field is left at zero, session ticket keys will be\n\t// automatically rotated every day and dropped after seven days. For\n\t// customizing the rotation schedule or synchronizing servers that are\n\t// terminating connections for the same host, use SetSessionTicketKeys.\n\tSessionTicketKey\t[32]byte\n\n\t// ClientSessionCache is a cache of ClientSessionState entries for TLS\n\t// session resumption. It is only used by clients.\n\tClientSessionCache\tClientSessionCache\n\n\t// UnwrapSession is called on the server to turn a ticket/identity\n\t// previously produced by [WrapSession] into a usable session.\n\t//\n\t// UnwrapSession will usually either decrypt a session state in the ticket\n\t// (for example with [Config.EncryptTicket]), or use the ticket as a handle\n\t// to recover a previously stored state. It must use [ParseSessionState] to\n\t// deserialize the session state.\n\t//\n\t// If UnwrapSession returns an error, the connection is terminated. If it\n\t// returns (nil, nil), the session is ignored. crypto/tls may still choose\n\t// not to resume the returned session.\n\tUnwrapSession\tfunc(identity []byte, cs ConnectionState) (*SessionState, error)\n\n\t// WrapSession is called on the server to produce a session ticket/identity.\n\t//\n\t// WrapSession must serialize the session state with [SessionState.Bytes].\n\t// It may then encrypt the serialized state (for example with\n\t// [Config.DecryptTicket]) and use it as the ticket, or store the state and\n\t// return a handle for it.\n\t//\n\t// If WrapSession returns an error, the connection is terminated.\n\t//\n\t// Warning: the return value will be exposed on the wire and to clients in\n\t// plaintext. The application is in charge of encrypting and authenticating\n\t// it (and rotating keys) or returning high-entropy identifiers. Failing to\n\t// do so correctly can compromise current, previous, and future connections\n\t// depending on the protocol version.\n\tWrapSession\tfunc(ConnectionState, *SessionState) ([]byte, error)\n\n\t// MinVersion contains the minimum TLS version that is acceptable.\n\t//\n\t// By default, TLS 1.2 is currently used as the minimum. TLS 1.0 is the\n\t// minimum supported by this package.\n\t//\n\t// The server-side default can be reverted to TLS 1.0 by including the value\n\t// \"tls10server=1\" in the GODEBUG environment variable.\n\tMinVersion\tuint16\n\n\t// MaxVersion contains the maximum TLS version that is acceptable.\n\t//\n\t// By default, the maximum version supported by this package is used,\n\t// which is currently TLS 1.3.\n\tMaxVersion\tuint16\n\n\t// CurvePreferences contains the elliptic curves that will be used in\n\t// an ECDHE handshake, in preference order. If empty, the default will\n\t// be used. The client will use the first preference as the type for\n\t// its key share in TLS 1.3. This may change in the future.\n\t//\n\t// From Go 1.23, the default includes the X25519Kyber768Draft00 hybrid\n\t// post-quantum key exchange. To disable it, set CurvePreferences explicitly\n\t// or use the GODEBUG=tlskyber=0 environment variable.\n\tCurvePreferences\t[]CurveID\n\n\t// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.\n\t// When true, the largest possible TLS record size is always used. When\n\t// false, the size of TLS records may be adjusted in an attempt to\n\t// improve latency.\n\tDynamicRecordSizingDisabled\tbool\n\n\t// Renegotiation controls what types of renegotiation are supported.\n\t// The default, none, is correct for the vast majority of applications.\n\tRenegotiation\tRenegotiationSupport\n\n\t// KeyLogWriter optionally specifies a destination for TLS master secrets\n\t// in NSS key log format that can be used to allow external programs\n\t// such as Wireshark to decrypt TLS connections.\n\t// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.\n\t// Use of KeyLogWriter compromises security and should only be\n\t// used for debugging.\n\tKeyLogWriter\tio.Writer\n\n\t// EncryptedClientHelloConfigList is a serialized ECHConfigList. If\n\t// provided, clients will attempt to connect to servers using Encrypted\n\t// Client Hello (ECH) using one of the provided ECHConfigs. Servers\n\t// currently ignore this field.\n\t//\n\t// If the list contains no valid ECH configs, the handshake will fail\n\t// and return an error.\n\t//\n\t// If EncryptedClientHelloConfigList is set, MinVersion, if set, must\n\t// be VersionTLS13.\n\t//\n\t// When EncryptedClientHelloConfigList is set, the handshake will only\n\t// succeed if ECH is sucessfully negotiated. If the server rejects ECH,\n\t// an ECHRejectionError error will be returned, which may contain a new\n\t// ECHConfigList that the server suggests using.\n\t//\n\t// How this field is parsed may change in future Go versions, if the\n\t// encoding described in the final Encrypted Client Hello RFC changes.\n\tEncryptedClientHelloConfigList\t[]byte\n\n\t// EncryptedClientHelloRejectionVerify, if not nil, is called when ECH is\n\t// rejected, in order to verify the ECH provider certificate in the outer\n\t// Client Hello. If it returns a non-nil error, the handshake is aborted and\n\t// that error results.\n\t//\n\t// Unlike VerifyPeerCertificate and VerifyConnection, normal certificate\n\t// verification will not be performed before calling\n\t// EncryptedClientHelloRejectionVerify.\n\t//\n\t// If EncryptedClientHelloRejectionVerify is nil and ECH is rejected, the\n\t// roots in RootCAs will be used to verify the ECH providers public\n\t// certificate. VerifyPeerCertificate and VerifyConnection are not called\n\t// when ECH is rejected, even if set, and InsecureSkipVerify is ignored.\n\tEncryptedClientHelloRejectionVerify\tfunc(ConnectionState) error\n\n\t// mutex protects sessionTicketKeys and autoSessionTicketKeys.\n\tmutex\tsync.RWMutex\n\t// sessionTicketKeys contains zero or more ticket keys. If set, it means\n\t// the keys were set with SessionTicketKey or SetSessionTicketKeys. The\n\t// first key is used for new tickets and any subsequent keys can be used to\n\t// decrypt old tickets. The slice contents are not protected by the mutex\n\t// and are immutable.\n\tsessionTicketKeys\t[]ticketKey\n\t// autoSessionTicketKeys is like sessionTicketKeys but is owned by the\n\t// auto-rotation logic. See Config.ticketKeys.\n\tautoSessionTicketKeys\t[]ticketKey\n}","type Certificate struct {\n\tCertificate\t[][]byte\n\t// PrivateKey contains the private key corresponding to the public key in\n\t// Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.\n\t// For a server up to TLS 1.2, it can also implement crypto.Decrypter with\n\t// an RSA PublicKey.\n\tPrivateKey\tcrypto.PrivateKey\n\t// SupportedSignatureAlgorithms is an optional list restricting what\n\t// signature algorithms the PrivateKey can be used for.\n\tSupportedSignatureAlgorithms\t[]SignatureScheme\n\t// OCSPStaple contains an optional OCSP response which will be served\n\t// to clients that request it.\n\tOCSPStaple\t[]byte\n\t// SignedCertificateTimestamps contains an optional list of Signed\n\t// Certificate Timestamps which will be served to clients that request it.\n\tSignedCertificateTimestamps\t[][]byte\n\t// Leaf is the parsed form of the leaf certificate, which may be initialized\n\t// using x509.ParseCertificate to reduce per-handshake processing. If nil,\n\t// the leaf certificate will be parsed as needed.\n\tLeaf\t*x509.Certificate\n}","func NewLRUClientSessionCache(capacity int) ClientSessionCache","type CertificateVerificationError struct {\n\t// UnverifiedCertificates and its contents should not be modified.\n\tUnverifiedCertificates\t[]*x509.Certificate\n\tErr\t\t\terror\n}","type Conn struct {\n\t// constant\n\tconn\t\tnet.Conn\n\tisClient\tbool\n\thandshakeFn\tfunc(context.Context) error\t// (*Conn).clientHandshake or serverHandshake\n\tquic\t\t*quicState\t\t\t// nil for non-QUIC connections\n\n\t// isHandshakeComplete is true if the connection is currently transferring\n\t// application data (i.e. is not currently processing a handshake).\n\t// isHandshakeComplete is true implies handshakeErr == nil.\n\tisHandshakeComplete\tatomic.Bool\n\t// constant after handshake; protected by handshakeMutex\n\thandshakeMutex\tsync.Mutex\n\thandshakeErr\terror\t// error resulting from handshake\n\tvers\t\tuint16\t// TLS version\n\thaveVers\tbool\t// version has been negotiated\n\tconfig\t\t*Config\t// configuration passed to constructor\n\t// handshakes counts the number of handshakes performed on the\n\t// connection so far. If renegotiation is disabled then this is either\n\t// zero or one.\n\thandshakes\t\tint\n\textMasterSecret\t\tbool\n\tdidResume\t\tbool\t// whether this connection was a session resumption\n\tdidHRR\t\t\tbool\t// whether a HelloRetryRequest was sent/received\n\tcipherSuite\t\tuint16\n\tcurveID\t\t\tCurveID\n\tocspResponse\t\t[]byte\t\t// stapled OCSP response\n\tscts\t\t\t[][]byte\t// signed certificate timestamps from server\n\tpeerCertificates\t[]*x509.Certificate\n\t// activeCertHandles contains the cache handles to certificates in\n\t// peerCertificates that are used to track active references.\n\tactiveCertHandles\t[]*activeCert\n\t// verifiedChains contains the certificate chains that we built, as\n\t// opposed to the ones presented by the server.\n\tverifiedChains\t[][]*x509.Certificate\n\t// serverName contains the server name indicated by the client, if any.\n\tserverName\tstring\n\t// secureRenegotiation is true if the server echoed the secure\n\t// renegotiation extension. (This is meaningless as a server because\n\t// renegotiation is not supported in that case.)\n\tsecureRenegotiation\tbool\n\t// ekm is a closure for exporting keying material.\n\tekm\tfunc(label string, context []byte, length int) ([]byte, error)\n\t// resumptionSecret is the resumption_master_secret for handling\n\t// or sending NewSessionTicket messages.\n\tresumptionSecret\t[]byte\n\techAccepted\t\tbool\n\n\t// ticketKeys is the set of active session ticket keys for this\n\t// connection. The first one is used to encrypt new tickets and\n\t// all are tried to decrypt tickets.\n\tticketKeys\t[]ticketKey\n\n\t// clientFinishedIsFirst is true if the client sent the first Finished\n\t// message during the most recent handshake. This is recorded because\n\t// the first transmitted Finished message is the tls-unique\n\t// channel-binding value.\n\tclientFinishedIsFirst\tbool\n\n\t// closeNotifyErr is any error from sending the alertCloseNotify record.\n\tcloseNotifyErr\terror\n\t// closeNotifySent is true if the Conn attempted to send an\n\t// alertCloseNotify record.\n\tcloseNotifySent\tbool\n\n\t// clientFinished and serverFinished contain the Finished message sent\n\t// by the client or server in the most recent handshake. This is\n\t// retained to support the renegotiation extension and tls-unique\n\t// channel-binding.\n\tclientFinished\t[12]byte\n\tserverFinished\t[12]byte\n\n\t// clientProtocol is the negotiated ALPN protocol.\n\tclientProtocol\tstring\n\n\t// input/output\n\tin, out\t\thalfConn\n\trawInput\tbytes.Buffer\t// raw input, starting with a record header\n\tinput\t\tbytes.Reader\t// application data waiting to be read, from rawInput.Next\n\thand\t\tbytes.Buffer\t// handshake data waiting to be read\n\tbuffering\tbool\t\t// whether records are buffered in sendBuf\n\tsendBuf\t\t[]byte\t\t// a buffer of records waiting to be sent\n\n\t// bytesSent counts the bytes of application data sent.\n\t// packetsSent counts packets.\n\tbytesSent\tint64\n\tpacketsSent\tint64\n\n\t// retryCount counts the number of consecutive non-advancing records\n\t// received by Conn.readRecord. That is, records that neither advance the\n\t// handshake, nor deliver application data. Protected by in.Mutex.\n\tretryCount\tint\n\n\t// activeCall indicates whether Close has been call in the low bit.\n\t// the rest of the bits are the number of goroutines in Conn.Write.\n\tactiveCall\tatomic.Int32\n\n\ttmp\t[16]byte\n}","type RecordHeaderError struct {\n\t// Msg contains a human readable string that describes the error.\n\tMsg\tstring\n\t// RecordHeader contains the five bytes of TLS record header that\n\t// triggered the error.\n\tRecordHeader\t[5]byte\n\t// Conn provides the underlying net.Conn in the case that a client\n\t// sent an initial handshake that didn't look like TLS.\n\t// It is nil if there's already been a handshake or a TLS alert has\n\t// been written to the connection.\n\tConn\tnet.Conn\n}","type ECHRejectionError struct {\n\tRetryConfigList []byte\n}","","","const QUICEncryptionLevelEarly","const QUICEncryptionLevelHandshake","const QUICEncryptionLevelApplication","type QUICConn struct {\n\tconn\t*Conn\n\n\tsessionTicketSent\tbool\n}","type QUICConfig struct {\n\tTLSConfig\t*Config\n\n\t// EnableSessionEvents may be set to true to enable the\n\t// [QUICStoreSession] and [QUICResumeSession] events for client connections.\n\t// When this event is enabled, sessions are not automatically\n\t// stored in the client session cache.\n\t// The application should use [QUICConn.StoreSession] to store sessions.\n\tEnableSessionEvents\tbool\n}","","const QUICNoEvent QUICEventKind","const QUICSetReadSecret","const QUICSetWriteSecret","const QUICWriteData","const QUICTransportParameters","const QUICTransportParametersRequired","const QUICRejectedEarlyData","const QUICHandshakeDone","const QUICResumeSession","const QUICStoreSession","type QUICEvent struct {\n\tKind\tQUICEventKind\n\n\t// Set for QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.\n\tLevel\tQUICEncryptionLevel\n\n\t// Set for QUICTransportParameters, QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.\n\t// The contents are owned by crypto/tls, and are valid until the next NextEvent call.\n\tData\t[]byte\n\n\t// Set for QUICSetReadSecret and QUICSetWriteSecret.\n\tSuite\tuint16\n\n\t// Set for QUICResumeSession and QUICStoreSession.\n\tSessionState\t*SessionState\n}","func QUICClient(config *QUICConfig) *QUICConn","func QUICServer(config *QUICConfig) *QUICConn","type QUICSessionTicketOptions struct {\n\t// EarlyData specifies whether the ticket may be used for 0-RTT.\n\tEarlyData\tbool\n\tExtra\t\t[][]byte\n}","type SessionState struct {\n\n\t// Extra is ignored by crypto/tls, but is encoded by [SessionState.Bytes]\n\t// and parsed by [ParseSessionState].\n\t//\n\t// This allows [Config.UnwrapSession]/[Config.WrapSession] and\n\t// [ClientSessionCache] implementations to store and retrieve additional\n\t// data alongside this session.\n\t//\n\t// To allow different layers in a protocol stack to share this field,\n\t// applications must only append to it, not replace it, and must use entries\n\t// that can be recognized even if out of order (for example, by starting\n\t// with an id and version prefix).\n\tExtra\t[][]byte\n\n\t// EarlyData indicates whether the ticket can be used for 0-RTT in a QUIC\n\t// connection. The application may set this to false if it is true to\n\t// decline to offer 0-RTT even if supported.\n\tEarlyData\tbool\n\n\tversion\t\tuint16\n\tisClient\tbool\n\tcipherSuite\tuint16\n\t// createdAt is the generation time of the secret on the sever (which for\n\t// TLS 1.0–1.2 might be earlier than the current session) and the time at\n\t// which the ticket was received on the client.\n\tcreatedAt\t\tuint64\t// seconds since UNIX epoch\n\tsecret\t\t\t[]byte\t// master secret for TLS 1.2, or the PSK for TLS 1.3\n\textMasterSecret\t\tbool\n\tpeerCertificates\t[]*x509.Certificate\n\tactiveCertHandles\t[]*activeCert\n\tocspResponse\t\t[]byte\n\tscts\t\t\t[][]byte\n\tverifiedChains\t\t[][]*x509.Certificate\n\talpnProtocol\t\tstring\t// only set if EarlyData is true\n\n\t// Client-side TLS 1.3-only fields.\n\tuseBy\tuint64\t// seconds since UNIX epoch\n\tageAdd\tuint32\n\tticket\t[]byte\n}","func ParseSessionState(data []byte) (*SessionState, error)","type ClientSessionState struct {\n\tsession *SessionState\n}","func NewResumptionState(ticket []byte, state *SessionState) (*ClientSessionState, error)","func Server(conn net.Conn, config *Config) *Conn","func Client(conn net.Conn, config *Config) *Conn","func NewListener(inner net.Listener, config *Config) net.Listener","func Listen(network, laddr string, config *Config) (net.Listener, error)","func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)","func Dial(network, addr string, config *Config) (*Conn, error)","type Dialer struct {\n\t// NetDialer is the optional dialer to use for the TLS connections'\n\t// underlying TCP connections.\n\t// A nil NetDialer is equivalent to the net.Dialer zero value.\n\tNetDialer\t*net.Dialer\n\n\t// Config is the TLS configuration to use for new connections.\n\t// A nil configuration is equivalent to the zero\n\t// configuration; see the documentation of Config for the\n\t// defaults.\n\tConfig\t*Config\n}","func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)","func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)","type CertPool struct {\n\tbyName\tmap[string][]int\t// cert.RawSubject =\u003e index into lazyCerts\n\n\t// lazyCerts contains funcs that return a certificate,\n\t// lazily parsing/decompressing it as needed.\n\tlazyCerts\t[]lazyCert\n\n\t// haveSum maps from sum224(cert.Raw) to true. It's used only\n\t// for AddCert duplicate detection, to avoid CertPool.contains\n\t// calls in the AddCert path (because the contains method can\n\t// call getCert and otherwise negate savings from lazy getCert\n\t// funcs).\n\thaveSum\tmap[sum224]bool\n\n\t// systemPool indicates whether this is a special pool derived from the\n\t// system roots. If it includes additional roots, it requires doing two\n\t// verifications, one using the roots provided by the caller, and one using\n\t// the system platform verifier.\n\tsystemPool\tbool\n}","func NewCertPool() *CertPool","func SystemCertPool() (*CertPool, error)","type OID struct {\n\tder []byte\n}","func ParseOID(oid string) (OID, error)","func OIDFromInts(oid []uint64) (OID, error)","func ParseCertificate(der []byte) (*Certificate, error)","func ParseCertificates(der []byte) ([]*Certificate, error)","func ParseRevocationList(der []byte) (*RevocationList, error)","","const PEMCipherDES","const PEMCipher3DES","const PEMCipherAES128","const PEMCipherAES192","const PEMCipherAES256","func IsEncryptedPEMBlock(b *pem.Block) bool","","func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)","func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)","func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)","func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte","func ParsePKCS1PublicKey(der []byte) (*rsa.PublicKey, error)","func MarshalPKCS1PublicKey(key *rsa.PublicKey) []byte","func ParsePKCS8PrivateKey(der []byte) (key any, err error)","func MarshalPKCS8PrivateKey(key any) ([]byte, error)","func SetFallbackRoots(roots *CertPool)","func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)","func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)","","const NotAuthorizedToSign InvalidReason","const Expired","const CANotAuthorizedForThisName","const TooManyIntermediates","const IncompatibleUsage","const NameMismatch","const NameConstraintsWithoutSANs","const UnconstrainedName","const TooManyConstraints","const CANotAuthorizedForExtKeyUsage","type CertificateInvalidError struct {\n\tCert\t*Certificate\n\tReason\tInvalidReason\n\tDetail\tstring\n}","type HostnameError struct {\n\tCertificate\t*Certificate\n\tHost\t\tstring\n}","type UnknownAuthorityError struct {\n\tCert\t*Certificate\n\t// hintErr contains an error that may be helpful in determining why an\n\t// authority wasn't found.\n\thintErr\terror\n\t// hintCert contains a possible authority certificate that was rejected\n\t// because of the error in hintErr.\n\thintCert\t*Certificate\n}","type SystemRootsError struct {\n\tErr error\n}","type VerifyOptions struct {\n\t// DNSName, if set, is checked against the leaf certificate with\n\t// Certificate.VerifyHostname or the platform verifier.\n\tDNSName\tstring\n\n\t// Intermediates is an optional pool of certificates that are not trust\n\t// anchors, but can be used to form a chain from the leaf certificate to a\n\t// root certificate.\n\tIntermediates\t*CertPool\n\t// Roots is the set of trusted root certificates the leaf certificate needs\n\t// to chain up to. If nil, the system roots or the platform verifier are used.\n\tRoots\t*CertPool\n\n\t// CurrentTime is used to check the validity of all certificates in the\n\t// chain. If zero, the current time is used.\n\tCurrentTime\ttime.Time\n\n\t// KeyUsages specifies which Extended Key Usage values are acceptable. A\n\t// chain is accepted if it allows any of the listed values. An empty list\n\t// means ExtKeyUsageServerAuth. To accept any key usage, include ExtKeyUsageAny.\n\tKeyUsages\t[]ExtKeyUsage\n\n\t// MaxConstraintComparisions is the maximum number of comparisons to\n\t// perform when checking a given certificate's name constraints. If\n\t// zero, a sensible default is used. This limit prevents pathological\n\t// certificates from consuming excessive amounts of CPU time when\n\t// validating. It does not apply to the platform verifier.\n\tMaxConstraintComparisions\tint\n}","func ParsePKIXPublicKey(derBytes []byte) (pub any, err error)","func MarshalPKIXPublicKey(pub any) ([]byte, error)","","const UnknownSignatureAlgorithm SignatureAlgorithm","const MD2WithRSA","const MD5WithRSA","const SHA1WithRSA","const SHA256WithRSA","const SHA384WithRSA","const SHA512WithRSA","const DSAWithSHA1","const DSAWithSHA256","const ECDSAWithSHA1","const ECDSAWithSHA256","const ECDSAWithSHA384","const ECDSAWithSHA512","const SHA256WithRSAPSS","const SHA384WithRSAPSS","const SHA512WithRSAPSS","const PureEd25519","","const UnknownPublicKeyAlgorithm PublicKeyAlgorithm","const RSA","const DSA","const ECDSA","const Ed25519","","const KeyUsageDigitalSignature KeyUsage","const KeyUsageContentCommitment","const KeyUsageKeyEncipherment","const KeyUsageDataEncipherment","const KeyUsageKeyAgreement","const KeyUsageCertSign","const KeyUsageCRLSign","const KeyUsageEncipherOnly","const KeyUsageDecipherOnly","","const ExtKeyUsageAny ExtKeyUsage","const ExtKeyUsageServerAuth","const ExtKeyUsageClientAuth","const ExtKeyUsageCodeSigning","const ExtKeyUsageEmailProtection","const ExtKeyUsageIPSECEndSystem","const ExtKeyUsageIPSECTunnel","const ExtKeyUsageIPSECUser","const ExtKeyUsageTimeStamping","const ExtKeyUsageOCSPSigning","const ExtKeyUsageMicrosoftServerGatedCrypto","const ExtKeyUsageNetscapeServerGatedCrypto","const ExtKeyUsageMicrosoftCommercialCodeSigning","const ExtKeyUsageMicrosoftKernelCodeSigning","type Certificate struct {\n\tRaw\t\t\t[]byte\t// Complete ASN.1 DER content (certificate, signature algorithm and signature).\n\tRawTBSCertificate\t[]byte\t// Certificate part of raw ASN.1 DER content.\n\tRawSubjectPublicKeyInfo\t[]byte\t// DER encoded SubjectPublicKeyInfo.\n\tRawSubject\t\t[]byte\t// DER encoded Subject\n\tRawIssuer\t\t[]byte\t// DER encoded Issuer\n\n\tSignature\t\t[]byte\n\tSignatureAlgorithm\tSignatureAlgorithm\n\n\tPublicKeyAlgorithm\tPublicKeyAlgorithm\n\tPublicKey\t\tany\n\n\tVersion\t\t\tint\n\tSerialNumber\t\t*big.Int\n\tIssuer\t\t\tpkix.Name\n\tSubject\t\t\tpkix.Name\n\tNotBefore, NotAfter\ttime.Time\t// Validity bounds.\n\tKeyUsage\t\tKeyUsage\n\n\t// Extensions contains raw X.509 extensions. When parsing certificates,\n\t// this can be used to extract non-critical extensions that are not\n\t// parsed by this package. When marshaling certificates, the Extensions\n\t// field is ignored, see ExtraExtensions.\n\tExtensions\t[]pkix.Extension\n\n\t// ExtraExtensions contains extensions to be copied, raw, into any\n\t// marshaled certificates. Values override any extensions that would\n\t// otherwise be produced based on the other fields. The ExtraExtensions\n\t// field is not populated when parsing certificates, see Extensions.\n\tExtraExtensions\t[]pkix.Extension\n\n\t// UnhandledCriticalExtensions contains a list of extension IDs that\n\t// were not (fully) processed when parsing. Verify will fail if this\n\t// slice is non-empty, unless verification is delegated to an OS\n\t// library which understands all the critical extensions.\n\t//\n\t// Users can access these extensions using Extensions and can remove\n\t// elements from this slice if they believe that they have been\n\t// handled.\n\tUnhandledCriticalExtensions\t[]asn1.ObjectIdentifier\n\n\tExtKeyUsage\t\t[]ExtKeyUsage\t\t// Sequence of extended key usages.\n\tUnknownExtKeyUsage\t[]asn1.ObjectIdentifier\t// Encountered extended key usages unknown to this package.\n\n\t// BasicConstraintsValid indicates whether IsCA, MaxPathLen,\n\t// and MaxPathLenZero are valid.\n\tBasicConstraintsValid\tbool\n\tIsCA\t\t\tbool\n\n\t// MaxPathLen and MaxPathLenZero indicate the presence and\n\t// value of the BasicConstraints' \"pathLenConstraint\".\n\t//\n\t// When parsing a certificate, a positive non-zero MaxPathLen\n\t// means that the field was specified, -1 means it was unset,\n\t// and MaxPathLenZero being true mean that the field was\n\t// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false\n\t// should be treated equivalent to -1 (unset).\n\t//\n\t// When generating a certificate, an unset pathLenConstraint\n\t// can be requested with either MaxPathLen == -1 or using the\n\t// zero value for both MaxPathLen and MaxPathLenZero.\n\tMaxPathLen\tint\n\t// MaxPathLenZero indicates that BasicConstraintsValid==true\n\t// and MaxPathLen==0 should be interpreted as an actual\n\t// maximum path length of zero. Otherwise, that combination is\n\t// interpreted as MaxPathLen not being set.\n\tMaxPathLenZero\tbool\n\n\tSubjectKeyId\t[]byte\n\tAuthorityKeyId\t[]byte\n\n\t// RFC 5280, 4.2.2.1 (Authority Information Access)\n\tOCSPServer\t\t[]string\n\tIssuingCertificateURL\t[]string\n\n\t// Subject Alternate Name values. (Note that these values may not be valid\n\t// if invalid values were contained within a parsed certificate. For\n\t// example, an element of DNSNames may not be a valid DNS domain name.)\n\tDNSNames\t[]string\n\tEmailAddresses\t[]string\n\tIPAddresses\t[]net.IP\n\tURIs\t\t[]*url.URL\n\n\t// Name constraints\n\tPermittedDNSDomainsCritical\tbool\t// if true then the name constraints are marked critical.\n\tPermittedDNSDomains\t\t[]string\n\tExcludedDNSDomains\t\t[]string\n\tPermittedIPRanges\t\t[]*net.IPNet\n\tExcludedIPRanges\t\t[]*net.IPNet\n\tPermittedEmailAddresses\t\t[]string\n\tExcludedEmailAddresses\t\t[]string\n\tPermittedURIDomains\t\t[]string\n\tExcludedURIDomains\t\t[]string\n\n\t// CRL Distribution Points\n\tCRLDistributionPoints\t[]string\n\n\t// PolicyIdentifiers contains asn1.ObjectIdentifiers, the components\n\t// of which are limited to int32. If a certificate contains a policy which\n\t// cannot be represented by asn1.ObjectIdentifier, it will not be included in\n\t// PolicyIdentifiers, but will be present in Policies, which contains all parsed\n\t// policy OIDs.\n\tPolicyIdentifiers\t[]asn1.ObjectIdentifier\n\n\t// Policies contains all policy identifiers included in the certificate.\n\t// In Go 1.22, encoding/gob cannot handle and ignores this field.\n\tPolicies\t[]OID\n}","","","type ConstraintViolationError struct{}","type UnhandledCriticalExtension struct{}","func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv any) ([]byte, error)","func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)","func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)","type CertificateRequest struct {\n\tRaw\t\t\t\t[]byte\t// Complete ASN.1 DER content (CSR, signature algorithm and signature).\n\tRawTBSCertificateRequest\t[]byte\t// Certificate request info part of raw ASN.1 DER content.\n\tRawSubjectPublicKeyInfo\t\t[]byte\t// DER encoded SubjectPublicKeyInfo.\n\tRawSubject\t\t\t[]byte\t// DER encoded Subject.\n\n\tVersion\t\t\tint\n\tSignature\t\t[]byte\n\tSignatureAlgorithm\tSignatureAlgorithm\n\n\tPublicKeyAlgorithm\tPublicKeyAlgorithm\n\tPublicKey\t\tany\n\n\tSubject\tpkix.Name\n\n\t// Attributes contains the CSR attributes that can parse as\n\t// pkix.AttributeTypeAndValueSET.\n\t//\n\t// Deprecated: Use Extensions and ExtraExtensions instead for parsing and\n\t// generating the requestedExtensions attribute.\n\tAttributes\t[]pkix.AttributeTypeAndValueSET\n\n\t// Extensions contains all requested extensions, in raw form. When parsing\n\t// CSRs, this can be used to extract extensions that are not parsed by this\n\t// package.\n\tExtensions\t[]pkix.Extension\n\n\t// ExtraExtensions contains extensions to be copied, raw, into any CSR\n\t// marshaled by CreateCertificateRequest. Values override any extensions\n\t// that would otherwise be produced based on the other fields but are\n\t// overridden by any extensions specified in Attributes.\n\t//\n\t// The ExtraExtensions field is not populated by ParseCertificateRequest,\n\t// see Extensions instead.\n\tExtraExtensions\t[]pkix.Extension\n\n\t// Subject Alternate Name values.\n\tDNSNames\t[]string\n\tEmailAddresses\t[]string\n\tIPAddresses\t[]net.IP\n\tURIs\t\t[]*url.URL\n}","func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv any) (csr []byte, err error)","func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)","type RevocationListEntry struct {\n\t// Raw contains the raw bytes of the revokedCertificates entry. It is set when\n\t// parsing a CRL; it is ignored when generating a CRL.\n\tRaw\t[]byte\n\n\t// SerialNumber represents the serial number of a revoked certificate. It is\n\t// both used when creating a CRL and populated when parsing a CRL. It must not\n\t// be nil.\n\tSerialNumber\t*big.Int\n\t// RevocationTime represents the time at which the certificate was revoked. It\n\t// is both used when creating a CRL and populated when parsing a CRL. It must\n\t// not be the zero time.\n\tRevocationTime\ttime.Time\n\t// ReasonCode represents the reason for revocation, using the integer enum\n\t// values specified in RFC 5280 Section 5.3.1. When creating a CRL, the zero\n\t// value will result in the reasonCode extension being omitted. When parsing a\n\t// CRL, the zero value may represent either the reasonCode extension being\n\t// absent (which implies the default revocation reason of 0/Unspecified), or\n\t// it may represent the reasonCode extension being present and explicitly\n\t// containing a value of 0/Unspecified (which should not happen according to\n\t// the DER encoding rules, but can and does happen anyway).\n\tReasonCode\tint\n\n\t// Extensions contains raw X.509 extensions. When parsing CRL entries,\n\t// this can be used to extract non-critical extensions that are not\n\t// parsed by this package. When marshaling CRL entries, the Extensions\n\t// field is ignored, see ExtraExtensions.\n\tExtensions\t[]pkix.Extension\n\t// ExtraExtensions contains extensions to be copied, raw, into any\n\t// marshaled CRL entries. Values override any extensions that would\n\t// otherwise be produced based on the other fields. The ExtraExtensions\n\t// field is not populated when parsing CRL entries, see Extensions.\n\tExtraExtensions\t[]pkix.Extension\n}","type RevocationList struct {\n\t// Raw contains the complete ASN.1 DER content of the CRL (tbsCertList,\n\t// signatureAlgorithm, and signatureValue.)\n\tRaw\t[]byte\n\t// RawTBSRevocationList contains just the tbsCertList portion of the ASN.1\n\t// DER.\n\tRawTBSRevocationList\t[]byte\n\t// RawIssuer contains the DER encoded Issuer.\n\tRawIssuer\t[]byte\n\n\t// Issuer contains the DN of the issuing certificate.\n\tIssuer\tpkix.Name\n\t// AuthorityKeyId is used to identify the public key associated with the\n\t// issuing certificate. It is populated from the authorityKeyIdentifier\n\t// extension when parsing a CRL. It is ignored when creating a CRL; the\n\t// extension is populated from the issuing certificate itself.\n\tAuthorityKeyId\t[]byte\n\n\tSignature\t[]byte\n\t// SignatureAlgorithm is used to determine the signature algorithm to be\n\t// used when signing the CRL. If 0 the default algorithm for the signing\n\t// key will be used.\n\tSignatureAlgorithm\tSignatureAlgorithm\n\n\t// RevokedCertificateEntries represents the revokedCertificates sequence in\n\t// the CRL. It is used when creating a CRL and also populated when parsing a\n\t// CRL. When creating a CRL, it may be empty or nil, in which case the\n\t// revokedCertificates ASN.1 sequence will be omitted from the CRL entirely.\n\tRevokedCertificateEntries\t[]RevocationListEntry\n\n\t// RevokedCertificates is used to populate the revokedCertificates\n\t// sequence in the CRL if RevokedCertificateEntries is empty. It may be empty\n\t// or nil, in which case an empty CRL will be created.\n\t//\n\t// Deprecated: Use RevokedCertificateEntries instead.\n\tRevokedCertificates\t[]pkix.RevokedCertificate\n\n\t// Number is used to populate the X.509 v2 cRLNumber extension in the CRL,\n\t// which should be a monotonically increasing sequence number for a given\n\t// CRL scope and CRL issuer. It is also populated from the cRLNumber\n\t// extension when parsing a CRL.\n\tNumber\t*big.Int\n\n\t// ThisUpdate is used to populate the thisUpdate field in the CRL, which\n\t// indicates the issuance date of the CRL.\n\tThisUpdate\ttime.Time\n\t// NextUpdate is used to populate the nextUpdate field in the CRL, which\n\t// indicates the date by which the next CRL will be issued. NextUpdate\n\t// must be greater than ThisUpdate.\n\tNextUpdate\ttime.Time\n\n\t// Extensions contains raw X.509 extensions. When creating a CRL,\n\t// the Extensions field is ignored, see ExtraExtensions.\n\tExtensions\t[]pkix.Extension\n\n\t// ExtraExtensions contains any additional extensions to add directly to\n\t// the CRL.\n\tExtraExtensions\t[]pkix.Extension\n}","func CreateRevocationList(rand io.Reader, template *RevocationList, issuer *Certificate, priv crypto.Signer) ([]byte, error)","func Register(name string, driver driver.Driver)","func Drivers() []string","type NamedArg struct {\n\t_NamedFieldsRequired\tstruct{}\n\n\t// Name is the name of the parameter placeholder.\n\t//\n\t// If empty, the ordinal position in the argument list will be\n\t// used.\n\t//\n\t// Name must omit any symbol prefix.\n\tName\tstring\n\n\t// Value is the value of the parameter.\n\t// It may be assigned the same value types as the query\n\t// arguments.\n\tValue\tany\n}","func Named(name string, value any) NamedArg","","const LevelDefault IsolationLevel","const LevelReadUncommitted","const LevelReadCommitted","const LevelWriteCommitted","const LevelRepeatableRead","const LevelSnapshot","const LevelSerializable","const LevelLinearizable","type TxOptions struct {\n\t// Isolation is the transaction isolation level.\n\t// If zero, the driver or database's default level is used.\n\tIsolation\tIsolationLevel\n\tReadOnly\tbool\n}","type RawBytes []byte","type NullString struct {\n\tString\tstring\n\tValid\tbool\t// Valid is true if String is not NULL\n}","type NullInt64 struct {\n\tInt64\tint64\n\tValid\tbool\t// Valid is true if Int64 is not NULL\n}","type NullInt32 struct {\n\tInt32\tint32\n\tValid\tbool\t// Valid is true if Int32 is not NULL\n}","type NullInt16 struct {\n\tInt16\tint16\n\tValid\tbool\t// Valid is true if Int16 is not NULL\n}","type NullByte struct {\n\tByte\tbyte\n\tValid\tbool\t// Valid is true if Byte is not NULL\n}","type NullFloat64 struct {\n\tFloat64\tfloat64\n\tValid\tbool\t// Valid is true if Float64 is not NULL\n}","type NullBool struct {\n\tBool\tbool\n\tValid\tbool\t// Valid is true if Bool is not NULL\n}","type NullTime struct {\n\tTime\ttime.Time\n\tValid\tbool\t// Valid is true if Time is not NULL\n}","type Null[T any] struct {\n\tV\tT\n\tValid\tbool\n}","type Scanner interface {\n\t// Scan assigns a value from a database driver.\n\t//\n\t// The src value will be of one of the following types:\n\t//\n\t//    int64\n\t//    float64\n\t//    bool\n\t//    []byte\n\t//    string\n\t//    time.Time\n\t//    nil - for NULL values\n\t//\n\t// An error should be returned if the value cannot be stored\n\t// without loss of information.\n\t//\n\t// Reference types such as []byte are only valid until the next call to Scan\n\t// and should not be retained. Their underlying memory is owned by the driver.\n\t// If retention is necessary, copy their values before the next call to Scan.\n\tScan(src any) error\n}","type Out struct {\n\t_NamedFieldsRequired\tstruct{}\n\n\t// Dest is a pointer to the value that will be set to the result of the\n\t// stored procedure's OUTPUT parameter.\n\tDest\tany\n\n\t// In is whether the parameter is an INOUT parameter. If so, the input value to the stored\n\t// procedure is the dereferenced value of Dest's pointer, which is then replaced with\n\t// the output value.\n\tIn\tbool\n}","","type DB struct {\n\t// Total time waited for new connections.\n\twaitDuration\tatomic.Int64\n\n\tconnector\tdriver.Connector\n\t// numClosed is an atomic counter which represents a total number of\n\t// closed connections. Stmt.openStmt checks it before cleaning closed\n\t// connections in Stmt.css.\n\tnumClosed\tatomic.Uint64\n\n\tmu\t\tsync.Mutex\t// protects following fields\n\tfreeConn\t[]*driverConn\t// free connections ordered by returnedAt oldest to newest\n\tconnRequests\tconnRequestSet\n\tnumOpen\t\tint\t// number of opened and pending open connections\n\t// Used to signal the need for new connections\n\t// a goroutine running connectionOpener() reads on this chan and\n\t// maybeOpenNewConnections sends on the chan (one send per needed connection)\n\t// It is closed during db.Close(). The close tells the connectionOpener\n\t// goroutine to exit.\n\topenerCh\t\tchan struct{}\n\tclosed\t\t\tbool\n\tdep\t\t\tmap[finalCloser]depSet\n\tlastPut\t\t\tmap[*driverConn]string\t// stacktrace of last conn's put; debug only\n\tmaxIdleCount\t\tint\t\t\t// zero means defaultMaxIdleConns; negative means 0\n\tmaxOpen\t\t\tint\t\t\t// \u003c= 0 means unlimited\n\tmaxLifetime\t\ttime.Duration\t\t// maximum amount of time a connection may be reused\n\tmaxIdleTime\t\ttime.Duration\t\t// maximum amount of time a connection may be idle before being closed\n\tcleanerCh\t\tchan struct{}\n\twaitCount\t\tint64\t// Total number of connections waited for.\n\tmaxIdleClosed\t\tint64\t// Total number of connections closed due to idle count.\n\tmaxIdleTimeClosed\tint64\t// Total number of connections closed due to idle time.\n\tmaxLifetimeClosed\tint64\t// Total number of connections closed due to max connection lifetime limit.\n\n\tstop\tfunc()\t// stop cancels the connection opener.\n}","func OpenDB(c driver.Connector) *DB","func Open(driverName, dataSourceName string) (*DB, error)","type DBStats struct {\n\tMaxOpenConnections\tint\t// Maximum number of open connections to the database.\n\n\t// Pool Status\n\tOpenConnections\tint\t// The number of established connections both in use and idle.\n\tInUse\t\tint\t// The number of connections currently in use.\n\tIdle\t\tint\t// The number of idle connections.\n\n\t// Counters\n\tWaitCount\t\tint64\t\t// The total number of connections waited for.\n\tWaitDuration\t\ttime.Duration\t// The total time blocked waiting for a new connection.\n\tMaxIdleClosed\t\tint64\t\t// The total number of connections closed due to SetMaxIdleConns.\n\tMaxIdleTimeClosed\tint64\t\t// The total number of connections closed due to SetConnMaxIdleTime.\n\tMaxLifetimeClosed\tint64\t\t// The total number of connections closed due to SetConnMaxLifetime.\n}","","type Conn struct {\n\tdb\t*DB\n\n\t// closemu prevents the connection from closing while there\n\t// is an active query. It is held for read during queries\n\t// and exclusively during close.\n\tclosemu\tsync.RWMutex\n\n\t// dc is owned until close, at which point\n\t// it's returned to the connection pool.\n\tdc\t*driverConn\n\n\t// done transitions from false to true exactly once, on close.\n\t// Once done, all operations fail with ErrConnDone.\n\tdone\tatomic.Bool\n\n\treleaseConnOnce\tsync.Once\n\t// releaseConnCache is a cache of c.closemuRUnlockCondReleaseConn\n\t// to save allocations in a call to grabConn.\n\treleaseConnCache\treleaseConn\n}","type Tx struct {\n\tdb\t*DB\n\n\t// closemu prevents the transaction from closing while there\n\t// is an active query. It is held for read during queries\n\t// and exclusively during close.\n\tclosemu\tsync.RWMutex\n\n\t// dc is owned exclusively until Commit or Rollback, at which point\n\t// it's returned with putConn.\n\tdc\t*driverConn\n\ttxi\tdriver.Tx\n\n\t// releaseConn is called once the Tx is closed to release\n\t// any held driverConn back to the pool.\n\treleaseConn\tfunc(error)\n\n\t// done transitions from false to true exactly once, on Commit\n\t// or Rollback. once done, all operations fail with\n\t// ErrTxDone.\n\tdone\tatomic.Bool\n\n\t// keepConnOnRollback is true if the driver knows\n\t// how to reset the connection's session and if need be discard\n\t// the connection.\n\tkeepConnOnRollback\tbool\n\n\t// All Stmts prepared for this transaction. These will be closed after the\n\t// transaction has been committed or rolled back.\n\tstmts\tstruct {\n\t\tsync.Mutex\n\t\tv\t[]*Stmt\n\t}\n\n\t// cancel is called after done transitions from 0 to 1.\n\tcancel\tfunc()\n\n\t// ctx lives for the life of the transaction.\n\tctx\tcontext.Context\n}","","type Stmt struct {\n\t// Immutable:\n\tdb\t\t*DB\t// where we came from\n\tquery\t\tstring\t// that created the Stmt\n\tstickyErr\terror\t// if non-nil, this error is returned for all operations\n\n\tclosemu\tsync.RWMutex\t// held exclusively during close, for read otherwise.\n\n\t// If Stmt is prepared on a Tx or Conn then cg is present and will\n\t// only ever grab a connection from cg.\n\t// If cg is nil then the Stmt must grab an arbitrary connection\n\t// from db and determine if it must prepare the stmt again by\n\t// inspecting css.\n\tcg\tstmtConnGrabber\n\tcgds\t*driverStmt\n\n\t// parentStmt is set when a transaction-specific statement\n\t// is requested from an identical statement prepared on the same\n\t// conn. parentStmt is used to track the dependency of this statement\n\t// on its originating (\"parent\") statement so that parentStmt may\n\t// be closed by the user without them having to know whether or not\n\t// any transactions are still using it.\n\tparentStmt\t*Stmt\n\n\tmu\tsync.Mutex\t// protects the rest of the fields\n\tclosed\tbool\n\n\t// css is a list of underlying driver statement interfaces\n\t// that are valid on particular connections. This is only\n\t// used if cg == nil and one is found that has idle\n\t// connections. If cg != nil, cgds is always used.\n\tcss\t[]connStmt\n\n\t// lastNumClosed is copied from db.numClosed when Stmt is created\n\t// without tx and closed connections in css are removed.\n\tlastNumClosed\tuint64\n}","type Rows struct {\n\tdc\t\t*driverConn\t// owned; must call releaseConn when closed to release\n\treleaseConn\tfunc(error)\n\trowsi\t\tdriver.Rows\n\tcancel\t\tfunc()\t\t// called when Rows is closed, may be nil.\n\tcloseStmt\t*driverStmt\t// if non-nil, statement to Close on close\n\n\tcontextDone\tatomic.Pointer[error]\t// error that awaitDone saw; set before close attempt\n\n\t// closemu prevents Rows from closing while there\n\t// is an active streaming result. It is held for read during non-close operations\n\t// and exclusively during close.\n\t//\n\t// closemu guards lasterr and closed.\n\tclosemu\tsync.RWMutex\n\tlasterr\terror\t// non-nil only if closed is true\n\tclosed\tbool\n\n\t// closemuScanHold is whether the previous call to Scan kept closemu RLock'ed\n\t// without unlocking it. It does that when the user passes a *RawBytes scan\n\t// target. In that case, we need to prevent awaitDone from closing the Rows\n\t// while the user's still using the memory. See go.dev/issue/60304.\n\t//\n\t// It is only used by Scan, Next, and NextResultSet which are expected\n\t// not to be called concurrently.\n\tclosemuScanHold\tbool\n\n\t// hitEOF is whether Next hit the end of the rows without\n\t// encountering an error. It's set in Next before\n\t// returning. It's only used by Next and Err which are\n\t// expected not to be called concurrently.\n\thitEOF\tbool\n\n\t// lastcols is only used in Scan, Next, and NextResultSet which are expected\n\t// not to be called concurrently.\n\tlastcols\t[]driver.Value\n\n\t// raw is a buffer for RawBytes that persists between Scan calls.\n\t// This is used when the driver returns a mismatched type that requires\n\t// a cloning allocation. For example, if the driver returns a *string and\n\t// the user is scanning into a *RawBytes, we need to copy the string.\n\t// The raw buffer here lets us reuse the memory for that copy across Scan calls.\n\traw\t[]byte\n}","type ColumnType struct {\n\tname\tstring\n\n\thasNullable\t\tbool\n\thasLength\t\tbool\n\thasPrecisionScale\tbool\n\n\tnullable\tbool\n\tlength\t\tint64\n\tdatabaseType\tstring\n\tprecision\tint64\n\tscale\t\tint64\n\tscanType\treflect.Type\n}","type Row struct {\n\t// One of these two will be non-nil:\n\terr\terror\t// deferred error for easy chaining\n\trows\t*Rows\n}","type Result interface {\n\t// LastInsertId returns the integer generated by the database\n\t// in response to a command. Typically this will be from an\n\t// \"auto increment\" column when inserting a new row. Not all\n\t// databases support this feature, and the syntax of such\n\t// statements varies.\n\tLastInsertId() (int64, error)\n\n\t// RowsAffected returns the number of rows affected by an\n\t// update, insert, or delete. Not every database or database\n\t// driver may support this.\n\tRowsAffected() (int64, error)\n}","type BuildInfo = debug.BuildInfo","func ReadFile(name string) (info *BuildInfo, err error)","func Read(r io.ReaderAt) (*BuildInfo, error)","type DecodeError struct {\n\tName\tstring\n\tOffset\tOffset\n\tErr\tstring\n}","","const AttrSibling Attr = 0x01","const AttrLocation Attr = 0x02","const AttrName Attr = 0x03","const AttrOrdering Attr = 0x09","const AttrByteSize Attr = 0x0B","const AttrBitOffset Attr = 0x0C","const AttrBitSize Attr = 0x0D","const AttrStmtList Attr = 0x10","const AttrLowpc Attr = 0x11","const AttrHighpc Attr = 0x12","const AttrLanguage Attr = 0x13","const AttrDiscr Attr = 0x15","const AttrDiscrValue Attr = 0x16","const AttrVisibility Attr = 0x17","const AttrImport Attr = 0x18","const AttrStringLength Attr = 0x19","const AttrCommonRef Attr = 0x1A","const AttrCompDir Attr = 0x1B","const AttrConstValue Attr = 0x1C","const AttrContainingType Attr = 0x1D","const AttrDefaultValue Attr = 0x1E","const AttrInline Attr = 0x20","const AttrIsOptional Attr = 0x21","const AttrLowerBound Attr = 0x22","const AttrProducer Attr = 0x25","const AttrPrototyped Attr = 0x27","const AttrReturnAddr Attr = 0x2A","const AttrStartScope Attr = 0x2C","const AttrStrideSize Attr = 0x2E","const AttrUpperBound Attr = 0x2F","const AttrAbstractOrigin Attr = 0x31","const AttrAccessibility Attr = 0x32","const AttrAddrClass Attr = 0x33","const AttrArtificial Attr = 0x34","const AttrBaseTypes Attr = 0x35","const AttrCalling Attr = 0x36","const AttrCount Attr = 0x37","const AttrDataMemberLoc Attr = 0x38","const AttrDeclColumn Attr = 0x39","const AttrDeclFile Attr = 0x3A","const AttrDeclLine Attr = 0x3B","const AttrDeclaration Attr = 0x3C","const AttrDiscrList Attr = 0x3D","const AttrEncoding Attr = 0x3E","const AttrExternal Attr = 0x3F","const AttrFrameBase Attr = 0x40","const AttrFriend Attr = 0x41","const AttrIdentifierCase Attr = 0x42","const AttrMacroInfo Attr = 0x43","const AttrNamelistItem Attr = 0x44","const AttrPriority Attr = 0x45","const AttrSegment Attr = 0x46","const AttrSpecification Attr = 0x47","const AttrStaticLink Attr = 0x48","const AttrType Attr = 0x49","const AttrUseLocation Attr = 0x4A","const AttrVarParam Attr = 0x4B","const AttrVirtuality Attr = 0x4C","const AttrVtableElemLoc Attr = 0x4D","const AttrAllocated Attr = 0x4E","const AttrAssociated Attr = 0x4F","const AttrDataLocation Attr = 0x50","const AttrStride Attr = 0x51","const AttrEntrypc Attr = 0x52","const AttrUseUTF8 Attr = 0x53","const AttrExtension Attr = 0x54","const AttrRanges Attr = 0x55","const AttrTrampoline Attr = 0x56","const AttrCallColumn Attr = 0x57","const AttrCallFile Attr = 0x58","const AttrCallLine Attr = 0x59","const AttrDescription Attr = 0x5A","const AttrBinaryScale Attr = 0x5B","const AttrDecimalScale Attr = 0x5C","const AttrSmall Attr = 0x5D","const AttrDecimalSign Attr = 0x5E","const AttrDigitCount Attr = 0x5F","const AttrPictureString Attr = 0x60","const AttrMutable Attr = 0x61","const AttrThreadsScaled Attr = 0x62","const AttrExplicit Attr = 0x63","const AttrObjectPointer Attr = 0x64","const AttrEndianity Attr = 0x65","const AttrElemental Attr = 0x66","const AttrPure Attr = 0x67","const AttrRecursive Attr = 0x68","const AttrSignature Attr = 0x69","const AttrMainSubprogram Attr = 0x6A","const AttrDataBitOffset Attr = 0x6B","const AttrConstExpr Attr = 0x6C","const AttrEnumClass Attr = 0x6D","const AttrLinkageName Attr = 0x6E","const AttrStringLengthBitSize Attr = 0x6F","const AttrStringLengthByteSize Attr = 0x70","const AttrRank Attr = 0x71","const AttrStrOffsetsBase Attr = 0x72","const AttrAddrBase Attr = 0x73","const AttrRnglistsBase Attr = 0x74","const AttrDwoName Attr = 0x76","const AttrReference Attr = 0x77","const AttrRvalueReference Attr = 0x78","const AttrMacros Attr = 0x79","const AttrCallAllCalls Attr = 0x7A","const AttrCallAllSourceCalls Attr = 0x7B","const AttrCallAllTailCalls Attr = 0x7C","const AttrCallReturnPC Attr = 0x7D","const AttrCallValue Attr = 0x7E","const AttrCallOrigin Attr = 0x7F","const AttrCallParameter Attr = 0x80","const AttrCallPC Attr = 0x81","const AttrCallTailCall Attr = 0x82","const AttrCallTarget Attr = 0x83","const AttrCallTargetClobbered Attr = 0x84","const AttrCallDataLocation Attr = 0x85","const AttrCallDataValue Attr = 0x86","const AttrNoreturn Attr = 0x87","const AttrAlignment Attr = 0x88","const AttrExportSymbols Attr = 0x89","const AttrDeleted Attr = 0x8A","const AttrDefaulted Attr = 0x8B","const AttrLoclistsBase Attr = 0x8C","","const TagArrayType Tag = 0x01","const TagClassType Tag = 0x02","const TagEntryPoint Tag = 0x03","const TagEnumerationType Tag = 0x04","const TagFormalParameter Tag = 0x05","const TagImportedDeclaration Tag = 0x08","const TagLabel Tag = 0x0A","const TagLexDwarfBlock Tag = 0x0B","const TagMember Tag = 0x0D","const TagPointerType Tag = 0x0F","const TagReferenceType Tag = 0x10","const TagCompileUnit Tag = 0x11","const TagStringType Tag = 0x12","const TagStructType Tag = 0x13","const TagSubroutineType Tag = 0x15","const TagTypedef Tag = 0x16","const TagUnionType Tag = 0x17","const TagUnspecifiedParameters Tag = 0x18","const TagVariant Tag = 0x19","const TagCommonDwarfBlock Tag = 0x1A","const TagCommonInclusion Tag = 0x1B","const TagInheritance Tag = 0x1C","const TagInlinedSubroutine Tag = 0x1D","const TagModule Tag = 0x1E","const TagPtrToMemberType Tag = 0x1F","const TagSetType Tag = 0x20","const TagSubrangeType Tag = 0x21","const TagWithStmt Tag = 0x22","const TagAccessDeclaration Tag = 0x23","const TagBaseType Tag = 0x24","const TagCatchDwarfBlock Tag = 0x25","const TagConstType Tag = 0x26","const TagConstant Tag = 0x27","const TagEnumerator Tag = 0x28","const TagFileType Tag = 0x29","const TagFriend Tag = 0x2A","const TagNamelist Tag = 0x2B","const TagNamelistItem Tag = 0x2C","const TagPackedType Tag = 0x2D","const TagSubprogram Tag = 0x2E","const TagTemplateTypeParameter Tag = 0x2F","const TagTemplateValueParameter Tag = 0x30","const TagThrownType Tag = 0x31","const TagTryDwarfBlock Tag = 0x32","const TagVariantPart Tag = 0x33","const TagVariable Tag = 0x34","const TagVolatileType Tag = 0x35","const TagDwarfProcedure Tag = 0x36","const TagRestrictType Tag = 0x37","const TagInterfaceType Tag = 0x38","const TagNamespace Tag = 0x39","const TagImportedModule Tag = 0x3A","const TagUnspecifiedType Tag = 0x3B","const TagPartialUnit Tag = 0x3C","const TagImportedUnit Tag = 0x3D","const TagMutableType Tag = 0x3E","const TagCondition Tag = 0x3F","const TagSharedType Tag = 0x40","const TagTypeUnit Tag = 0x41","const TagRvalueReferenceType Tag = 0x42","const TagTemplateAlias Tag = 0x43","const TagCoarrayType Tag = 0x44","const TagGenericSubrange Tag = 0x45","const TagDynamicType Tag = 0x46","const TagAtomicType Tag = 0x47","const TagCallSite Tag = 0x48","const TagCallSiteParameter Tag = 0x49","const TagSkeletonUnit Tag = 0x4A","const TagImmutableType Tag = 0x4B","type Entry struct {\n\tOffset\t\tOffset\t// offset of Entry in DWARF info\n\tTag\t\tTag\t// tag (kind of Entry)\n\tChildren\tbool\t// whether Entry is followed by children\n\tField\t\t[]Field\n}","type Field struct {\n\tAttr\tAttr\n\tVal\tany\n\tClass\tClass\n}","","const ClassUnknown Class","const ClassAddress","const ClassBlock","const ClassConstant","const ClassExprLoc","const ClassFlag","const ClassLinePtr","const ClassLocListPtr","const ClassMacPtr","const ClassRangeListPtr","const ClassReference","const ClassReferenceSig","const ClassString","const ClassReferenceAlt","const ClassStringAlt","const ClassAddrPtr","const ClassLocList","const ClassRngList","const ClassRngListsPtr","const ClassStrOffsetsPtr","","type Reader struct {\n\tb\t\tbuf\n\td\t\t*Data\n\terr\t\terror\n\tunit\t\tint\n\tlastUnit\tbool\t// set if last entry returned by Next is TagCompileUnit/TagPartialUnit\n\tlastChildren\tbool\t// .Children of last entry returned by Next\n\tlastSibling\tOffset\t// .Val(AttrSibling) of last entry returned by Next\n\tcu\t\t*Entry\t// current compilation unit\n}","type LineReader struct {\n\tbuf\tbuf\n\n\t// Original .debug_line section data. Used by Seek.\n\tsection\t[]byte\n\n\tstr\t[]byte\t// .debug_str\n\tlineStr\t[]byte\t// .debug_line_str\n\n\t// Header information\n\tversion\t\t\tuint16\n\taddrsize\t\tint\n\tsegmentSelectorSize\tint\n\tminInstructionLength\tint\n\tmaxOpsPerInstruction\tint\n\tdefaultIsStmt\t\tbool\n\tlineBase\t\tint\n\tlineRange\t\tint\n\topcodeBase\t\tint\n\topcodeLengths\t\t[]int\n\tdirectories\t\t[]string\n\tfileEntries\t\t[]*LineFile\n\n\tprogramOffset\tOffset\t// section offset of line number program\n\tendOffset\tOffset\t// section offset of byte following program\n\n\tinitialFileEntries\tint\t// initial length of fileEntries\n\n\t// Current line number program state machine registers\n\tstate\t\tLineEntry\t// public state\n\tfileIndex\tint\t\t// private state\n}","type LineEntry struct {\n\t// Address is the program-counter value of a machine\n\t// instruction generated by the compiler. This LineEntry\n\t// applies to each instruction from Address to just before the\n\t// Address of the next LineEntry.\n\tAddress\tuint64\n\n\t// OpIndex is the index of an operation within a VLIW\n\t// instruction. The index of the first operation is 0. For\n\t// non-VLIW architectures, it will always be 0. Address and\n\t// OpIndex together form an operation pointer that can\n\t// reference any individual operation within the instruction\n\t// stream.\n\tOpIndex\tint\n\n\t// File is the source file corresponding to these\n\t// instructions.\n\tFile\t*LineFile\n\n\t// Line is the source code line number corresponding to these\n\t// instructions. Lines are numbered beginning at 1. It may be\n\t// 0 if these instructions cannot be attributed to any source\n\t// line.\n\tLine\tint\n\n\t// Column is the column number within the source line of these\n\t// instructions. Columns are numbered beginning at 1. It may\n\t// be 0 to indicate the \"left edge\" of the line.\n\tColumn\tint\n\n\t// IsStmt indicates that Address is a recommended breakpoint\n\t// location, such as the beginning of a line, statement, or a\n\t// distinct subpart of a statement.\n\tIsStmt\tbool\n\n\t// BasicBlock indicates that Address is the beginning of a\n\t// basic block.\n\tBasicBlock\tbool\n\n\t// PrologueEnd indicates that Address is one (of possibly\n\t// many) PCs where execution should be suspended for a\n\t// breakpoint on entry to the containing function.\n\t//\n\t// Added in DWARF 3.\n\tPrologueEnd\tbool\n\n\t// EpilogueBegin indicates that Address is one (of possibly\n\t// many) PCs where execution should be suspended for a\n\t// breakpoint on exit from this function.\n\t//\n\t// Added in DWARF 3.\n\tEpilogueBegin\tbool\n\n\t// ISA is the instruction set architecture for these\n\t// instructions. Possible ISA values should be defined by the\n\t// applicable ABI specification.\n\t//\n\t// Added in DWARF 3.\n\tISA\tint\n\n\t// Discriminator is an arbitrary integer indicating the block\n\t// to which these instructions belong. It serves to\n\t// distinguish among multiple blocks that may all have with\n\t// the same source file, line, and column. Where only one\n\t// block exists for a given source position, it should be 0.\n\t//\n\t// Added in DWARF 3.\n\tDiscriminator\tint\n\n\t// EndSequence indicates that Address is the first byte after\n\t// the end of a sequence of target machine instructions. If it\n\t// is set, only this and the Address field are meaningful. A\n\t// line number table may contain information for multiple\n\t// potentially disjoint instruction sequences. The last entry\n\t// in a line table should always have EndSequence set.\n\tEndSequence\tbool\n}","type LineFile struct {\n\tName\tstring\n\tMtime\tuint64\t// Implementation defined modification time, or 0 if unknown\n\tLength\tint\t// File length, or 0 if unknown\n}","type LineReaderPos struct {\n\t// off is the current offset in the DWARF line section.\n\toff\tOffset\n\t// numFileEntries is the length of fileEntries.\n\tnumFileEntries\tint\n\t// state and fileIndex are the statement machine state at\n\t// offset off.\n\tstate\t\tLineEntry\n\tfileIndex\tint\n}","","type Data struct {\n\t// raw data\n\tabbrev\t\t[]byte\n\taranges\t\t[]byte\n\tframe\t\t[]byte\n\tinfo\t\t[]byte\n\tline\t\t[]byte\n\tpubnames\t[]byte\n\tranges\t\t[]byte\n\tstr\t\t[]byte\n\n\t// New sections added in DWARF 5.\n\taddr\t\t[]byte\n\tlineStr\t\t[]byte\n\tstrOffsets\t[]byte\n\trngLists\t[]byte\n\n\t// parsed data\n\tabbrevCache\tmap[uint64]abbrevTable\n\tbigEndian\tbool\n\torder\t\tbinary.ByteOrder\n\ttypeCache\tmap[Offset]Type\n\ttypeSigs\tmap[uint64]*typeUnit\n\tunit\t\t[]unit\n}","func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)","type Type interface {\n\tCommon() *CommonType\n\tString() string\n\tSize() int64\n}","type CommonType struct {\n\tByteSize\tint64\t// size of value of this type, in bytes\n\tName\t\tstring\t// name that can be used to refer to type\n}","type BasicType struct {\n\tCommonType\n\tBitSize\t\tint64\n\tBitOffset\tint64\n\tDataBitOffset\tint64\n}","type CharType struct {\n\tBasicType\n}","type UcharType struct {\n\tBasicType\n}","type IntType struct {\n\tBasicType\n}","type UintType struct {\n\tBasicType\n}","type FloatType struct {\n\tBasicType\n}","type ComplexType struct {\n\tBasicType\n}","type BoolType struct {\n\tBasicType\n}","type AddrType struct {\n\tBasicType\n}","type UnspecifiedType struct {\n\tBasicType\n}","type QualType struct {\n\tCommonType\n\tQual\tstring\n\tType\tType\n}","type ArrayType struct {\n\tCommonType\n\tType\t\tType\n\tStrideBitSize\tint64\t// if \u003e 0, number of bits to hold each element\n\tCount\t\tint64\t// if == -1, an incomplete array, like char x[].\n}","type VoidType struct {\n\tCommonType\n}","type PtrType struct {\n\tCommonType\n\tType\tType\n}","type StructType struct {\n\tCommonType\n\tStructName\tstring\n\tKind\t\tstring\t// \"struct\", \"union\", or \"class\".\n\tField\t\t[]*StructField\n\tIncomplete\tbool\t// if true, struct, union, class is declared but not defined\n}","type StructField struct {\n\tName\t\tstring\n\tType\t\tType\n\tByteOffset\tint64\n\tByteSize\tint64\t// usually zero; use Type.Size() for normal fields\n\tBitOffset\tint64\n\tDataBitOffset\tint64\n\tBitSize\t\tint64\t// zero if not a bit field\n}","type EnumType struct {\n\tCommonType\n\tEnumName\tstring\n\tVal\t\t[]*EnumValue\n}","type EnumValue struct {\n\tName\tstring\n\tVal\tint64\n}","type FuncType struct {\n\tCommonType\n\tReturnType\tType\n\tParamType\t[]Type\n}","type DotDotDotType struct {\n\tCommonType\n}","type TypedefType struct {\n\tCommonType\n\tType\tType\n}","type UnsupportedType struct {\n\tCommonType\n\tTag\tTag\n}","const EI_CLASS = 4","const EI_DATA = 5","const EI_VERSION = 6","const EI_OSABI = 7","const EI_ABIVERSION = 8","const EI_PAD = 9","const EI_NIDENT = 16","const ELFMAG = \"\\177ELF\"","","const EV_NONE Version = 0","const EV_CURRENT Version = 1","","const ELFCLASSNONE Class = 0","const ELFCLASS32 Class = 1","const ELFCLASS64 Class = 2","","const ELFDATANONE Data = 0","const ELFDATA2LSB Data = 1","const ELFDATA2MSB Data = 2","","const ELFOSABI_NONE OSABI = 0","const ELFOSABI_HPUX OSABI = 1","const ELFOSABI_NETBSD OSABI = 2","const ELFOSABI_LINUX OSABI = 3","const ELFOSABI_HURD OSABI = 4","const ELFOSABI_86OPEN OSABI = 5","const ELFOSABI_SOLARIS OSABI = 6","const ELFOSABI_AIX OSABI = 7","const ELFOSABI_IRIX OSABI = 8","const ELFOSABI_FREEBSD OSABI = 9","const ELFOSABI_TRU64 OSABI = 10","const ELFOSABI_MODESTO OSABI = 11","const ELFOSABI_OPENBSD OSABI = 12","const ELFOSABI_OPENVMS OSABI = 13","const ELFOSABI_NSK OSABI = 14","const ELFOSABI_AROS OSABI = 15","const ELFOSABI_FENIXOS OSABI = 16","const ELFOSABI_CLOUDABI OSABI = 17","const ELFOSABI_ARM OSABI = 97","const ELFOSABI_STANDALONE OSABI = 255","","const ET_NONE Type = 0","const ET_REL Type = 1","const ET_EXEC Type = 2","const ET_DYN Type = 3","const ET_CORE Type = 4","const ET_LOOS Type = 0xfe00","const ET_HIOS Type = 0xfeff","const ET_LOPROC Type = 0xff00","const ET_HIPROC Type = 0xffff","","const EM_NONE Machine = 0","const EM_M32 Machine = 1","const EM_SPARC Machine = 2","const EM_386 Machine = 3","const EM_68K Machine = 4","const EM_88K Machine = 5","const EM_860 Machine = 7","const EM_MIPS Machine = 8","const EM_S370 Machine = 9","const EM_MIPS_RS3_LE Machine = 10","const EM_PARISC Machine = 15","const EM_VPP500 Machine = 17","const EM_SPARC32PLUS Machine = 18","const EM_960 Machine = 19","const EM_PPC Machine = 20","const EM_PPC64 Machine = 21","const EM_S390 Machine = 22","const EM_V800 Machine = 36","const EM_FR20 Machine = 37","const EM_RH32 Machine = 38","const EM_RCE Machine = 39","const EM_ARM Machine = 40","const EM_SH Machine = 42","const EM_SPARCV9 Machine = 43","const EM_TRICORE Machine = 44","const EM_ARC Machine = 45","const EM_H8_300 Machine = 46","const EM_H8_300H Machine = 47","const EM_H8S Machine = 48","const EM_H8_500 Machine = 49","const EM_IA_64 Machine = 50","const EM_MIPS_X Machine = 51","const EM_COLDFIRE Machine = 52","const EM_68HC12 Machine = 53","const EM_MMA Machine = 54","const EM_PCP Machine = 55","const EM_NCPU Machine = 56","const EM_NDR1 Machine = 57","const EM_STARCORE Machine = 58","const EM_ME16 Machine = 59","const EM_ST100 Machine = 60","const EM_TINYJ Machine = 61","const EM_X86_64 Machine = 62","const EM_PDSP Machine = 63","const EM_PDP10 Machine = 64","const EM_PDP11 Machine = 65","const EM_FX66 Machine = 66","const EM_ST9PLUS Machine = 67","const EM_ST7 Machine = 68","const EM_68HC16 Machine = 69","const EM_68HC11 Machine = 70","const EM_68HC08 Machine = 71","const EM_68HC05 Machine = 72","const EM_SVX Machine = 73","const EM_ST19 Machine = 74","const EM_VAX Machine = 75","const EM_CRIS Machine = 76","const EM_JAVELIN Machine = 77","const EM_FIREPATH Machine = 78","const EM_ZSP Machine = 79","const EM_MMIX Machine = 80","const EM_HUANY Machine = 81","const EM_PRISM Machine = 82","const EM_AVR Machine = 83","const EM_FR30 Machine = 84","const EM_D10V Machine = 85","const EM_D30V Machine = 86","const EM_V850 Machine = 87","const EM_M32R Machine = 88","const EM_MN10300 Machine = 89","const EM_MN10200 Machine = 90","const EM_PJ Machine = 91","const EM_OPENRISC Machine = 92","const EM_ARC_COMPACT Machine = 93","const EM_XTENSA Machine = 94","const EM_VIDEOCORE Machine = 95","const EM_TMM_GPP Machine = 96","const EM_NS32K Machine = 97","const EM_TPC Machine = 98","const EM_SNP1K Machine = 99","const EM_ST200 Machine = 100","const EM_IP2K Machine = 101","const EM_MAX Machine = 102","const EM_CR Machine = 103","const EM_F2MC16 Machine = 104","const EM_MSP430 Machine = 105","const EM_BLACKFIN Machine = 106","const EM_SE_C33 Machine = 107","const EM_SEP Machine = 108","const EM_ARCA Machine = 109","const EM_UNICORE Machine = 110","const EM_EXCESS Machine = 111","const EM_DXP Machine = 112","const EM_ALTERA_NIOS2 Machine = 113","const EM_CRX Machine = 114","const EM_XGATE Machine = 115","const EM_C166 Machine = 116","const EM_M16C Machine = 117","const EM_DSPIC30F Machine = 118","const EM_CE Machine = 119","const EM_M32C Machine = 120","const EM_TSK3000 Machine = 131","const EM_RS08 Machine = 132","const EM_SHARC Machine = 133","const EM_ECOG2 Machine = 134","const EM_SCORE7 Machine = 135","const EM_DSP24 Machine = 136","const EM_VIDEOCORE3 Machine = 137","const EM_LATTICEMICO32 Machine = 138","const EM_SE_C17 Machine = 139","const EM_TI_C6000 Machine = 140","const EM_TI_C2000 Machine = 141","const EM_TI_C5500 Machine = 142","const EM_TI_ARP32 Machine = 143","const EM_TI_PRU Machine = 144","const EM_MMDSP_PLUS Machine = 160","const EM_CYPRESS_M8C Machine = 161","const EM_R32C Machine = 162","const EM_TRIMEDIA Machine = 163","const EM_QDSP6 Machine = 164","const EM_8051 Machine = 165","const EM_STXP7X Machine = 166","const EM_NDS32 Machine = 167","const EM_ECOG1 Machine = 168","const EM_ECOG1X Machine = 168","const EM_MAXQ30 Machine = 169","const EM_XIMO16 Machine = 170","const EM_MANIK Machine = 171","const EM_CRAYNV2 Machine = 172","const EM_RX Machine = 173","const EM_METAG Machine = 174","const EM_MCST_ELBRUS Machine = 175","const EM_ECOG16 Machine = 176","const EM_CR16 Machine = 177","const EM_ETPU Machine = 178","const EM_SLE9X Machine = 179","const EM_L10M Machine = 180","const EM_K10M Machine = 181","const EM_AARCH64 Machine = 183","const EM_AVR32 Machine = 185","const EM_STM8 Machine = 186","const EM_TILE64 Machine = 187","const EM_TILEPRO Machine = 188","const EM_MICROBLAZE Machine = 189","const EM_CUDA Machine = 190","const EM_TILEGX Machine = 191","const EM_CLOUDSHIELD Machine = 192","const EM_COREA_1ST Machine = 193","const EM_COREA_2ND Machine = 194","const EM_ARC_COMPACT2 Machine = 195","const EM_OPEN8 Machine = 196","const EM_RL78 Machine = 197","const EM_VIDEOCORE5 Machine = 198","const EM_78KOR Machine = 199","const EM_56800EX Machine = 200","const EM_BA1 Machine = 201","const EM_BA2 Machine = 202","const EM_XCORE Machine = 203","const EM_MCHP_PIC Machine = 204","const EM_INTEL205 Machine = 205","const EM_INTEL206 Machine = 206","const EM_INTEL207 Machine = 207","const EM_INTEL208 Machine = 208","const EM_INTEL209 Machine = 209","const EM_KM32 Machine = 210","const EM_KMX32 Machine = 211","const EM_KMX16 Machine = 212","const EM_KMX8 Machine = 213","const EM_KVARC Machine = 214","const EM_CDP Machine = 215","const EM_COGE Machine = 216","const EM_COOL Machine = 217","const EM_NORC Machine = 218","const EM_CSR_KALIMBA Machine = 219","const EM_Z80 Machine = 220","const EM_VISIUM Machine = 221","const EM_FT32 Machine = 222","const EM_MOXIE Machine = 223","const EM_AMDGPU Machine = 224","const EM_RISCV Machine = 243","const EM_LANAI Machine = 244","const EM_BPF Machine = 247","const EM_LOONGARCH Machine = 258","const EM_486 Machine = 6","const EM_MIPS_RS4_BE Machine = 10","const EM_ALPHA_STD Machine = 41","const EM_ALPHA Machine = 0x9026","","const SHN_UNDEF SectionIndex = 0","const SHN_LORESERVE SectionIndex = 0xff00","const SHN_LOPROC SectionIndex = 0xff00","const SHN_HIPROC SectionIndex = 0xff1f","const SHN_LOOS SectionIndex = 0xff20","const SHN_HIOS SectionIndex = 0xff3f","const SHN_ABS SectionIndex = 0xfff1","const SHN_COMMON SectionIndex = 0xfff2","const SHN_XINDEX SectionIndex = 0xffff","const SHN_HIRESERVE SectionIndex = 0xffff","","const SHT_NULL SectionType = 0","const SHT_PROGBITS SectionType = 1","const SHT_SYMTAB SectionType = 2","const SHT_STRTAB SectionType = 3","const SHT_RELA SectionType = 4","const SHT_HASH SectionType = 5","const SHT_DYNAMIC SectionType = 6","const SHT_NOTE SectionType = 7","const SHT_NOBITS SectionType = 8","const SHT_REL SectionType = 9","const SHT_SHLIB SectionType = 10","const SHT_DYNSYM SectionType = 11","const SHT_INIT_ARRAY SectionType = 14","const SHT_FINI_ARRAY SectionType = 15","const SHT_PREINIT_ARRAY SectionType = 16","const SHT_GROUP SectionType = 17","const SHT_SYMTAB_SHNDX SectionType = 18","const SHT_LOOS SectionType = 0x60000000","const SHT_GNU_ATTRIBUTES SectionType = 0x6ffffff5","const SHT_GNU_HASH SectionType = 0x6ffffff6","const SHT_GNU_LIBLIST SectionType = 0x6ffffff7","const SHT_GNU_VERDEF SectionType = 0x6ffffffd","const SHT_GNU_VERNEED SectionType = 0x6ffffffe","const SHT_GNU_VERSYM SectionType = 0x6fffffff","const SHT_HIOS SectionType = 0x6fffffff","const SHT_LOPROC SectionType = 0x70000000","const SHT_MIPS_ABIFLAGS SectionType = 0x7000002a","const SHT_HIPROC SectionType = 0x7fffffff","const SHT_LOUSER SectionType = 0x80000000","const SHT_HIUSER SectionType = 0xffffffff","","const SHF_WRITE SectionFlag = 0x1","const SHF_ALLOC SectionFlag = 0x2","const SHF_EXECINSTR SectionFlag = 0x4","const SHF_MERGE SectionFlag = 0x10","const SHF_STRINGS SectionFlag = 0x20","const SHF_INFO_LINK SectionFlag = 0x40","const SHF_LINK_ORDER SectionFlag = 0x80","const SHF_OS_NONCONFORMING SectionFlag = 0x100","const SHF_GROUP SectionFlag = 0x200","const SHF_TLS SectionFlag = 0x400","const SHF_COMPRESSED SectionFlag = 0x800","const SHF_MASKOS SectionFlag = 0x0ff00000","const SHF_MASKPROC SectionFlag = 0xf0000000","","const COMPRESS_ZLIB CompressionType = 1","const COMPRESS_ZSTD CompressionType = 2","const COMPRESS_LOOS CompressionType = 0x60000000","const COMPRESS_HIOS CompressionType = 0x6fffffff","const COMPRESS_LOPROC CompressionType = 0x70000000","const COMPRESS_HIPROC CompressionType = 0x7fffffff","","const PT_NULL ProgType = 0","const PT_LOAD ProgType = 1","const PT_DYNAMIC ProgType = 2","const PT_INTERP ProgType = 3","const PT_NOTE ProgType = 4","const PT_SHLIB ProgType = 5","const PT_PHDR ProgType = 6","const PT_TLS ProgType = 7","const PT_LOOS ProgType = 0x60000000","const PT_GNU_EH_FRAME ProgType = 0x6474e550","const PT_GNU_STACK ProgType = 0x6474e551","const PT_GNU_RELRO ProgType = 0x6474e552","const PT_GNU_PROPERTY ProgType = 0x6474e553","const PT_GNU_MBIND_LO ProgType = 0x6474e555","const PT_GNU_MBIND_HI ProgType = 0x6474f554","const PT_PAX_FLAGS ProgType = 0x65041580","const PT_OPENBSD_RANDOMIZE ProgType = 0x65a3dbe6","const PT_OPENBSD_WXNEEDED ProgType = 0x65a3dbe7","const PT_OPENBSD_NOBTCFI ProgType = 0x65a3dbe8","const PT_OPENBSD_BOOTDATA ProgType = 0x65a41be6","const PT_SUNW_EH_FRAME ProgType = 0x6474e550","const PT_SUNWSTACK ProgType = 0x6ffffffb","const PT_HIOS ProgType = 0x6fffffff","const PT_LOPROC ProgType = 0x70000000","const PT_ARM_ARCHEXT ProgType = 0x70000000","const PT_ARM_EXIDX ProgType = 0x70000001","const PT_AARCH64_ARCHEXT ProgType = 0x70000000","const PT_AARCH64_UNWIND ProgType = 0x70000001","const PT_MIPS_REGINFO ProgType = 0x70000000","const PT_MIPS_RTPROC ProgType = 0x70000001","const PT_MIPS_OPTIONS ProgType = 0x70000002","const PT_MIPS_ABIFLAGS ProgType = 0x70000003","const PT_S390_PGSTE ProgType = 0x70000000","const PT_HIPROC ProgType = 0x7fffffff","","const PF_X ProgFlag = 0x1","const PF_W ProgFlag = 0x2","const PF_R ProgFlag = 0x4","const PF_MASKOS ProgFlag = 0x0ff00000","const PF_MASKPROC ProgFlag = 0xf0000000","","const DT_NULL DynTag = 0","const DT_NEEDED DynTag = 1","const DT_PLTRELSZ DynTag = 2","const DT_PLTGOT DynTag = 3","const DT_HASH DynTag = 4","const DT_STRTAB DynTag = 5","const DT_SYMTAB DynTag = 6","const DT_RELA DynTag = 7","const DT_RELASZ DynTag = 8","const DT_RELAENT DynTag = 9","const DT_STRSZ DynTag = 10","const DT_SYMENT DynTag = 11","const DT_INIT DynTag = 12","const DT_FINI DynTag = 13","const DT_SONAME DynTag = 14","const DT_RPATH DynTag = 15","const DT_SYMBOLIC DynTag = 16","const DT_REL DynTag = 17","const DT_RELSZ DynTag = 18","const DT_RELENT DynTag = 19","const DT_PLTREL DynTag = 20","const DT_DEBUG DynTag = 21","const DT_TEXTREL DynTag = 22","const DT_JMPREL DynTag = 23","const DT_BIND_NOW DynTag = 24","const DT_INIT_ARRAY DynTag = 25","const DT_FINI_ARRAY DynTag = 26","const DT_INIT_ARRAYSZ DynTag = 27","const DT_FINI_ARRAYSZ DynTag = 28","const DT_RUNPATH DynTag = 29","const DT_FLAGS DynTag = 30","const DT_ENCODING DynTag = 32","const DT_PREINIT_ARRAY DynTag = 32","const DT_PREINIT_ARRAYSZ DynTag = 33","const DT_SYMTAB_SHNDX DynTag = 34","const DT_LOOS DynTag = 0x6000000d","const DT_HIOS DynTag = 0x6ffff000","const DT_VALRNGLO DynTag = 0x6ffffd00","const DT_GNU_PRELINKED DynTag = 0x6ffffdf5","const DT_GNU_CONFLICTSZ DynTag = 0x6ffffdf6","const DT_GNU_LIBLISTSZ DynTag = 0x6ffffdf7","const DT_CHECKSUM DynTag = 0x6ffffdf8","const DT_PLTPADSZ DynTag = 0x6ffffdf9","const DT_MOVEENT DynTag = 0x6ffffdfa","const DT_MOVESZ DynTag = 0x6ffffdfb","const DT_FEATURE DynTag = 0x6ffffdfc","const DT_POSFLAG_1 DynTag = 0x6ffffdfd","const DT_SYMINSZ DynTag = 0x6ffffdfe","const DT_SYMINENT DynTag = 0x6ffffdff","const DT_VALRNGHI DynTag = 0x6ffffdff","const DT_ADDRRNGLO DynTag = 0x6ffffe00","const DT_GNU_HASH DynTag = 0x6ffffef5","const DT_TLSDESC_PLT DynTag = 0x6ffffef6","const DT_TLSDESC_GOT DynTag = 0x6ffffef7","const DT_GNU_CONFLICT DynTag = 0x6ffffef8","const DT_GNU_LIBLIST DynTag = 0x6ffffef9","const DT_CONFIG DynTag = 0x6ffffefa","const DT_DEPAUDIT DynTag = 0x6ffffefb","const DT_AUDIT DynTag = 0x6ffffefc","const DT_PLTPAD DynTag = 0x6ffffefd","const DT_MOVETAB DynTag = 0x6ffffefe","const DT_SYMINFO DynTag = 0x6ffffeff","const DT_ADDRRNGHI DynTag = 0x6ffffeff","const DT_VERSYM DynTag = 0x6ffffff0","const DT_RELACOUNT DynTag = 0x6ffffff9","const DT_RELCOUNT DynTag = 0x6ffffffa","const DT_FLAGS_1 DynTag = 0x6ffffffb","const DT_VERDEF DynTag = 0x6ffffffc","const DT_VERDEFNUM DynTag = 0x6ffffffd","const DT_VERNEED DynTag = 0x6ffffffe","const DT_VERNEEDNUM DynTag = 0x6fffffff","const DT_LOPROC DynTag = 0x70000000","const DT_MIPS_RLD_VERSION DynTag = 0x70000001","const DT_MIPS_TIME_STAMP DynTag = 0x70000002","const DT_MIPS_ICHECKSUM DynTag = 0x70000003","const DT_MIPS_IVERSION DynTag = 0x70000004","const DT_MIPS_FLAGS DynTag = 0x70000005","const DT_MIPS_BASE_ADDRESS DynTag = 0x70000006","const DT_MIPS_MSYM DynTag = 0x70000007","const DT_MIPS_CONFLICT DynTag = 0x70000008","const DT_MIPS_LIBLIST DynTag = 0x70000009","const DT_MIPS_LOCAL_GOTNO DynTag = 0x7000000a","const DT_MIPS_CONFLICTNO DynTag = 0x7000000b","const DT_MIPS_LIBLISTNO DynTag = 0x70000010","const DT_MIPS_SYMTABNO DynTag = 0x70000011","const DT_MIPS_UNREFEXTNO DynTag = 0x70000012","const DT_MIPS_GOTSYM DynTag = 0x70000013","const DT_MIPS_HIPAGENO DynTag = 0x70000014","const DT_MIPS_RLD_MAP DynTag = 0x70000016","const DT_MIPS_DELTA_CLASS DynTag = 0x70000017","const DT_MIPS_DELTA_CLASS_NO DynTag = 0x70000018","const DT_MIPS_DELTA_INSTANCE DynTag = 0x70000019","const DT_MIPS_DELTA_INSTANCE_NO DynTag = 0x7000001a","const DT_MIPS_DELTA_RELOC DynTag = 0x7000001b","const DT_MIPS_DELTA_RELOC_NO DynTag = 0x7000001c","const DT_MIPS_DELTA_SYM DynTag = 0x7000001d","const DT_MIPS_DELTA_SYM_NO DynTag = 0x7000001e","const DT_MIPS_DELTA_CLASSSYM DynTag = 0x70000020","const DT_MIPS_DELTA_CLASSSYM_NO DynTag = 0x70000021","const DT_MIPS_CXX_FLAGS DynTag = 0x70000022","const DT_MIPS_PIXIE_INIT DynTag = 0x70000023","const DT_MIPS_SYMBOL_LIB DynTag = 0x70000024","const DT_MIPS_LOCALPAGE_GOTIDX DynTag = 0x70000025","const DT_MIPS_LOCAL_GOTIDX DynTag = 0x70000026","const DT_MIPS_HIDDEN_GOTIDX DynTag = 0x70000027","const DT_MIPS_PROTECTED_GOTIDX DynTag = 0x70000028","const DT_MIPS_OPTIONS DynTag = 0x70000029","const DT_MIPS_INTERFACE DynTag = 0x7000002a","const DT_MIPS_DYNSTR_ALIGN DynTag = 0x7000002b","const DT_MIPS_INTERFACE_SIZE DynTag = 0x7000002c","const DT_MIPS_RLD_TEXT_RESOLVE_ADDR DynTag = 0x7000002d","const DT_MIPS_PERF_SUFFIX DynTag = 0x7000002e","const DT_MIPS_COMPACT_SIZE DynTag = 0x7000002f","const DT_MIPS_GP_VALUE DynTag = 0x70000030","const DT_MIPS_AUX_DYNAMIC DynTag = 0x70000031","const DT_MIPS_PLTGOT DynTag = 0x70000032","const DT_MIPS_RWPLT DynTag = 0x70000034","const DT_MIPS_RLD_MAP_REL DynTag = 0x70000035","const DT_PPC_GOT DynTag = 0x70000000","const DT_PPC_OPT DynTag = 0x70000001","const DT_PPC64_GLINK DynTag = 0x70000000","const DT_PPC64_OPD DynTag = 0x70000001","const DT_PPC64_OPDSZ DynTag = 0x70000002","const DT_PPC64_OPT DynTag = 0x70000003","const DT_SPARC_REGISTER DynTag = 0x70000001","const DT_AUXILIARY DynTag = 0x7ffffffd","const DT_USED DynTag = 0x7ffffffe","const DT_FILTER DynTag = 0x7fffffff","const DT_HIPROC DynTag = 0x7fffffff","","const DF_ORIGIN DynFlag = 0x0001","const DF_SYMBOLIC DynFlag = 0x0002","const DF_TEXTREL DynFlag = 0x0004","const DF_BIND_NOW DynFlag = 0x0008","const DF_STATIC_TLS DynFlag = 0x0010","","const DF_1_NOW DynFlag1 = 0x00000001","const DF_1_GLOBAL DynFlag1 = 0x00000002","const DF_1_GROUP DynFlag1 = 0x00000004","const DF_1_NODELETE DynFlag1 = 0x00000008","const DF_1_LOADFLTR DynFlag1 = 0x00000010","const DF_1_INITFIRST DynFlag1 = 0x00000020","const DF_1_NOOPEN DynFlag1 = 0x00000040","const DF_1_ORIGIN DynFlag1 = 0x00000080","const DF_1_DIRECT DynFlag1 = 0x00000100","const DF_1_TRANS DynFlag1 = 0x00000200","const DF_1_INTERPOSE DynFlag1 = 0x00000400","const DF_1_NODEFLIB DynFlag1 = 0x00000800","const DF_1_NODUMP DynFlag1 = 0x00001000","const DF_1_CONFALT DynFlag1 = 0x00002000","const DF_1_ENDFILTEE DynFlag1 = 0x00004000","const DF_1_DISPRELDNE DynFlag1 = 0x00008000","const DF_1_DISPRELPND DynFlag1 = 0x00010000","const DF_1_NODIRECT DynFlag1 = 0x00020000","const DF_1_IGNMULDEF DynFlag1 = 0x00040000","const DF_1_NOKSYMS DynFlag1 = 0x00080000","const DF_1_NOHDR DynFlag1 = 0x00100000","const DF_1_EDITED DynFlag1 = 0x00200000","const DF_1_NORELOC DynFlag1 = 0x00400000","const DF_1_SYMINTPOSE DynFlag1 = 0x00800000","const DF_1_GLOBAUDIT DynFlag1 = 0x01000000","const DF_1_SINGLETON DynFlag1 = 0x02000000","const DF_1_STUB DynFlag1 = 0x04000000","const DF_1_PIE DynFlag1 = 0x08000000","const DF_1_KMOD DynFlag1 = 0x10000000","const DF_1_WEAKFILTER DynFlag1 = 0x20000000","const DF_1_NOCOMMON DynFlag1 = 0x40000000","","const NT_PRSTATUS NType = 1","const NT_FPREGSET NType = 2","const NT_PRPSINFO NType = 3","","const STB_LOCAL SymBind = 0","const STB_GLOBAL SymBind = 1","const STB_WEAK SymBind = 2","const STB_LOOS SymBind = 10","const STB_HIOS SymBind = 12","const STB_LOPROC SymBind = 13","const STB_HIPROC SymBind = 15","","const STT_NOTYPE SymType = 0","const STT_OBJECT SymType = 1","const STT_FUNC SymType = 2","const STT_SECTION SymType = 3","const STT_FILE SymType = 4","const STT_COMMON SymType = 5","const STT_TLS SymType = 6","const STT_LOOS SymType = 10","const STT_HIOS SymType = 12","const STT_LOPROC SymType = 13","const STT_HIPROC SymType = 15","const STT_RELC SymType = 8","const STT_SRELC SymType = 9","const STT_GNU_IFUNC SymType = 10","","const STV_DEFAULT SymVis = 0x0","const STV_INTERNAL SymVis = 0x1","const STV_HIDDEN SymVis = 0x2","const STV_PROTECTED SymVis = 0x3","","const R_X86_64_NONE R_X86_64 = 0","const R_X86_64_64 R_X86_64 = 1","const R_X86_64_PC32 R_X86_64 = 2","const R_X86_64_GOT32 R_X86_64 = 3","const R_X86_64_PLT32 R_X86_64 = 4","const R_X86_64_COPY R_X86_64 = 5","const R_X86_64_GLOB_DAT R_X86_64 = 6","const R_X86_64_JMP_SLOT R_X86_64 = 7","const R_X86_64_RELATIVE R_X86_64 = 8","const R_X86_64_GOTPCREL R_X86_64 = 9","const R_X86_64_32 R_X86_64 = 10","const R_X86_64_32S R_X86_64 = 11","const R_X86_64_16 R_X86_64 = 12","const R_X86_64_PC16 R_X86_64 = 13","const R_X86_64_8 R_X86_64 = 14","const R_X86_64_PC8 R_X86_64 = 15","const R_X86_64_DTPMOD64 R_X86_64 = 16","const R_X86_64_DTPOFF64 R_X86_64 = 17","const R_X86_64_TPOFF64 R_X86_64 = 18","const R_X86_64_TLSGD R_X86_64 = 19","const R_X86_64_TLSLD R_X86_64 = 20","const R_X86_64_DTPOFF32 R_X86_64 = 21","const R_X86_64_GOTTPOFF R_X86_64 = 22","const R_X86_64_TPOFF32 R_X86_64 = 23","const R_X86_64_PC64 R_X86_64 = 24","const R_X86_64_GOTOFF64 R_X86_64 = 25","const R_X86_64_GOTPC32 R_X86_64 = 26","const R_X86_64_GOT64 R_X86_64 = 27","const R_X86_64_GOTPCREL64 R_X86_64 = 28","const R_X86_64_GOTPC64 R_X86_64 = 29","const R_X86_64_GOTPLT64 R_X86_64 = 30","const R_X86_64_PLTOFF64 R_X86_64 = 31","const R_X86_64_SIZE32 R_X86_64 = 32","const R_X86_64_SIZE64 R_X86_64 = 33","const R_X86_64_GOTPC32_TLSDESC R_X86_64 = 34","const R_X86_64_TLSDESC_CALL R_X86_64 = 35","const R_X86_64_TLSDESC R_X86_64 = 36","const R_X86_64_IRELATIVE R_X86_64 = 37","const R_X86_64_RELATIVE64 R_X86_64 = 38","const R_X86_64_PC32_BND R_X86_64 = 39","const R_X86_64_PLT32_BND R_X86_64 = 40","const R_X86_64_GOTPCRELX R_X86_64 = 41","const R_X86_64_REX_GOTPCRELX R_X86_64 = 42","","const R_AARCH64_NONE R_AARCH64 = 0","const R_AARCH64_P32_ABS32 R_AARCH64 = 1","const R_AARCH64_P32_ABS16 R_AARCH64 = 2","const R_AARCH64_P32_PREL32 R_AARCH64 = 3","const R_AARCH64_P32_PREL16 R_AARCH64 = 4","const R_AARCH64_P32_MOVW_UABS_G0 R_AARCH64 = 5","const R_AARCH64_P32_MOVW_UABS_G0_NC R_AARCH64 = 6","const R_AARCH64_P32_MOVW_UABS_G1 R_AARCH64 = 7","const R_AARCH64_P32_MOVW_SABS_G0 R_AARCH64 = 8","const R_AARCH64_P32_LD_PREL_LO19 R_AARCH64 = 9","const R_AARCH64_P32_ADR_PREL_LO21 R_AARCH64 = 10","const R_AARCH64_P32_ADR_PREL_PG_HI21 R_AARCH64 = 11","const R_AARCH64_P32_ADD_ABS_LO12_NC R_AARCH64 = 12","const R_AARCH64_P32_LDST8_ABS_LO12_NC R_AARCH64 = 13","const R_AARCH64_P32_LDST16_ABS_LO12_NC R_AARCH64 = 14","const R_AARCH64_P32_LDST32_ABS_LO12_NC R_AARCH64 = 15","const R_AARCH64_P32_LDST64_ABS_LO12_NC R_AARCH64 = 16","const R_AARCH64_P32_LDST128_ABS_LO12_NC R_AARCH64 = 17","const R_AARCH64_P32_TSTBR14 R_AARCH64 = 18","const R_AARCH64_P32_CONDBR19 R_AARCH64 = 19","const R_AARCH64_P32_JUMP26 R_AARCH64 = 20","const R_AARCH64_P32_CALL26 R_AARCH64 = 21","const R_AARCH64_P32_GOT_LD_PREL19 R_AARCH64 = 25","const R_AARCH64_P32_ADR_GOT_PAGE R_AARCH64 = 26","const R_AARCH64_P32_LD32_GOT_LO12_NC R_AARCH64 = 27","const R_AARCH64_P32_TLSGD_ADR_PAGE21 R_AARCH64 = 81","const R_AARCH64_P32_TLSGD_ADD_LO12_NC R_AARCH64 = 82","const R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21 R_AARCH64 = 103","const R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC R_AARCH64 = 104","const R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19 R_AARCH64 = 105","const R_AARCH64_P32_TLSLE_MOVW_TPREL_G1 R_AARCH64 = 106","const R_AARCH64_P32_TLSLE_MOVW_TPREL_G0 R_AARCH64 = 107","const R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC R_AARCH64 = 108","const R_AARCH64_P32_TLSLE_ADD_TPREL_HI12 R_AARCH64 = 109","const R_AARCH64_P32_TLSLE_ADD_TPREL_LO12 R_AARCH64 = 110","const R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC R_AARCH64 = 111","const R_AARCH64_P32_TLSDESC_LD_PREL19 R_AARCH64 = 122","const R_AARCH64_P32_TLSDESC_ADR_PREL21 R_AARCH64 = 123","const R_AARCH64_P32_TLSDESC_ADR_PAGE21 R_AARCH64 = 124","const R_AARCH64_P32_TLSDESC_LD32_LO12_NC R_AARCH64 = 125","const R_AARCH64_P32_TLSDESC_ADD_LO12_NC R_AARCH64 = 126","const R_AARCH64_P32_TLSDESC_CALL R_AARCH64 = 127","const R_AARCH64_P32_COPY R_AARCH64 = 180","const R_AARCH64_P32_GLOB_DAT R_AARCH64 = 181","const R_AARCH64_P32_JUMP_SLOT R_AARCH64 = 182","const R_AARCH64_P32_RELATIVE R_AARCH64 = 183","const R_AARCH64_P32_TLS_DTPMOD R_AARCH64 = 184","const R_AARCH64_P32_TLS_DTPREL R_AARCH64 = 185","const R_AARCH64_P32_TLS_TPREL R_AARCH64 = 186","const R_AARCH64_P32_TLSDESC R_AARCH64 = 187","const R_AARCH64_P32_IRELATIVE R_AARCH64 = 188","const R_AARCH64_NULL R_AARCH64 = 256","const R_AARCH64_ABS64 R_AARCH64 = 257","const R_AARCH64_ABS32 R_AARCH64 = 258","const R_AARCH64_ABS16 R_AARCH64 = 259","const R_AARCH64_PREL64 R_AARCH64 = 260","const R_AARCH64_PREL32 R_AARCH64 = 261","const R_AARCH64_PREL16 R_AARCH64 = 262","const R_AARCH64_MOVW_UABS_G0 R_AARCH64 = 263","const R_AARCH64_MOVW_UABS_G0_NC R_AARCH64 = 264","const R_AARCH64_MOVW_UABS_G1 R_AARCH64 = 265","const R_AARCH64_MOVW_UABS_G1_NC R_AARCH64 = 266","const R_AARCH64_MOVW_UABS_G2 R_AARCH64 = 267","const R_AARCH64_MOVW_UABS_G2_NC R_AARCH64 = 268","const R_AARCH64_MOVW_UABS_G3 R_AARCH64 = 269","const R_AARCH64_MOVW_SABS_G0 R_AARCH64 = 270","const R_AARCH64_MOVW_SABS_G1 R_AARCH64 = 271","const R_AARCH64_MOVW_SABS_G2 R_AARCH64 = 272","const R_AARCH64_LD_PREL_LO19 R_AARCH64 = 273","const R_AARCH64_ADR_PREL_LO21 R_AARCH64 = 274","const R_AARCH64_ADR_PREL_PG_HI21 R_AARCH64 = 275","const R_AARCH64_ADR_PREL_PG_HI21_NC R_AARCH64 = 276","const R_AARCH64_ADD_ABS_LO12_NC R_AARCH64 = 277","const R_AARCH64_LDST8_ABS_LO12_NC R_AARCH64 = 278","const R_AARCH64_TSTBR14 R_AARCH64 = 279","const R_AARCH64_CONDBR19 R_AARCH64 = 280","const R_AARCH64_JUMP26 R_AARCH64 = 282","const R_AARCH64_CALL26 R_AARCH64 = 283","const R_AARCH64_LDST16_ABS_LO12_NC R_AARCH64 = 284","const R_AARCH64_LDST32_ABS_LO12_NC R_AARCH64 = 285","const R_AARCH64_LDST64_ABS_LO12_NC R_AARCH64 = 286","const R_AARCH64_LDST128_ABS_LO12_NC R_AARCH64 = 299","const R_AARCH64_GOT_LD_PREL19 R_AARCH64 = 309","const R_AARCH64_LD64_GOTOFF_LO15 R_AARCH64 = 310","const R_AARCH64_ADR_GOT_PAGE R_AARCH64 = 311","const R_AARCH64_LD64_GOT_LO12_NC R_AARCH64 = 312","const R_AARCH64_LD64_GOTPAGE_LO15 R_AARCH64 = 313","const R_AARCH64_TLSGD_ADR_PREL21 R_AARCH64 = 512","const R_AARCH64_TLSGD_ADR_PAGE21 R_AARCH64 = 513","const R_AARCH64_TLSGD_ADD_LO12_NC R_AARCH64 = 514","const R_AARCH64_TLSGD_MOVW_G1 R_AARCH64 = 515","const R_AARCH64_TLSGD_MOVW_G0_NC R_AARCH64 = 516","const R_AARCH64_TLSLD_ADR_PREL21 R_AARCH64 = 517","const R_AARCH64_TLSLD_ADR_PAGE21 R_AARCH64 = 518","const R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 R_AARCH64 = 539","const R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC R_AARCH64 = 540","const R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 R_AARCH64 = 541","const R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC R_AARCH64 = 542","const R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 R_AARCH64 = 543","const R_AARCH64_TLSLE_MOVW_TPREL_G2 R_AARCH64 = 544","const R_AARCH64_TLSLE_MOVW_TPREL_G1 R_AARCH64 = 545","const R_AARCH64_TLSLE_MOVW_TPREL_G1_NC R_AARCH64 = 546","const R_AARCH64_TLSLE_MOVW_TPREL_G0 R_AARCH64 = 547","const R_AARCH64_TLSLE_MOVW_TPREL_G0_NC R_AARCH64 = 548","const R_AARCH64_TLSLE_ADD_TPREL_HI12 R_AARCH64 = 549","const R_AARCH64_TLSLE_ADD_TPREL_LO12 R_AARCH64 = 550","const R_AARCH64_TLSLE_ADD_TPREL_LO12_NC R_AARCH64 = 551","const R_AARCH64_TLSDESC_LD_PREL19 R_AARCH64 = 560","const R_AARCH64_TLSDESC_ADR_PREL21 R_AARCH64 = 561","const R_AARCH64_TLSDESC_ADR_PAGE21 R_AARCH64 = 562","const R_AARCH64_TLSDESC_LD64_LO12_NC R_AARCH64 = 563","const R_AARCH64_TLSDESC_ADD_LO12_NC R_AARCH64 = 564","const R_AARCH64_TLSDESC_OFF_G1 R_AARCH64 = 565","const R_AARCH64_TLSDESC_OFF_G0_NC R_AARCH64 = 566","const R_AARCH64_TLSDESC_LDR R_AARCH64 = 567","const R_AARCH64_TLSDESC_ADD R_AARCH64 = 568","const R_AARCH64_TLSDESC_CALL R_AARCH64 = 569","const R_AARCH64_TLSLE_LDST128_TPREL_LO12 R_AARCH64 = 570","const R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC R_AARCH64 = 571","const R_AARCH64_TLSLD_LDST128_DTPREL_LO12 R_AARCH64 = 572","const R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC R_AARCH64 = 573","const R_AARCH64_COPY R_AARCH64 = 1024","const R_AARCH64_GLOB_DAT R_AARCH64 = 1025","const R_AARCH64_JUMP_SLOT R_AARCH64 = 1026","const R_AARCH64_RELATIVE R_AARCH64 = 1027","const R_AARCH64_TLS_DTPMOD64 R_AARCH64 = 1028","const R_AARCH64_TLS_DTPREL64 R_AARCH64 = 1029","const R_AARCH64_TLS_TPREL64 R_AARCH64 = 1030","const R_AARCH64_TLSDESC R_AARCH64 = 1031","const R_AARCH64_IRELATIVE R_AARCH64 = 1032","","const R_ALPHA_NONE R_ALPHA = 0","const R_ALPHA_REFLONG R_ALPHA = 1","const R_ALPHA_REFQUAD R_ALPHA = 2","const R_ALPHA_GPREL32 R_ALPHA = 3","const R_ALPHA_LITERAL R_ALPHA = 4","const R_ALPHA_LITUSE R_ALPHA = 5","const R_ALPHA_GPDISP R_ALPHA = 6","const R_ALPHA_BRADDR R_ALPHA = 7","const R_ALPHA_HINT R_ALPHA = 8","const R_ALPHA_SREL16 R_ALPHA = 9","const R_ALPHA_SREL32 R_ALPHA = 10","const R_ALPHA_SREL64 R_ALPHA = 11","const R_ALPHA_OP_PUSH R_ALPHA = 12","const R_ALPHA_OP_STORE R_ALPHA = 13","const R_ALPHA_OP_PSUB R_ALPHA = 14","const R_ALPHA_OP_PRSHIFT R_ALPHA = 15","const R_ALPHA_GPVALUE R_ALPHA = 16","const R_ALPHA_GPRELHIGH R_ALPHA = 17","const R_ALPHA_GPRELLOW R_ALPHA = 18","const R_ALPHA_IMMED_GP_16 R_ALPHA = 19","const R_ALPHA_IMMED_GP_HI32 R_ALPHA = 20","const R_ALPHA_IMMED_SCN_HI32 R_ALPHA = 21","const R_ALPHA_IMMED_BR_HI32 R_ALPHA = 22","const R_ALPHA_IMMED_LO32 R_ALPHA = 23","const R_ALPHA_COPY R_ALPHA = 24","const R_ALPHA_GLOB_DAT R_ALPHA = 25","const R_ALPHA_JMP_SLOT R_ALPHA = 26","const R_ALPHA_RELATIVE R_ALPHA = 27","","const R_ARM_NONE R_ARM = 0","const R_ARM_PC24 R_ARM = 1","const R_ARM_ABS32 R_ARM = 2","const R_ARM_REL32 R_ARM = 3","const R_ARM_PC13 R_ARM = 4","const R_ARM_ABS16 R_ARM = 5","const R_ARM_ABS12 R_ARM = 6","const R_ARM_THM_ABS5 R_ARM = 7","const R_ARM_ABS8 R_ARM = 8","const R_ARM_SBREL32 R_ARM = 9","const R_ARM_THM_PC22 R_ARM = 10","const R_ARM_THM_PC8 R_ARM = 11","const R_ARM_AMP_VCALL9 R_ARM = 12","const R_ARM_SWI24 R_ARM = 13","const R_ARM_THM_SWI8 R_ARM = 14","const R_ARM_XPC25 R_ARM = 15","const R_ARM_THM_XPC22 R_ARM = 16","const R_ARM_TLS_DTPMOD32 R_ARM = 17","const R_ARM_TLS_DTPOFF32 R_ARM = 18","const R_ARM_TLS_TPOFF32 R_ARM = 19","const R_ARM_COPY R_ARM = 20","const R_ARM_GLOB_DAT R_ARM = 21","const R_ARM_JUMP_SLOT R_ARM = 22","const R_ARM_RELATIVE R_ARM = 23","const R_ARM_GOTOFF R_ARM = 24","const R_ARM_GOTPC R_ARM = 25","const R_ARM_GOT32 R_ARM = 26","const R_ARM_PLT32 R_ARM = 27","const R_ARM_CALL R_ARM = 28","const R_ARM_JUMP24 R_ARM = 29","const R_ARM_THM_JUMP24 R_ARM = 30","const R_ARM_BASE_ABS R_ARM = 31","const R_ARM_ALU_PCREL_7_0 R_ARM = 32","const R_ARM_ALU_PCREL_15_8 R_ARM = 33","const R_ARM_ALU_PCREL_23_15 R_ARM = 34","const R_ARM_LDR_SBREL_11_10_NC R_ARM = 35","const R_ARM_ALU_SBREL_19_12_NC R_ARM = 36","const R_ARM_ALU_SBREL_27_20_CK R_ARM = 37","const R_ARM_TARGET1 R_ARM = 38","const R_ARM_SBREL31 R_ARM = 39","const R_ARM_V4BX R_ARM = 40","const R_ARM_TARGET2 R_ARM = 41","const R_ARM_PREL31 R_ARM = 42","const R_ARM_MOVW_ABS_NC R_ARM = 43","const R_ARM_MOVT_ABS R_ARM = 44","const R_ARM_MOVW_PREL_NC R_ARM = 45","const R_ARM_MOVT_PREL R_ARM = 46","const R_ARM_THM_MOVW_ABS_NC R_ARM = 47","const R_ARM_THM_MOVT_ABS R_ARM = 48","const R_ARM_THM_MOVW_PREL_NC R_ARM = 49","const R_ARM_THM_MOVT_PREL R_ARM = 50","const R_ARM_THM_JUMP19 R_ARM = 51","const R_ARM_THM_JUMP6 R_ARM = 52","const R_ARM_THM_ALU_PREL_11_0 R_ARM = 53","const R_ARM_THM_PC12 R_ARM = 54","const R_ARM_ABS32_NOI R_ARM = 55","const R_ARM_REL32_NOI R_ARM = 56","const R_ARM_ALU_PC_G0_NC R_ARM = 57","const R_ARM_ALU_PC_G0 R_ARM = 58","const R_ARM_ALU_PC_G1_NC R_ARM = 59","const R_ARM_ALU_PC_G1 R_ARM = 60","const R_ARM_ALU_PC_G2 R_ARM = 61","const R_ARM_LDR_PC_G1 R_ARM = 62","const R_ARM_LDR_PC_G2 R_ARM = 63","const R_ARM_LDRS_PC_G0 R_ARM = 64","const R_ARM_LDRS_PC_G1 R_ARM = 65","const R_ARM_LDRS_PC_G2 R_ARM = 66","const R_ARM_LDC_PC_G0 R_ARM = 67","const R_ARM_LDC_PC_G1 R_ARM = 68","const R_ARM_LDC_PC_G2 R_ARM = 69","const R_ARM_ALU_SB_G0_NC R_ARM = 70","const R_ARM_ALU_SB_G0 R_ARM = 71","const R_ARM_ALU_SB_G1_NC R_ARM = 72","const R_ARM_ALU_SB_G1 R_ARM = 73","const R_ARM_ALU_SB_G2 R_ARM = 74","const R_ARM_LDR_SB_G0 R_ARM = 75","const R_ARM_LDR_SB_G1 R_ARM = 76","const R_ARM_LDR_SB_G2 R_ARM = 77","const R_ARM_LDRS_SB_G0 R_ARM = 78","const R_ARM_LDRS_SB_G1 R_ARM = 79","const R_ARM_LDRS_SB_G2 R_ARM = 80","const R_ARM_LDC_SB_G0 R_ARM = 81","const R_ARM_LDC_SB_G1 R_ARM = 82","const R_ARM_LDC_SB_G2 R_ARM = 83","const R_ARM_MOVW_BREL_NC R_ARM = 84","const R_ARM_MOVT_BREL R_ARM = 85","const R_ARM_MOVW_BREL R_ARM = 86","const R_ARM_THM_MOVW_BREL_NC R_ARM = 87","const R_ARM_THM_MOVT_BREL R_ARM = 88","const R_ARM_THM_MOVW_BREL R_ARM = 89","const R_ARM_TLS_GOTDESC R_ARM = 90","const R_ARM_TLS_CALL R_ARM = 91","const R_ARM_TLS_DESCSEQ R_ARM = 92","const R_ARM_THM_TLS_CALL R_ARM = 93","const R_ARM_PLT32_ABS R_ARM = 94","const R_ARM_GOT_ABS R_ARM = 95","const R_ARM_GOT_PREL R_ARM = 96","const R_ARM_GOT_BREL12 R_ARM = 97","const R_ARM_GOTOFF12 R_ARM = 98","const R_ARM_GOTRELAX R_ARM = 99","const R_ARM_GNU_VTENTRY R_ARM = 100","const R_ARM_GNU_VTINHERIT R_ARM = 101","const R_ARM_THM_JUMP11 R_ARM = 102","const R_ARM_THM_JUMP8 R_ARM = 103","const R_ARM_TLS_GD32 R_ARM = 104","const R_ARM_TLS_LDM32 R_ARM = 105","const R_ARM_TLS_LDO32 R_ARM = 106","const R_ARM_TLS_IE32 R_ARM = 107","const R_ARM_TLS_LE32 R_ARM = 108","const R_ARM_TLS_LDO12 R_ARM = 109","const R_ARM_TLS_LE12 R_ARM = 110","const R_ARM_TLS_IE12GP R_ARM = 111","const R_ARM_PRIVATE_0 R_ARM = 112","const R_ARM_PRIVATE_1 R_ARM = 113","const R_ARM_PRIVATE_2 R_ARM = 114","const R_ARM_PRIVATE_3 R_ARM = 115","const R_ARM_PRIVATE_4 R_ARM = 116","const R_ARM_PRIVATE_5 R_ARM = 117","const R_ARM_PRIVATE_6 R_ARM = 118","const R_ARM_PRIVATE_7 R_ARM = 119","const R_ARM_PRIVATE_8 R_ARM = 120","const R_ARM_PRIVATE_9 R_ARM = 121","const R_ARM_PRIVATE_10 R_ARM = 122","const R_ARM_PRIVATE_11 R_ARM = 123","const R_ARM_PRIVATE_12 R_ARM = 124","const R_ARM_PRIVATE_13 R_ARM = 125","const R_ARM_PRIVATE_14 R_ARM = 126","const R_ARM_PRIVATE_15 R_ARM = 127","const R_ARM_ME_TOO R_ARM = 128","const R_ARM_THM_TLS_DESCSEQ16 R_ARM = 129","const R_ARM_THM_TLS_DESCSEQ32 R_ARM = 130","const R_ARM_THM_GOT_BREL12 R_ARM = 131","const R_ARM_THM_ALU_ABS_G0_NC R_ARM = 132","const R_ARM_THM_ALU_ABS_G1_NC R_ARM = 133","const R_ARM_THM_ALU_ABS_G2_NC R_ARM = 134","const R_ARM_THM_ALU_ABS_G3 R_ARM = 135","const R_ARM_IRELATIVE R_ARM = 160","const R_ARM_RXPC25 R_ARM = 249","const R_ARM_RSBREL32 R_ARM = 250","const R_ARM_THM_RPC22 R_ARM = 251","const R_ARM_RREL32 R_ARM = 252","const R_ARM_RABS32 R_ARM = 253","const R_ARM_RPC24 R_ARM = 254","const R_ARM_RBASE R_ARM = 255","","const R_386_NONE R_386 = 0","const R_386_32 R_386 = 1","const R_386_PC32 R_386 = 2","const R_386_GOT32 R_386 = 3","const R_386_PLT32 R_386 = 4","const R_386_COPY R_386 = 5","const R_386_GLOB_DAT R_386 = 6","const R_386_JMP_SLOT R_386 = 7","const R_386_RELATIVE R_386 = 8","const R_386_GOTOFF R_386 = 9","const R_386_GOTPC R_386 = 10","const R_386_32PLT R_386 = 11","const R_386_TLS_TPOFF R_386 = 14","const R_386_TLS_IE R_386 = 15","const R_386_TLS_GOTIE R_386 = 16","const R_386_TLS_LE R_386 = 17","const R_386_TLS_GD R_386 = 18","const R_386_TLS_LDM R_386 = 19","const R_386_16 R_386 = 20","const R_386_PC16 R_386 = 21","const R_386_8 R_386 = 22","const R_386_PC8 R_386 = 23","const R_386_TLS_GD_32 R_386 = 24","const R_386_TLS_GD_PUSH R_386 = 25","const R_386_TLS_GD_CALL R_386 = 26","const R_386_TLS_GD_POP R_386 = 27","const R_386_TLS_LDM_32 R_386 = 28","const R_386_TLS_LDM_PUSH R_386 = 29","const R_386_TLS_LDM_CALL R_386 = 30","const R_386_TLS_LDM_POP R_386 = 31","const R_386_TLS_LDO_32 R_386 = 32","const R_386_TLS_IE_32 R_386 = 33","const R_386_TLS_LE_32 R_386 = 34","const R_386_TLS_DTPMOD32 R_386 = 35","const R_386_TLS_DTPOFF32 R_386 = 36","const R_386_TLS_TPOFF32 R_386 = 37","const R_386_SIZE32 R_386 = 38","const R_386_TLS_GOTDESC R_386 = 39","const R_386_TLS_DESC_CALL R_386 = 40","const R_386_TLS_DESC R_386 = 41","const R_386_IRELATIVE R_386 = 42","const R_386_GOT32X R_386 = 43","","const R_MIPS_NONE R_MIPS = 0","const R_MIPS_16 R_MIPS = 1","const R_MIPS_32 R_MIPS = 2","const R_MIPS_REL32 R_MIPS = 3","const R_MIPS_26 R_MIPS = 4","const R_MIPS_HI16 R_MIPS = 5","const R_MIPS_LO16 R_MIPS = 6","const R_MIPS_GPREL16 R_MIPS = 7","const R_MIPS_LITERAL R_MIPS = 8","const R_MIPS_GOT16 R_MIPS = 9","const R_MIPS_PC16 R_MIPS = 10","const R_MIPS_CALL16 R_MIPS = 11","const R_MIPS_GPREL32 R_MIPS = 12","const R_MIPS_SHIFT5 R_MIPS = 16","const R_MIPS_SHIFT6 R_MIPS = 17","const R_MIPS_64 R_MIPS = 18","const R_MIPS_GOT_DISP R_MIPS = 19","const R_MIPS_GOT_PAGE R_MIPS = 20","const R_MIPS_GOT_OFST R_MIPS = 21","const R_MIPS_GOT_HI16 R_MIPS = 22","const R_MIPS_GOT_LO16 R_MIPS = 23","const R_MIPS_SUB R_MIPS = 24","const R_MIPS_INSERT_A R_MIPS = 25","const R_MIPS_INSERT_B R_MIPS = 26","const R_MIPS_DELETE R_MIPS = 27","const R_MIPS_HIGHER R_MIPS = 28","const R_MIPS_HIGHEST R_MIPS = 29","const R_MIPS_CALL_HI16 R_MIPS = 30","const R_MIPS_CALL_LO16 R_MIPS = 31","const R_MIPS_SCN_DISP R_MIPS = 32","const R_MIPS_REL16 R_MIPS = 33","const R_MIPS_ADD_IMMEDIATE R_MIPS = 34","const R_MIPS_PJUMP R_MIPS = 35","const R_MIPS_RELGOT R_MIPS = 36","const R_MIPS_JALR R_MIPS = 37","const R_MIPS_TLS_DTPMOD32 R_MIPS = 38","const R_MIPS_TLS_DTPREL32 R_MIPS = 39","const R_MIPS_TLS_DTPMOD64 R_MIPS = 40","const R_MIPS_TLS_DTPREL64 R_MIPS = 41","const R_MIPS_TLS_GD R_MIPS = 42","const R_MIPS_TLS_LDM R_MIPS = 43","const R_MIPS_TLS_DTPREL_HI16 R_MIPS = 44","const R_MIPS_TLS_DTPREL_LO16 R_MIPS = 45","const R_MIPS_TLS_GOTTPREL R_MIPS = 46","const R_MIPS_TLS_TPREL32 R_MIPS = 47","const R_MIPS_TLS_TPREL64 R_MIPS = 48","const R_MIPS_TLS_TPREL_HI16 R_MIPS = 49","const R_MIPS_TLS_TPREL_LO16 R_MIPS = 50","const R_MIPS_PC32 R_MIPS = 248","","const R_LARCH_NONE R_LARCH = 0","const R_LARCH_32 R_LARCH = 1","const R_LARCH_64 R_LARCH = 2","const R_LARCH_RELATIVE R_LARCH = 3","const R_LARCH_COPY R_LARCH = 4","const R_LARCH_JUMP_SLOT R_LARCH = 5","const R_LARCH_TLS_DTPMOD32 R_LARCH = 6","const R_LARCH_TLS_DTPMOD64 R_LARCH = 7","const R_LARCH_TLS_DTPREL32 R_LARCH = 8","const R_LARCH_TLS_DTPREL64 R_LARCH = 9","const R_LARCH_TLS_TPREL32 R_LARCH = 10","const R_LARCH_TLS_TPREL64 R_LARCH = 11","const R_LARCH_IRELATIVE R_LARCH = 12","const R_LARCH_MARK_LA R_LARCH = 20","const R_LARCH_MARK_PCREL R_LARCH = 21","const R_LARCH_SOP_PUSH_PCREL R_LARCH = 22","const R_LARCH_SOP_PUSH_ABSOLUTE R_LARCH = 23","const R_LARCH_SOP_PUSH_DUP R_LARCH = 24","const R_LARCH_SOP_PUSH_GPREL R_LARCH = 25","const R_LARCH_SOP_PUSH_TLS_TPREL R_LARCH = 26","const R_LARCH_SOP_PUSH_TLS_GOT R_LARCH = 27","const R_LARCH_SOP_PUSH_TLS_GD R_LARCH = 28","const R_LARCH_SOP_PUSH_PLT_PCREL R_LARCH = 29","const R_LARCH_SOP_ASSERT R_LARCH = 30","const R_LARCH_SOP_NOT R_LARCH = 31","const R_LARCH_SOP_SUB R_LARCH = 32","const R_LARCH_SOP_SL R_LARCH = 33","const R_LARCH_SOP_SR R_LARCH = 34","const R_LARCH_SOP_ADD R_LARCH = 35","const R_LARCH_SOP_AND R_LARCH = 36","const R_LARCH_SOP_IF_ELSE R_LARCH = 37","const R_LARCH_SOP_POP_32_S_10_5 R_LARCH = 38","const R_LARCH_SOP_POP_32_U_10_12 R_LARCH = 39","const R_LARCH_SOP_POP_32_S_10_12 R_LARCH = 40","const R_LARCH_SOP_POP_32_S_10_16 R_LARCH = 41","const R_LARCH_SOP_POP_32_S_10_16_S2 R_LARCH = 42","const R_LARCH_SOP_POP_32_S_5_20 R_LARCH = 43","const R_LARCH_SOP_POP_32_S_0_5_10_16_S2 R_LARCH = 44","const R_LARCH_SOP_POP_32_S_0_10_10_16_S2 R_LARCH = 45","const R_LARCH_SOP_POP_32_U R_LARCH = 46","const R_LARCH_ADD8 R_LARCH = 47","const R_LARCH_ADD16 R_LARCH = 48","const R_LARCH_ADD24 R_LARCH = 49","const R_LARCH_ADD32 R_LARCH = 50","const R_LARCH_ADD64 R_LARCH = 51","const R_LARCH_SUB8 R_LARCH = 52","const R_LARCH_SUB16 R_LARCH = 53","const R_LARCH_SUB24 R_LARCH = 54","const R_LARCH_SUB32 R_LARCH = 55","const R_LARCH_SUB64 R_LARCH = 56","const R_LARCH_GNU_VTINHERIT R_LARCH = 57","const R_LARCH_GNU_VTENTRY R_LARCH = 58","const R_LARCH_B16 R_LARCH = 64","const R_LARCH_B21 R_LARCH = 65","const R_LARCH_B26 R_LARCH = 66","const R_LARCH_ABS_HI20 R_LARCH = 67","const R_LARCH_ABS_LO12 R_LARCH = 68","const R_LARCH_ABS64_LO20 R_LARCH = 69","const R_LARCH_ABS64_HI12 R_LARCH = 70","const R_LARCH_PCALA_HI20 R_LARCH = 71","const R_LARCH_PCALA_LO12 R_LARCH = 72","const R_LARCH_PCALA64_LO20 R_LARCH = 73","const R_LARCH_PCALA64_HI12 R_LARCH = 74","const R_LARCH_GOT_PC_HI20 R_LARCH = 75","const R_LARCH_GOT_PC_LO12 R_LARCH = 76","const R_LARCH_GOT64_PC_LO20 R_LARCH = 77","const R_LARCH_GOT64_PC_HI12 R_LARCH = 78","const R_LARCH_GOT_HI20 R_LARCH = 79","const R_LARCH_GOT_LO12 R_LARCH = 80","const R_LARCH_GOT64_LO20 R_LARCH = 81","const R_LARCH_GOT64_HI12 R_LARCH = 82","const R_LARCH_TLS_LE_HI20 R_LARCH = 83","const R_LARCH_TLS_LE_LO12 R_LARCH = 84","const R_LARCH_TLS_LE64_LO20 R_LARCH = 85","const R_LARCH_TLS_LE64_HI12 R_LARCH = 86","const R_LARCH_TLS_IE_PC_HI20 R_LARCH = 87","const R_LARCH_TLS_IE_PC_LO12 R_LARCH = 88","const R_LARCH_TLS_IE64_PC_LO20 R_LARCH = 89","const R_LARCH_TLS_IE64_PC_HI12 R_LARCH = 90","const R_LARCH_TLS_IE_HI20 R_LARCH = 91","const R_LARCH_TLS_IE_LO12 R_LARCH = 92","const R_LARCH_TLS_IE64_LO20 R_LARCH = 93","const R_LARCH_TLS_IE64_HI12 R_LARCH = 94","const R_LARCH_TLS_LD_PC_HI20 R_LARCH = 95","const R_LARCH_TLS_LD_HI20 R_LARCH = 96","const R_LARCH_TLS_GD_PC_HI20 R_LARCH = 97","const R_LARCH_TLS_GD_HI20 R_LARCH = 98","const R_LARCH_32_PCREL R_LARCH = 99","const R_LARCH_RELAX R_LARCH = 100","const R_LARCH_DELETE R_LARCH = 101","const R_LARCH_ALIGN R_LARCH = 102","const R_LARCH_PCREL20_S2 R_LARCH = 103","const R_LARCH_CFA R_LARCH = 104","const R_LARCH_ADD6 R_LARCH = 105","const R_LARCH_SUB6 R_LARCH = 106","const R_LARCH_ADD_ULEB128 R_LARCH = 107","const R_LARCH_SUB_ULEB128 R_LARCH = 108","const R_LARCH_64_PCREL R_LARCH = 109","","const R_PPC_NONE R_PPC = 0","const R_PPC_ADDR32 R_PPC = 1","const R_PPC_ADDR24 R_PPC = 2","const R_PPC_ADDR16 R_PPC = 3","const R_PPC_ADDR16_LO R_PPC = 4","const R_PPC_ADDR16_HI R_PPC = 5","const R_PPC_ADDR16_HA R_PPC = 6","const R_PPC_ADDR14 R_PPC = 7","const R_PPC_ADDR14_BRTAKEN R_PPC = 8","const R_PPC_ADDR14_BRNTAKEN R_PPC = 9","const R_PPC_REL24 R_PPC = 10","const R_PPC_REL14 R_PPC = 11","const R_PPC_REL14_BRTAKEN R_PPC = 12","const R_PPC_REL14_BRNTAKEN R_PPC = 13","const R_PPC_GOT16 R_PPC = 14","const R_PPC_GOT16_LO R_PPC = 15","const R_PPC_GOT16_HI R_PPC = 16","const R_PPC_GOT16_HA R_PPC = 17","const R_PPC_PLTREL24 R_PPC = 18","const R_PPC_COPY R_PPC = 19","const R_PPC_GLOB_DAT R_PPC = 20","const R_PPC_JMP_SLOT R_PPC = 21","const R_PPC_RELATIVE R_PPC = 22","const R_PPC_LOCAL24PC R_PPC = 23","const R_PPC_UADDR32 R_PPC = 24","const R_PPC_UADDR16 R_PPC = 25","const R_PPC_REL32 R_PPC = 26","const R_PPC_PLT32 R_PPC = 27","const R_PPC_PLTREL32 R_PPC = 28","const R_PPC_PLT16_LO R_PPC = 29","const R_PPC_PLT16_HI R_PPC = 30","const R_PPC_PLT16_HA R_PPC = 31","const R_PPC_SDAREL16 R_PPC = 32","const R_PPC_SECTOFF R_PPC = 33","const R_PPC_SECTOFF_LO R_PPC = 34","const R_PPC_SECTOFF_HI R_PPC = 35","const R_PPC_SECTOFF_HA R_PPC = 36","const R_PPC_TLS R_PPC = 67","const R_PPC_DTPMOD32 R_PPC = 68","const R_PPC_TPREL16 R_PPC = 69","const R_PPC_TPREL16_LO R_PPC = 70","const R_PPC_TPREL16_HI R_PPC = 71","const R_PPC_TPREL16_HA R_PPC = 72","const R_PPC_TPREL32 R_PPC = 73","const R_PPC_DTPREL16 R_PPC = 74","const R_PPC_DTPREL16_LO R_PPC = 75","const R_PPC_DTPREL16_HI R_PPC = 76","const R_PPC_DTPREL16_HA R_PPC = 77","const R_PPC_DTPREL32 R_PPC = 78","const R_PPC_GOT_TLSGD16 R_PPC = 79","const R_PPC_GOT_TLSGD16_LO R_PPC = 80","const R_PPC_GOT_TLSGD16_HI R_PPC = 81","const R_PPC_GOT_TLSGD16_HA R_PPC = 82","const R_PPC_GOT_TLSLD16 R_PPC = 83","const R_PPC_GOT_TLSLD16_LO R_PPC = 84","const R_PPC_GOT_TLSLD16_HI R_PPC = 85","const R_PPC_GOT_TLSLD16_HA R_PPC = 86","const R_PPC_GOT_TPREL16 R_PPC = 87","const R_PPC_GOT_TPREL16_LO R_PPC = 88","const R_PPC_GOT_TPREL16_HI R_PPC = 89","const R_PPC_GOT_TPREL16_HA R_PPC = 90","const R_PPC_EMB_NADDR32 R_PPC = 101","const R_PPC_EMB_NADDR16 R_PPC = 102","const R_PPC_EMB_NADDR16_LO R_PPC = 103","const R_PPC_EMB_NADDR16_HI R_PPC = 104","const R_PPC_EMB_NADDR16_HA R_PPC = 105","const R_PPC_EMB_SDAI16 R_PPC = 106","const R_PPC_EMB_SDA2I16 R_PPC = 107","const R_PPC_EMB_SDA2REL R_PPC = 108","const R_PPC_EMB_SDA21 R_PPC = 109","const R_PPC_EMB_MRKREF R_PPC = 110","const R_PPC_EMB_RELSEC16 R_PPC = 111","const R_PPC_EMB_RELST_LO R_PPC = 112","const R_PPC_EMB_RELST_HI R_PPC = 113","const R_PPC_EMB_RELST_HA R_PPC = 114","const R_PPC_EMB_BIT_FLD R_PPC = 115","const R_PPC_EMB_RELSDA R_PPC = 116","","const R_PPC64_NONE R_PPC64 = 0","const R_PPC64_ADDR32 R_PPC64 = 1","const R_PPC64_ADDR24 R_PPC64 = 2","const R_PPC64_ADDR16 R_PPC64 = 3","const R_PPC64_ADDR16_LO R_PPC64 = 4","const R_PPC64_ADDR16_HI R_PPC64 = 5","const R_PPC64_ADDR16_HA R_PPC64 = 6","const R_PPC64_ADDR14 R_PPC64 = 7","const R_PPC64_ADDR14_BRTAKEN R_PPC64 = 8","const R_PPC64_ADDR14_BRNTAKEN R_PPC64 = 9","const R_PPC64_REL24 R_PPC64 = 10","const R_PPC64_REL14 R_PPC64 = 11","const R_PPC64_REL14_BRTAKEN R_PPC64 = 12","const R_PPC64_REL14_BRNTAKEN R_PPC64 = 13","const R_PPC64_GOT16 R_PPC64 = 14","const R_PPC64_GOT16_LO R_PPC64 = 15","const R_PPC64_GOT16_HI R_PPC64 = 16","const R_PPC64_GOT16_HA R_PPC64 = 17","const R_PPC64_COPY R_PPC64 = 19","const R_PPC64_GLOB_DAT R_PPC64 = 20","const R_PPC64_JMP_SLOT R_PPC64 = 21","const R_PPC64_RELATIVE R_PPC64 = 22","const R_PPC64_UADDR32 R_PPC64 = 24","const R_PPC64_UADDR16 R_PPC64 = 25","const R_PPC64_REL32 R_PPC64 = 26","const R_PPC64_PLT32 R_PPC64 = 27","const R_PPC64_PLTREL32 R_PPC64 = 28","const R_PPC64_PLT16_LO R_PPC64 = 29","const R_PPC64_PLT16_HI R_PPC64 = 30","const R_PPC64_PLT16_HA R_PPC64 = 31","const R_PPC64_SECTOFF R_PPC64 = 33","const R_PPC64_SECTOFF_LO R_PPC64 = 34","const R_PPC64_SECTOFF_HI R_PPC64 = 35","const R_PPC64_SECTOFF_HA R_PPC64 = 36","const R_PPC64_REL30 R_PPC64 = 37","const R_PPC64_ADDR64 R_PPC64 = 38","const R_PPC64_ADDR16_HIGHER R_PPC64 = 39","const R_PPC64_ADDR16_HIGHERA R_PPC64 = 40","const R_PPC64_ADDR16_HIGHEST R_PPC64 = 41","const R_PPC64_ADDR16_HIGHESTA R_PPC64 = 42","const R_PPC64_UADDR64 R_PPC64 = 43","const R_PPC64_REL64 R_PPC64 = 44","const R_PPC64_PLT64 R_PPC64 = 45","const R_PPC64_PLTREL64 R_PPC64 = 46","const R_PPC64_TOC16 R_PPC64 = 47","const R_PPC64_TOC16_LO R_PPC64 = 48","const R_PPC64_TOC16_HI R_PPC64 = 49","const R_PPC64_TOC16_HA R_PPC64 = 50","const R_PPC64_TOC R_PPC64 = 51","const R_PPC64_PLTGOT16 R_PPC64 = 52","const R_PPC64_PLTGOT16_LO R_PPC64 = 53","const R_PPC64_PLTGOT16_HI R_PPC64 = 54","const R_PPC64_PLTGOT16_HA R_PPC64 = 55","const R_PPC64_ADDR16_DS R_PPC64 = 56","const R_PPC64_ADDR16_LO_DS R_PPC64 = 57","const R_PPC64_GOT16_DS R_PPC64 = 58","const R_PPC64_GOT16_LO_DS R_PPC64 = 59","const R_PPC64_PLT16_LO_DS R_PPC64 = 60","const R_PPC64_SECTOFF_DS R_PPC64 = 61","const R_PPC64_SECTOFF_LO_DS R_PPC64 = 62","const R_PPC64_TOC16_DS R_PPC64 = 63","const R_PPC64_TOC16_LO_DS R_PPC64 = 64","const R_PPC64_PLTGOT16_DS R_PPC64 = 65","const R_PPC64_PLTGOT_LO_DS R_PPC64 = 66","const R_PPC64_TLS R_PPC64 = 67","const R_PPC64_DTPMOD64 R_PPC64 = 68","const R_PPC64_TPREL16 R_PPC64 = 69","const R_PPC64_TPREL16_LO R_PPC64 = 70","const R_PPC64_TPREL16_HI R_PPC64 = 71","const R_PPC64_TPREL16_HA R_PPC64 = 72","const R_PPC64_TPREL64 R_PPC64 = 73","const R_PPC64_DTPREL16 R_PPC64 = 74","const R_PPC64_DTPREL16_LO R_PPC64 = 75","const R_PPC64_DTPREL16_HI R_PPC64 = 76","const R_PPC64_DTPREL16_HA R_PPC64 = 77","const R_PPC64_DTPREL64 R_PPC64 = 78","const R_PPC64_GOT_TLSGD16 R_PPC64 = 79","const R_PPC64_GOT_TLSGD16_LO R_PPC64 = 80","const R_PPC64_GOT_TLSGD16_HI R_PPC64 = 81","const R_PPC64_GOT_TLSGD16_HA R_PPC64 = 82","const R_PPC64_GOT_TLSLD16 R_PPC64 = 83","const R_PPC64_GOT_TLSLD16_LO R_PPC64 = 84","const R_PPC64_GOT_TLSLD16_HI R_PPC64 = 85","const R_PPC64_GOT_TLSLD16_HA R_PPC64 = 86","const R_PPC64_GOT_TPREL16_DS R_PPC64 = 87","const R_PPC64_GOT_TPREL16_LO_DS R_PPC64 = 88","const R_PPC64_GOT_TPREL16_HI R_PPC64 = 89","const R_PPC64_GOT_TPREL16_HA R_PPC64 = 90","const R_PPC64_GOT_DTPREL16_DS R_PPC64 = 91","const R_PPC64_GOT_DTPREL16_LO_DS R_PPC64 = 92","const R_PPC64_GOT_DTPREL16_HI R_PPC64 = 93","const R_PPC64_GOT_DTPREL16_HA R_PPC64 = 94","const R_PPC64_TPREL16_DS R_PPC64 = 95","const R_PPC64_TPREL16_LO_DS R_PPC64 = 96","const R_PPC64_TPREL16_HIGHER R_PPC64 = 97","const R_PPC64_TPREL16_HIGHERA R_PPC64 = 98","const R_PPC64_TPREL16_HIGHEST R_PPC64 = 99","const R_PPC64_TPREL16_HIGHESTA R_PPC64 = 100","const R_PPC64_DTPREL16_DS R_PPC64 = 101","const R_PPC64_DTPREL16_LO_DS R_PPC64 = 102","const R_PPC64_DTPREL16_HIGHER R_PPC64 = 103","const R_PPC64_DTPREL16_HIGHERA R_PPC64 = 104","const R_PPC64_DTPREL16_HIGHEST R_PPC64 = 105","const R_PPC64_DTPREL16_HIGHESTA R_PPC64 = 106","const R_PPC64_TLSGD R_PPC64 = 107","const R_PPC64_TLSLD R_PPC64 = 108","const R_PPC64_TOCSAVE R_PPC64 = 109","const R_PPC64_ADDR16_HIGH R_PPC64 = 110","const R_PPC64_ADDR16_HIGHA R_PPC64 = 111","const R_PPC64_TPREL16_HIGH R_PPC64 = 112","const R_PPC64_TPREL16_HIGHA R_PPC64 = 113","const R_PPC64_DTPREL16_HIGH R_PPC64 = 114","const R_PPC64_DTPREL16_HIGHA R_PPC64 = 115","const R_PPC64_REL24_NOTOC R_PPC64 = 116","const R_PPC64_ADDR64_LOCAL R_PPC64 = 117","const R_PPC64_ENTRY R_PPC64 = 118","const R_PPC64_PLTSEQ R_PPC64 = 119","const R_PPC64_PLTCALL R_PPC64 = 120","const R_PPC64_PLTSEQ_NOTOC R_PPC64 = 121","const R_PPC64_PLTCALL_NOTOC R_PPC64 = 122","const R_PPC64_PCREL_OPT R_PPC64 = 123","const R_PPC64_REL24_P9NOTOC R_PPC64 = 124","const R_PPC64_D34 R_PPC64 = 128","const R_PPC64_D34_LO R_PPC64 = 129","const R_PPC64_D34_HI30 R_PPC64 = 130","const R_PPC64_D34_HA30 R_PPC64 = 131","const R_PPC64_PCREL34 R_PPC64 = 132","const R_PPC64_GOT_PCREL34 R_PPC64 = 133","const R_PPC64_PLT_PCREL34 R_PPC64 = 134","const R_PPC64_PLT_PCREL34_NOTOC R_PPC64 = 135","const R_PPC64_ADDR16_HIGHER34 R_PPC64 = 136","const R_PPC64_ADDR16_HIGHERA34 R_PPC64 = 137","const R_PPC64_ADDR16_HIGHEST34 R_PPC64 = 138","const R_PPC64_ADDR16_HIGHESTA34 R_PPC64 = 139","const R_PPC64_REL16_HIGHER34 R_PPC64 = 140","const R_PPC64_REL16_HIGHERA34 R_PPC64 = 141","const R_PPC64_REL16_HIGHEST34 R_PPC64 = 142","const R_PPC64_REL16_HIGHESTA34 R_PPC64 = 143","const R_PPC64_D28 R_PPC64 = 144","const R_PPC64_PCREL28 R_PPC64 = 145","const R_PPC64_TPREL34 R_PPC64 = 146","const R_PPC64_DTPREL34 R_PPC64 = 147","const R_PPC64_GOT_TLSGD_PCREL34 R_PPC64 = 148","const R_PPC64_GOT_TLSLD_PCREL34 R_PPC64 = 149","const R_PPC64_GOT_TPREL_PCREL34 R_PPC64 = 150","const R_PPC64_GOT_DTPREL_PCREL34 R_PPC64 = 151","const R_PPC64_REL16_HIGH R_PPC64 = 240","const R_PPC64_REL16_HIGHA R_PPC64 = 241","const R_PPC64_REL16_HIGHER R_PPC64 = 242","const R_PPC64_REL16_HIGHERA R_PPC64 = 243","const R_PPC64_REL16_HIGHEST R_PPC64 = 244","const R_PPC64_REL16_HIGHESTA R_PPC64 = 245","const R_PPC64_REL16DX_HA R_PPC64 = 246","const R_PPC64_JMP_IREL R_PPC64 = 247","const R_PPC64_IRELATIVE R_PPC64 = 248","const R_PPC64_REL16 R_PPC64 = 249","const R_PPC64_REL16_LO R_PPC64 = 250","const R_PPC64_REL16_HI R_PPC64 = 251","const R_PPC64_REL16_HA R_PPC64 = 252","const R_PPC64_GNU_VTINHERIT R_PPC64 = 253","const R_PPC64_GNU_VTENTRY R_PPC64 = 254","","const R_RISCV_NONE R_RISCV = 0","const R_RISCV_32 R_RISCV = 1","const R_RISCV_64 R_RISCV = 2","const R_RISCV_RELATIVE R_RISCV = 3","const R_RISCV_COPY R_RISCV = 4","const R_RISCV_JUMP_SLOT R_RISCV = 5","const R_RISCV_TLS_DTPMOD32 R_RISCV = 6","const R_RISCV_TLS_DTPMOD64 R_RISCV = 7","const R_RISCV_TLS_DTPREL32 R_RISCV = 8","const R_RISCV_TLS_DTPREL64 R_RISCV = 9","const R_RISCV_TLS_TPREL32 R_RISCV = 10","const R_RISCV_TLS_TPREL64 R_RISCV = 11","const R_RISCV_BRANCH R_RISCV = 16","const R_RISCV_JAL R_RISCV = 17","const R_RISCV_CALL R_RISCV = 18","const R_RISCV_CALL_PLT R_RISCV = 19","const R_RISCV_GOT_HI20 R_RISCV = 20","const R_RISCV_TLS_GOT_HI20 R_RISCV = 21","const R_RISCV_TLS_GD_HI20 R_RISCV = 22","const R_RISCV_PCREL_HI20 R_RISCV = 23","const R_RISCV_PCREL_LO12_I R_RISCV = 24","const R_RISCV_PCREL_LO12_S R_RISCV = 25","const R_RISCV_HI20 R_RISCV = 26","const R_RISCV_LO12_I R_RISCV = 27","const R_RISCV_LO12_S R_RISCV = 28","const R_RISCV_TPREL_HI20 R_RISCV = 29","const R_RISCV_TPREL_LO12_I R_RISCV = 30","const R_RISCV_TPREL_LO12_S R_RISCV = 31","const R_RISCV_TPREL_ADD R_RISCV = 32","const R_RISCV_ADD8 R_RISCV = 33","const R_RISCV_ADD16 R_RISCV = 34","const R_RISCV_ADD32 R_RISCV = 35","const R_RISCV_ADD64 R_RISCV = 36","const R_RISCV_SUB8 R_RISCV = 37","const R_RISCV_SUB16 R_RISCV = 38","const R_RISCV_SUB32 R_RISCV = 39","const R_RISCV_SUB64 R_RISCV = 40","const R_RISCV_GNU_VTINHERIT R_RISCV = 41","const R_RISCV_GNU_VTENTRY R_RISCV = 42","const R_RISCV_ALIGN R_RISCV = 43","const R_RISCV_RVC_BRANCH R_RISCV = 44","const R_RISCV_RVC_JUMP R_RISCV = 45","const R_RISCV_RVC_LUI R_RISCV = 46","const R_RISCV_GPREL_I R_RISCV = 47","const R_RISCV_GPREL_S R_RISCV = 48","const R_RISCV_TPREL_I R_RISCV = 49","const R_RISCV_TPREL_S R_RISCV = 50","const R_RISCV_RELAX R_RISCV = 51","const R_RISCV_SUB6 R_RISCV = 52","const R_RISCV_SET6 R_RISCV = 53","const R_RISCV_SET8 R_RISCV = 54","const R_RISCV_SET16 R_RISCV = 55","const R_RISCV_SET32 R_RISCV = 56","const R_RISCV_32_PCREL R_RISCV = 57","","const R_390_NONE R_390 = 0","const R_390_8 R_390 = 1","const R_390_12 R_390 = 2","const R_390_16 R_390 = 3","const R_390_32 R_390 = 4","const R_390_PC32 R_390 = 5","const R_390_GOT12 R_390 = 6","const R_390_GOT32 R_390 = 7","const R_390_PLT32 R_390 = 8","const R_390_COPY R_390 = 9","const R_390_GLOB_DAT R_390 = 10","const R_390_JMP_SLOT R_390 = 11","const R_390_RELATIVE R_390 = 12","const R_390_GOTOFF R_390 = 13","const R_390_GOTPC R_390 = 14","const R_390_GOT16 R_390 = 15","const R_390_PC16 R_390 = 16","const R_390_PC16DBL R_390 = 17","const R_390_PLT16DBL R_390 = 18","const R_390_PC32DBL R_390 = 19","const R_390_PLT32DBL R_390 = 20","const R_390_GOTPCDBL R_390 = 21","const R_390_64 R_390 = 22","const R_390_PC64 R_390 = 23","const R_390_GOT64 R_390 = 24","const R_390_PLT64 R_390 = 25","const R_390_GOTENT R_390 = 26","const R_390_GOTOFF16 R_390 = 27","const R_390_GOTOFF64 R_390 = 28","const R_390_GOTPLT12 R_390 = 29","const R_390_GOTPLT16 R_390 = 30","const R_390_GOTPLT32 R_390 = 31","const R_390_GOTPLT64 R_390 = 32","const R_390_GOTPLTENT R_390 = 33","const R_390_GOTPLTOFF16 R_390 = 34","const R_390_GOTPLTOFF32 R_390 = 35","const R_390_GOTPLTOFF64 R_390 = 36","const R_390_TLS_LOAD R_390 = 37","const R_390_TLS_GDCALL R_390 = 38","const R_390_TLS_LDCALL R_390 = 39","const R_390_TLS_GD32 R_390 = 40","const R_390_TLS_GD64 R_390 = 41","const R_390_TLS_GOTIE12 R_390 = 42","const R_390_TLS_GOTIE32 R_390 = 43","const R_390_TLS_GOTIE64 R_390 = 44","const R_390_TLS_LDM32 R_390 = 45","const R_390_TLS_LDM64 R_390 = 46","const R_390_TLS_IE32 R_390 = 47","const R_390_TLS_IE64 R_390 = 48","const R_390_TLS_IEENT R_390 = 49","const R_390_TLS_LE32 R_390 = 50","const R_390_TLS_LE64 R_390 = 51","const R_390_TLS_LDO32 R_390 = 52","const R_390_TLS_LDO64 R_390 = 53","const R_390_TLS_DTPMOD R_390 = 54","const R_390_TLS_DTPOFF R_390 = 55","const R_390_TLS_TPOFF R_390 = 56","const R_390_20 R_390 = 57","const R_390_GOT20 R_390 = 58","const R_390_GOTPLT20 R_390 = 59","const R_390_TLS_GOTIE20 R_390 = 60","","const R_SPARC_NONE R_SPARC = 0","const R_SPARC_8 R_SPARC = 1","const R_SPARC_16 R_SPARC = 2","const R_SPARC_32 R_SPARC = 3","const R_SPARC_DISP8 R_SPARC = 4","const R_SPARC_DISP16 R_SPARC = 5","const R_SPARC_DISP32 R_SPARC = 6","const R_SPARC_WDISP30 R_SPARC = 7","const R_SPARC_WDISP22 R_SPARC = 8","const R_SPARC_HI22 R_SPARC = 9","const R_SPARC_22 R_SPARC = 10","const R_SPARC_13 R_SPARC = 11","const R_SPARC_LO10 R_SPARC = 12","const R_SPARC_GOT10 R_SPARC = 13","const R_SPARC_GOT13 R_SPARC = 14","const R_SPARC_GOT22 R_SPARC = 15","const R_SPARC_PC10 R_SPARC = 16","const R_SPARC_PC22 R_SPARC = 17","const R_SPARC_WPLT30 R_SPARC = 18","const R_SPARC_COPY R_SPARC = 19","const R_SPARC_GLOB_DAT R_SPARC = 20","const R_SPARC_JMP_SLOT R_SPARC = 21","const R_SPARC_RELATIVE R_SPARC = 22","const R_SPARC_UA32 R_SPARC = 23","const R_SPARC_PLT32 R_SPARC = 24","const R_SPARC_HIPLT22 R_SPARC = 25","const R_SPARC_LOPLT10 R_SPARC = 26","const R_SPARC_PCPLT32 R_SPARC = 27","const R_SPARC_PCPLT22 R_SPARC = 28","const R_SPARC_PCPLT10 R_SPARC = 29","const R_SPARC_10 R_SPARC = 30","const R_SPARC_11 R_SPARC = 31","const R_SPARC_64 R_SPARC = 32","const R_SPARC_OLO10 R_SPARC = 33","const R_SPARC_HH22 R_SPARC = 34","const R_SPARC_HM10 R_SPARC = 35","const R_SPARC_LM22 R_SPARC = 36","const R_SPARC_PC_HH22 R_SPARC = 37","const R_SPARC_PC_HM10 R_SPARC = 38","const R_SPARC_PC_LM22 R_SPARC = 39","const R_SPARC_WDISP16 R_SPARC = 40","const R_SPARC_WDISP19 R_SPARC = 41","const R_SPARC_GLOB_JMP R_SPARC = 42","const R_SPARC_7 R_SPARC = 43","const R_SPARC_5 R_SPARC = 44","const R_SPARC_6 R_SPARC = 45","const R_SPARC_DISP64 R_SPARC = 46","const R_SPARC_PLT64 R_SPARC = 47","const R_SPARC_HIX22 R_SPARC = 48","const R_SPARC_LOX10 R_SPARC = 49","const R_SPARC_H44 R_SPARC = 50","const R_SPARC_M44 R_SPARC = 51","const R_SPARC_L44 R_SPARC = 52","const R_SPARC_REGISTER R_SPARC = 53","const R_SPARC_UA64 R_SPARC = 54","const R_SPARC_UA16 R_SPARC = 55","const ARM_MAGIC_TRAMP_NUMBER = 0x5c000003","type Header32 struct {\n\tIdent\t\t[EI_NIDENT]byte\t/* File identification. */\n\tType\t\tuint16\t\t/* File type. */\n\tMachine\t\tuint16\t\t/* Machine architecture. */\n\tVersion\t\tuint32\t\t/* ELF format version. */\n\tEntry\t\tuint32\t\t/* Entry point. */\n\tPhoff\t\tuint32\t\t/* Program header file offset. */\n\tShoff\t\tuint32\t\t/* Section header file offset. */\n\tFlags\t\tuint32\t\t/* Architecture-specific flags. */\n\tEhsize\t\tuint16\t\t/* Size of ELF header in bytes. */\n\tPhentsize\tuint16\t\t/* Size of program header entry. */\n\tPhnum\t\tuint16\t\t/* Number of program header entries. */\n\tShentsize\tuint16\t\t/* Size of section header entry. */\n\tShnum\t\tuint16\t\t/* Number of section header entries. */\n\tShstrndx\tuint16\t\t/* Section name strings section. */\n}","type Section32 struct {\n\tName\t\tuint32\t/* Section name (index into the section header string table). */\n\tType\t\tuint32\t/* Section type. */\n\tFlags\t\tuint32\t/* Section flags. */\n\tAddr\t\tuint32\t/* Address in memory image. */\n\tOff\t\tuint32\t/* Offset in file. */\n\tSize\t\tuint32\t/* Size in bytes. */\n\tLink\t\tuint32\t/* Index of a related section. */\n\tInfo\t\tuint32\t/* Depends on section type. */\n\tAddralign\tuint32\t/* Alignment in bytes. */\n\tEntsize\t\tuint32\t/* Size of each entry in section. */\n}","type Prog32 struct {\n\tType\tuint32\t/* Entry type. */\n\tOff\tuint32\t/* File offset of contents. */\n\tVaddr\tuint32\t/* Virtual address in memory image. */\n\tPaddr\tuint32\t/* Physical address (not used). */\n\tFilesz\tuint32\t/* Size of contents in file. */\n\tMemsz\tuint32\t/* Size of contents in memory. */\n\tFlags\tuint32\t/* Access permission flags. */\n\tAlign\tuint32\t/* Alignment in memory and file. */\n}","type Dyn32 struct {\n\tTag\tint32\t/* Entry type. */\n\tVal\tuint32\t/* Integer/Address value. */\n}","type Chdr32 struct {\n\tType\t\tuint32\n\tSize\t\tuint32\n\tAddralign\tuint32\n}","type Rel32 struct {\n\tOff\tuint32\t/* Location to be relocated. */\n\tInfo\tuint32\t/* Relocation type and symbol index. */\n}","type Rela32 struct {\n\tOff\tuint32\t/* Location to be relocated. */\n\tInfo\tuint32\t/* Relocation type and symbol index. */\n\tAddend\tint32\t/* Addend. */\n}","func R_SYM32(info uint32) uint32","func R_TYPE32(info uint32) uint32","func R_INFO32(sym, typ uint32) uint32","type Sym32 struct {\n\tName\tuint32\n\tValue\tuint32\n\tSize\tuint32\n\tInfo\tuint8\n\tOther\tuint8\n\tShndx\tuint16\n}","const Sym32Size = 16","func ST_BIND(info uint8) SymBind","func ST_TYPE(info uint8) SymType","func ST_INFO(bind SymBind, typ SymType) uint8","func ST_VISIBILITY(other uint8) SymVis","type Header64 struct {\n\tIdent\t\t[EI_NIDENT]byte\t/* File identification. */\n\tType\t\tuint16\t\t/* File type. */\n\tMachine\t\tuint16\t\t/* Machine architecture. */\n\tVersion\t\tuint32\t\t/* ELF format version. */\n\tEntry\t\tuint64\t\t/* Entry point. */\n\tPhoff\t\tuint64\t\t/* Program header file offset. */\n\tShoff\t\tuint64\t\t/* Section header file offset. */\n\tFlags\t\tuint32\t\t/* Architecture-specific flags. */\n\tEhsize\t\tuint16\t\t/* Size of ELF header in bytes. */\n\tPhentsize\tuint16\t\t/* Size of program header entry. */\n\tPhnum\t\tuint16\t\t/* Number of program header entries. */\n\tShentsize\tuint16\t\t/* Size of section header entry. */\n\tShnum\t\tuint16\t\t/* Number of section header entries. */\n\tShstrndx\tuint16\t\t/* Section name strings section. */\n}","type Section64 struct {\n\tName\t\tuint32\t/* Section name (index into the section header string table). */\n\tType\t\tuint32\t/* Section type. */\n\tFlags\t\tuint64\t/* Section flags. */\n\tAddr\t\tuint64\t/* Address in memory image. */\n\tOff\t\tuint64\t/* Offset in file. */\n\tSize\t\tuint64\t/* Size in bytes. */\n\tLink\t\tuint32\t/* Index of a related section. */\n\tInfo\t\tuint32\t/* Depends on section type. */\n\tAddralign\tuint64\t/* Alignment in bytes. */\n\tEntsize\t\tuint64\t/* Size of each entry in section. */\n}","type Prog64 struct {\n\tType\tuint32\t/* Entry type. */\n\tFlags\tuint32\t/* Access permission flags. */\n\tOff\tuint64\t/* File offset of contents. */\n\tVaddr\tuint64\t/* Virtual address in memory image. */\n\tPaddr\tuint64\t/* Physical address (not used). */\n\tFilesz\tuint64\t/* Size of contents in file. */\n\tMemsz\tuint64\t/* Size of contents in memory. */\n\tAlign\tuint64\t/* Alignment in memory and file. */\n}","type Dyn64 struct {\n\tTag\tint64\t/* Entry type. */\n\tVal\tuint64\t/* Integer/address value */\n}","type Chdr64 struct {\n\tType\t\tuint32\n\t_\t\tuint32\t/* Reserved. */\n\tSize\t\tuint64\n\tAddralign\tuint64\n}","type Rel64 struct {\n\tOff\tuint64\t/* Location to be relocated. */\n\tInfo\tuint64\t/* Relocation type and symbol index. */\n}","type Rela64 struct {\n\tOff\tuint64\t/* Location to be relocated. */\n\tInfo\tuint64\t/* Relocation type and symbol index. */\n\tAddend\tint64\t/* Addend. */\n}","func R_SYM64(info uint64) uint32","func R_TYPE64(info uint64) uint32","func R_INFO(sym, typ uint32) uint64","type Sym64 struct {\n\tName\tuint32\t/* String table index of name. */\n\tInfo\tuint8\t/* Type and binding information. */\n\tOther\tuint8\t/* Reserved (not used). */\n\tShndx\tuint16\t/* Section index of symbol. */\n\tValue\tuint64\t/* Symbol value. */\n\tSize\tuint64\t/* Size of associated object. */\n}","const Sym64Size = 24","type FileHeader struct {\n\tClass\t\tClass\n\tData\t\tData\n\tVersion\t\tVersion\n\tOSABI\t\tOSABI\n\tABIVersion\tuint8\n\tByteOrder\tbinary.ByteOrder\n\tType\t\tType\n\tMachine\t\tMachine\n\tEntry\t\tuint64\n}","type File struct {\n\tFileHeader\n\tSections\t[]*Section\n\tProgs\t\t[]*Prog\n\tcloser\t\tio.Closer\n\tgnuNeed\t\t[]verneed\n\tgnuVersym\t[]byte\n}","type SectionHeader struct {\n\tName\t\tstring\n\tType\t\tSectionType\n\tFlags\t\tSectionFlag\n\tAddr\t\tuint64\n\tOffset\t\tuint64\n\tSize\t\tuint64\n\tLink\t\tuint32\n\tInfo\t\tuint32\n\tAddralign\tuint64\n\tEntsize\t\tuint64\n\n\t// FileSize is the size of this section in the file in bytes.\n\t// If a section is compressed, FileSize is the size of the\n\t// compressed data, while Size (above) is the size of the\n\t// uncompressed data.\n\tFileSize\tuint64\n}","type Section struct {\n\tSectionHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\t//\n\t// ReaderAt may be nil if the section is not easily available\n\t// in a random-access form. For example, a compressed section\n\t// may have a nil ReaderAt.\n\tio.ReaderAt\n\tsr\t*io.SectionReader\n\n\tcompressionType\t\tCompressionType\n\tcompressionOffset\tint64\n}","type ProgHeader struct {\n\tType\tProgType\n\tFlags\tProgFlag\n\tOff\tuint64\n\tVaddr\tuint64\n\tPaddr\tuint64\n\tFilesz\tuint64\n\tMemsz\tuint64\n\tAlign\tuint64\n}","type Prog struct {\n\tProgHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\tsr\t*io.SectionReader\n}","type Symbol struct {\n\tName\t\tstring\n\tInfo, Other\tbyte\n\tSection\t\tSectionIndex\n\tValue, Size\tuint64\n\n\t// Version and Library are present only for the dynamic symbol\n\t// table.\n\tVersion\tstring\n\tLibrary\tstring\n}","type FormatError struct {\n\toff\tint64\n\tmsg\tstring\n\tval\tany\n}","func Open(name string) (*File, error)","func NewFile(r io.ReaderAt) (*File, error)","","type ImportedSymbol struct {\n\tName\tstring\n\tVersion\tstring\n\tLibrary\tstring\n}","type LineTable struct {\n\tData\t[]byte\n\tPC\tuint64\n\tLine\tint\n\n\t// This mutex is used to keep parsing of pclntab synchronous.\n\tmu\tsync.Mutex\n\n\t// Contains the version of the pclntab section.\n\tversion\tversion\n\n\t// Go 1.2/1.16/1.18 state\n\tbinary\t\tbinary.ByteOrder\n\tquantum\t\tuint32\n\tptrsize\t\tuint32\n\ttextStart\tuint64\t// address of runtime.text symbol (1.18+)\n\tfuncnametab\t[]byte\n\tcutab\t\t[]byte\n\tfuncdata\t[]byte\n\tfunctab\t\t[]byte\n\tnfunctab\tuint32\n\tfiletab\t\t[]byte\n\tpctab\t\t[]byte\t// points to the pctables.\n\tnfiletab\tuint32\n\tfuncNames\tmap[uint32]string\t// cache the function names\n\tstrings\t\tmap[uint32]string\t// interned substrings of Data, keyed by offset\n\t// fileMap varies depending on the version of the object file.\n\t// For ver12, it maps the name to the index in the file table.\n\t// For ver116, it maps the name to the offset in filetab.\n\tfileMap\tmap[string]uint32\n}","func NewLineTable(data []byte, text uint64) *LineTable","type Sym struct {\n\tValue\tuint64\n\tType\tbyte\n\tName\tstring\n\tGoType\tuint64\n\t// If this symbol is a function symbol, the corresponding Func\n\tFunc\t*Func\n\n\tgoVersion\tversion\n}","type Func struct {\n\tEntry\tuint64\n\t*Sym\n\tEnd\t\tuint64\n\tParams\t\t[]*Sym\t// nil for Go 1.3 and later binaries\n\tLocals\t\t[]*Sym\t// nil for Go 1.3 and later binaries\n\tFrameSize\tint\n\tLineTable\t*LineTable\n\tObj\t\t*Obj\n}","type Obj struct {\n\t// Funcs is a list of functions in the Obj.\n\tFuncs\t[]Func\n\n\t// In Go 1.1 and earlier, Paths is a list of symbols corresponding\n\t// to the source file names that produced the Obj.\n\t// In Go 1.2, Paths is nil.\n\t// Use the keys of Table.Files to obtain a list of source files.\n\tPaths\t[]Sym\t// meta\n}","type Table struct {\n\tSyms\t[]Sym\t// nil for Go 1.3 and later binaries\n\tFuncs\t[]Func\n\tFiles\tmap[string]*Obj\t// for Go 1.2 and later all files map to one Obj\n\tObjs\t[]Obj\t\t// for Go 1.2 and later only one Obj in slice\n\n\tgo12line\t*LineTable\t// Go 1.2 line number table\n}","func NewTable(symtab []byte, pcln *LineTable) (*Table, error)","","type UnknownLineError struct {\n\tFile\tstring\n\tLine\tint\n}","type DecodingError struct {\n\toff\tint\n\tmsg\tstring\n\tval\tany\n}","type FatFile struct {\n\tMagic\tuint32\n\tArches\t[]FatArch\n\tcloser\tio.Closer\n}","type FatArchHeader struct {\n\tCpu\tCpu\n\tSubCpu\tuint32\n\tOffset\tuint32\n\tSize\tuint32\n\tAlign\tuint32\n}","type FatArch struct {\n\tFatArchHeader\n\t*File\n}","","func NewFatFile(r io.ReaderAt) (*FatFile, error)","func OpenFat(name string) (*FatFile, error)","type File struct {\n\tFileHeader\n\tByteOrder\tbinary.ByteOrder\n\tLoads\t\t[]Load\n\tSections\t[]*Section\n\n\tSymtab\t\t*Symtab\n\tDysymtab\t*Dysymtab\n\n\tcloser\tio.Closer\n}","type Load interface {\n\tRaw() []byte\n}","type LoadBytes []byte","type SegmentHeader struct {\n\tCmd\tLoadCmd\n\tLen\tuint32\n\tName\tstring\n\tAddr\tuint64\n\tMemsz\tuint64\n\tOffset\tuint64\n\tFilesz\tuint64\n\tMaxprot\tuint32\n\tProt\tuint32\n\tNsect\tuint32\n\tFlag\tuint32\n}","type Segment struct {\n\tLoadBytes\n\tSegmentHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\tsr\t*io.SectionReader\n}","type SectionHeader struct {\n\tName\tstring\n\tSeg\tstring\n\tAddr\tuint64\n\tSize\tuint64\n\tOffset\tuint32\n\tAlign\tuint32\n\tReloff\tuint32\n\tNreloc\tuint32\n\tFlags\tuint32\n}","type Reloc struct {\n\tAddr\tuint32\n\tValue\tuint32\n\t// when Scattered == false \u0026\u0026 Extern == true, Value is the symbol number.\n\t// when Scattered == false \u0026\u0026 Extern == false, Value is the section number.\n\t// when Scattered == true, Value is the value that this reloc refers to.\n\tType\t\tuint8\n\tLen\t\tuint8\t// 0=byte, 1=word, 2=long, 3=quad\n\tPcrel\t\tbool\n\tExtern\t\tbool\t// valid if Scattered == false\n\tScattered\tbool\n}","type Section struct {\n\tSectionHeader\n\tRelocs\t[]Reloc\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\tsr\t*io.SectionReader\n}","type Dylib struct {\n\tLoadBytes\n\tName\t\tstring\n\tTime\t\tuint32\n\tCurrentVersion\tuint32\n\tCompatVersion\tuint32\n}","type Symtab struct {\n\tLoadBytes\n\tSymtabCmd\n\tSyms\t[]Symbol\n}","type Dysymtab struct {\n\tLoadBytes\n\tDysymtabCmd\n\tIndirectSyms\t[]uint32\t// indices into Symtab.Syms\n}","type Rpath struct {\n\tLoadBytes\n\tPath\tstring\n}","type Symbol struct {\n\tName\tstring\n\tType\tuint8\n\tSect\tuint8\n\tDesc\tuint16\n\tValue\tuint64\n}","type FormatError struct {\n\toff\tint64\n\tmsg\tstring\n\tval\tany\n}","func Open(name string) (*File, error)","func NewFile(r io.ReaderAt) (*File, error)","type FileHeader struct {\n\tMagic\tuint32\n\tCpu\tCpu\n\tSubCpu\tuint32\n\tType\tType\n\tNcmd\tuint32\n\tCmdsz\tuint32\n\tFlags\tuint32\n}","const Magic32 uint32 = 0xfeedface","const Magic64 uint32 = 0xfeedfacf","const MagicFat uint32 = 0xcafebabe","","const TypeObj Type = 1","const TypeExec Type = 2","const TypeDylib Type = 6","const TypeBundle Type = 8","","const Cpu386 Cpu = 7","const CpuAmd64 Cpu","const CpuArm Cpu = 12","const CpuArm64 Cpu","const CpuPpc Cpu = 18","const CpuPpc64 Cpu","","const LoadCmdSegment LoadCmd = 0x1","const LoadCmdSymtab LoadCmd = 0x2","const LoadCmdThread LoadCmd = 0x4","const LoadCmdUnixThread LoadCmd = 0x5","const LoadCmdDysymtab LoadCmd = 0xb","const LoadCmdDylib LoadCmd = 0xc","const LoadCmdDylinker LoadCmd = 0xf","const LoadCmdSegment64 LoadCmd = 0x19","const LoadCmdRpath LoadCmd = 0x8000001c","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","type (\n\t// A Segment32 is a 32-bit Mach-O segment load command.\n\tSegment32\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint32\n\t\tMemsz\tuint32\n\t\tOffset\tuint32\n\t\tFilesz\tuint32\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A Segment64 is a 64-bit Mach-O segment load command.\n\tSegment64\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tName\t[16]byte\n\t\tAddr\tuint64\n\t\tMemsz\tuint64\n\t\tOffset\tuint64\n\t\tFilesz\tuint64\n\t\tMaxprot\tuint32\n\t\tProt\tuint32\n\t\tNsect\tuint32\n\t\tFlag\tuint32\n\t}\n\n\t// A SymtabCmd is a Mach-O symbol table command.\n\tSymtabCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tSymoff\tuint32\n\t\tNsyms\tuint32\n\t\tStroff\tuint32\n\t\tStrsize\tuint32\n\t}\n\n\t// A DysymtabCmd is a Mach-O dynamic symbol table command.\n\tDysymtabCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tIlocalsym\tuint32\n\t\tNlocalsym\tuint32\n\t\tIextdefsym\tuint32\n\t\tNextdefsym\tuint32\n\t\tIundefsym\tuint32\n\t\tNundefsym\tuint32\n\t\tTocoffset\tuint32\n\t\tNtoc\t\tuint32\n\t\tModtaboff\tuint32\n\t\tNmodtab\t\tuint32\n\t\tExtrefsymoff\tuint32\n\t\tNextrefsyms\tuint32\n\t\tIndirectsymoff\tuint32\n\t\tNindirectsyms\tuint32\n\t\tExtreloff\tuint32\n\t\tNextrel\t\tuint32\n\t\tLocreloff\tuint32\n\t\tNlocrel\t\tuint32\n\t}\n\n\t// A DylibCmd is a Mach-O load dynamic library command.\n\tDylibCmd\tstruct {\n\t\tCmd\t\tLoadCmd\n\t\tLen\t\tuint32\n\t\tName\t\tuint32\n\t\tTime\t\tuint32\n\t\tCurrentVersion\tuint32\n\t\tCompatVersion\tuint32\n\t}\n\n\t// A RpathCmd is a Mach-O rpath command.\n\tRpathCmd\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tPath\tuint32\n\t}\n\n\t// A Thread is a Mach-O thread state command.\n\tThread\tstruct {\n\t\tCmd\tLoadCmd\n\t\tLen\tuint32\n\t\tType\tuint32\n\t\tData\t[]uint32\n\t}\n)","const FlagNoUndefs uint32 = 0x1","const FlagIncrLink uint32 = 0x2","const FlagDyldLink uint32 = 0x4","const FlagBindAtLoad uint32 = 0x8","const FlagPrebound uint32 = 0x10","const FlagSplitSegs uint32 = 0x20","const FlagLazyInit uint32 = 0x40","const FlagTwoLevel uint32 = 0x80","const FlagForceFlat uint32 = 0x100","const FlagNoMultiDefs uint32 = 0x200","const FlagNoFixPrebinding uint32 = 0x400","const FlagPrebindable uint32 = 0x800","const FlagAllModsBound uint32 = 0x1000","const FlagSubsectionsViaSymbols uint32 = 0x2000","const FlagCanonical uint32 = 0x4000","const FlagWeakDefines uint32 = 0x8000","const FlagBindsToWeak uint32 = 0x10000","const FlagAllowStackExecution uint32 = 0x20000","const FlagRootSafe uint32 = 0x40000","const FlagSetuidSafe uint32 = 0x80000","const FlagNoReexportedDylibs uint32 = 0x100000","const FlagPIE uint32 = 0x200000","const FlagDeadStrippableDylib uint32 = 0x400000","const FlagHasTLVDescriptors uint32 = 0x800000","const FlagNoHeapExecution uint32 = 0x1000000","const FlagAppExtensionSafe uint32 = 0x2000000","type Section32 struct {\n\tName\t\t[16]byte\n\tSeg\t\t[16]byte\n\tAddr\t\tuint32\n\tSize\t\tuint32\n\tOffset\t\tuint32\n\tAlign\t\tuint32\n\tReloff\t\tuint32\n\tNreloc\t\tuint32\n\tFlags\t\tuint32\n\tReserve1\tuint32\n\tReserve2\tuint32\n}","type Section64 struct {\n\tName\t\t[16]byte\n\tSeg\t\t[16]byte\n\tAddr\t\tuint64\n\tSize\t\tuint64\n\tOffset\t\tuint32\n\tAlign\t\tuint32\n\tReloff\t\tuint32\n\tNreloc\t\tuint32\n\tFlags\t\tuint32\n\tReserve1\tuint32\n\tReserve2\tuint32\n\tReserve3\tuint32\n}","type Nlist32 struct {\n\tName\tuint32\n\tType\tuint8\n\tSect\tuint8\n\tDesc\tuint16\n\tValue\tuint32\n}","type Nlist64 struct {\n\tName\tuint32\n\tType\tuint8\n\tSect\tuint8\n\tDesc\tuint16\n\tValue\tuint64\n}","type Regs386 struct {\n\tAX\tuint32\n\tBX\tuint32\n\tCX\tuint32\n\tDX\tuint32\n\tDI\tuint32\n\tSI\tuint32\n\tBP\tuint32\n\tSP\tuint32\n\tSS\tuint32\n\tFLAGS\tuint32\n\tIP\tuint32\n\tCS\tuint32\n\tDS\tuint32\n\tES\tuint32\n\tFS\tuint32\n\tGS\tuint32\n}","type RegsAMD64 struct {\n\tAX\tuint64\n\tBX\tuint64\n\tCX\tuint64\n\tDX\tuint64\n\tDI\tuint64\n\tSI\tuint64\n\tBP\tuint64\n\tSP\tuint64\n\tR8\tuint64\n\tR9\tuint64\n\tR10\tuint64\n\tR11\tuint64\n\tR12\tuint64\n\tR13\tuint64\n\tR14\tuint64\n\tR15\tuint64\n\tIP\tuint64\n\tFLAGS\tuint64\n\tCS\tuint64\n\tFS\tuint64\n\tGS\tuint64\n}","","const GENERIC_RELOC_VANILLA RelocTypeGeneric = 0","const GENERIC_RELOC_PAIR RelocTypeGeneric = 1","const GENERIC_RELOC_SECTDIFF RelocTypeGeneric = 2","const GENERIC_RELOC_PB_LA_PTR RelocTypeGeneric = 3","const GENERIC_RELOC_LOCAL_SECTDIFF RelocTypeGeneric = 4","const GENERIC_RELOC_TLV RelocTypeGeneric = 5","","const X86_64_RELOC_UNSIGNED RelocTypeX86_64 = 0","const X86_64_RELOC_SIGNED RelocTypeX86_64 = 1","const X86_64_RELOC_BRANCH RelocTypeX86_64 = 2","const X86_64_RELOC_GOT_LOAD RelocTypeX86_64 = 3","const X86_64_RELOC_GOT RelocTypeX86_64 = 4","const X86_64_RELOC_SUBTRACTOR RelocTypeX86_64 = 5","const X86_64_RELOC_SIGNED_1 RelocTypeX86_64 = 6","const X86_64_RELOC_SIGNED_2 RelocTypeX86_64 = 7","const X86_64_RELOC_SIGNED_4 RelocTypeX86_64 = 8","const X86_64_RELOC_TLV RelocTypeX86_64 = 9","","const ARM_RELOC_VANILLA RelocTypeARM = 0","const ARM_RELOC_PAIR RelocTypeARM = 1","const ARM_RELOC_SECTDIFF RelocTypeARM = 2","const ARM_RELOC_LOCAL_SECTDIFF RelocTypeARM = 3","const ARM_RELOC_PB_LA_PTR RelocTypeARM = 4","const ARM_RELOC_BR24 RelocTypeARM = 5","const ARM_THUMB_RELOC_BR22 RelocTypeARM = 6","const ARM_THUMB_32BIT_BRANCH RelocTypeARM = 7","const ARM_RELOC_HALF RelocTypeARM = 8","const ARM_RELOC_HALF_SECTDIFF RelocTypeARM = 9","","const ARM64_RELOC_UNSIGNED RelocTypeARM64 = 0","const ARM64_RELOC_SUBTRACTOR RelocTypeARM64 = 1","const ARM64_RELOC_BRANCH26 RelocTypeARM64 = 2","const ARM64_RELOC_PAGE21 RelocTypeARM64 = 3","const ARM64_RELOC_PAGEOFF12 RelocTypeARM64 = 4","const ARM64_RELOC_GOT_LOAD_PAGE21 RelocTypeARM64 = 5","const ARM64_RELOC_GOT_LOAD_PAGEOFF12 RelocTypeARM64 = 6","const ARM64_RELOC_POINTER_TO_GOT RelocTypeARM64 = 7","const ARM64_RELOC_TLVP_LOAD_PAGE21 RelocTypeARM64 = 8","const ARM64_RELOC_TLVP_LOAD_PAGEOFF12 RelocTypeARM64 = 9","const ARM64_RELOC_ADDEND RelocTypeARM64 = 10","type File struct {\n\tFileHeader\n\tOptionalHeader\tany\t// of type *OptionalHeader32 or *OptionalHeader64\n\tSections\t[]*Section\n\tSymbols\t\t[]*Symbol\t// COFF symbols with auxiliary symbol records removed\n\tCOFFSymbols\t[]COFFSymbol\t// all COFF symbols (including auxiliary symbol records)\n\tStringTable\tStringTable\n\n\tcloser\tio.Closer\n}","func Open(name string) (*File, error)","func NewFile(r io.ReaderAt) (*File, error)","type ImportDirectory struct {\n\tOriginalFirstThunk\tuint32\n\tTimeDateStamp\t\tuint32\n\tForwarderChain\t\tuint32\n\tName\t\t\tuint32\n\tFirstThunk\t\tuint32\n\n\tdll\tstring\n}","type FormatError struct {\n}","type FileHeader struct {\n\tMachine\t\t\tuint16\n\tNumberOfSections\tuint16\n\tTimeDateStamp\t\tuint32\n\tPointerToSymbolTable\tuint32\n\tNumberOfSymbols\t\tuint32\n\tSizeOfOptionalHeader\tuint16\n\tCharacteristics\t\tuint16\n}","type DataDirectory struct {\n\tVirtualAddress\tuint32\n\tSize\t\tuint32\n}","type OptionalHeader32 struct {\n\tMagic\t\t\t\tuint16\n\tMajorLinkerVersion\t\tuint8\n\tMinorLinkerVersion\t\tuint8\n\tSizeOfCode\t\t\tuint32\n\tSizeOfInitializedData\t\tuint32\n\tSizeOfUninitializedData\t\tuint32\n\tAddressOfEntryPoint\t\tuint32\n\tBaseOfCode\t\t\tuint32\n\tBaseOfData\t\t\tuint32\n\tImageBase\t\t\tuint32\n\tSectionAlignment\t\tuint32\n\tFileAlignment\t\t\tuint32\n\tMajorOperatingSystemVersion\tuint16\n\tMinorOperatingSystemVersion\tuint16\n\tMajorImageVersion\t\tuint16\n\tMinorImageVersion\t\tuint16\n\tMajorSubsystemVersion\t\tuint16\n\tMinorSubsystemVersion\t\tuint16\n\tWin32VersionValue\t\tuint32\n\tSizeOfImage\t\t\tuint32\n\tSizeOfHeaders\t\t\tuint32\n\tCheckSum\t\t\tuint32\n\tSubsystem\t\t\tuint16\n\tDllCharacteristics\t\tuint16\n\tSizeOfStackReserve\t\tuint32\n\tSizeOfStackCommit\t\tuint32\n\tSizeOfHeapReserve\t\tuint32\n\tSizeOfHeapCommit\t\tuint32\n\tLoaderFlags\t\t\tuint32\n\tNumberOfRvaAndSizes\t\tuint32\n\tDataDirectory\t\t\t[16]DataDirectory\n}","type OptionalHeader64 struct {\n\tMagic\t\t\t\tuint16\n\tMajorLinkerVersion\t\tuint8\n\tMinorLinkerVersion\t\tuint8\n\tSizeOfCode\t\t\tuint32\n\tSizeOfInitializedData\t\tuint32\n\tSizeOfUninitializedData\t\tuint32\n\tAddressOfEntryPoint\t\tuint32\n\tBaseOfCode\t\t\tuint32\n\tImageBase\t\t\tuint64\n\tSectionAlignment\t\tuint32\n\tFileAlignment\t\t\tuint32\n\tMajorOperatingSystemVersion\tuint16\n\tMinorOperatingSystemVersion\tuint16\n\tMajorImageVersion\t\tuint16\n\tMinorImageVersion\t\tuint16\n\tMajorSubsystemVersion\t\tuint16\n\tMinorSubsystemVersion\t\tuint16\n\tWin32VersionValue\t\tuint32\n\tSizeOfImage\t\t\tuint32\n\tSizeOfHeaders\t\t\tuint32\n\tCheckSum\t\t\tuint32\n\tSubsystem\t\t\tuint16\n\tDllCharacteristics\t\tuint16\n\tSizeOfStackReserve\t\tuint64\n\tSizeOfStackCommit\t\tuint64\n\tSizeOfHeapReserve\t\tuint64\n\tSizeOfHeapCommit\t\tuint64\n\tLoaderFlags\t\t\tuint32\n\tNumberOfRvaAndSizes\t\tuint32\n\tDataDirectory\t\t\t[16]DataDirectory\n}","const IMAGE_FILE_MACHINE_UNKNOWN = 0x0","const IMAGE_FILE_MACHINE_AM33 = 0x1d3","const IMAGE_FILE_MACHINE_AMD64 = 0x8664","const IMAGE_FILE_MACHINE_ARM = 0x1c0","const IMAGE_FILE_MACHINE_ARMNT = 0x1c4","const IMAGE_FILE_MACHINE_ARM64 = 0xaa64","const IMAGE_FILE_MACHINE_EBC = 0xebc","const IMAGE_FILE_MACHINE_I386 = 0x14c","const IMAGE_FILE_MACHINE_IA64 = 0x200","const IMAGE_FILE_MACHINE_LOONGARCH32 = 0x6232","const IMAGE_FILE_MACHINE_LOONGARCH64 = 0x6264","const IMAGE_FILE_MACHINE_M32R = 0x9041","const IMAGE_FILE_MACHINE_MIPS16 = 0x266","const IMAGE_FILE_MACHINE_MIPSFPU = 0x366","const IMAGE_FILE_MACHINE_MIPSFPU16 = 0x466","const IMAGE_FILE_MACHINE_POWERPC = 0x1f0","const IMAGE_FILE_MACHINE_POWERPCFP = 0x1f1","const IMAGE_FILE_MACHINE_R4000 = 0x166","const IMAGE_FILE_MACHINE_SH3 = 0x1a2","const IMAGE_FILE_MACHINE_SH3DSP = 0x1a3","const IMAGE_FILE_MACHINE_SH4 = 0x1a6","const IMAGE_FILE_MACHINE_SH5 = 0x1a8","const IMAGE_FILE_MACHINE_THUMB = 0x1c2","const IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x169","const IMAGE_FILE_MACHINE_RISCV32 = 0x5032","const IMAGE_FILE_MACHINE_RISCV64 = 0x5064","const IMAGE_FILE_MACHINE_RISCV128 = 0x5128","const IMAGE_DIRECTORY_ENTRY_EXPORT = 0","const IMAGE_DIRECTORY_ENTRY_IMPORT = 1","const IMAGE_DIRECTORY_ENTRY_RESOURCE = 2","const IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3","const IMAGE_DIRECTORY_ENTRY_SECURITY = 4","const IMAGE_DIRECTORY_ENTRY_BASERELOC = 5","const IMAGE_DIRECTORY_ENTRY_DEBUG = 6","const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7","const IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8","const IMAGE_DIRECTORY_ENTRY_TLS = 9","const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10","const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11","const IMAGE_DIRECTORY_ENTRY_IAT = 12","const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13","const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14","const IMAGE_FILE_RELOCS_STRIPPED = 0x0001","const IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002","const IMAGE_FILE_LINE_NUMS_STRIPPED = 0x0004","const IMAGE_FILE_LOCAL_SYMS_STRIPPED = 0x0008","const IMAGE_FILE_AGGRESIVE_WS_TRIM = 0x0010","const IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020","const IMAGE_FILE_BYTES_REVERSED_LO = 0x0080","const IMAGE_FILE_32BIT_MACHINE = 0x0100","const IMAGE_FILE_DEBUG_STRIPPED = 0x0200","const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400","const IMAGE_FILE_NET_RUN_FROM_SWAP = 0x0800","const IMAGE_FILE_SYSTEM = 0x1000","const IMAGE_FILE_DLL = 0x2000","const IMAGE_FILE_UP_SYSTEM_ONLY = 0x4000","const IMAGE_FILE_BYTES_REVERSED_HI = 0x8000","const IMAGE_SUBSYSTEM_UNKNOWN = 0","const IMAGE_SUBSYSTEM_NATIVE = 1","const IMAGE_SUBSYSTEM_WINDOWS_GUI = 2","const IMAGE_SUBSYSTEM_WINDOWS_CUI = 3","const IMAGE_SUBSYSTEM_OS2_CUI = 5","const IMAGE_SUBSYSTEM_POSIX_CUI = 7","const IMAGE_SUBSYSTEM_NATIVE_WINDOWS = 8","const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = 9","const IMAGE_SUBSYSTEM_EFI_APPLICATION = 10","const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11","const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = 12","const IMAGE_SUBSYSTEM_EFI_ROM = 13","const IMAGE_SUBSYSTEM_XBOX = 14","const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16","const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = 0x0020","const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040","const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = 0x0080","const IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100","const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = 0x0200","const IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400","const IMAGE_DLLCHARACTERISTICS_NO_BIND = 0x0800","const IMAGE_DLLCHARACTERISTICS_APPCONTAINER = 0x1000","const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = 0x2000","const IMAGE_DLLCHARACTERISTICS_GUARD_CF = 0x4000","const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000","type SectionHeader32 struct {\n\tName\t\t\t[8]uint8\n\tVirtualSize\t\tuint32\n\tVirtualAddress\t\tuint32\n\tSizeOfRawData\t\tuint32\n\tPointerToRawData\tuint32\n\tPointerToRelocations\tuint32\n\tPointerToLineNumbers\tuint32\n\tNumberOfRelocations\tuint16\n\tNumberOfLineNumbers\tuint16\n\tCharacteristics\t\tuint32\n}","type Reloc struct {\n\tVirtualAddress\t\tuint32\n\tSymbolTableIndex\tuint32\n\tType\t\t\tuint16\n}","type SectionHeader struct {\n\tName\t\t\tstring\n\tVirtualSize\t\tuint32\n\tVirtualAddress\t\tuint32\n\tSize\t\t\tuint32\n\tOffset\t\t\tuint32\n\tPointerToRelocations\tuint32\n\tPointerToLineNumbers\tuint32\n\tNumberOfRelocations\tuint16\n\tNumberOfLineNumbers\tuint16\n\tCharacteristics\t\tuint32\n}","type Section struct {\n\tSectionHeader\n\tRelocs\t[]Reloc\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\tsr\t*io.SectionReader\n}","const IMAGE_SCN_CNT_CODE = 0x00000020","const IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040","const IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080","const IMAGE_SCN_LNK_COMDAT = 0x00001000","const IMAGE_SCN_MEM_DISCARDABLE = 0x02000000","const IMAGE_SCN_MEM_EXECUTE = 0x20000000","const IMAGE_SCN_MEM_READ = 0x40000000","const IMAGE_SCN_MEM_WRITE = 0x80000000","type StringTable []byte","const COFFSymbolSize = 18","type COFFSymbol struct {\n\tName\t\t\t[8]uint8\n\tValue\t\t\tuint32\n\tSectionNumber\t\tint16\n\tType\t\t\tuint16\n\tStorageClass\t\tuint8\n\tNumberOfAuxSymbols\tuint8\n}","type Symbol struct {\n\tName\t\tstring\n\tValue\t\tuint32\n\tSectionNumber\tint16\n\tType\t\tuint16\n\tStorageClass\tuint8\n}","type COFFSymbolAuxFormat5 struct {\n\tSize\t\tuint32\n\tNumRelocs\tuint16\n\tNumLineNumbers\tuint16\n\tChecksum\tuint32\n\tSecNum\t\tuint16\n\tSelection\tuint8\n\t_\t\t[3]uint8\t// padding\n}","const IMAGE_COMDAT_SELECT_NODUPLICATES = 1","const IMAGE_COMDAT_SELECT_ANY = 2","const IMAGE_COMDAT_SELECT_SAME_SIZE = 3","const IMAGE_COMDAT_SELECT_EXACT_MATCH = 4","const IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5","const IMAGE_COMDAT_SELECT_LARGEST = 6","type FileHeader struct {\n\tMagic\t\tuint32\n\tBss\t\tuint32\n\tEntry\t\tuint64\n\tPtrSize\t\tint\n\tLoadAddress\tuint64\n\tHdrSize\t\tuint64\n}","type File struct {\n\tFileHeader\n\tSections\t[]*Section\n\tcloser\t\tio.Closer\n}","type SectionHeader struct {\n\tName\tstring\n\tSize\tuint32\n\tOffset\tuint32\n}","type Section struct {\n\tSectionHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\tsr\t*io.SectionReader\n}","type Sym struct {\n\tValue\tuint64\n\tType\trune\n\tName\tstring\n}","func Open(name string) (*File, error)","func NewFile(r io.ReaderAt) (*File, error)","","const Magic64 = 0x8000","","","","func Encode(dst, src []byte) int","func MaxEncodedLen(n int) int","func NewEncoder(w io.Writer) io.WriteCloser","","func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error)","func NewDecoder(r io.Reader) io.Reader","type StructuralError struct {\n\tMsg string\n}","type SyntaxError struct {\n\tMsg string\n}","type BitString struct {\n\tBytes\t\t[]byte\t// bits packed into bytes.\n\tBitLength\tint\t// length in bits.\n}","","","type ObjectIdentifier []int","","","type RawValue struct {\n\tClass, Tag\tint\n\tIsCompound\tbool\n\tBytes\t\t[]byte\n\tFullBytes\t[]byte\t// includes the tag and length\n}","type RawContent []byte","func Unmarshal(b []byte, val any) (rest []byte, err error)","func UnmarshalWithParams(b []byte, val any, params string) (rest []byte, err error)","const TagBoolean = 1","const TagInteger = 2","const TagBitString = 3","const TagOctetString = 4","const TagNull = 5","const TagOID = 6","const TagEnum = 10","const TagUTF8String = 12","const TagSequence = 16","const TagSet = 17","const TagNumericString = 18","const TagPrintableString = 19","const TagT61String = 20","const TagIA5String = 22","const TagUTCTime = 23","const TagGeneralizedTime = 24","const TagGeneralString = 27","const TagBMPString = 30","const ClassUniversal = 0","const ClassApplication = 1","const ClassContextSpecific = 2","const ClassPrivate = 3","func Marshal(val any) ([]byte, error)","func MarshalWithParams(val any, params string) ([]byte, error)","type Encoding struct {\n\tencode\t\t[32]byte\t// mapping of symbol index to symbol byte value\n\tdecodeMap\t[256]uint8\t// mapping of symbol byte value to symbol index\n\tpadChar\t\trune\n}","const StdPadding rune = '='","const NoPadding rune","func NewEncoding(encoder string) *Encoding","","","func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser","","func NewDecoder(enc *Encoding, r io.Reader) io.Reader","type Encoding struct {\n\tencode\t\t[64]byte\t// mapping of symbol index to symbol byte value\n\tdecodeMap\t[256]uint8\t// mapping of symbol byte value to symbol index\n\tpadChar\t\trune\n\tstrict\t\tbool\n}","const StdPadding rune = '='","const NoPadding rune","func NewEncoding(encoder string) *Encoding","","","","","func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser","","func NewDecoder(enc *Encoding, r io.Reader) io.Reader","type ByteOrder interface {\n\tUint16([]byte) uint16\n\tUint32([]byte) uint32\n\tUint64([]byte) uint64\n\tPutUint16([]byte, uint16)\n\tPutUint32([]byte, uint32)\n\tPutUint64([]byte, uint64)\n\tString() string\n}","type AppendByteOrder interface {\n\tAppendUint16([]byte, uint16) []byte\n\tAppendUint32([]byte, uint32) []byte\n\tAppendUint64([]byte, uint64) []byte\n\tString() string\n}","var LittleEndian littleEndian","var BigEndian bigEndian","func Read(r io.Reader, order ByteOrder, data any) error","func Decode(buf []byte, order ByteOrder, data any) (int, error)","func Write(w io.Writer, order ByteOrder, data any) error","func Encode(buf []byte, order ByteOrder, data any) (int, error)","func Append(buf []byte, order ByteOrder, data any) ([]byte, error)","func Size(v any) int","var NativeEndian nativeEndian","const MaxVarintLen16 = 3","const MaxVarintLen32 = 5","const MaxVarintLen64 = 10","func AppendUvarint(buf []byte, x uint64) []byte","func PutUvarint(buf []byte, x uint64) int","func Uvarint(buf []byte) (uint64, int)","func AppendVarint(buf []byte, x int64) []byte","func PutVarint(buf []byte, x int64) int","func Varint(buf []byte) (int64, int)","func ReadUvarint(r io.ByteReader) (uint64, error)","func ReadVarint(r io.ByteReader) (int64, error)","type ParseError struct {\n\tStartLine\tint\t// Line where the record starts\n\tLine\t\tint\t// Line where the error occurred\n\tColumn\t\tint\t// Column (1-based byte index) where the error occurred\n\tErr\t\terror\t// The actual error\n}","","","","","type Reader struct {\n\t// Comma is the field delimiter.\n\t// It is set to comma (',') by NewReader.\n\t// Comma must be a valid rune and must not be \\r, \\n,\n\t// or the Unicode replacement character (0xFFFD).\n\tComma\trune\n\n\t// Comment, if not 0, is the comment character. Lines beginning with the\n\t// Comment character without preceding whitespace are ignored.\n\t// With leading whitespace the Comment character becomes part of the\n\t// field, even if TrimLeadingSpace is true.\n\t// Comment must be a valid rune and must not be \\r, \\n,\n\t// or the Unicode replacement character (0xFFFD).\n\t// It must also not be equal to Comma.\n\tComment\trune\n\n\t// FieldsPerRecord is the number of expected fields per record.\n\t// If FieldsPerRecord is positive, Read requires each record to\n\t// have the given number of fields. If FieldsPerRecord is 0, Read sets it to\n\t// the number of fields in the first record, so that future records must\n\t// have the same field count. If FieldsPerRecord is negative, no check is\n\t// made and records may have a variable number of fields.\n\tFieldsPerRecord\tint\n\n\t// If LazyQuotes is true, a quote may appear in an unquoted field and a\n\t// non-doubled quote may appear in a quoted field.\n\tLazyQuotes\tbool\n\n\t// If TrimLeadingSpace is true, leading white space in a field is ignored.\n\t// This is done even if the field delimiter, Comma, is white space.\n\tTrimLeadingSpace\tbool\n\n\t// ReuseRecord controls whether calls to Read may return a slice sharing\n\t// the backing array of the previous call's returned slice for performance.\n\t// By default, each call to Read returns newly allocated memory owned by the caller.\n\tReuseRecord\tbool\n\n\t// Deprecated: TrailingComma is no longer used.\n\tTrailingComma\tbool\n\n\tr\t*bufio.Reader\n\n\t// numLine is the current line being read in the CSV file.\n\tnumLine\tint\n\n\t// offset is the input stream byte offset of the current reader position.\n\toffset\tint64\n\n\t// rawBuffer is a line buffer only used by the readLine method.\n\trawBuffer\t[]byte\n\n\t// recordBuffer holds the unescaped fields, one after another.\n\t// The fields can be accessed by using the indexes in fieldIndexes.\n\t// E.g., For the row `a,\"b\",\"c\"\"d\",e`, recordBuffer will contain `abc\"de`\n\t// and fieldIndexes will contain the indexes [1, 2, 5, 6].\n\trecordBuffer\t[]byte\n\n\t// fieldIndexes is an index of fields inside recordBuffer.\n\t// The i'th field ends at offset fieldIndexes[i] in recordBuffer.\n\tfieldIndexes\t[]int\n\n\t// fieldPositions is an index of field positions for the\n\t// last record returned by Read.\n\tfieldPositions\t[]position\n\n\t// lastRecord is a record cache and only used when ReuseRecord == true.\n\tlastRecord\t[]string\n}","func NewReader(r io.Reader) *Reader","type Writer struct {\n\tComma\trune\t// Field delimiter (set to ',' by NewWriter)\n\tUseCRLF\tbool\t// True to use \\r\\n as the line terminator\n\tw\t*bufio.Writer\n}","func NewWriter(w io.Writer) *Writer","type Decoder struct {\n\tmutex\t\tsync.Mutex\t\t\t\t// each item must be received atomically\n\tr\t\tio.Reader\t\t\t\t// source of the data\n\tbuf\t\tdecBuffer\t\t\t\t// buffer for more efficient i/o from r\n\twireType\tmap[typeId]*wireType\t\t\t// map from remote ID to local description\n\tdecoderCache\tmap[reflect.Type]map[typeId]**decEngine\t// cache of compiled engines\n\tignorerCache\tmap[typeId]**decEngine\t\t\t// ditto for ignored objects\n\tfreeList\t*decoderState\t\t\t\t// list of free decoderStates; avoids reallocation\n\tcountBuf\t[]byte\t\t\t\t\t// used for decoding integers while parsing messages\n\terr\t\terror\n\t// ignoreDepth tracks the depth of recursively parsed ignored fields\n\tignoreDepth\tint\n}","func NewDecoder(r io.Reader) *Decoder","type Encoder struct {\n\tmutex\t\tsync.Mutex\t\t// each item must be sent atomically\n\tw\t\t[]io.Writer\t\t// where to send the data\n\tsent\t\tmap[reflect.Type]typeId\t// which types we've already sent\n\tcountState\t*encoderState\t\t// stage for writing counts\n\tfreeList\t*encoderState\t\t// list of free encoderStates; avoids reallocation\n\tbyteBuf\t\tencBuffer\t\t// buffer for top-level encoderState\n\terr\t\terror\n}","func NewEncoder(w io.Writer) *Encoder","type CommonType struct {\n\tName\tstring\n\tId\ttypeId\n}","type GobEncoder interface {\n\t// GobEncode returns a byte slice representing the encoding of the\n\t// receiver for transmission to a GobDecoder, usually of the same\n\t// concrete type.\n\tGobEncode() ([]byte, error)\n}","type GobDecoder interface {\n\t// GobDecode overwrites the receiver, which must be a pointer,\n\t// with the value represented by the byte slice, which was written\n\t// by GobEncode, usually for the same concrete type.\n\tGobDecode([]byte) error\n}","func RegisterName(name string, value any)","func Register(value any)","func EncodedLen(n int) int","func Encode(dst, src []byte) int","func AppendEncode(dst, src []byte) []byte","","","func DecodedLen(x int) int","func Decode(dst, src []byte) (int, error)","func AppendDecode(dst, src []byte) ([]byte, error)","func EncodeToString(src []byte) string","func DecodeString(s string) ([]byte, error)","func Dump(data []byte) string","func NewEncoder(w io.Writer) io.Writer","func NewDecoder(r io.Reader) io.Reader","func Dumper(w io.Writer) io.WriteCloser","func Unmarshal(data []byte, v any) error","type Unmarshaler interface {\n\tUnmarshalJSON([]byte) error\n}","type UnmarshalTypeError struct {\n\tValue\tstring\t\t// description of JSON value - \"bool\", \"array\", \"number -5\"\n\tType\treflect.Type\t// type of Go value it could not be assigned to\n\tOffset\tint64\t\t// error occurred after reading Offset bytes\n\tStruct\tstring\t\t// name of the struct type containing the field\n\tField\tstring\t\t// the full path from root node to the field\n}","type UnmarshalFieldError struct {\n\tKey\tstring\n\tType\treflect.Type\n\tField\treflect.StructField\n}","type InvalidUnmarshalError struct {\n\tType reflect.Type\n}","","func Marshal(v any) ([]byte, error)","func MarshalIndent(v any, prefix, indent string) ([]byte, error)","type Marshaler interface {\n\tMarshalJSON() ([]byte, error)\n}","type UnsupportedTypeError struct {\n\tType reflect.Type\n}","type UnsupportedValueError struct {\n\tValue\treflect.Value\n\tStr\tstring\n}","type InvalidUTF8Error struct {\n\tS string\t// the whole string value that caused the error\n}","type MarshalerError struct {\n\tType\t\treflect.Type\n\tErr\t\terror\n\tsourceFunc\tstring\n}","func HTMLEscape(dst *bytes.Buffer, src []byte)","func Compact(dst *bytes.Buffer, src []byte) error","func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error","func Valid(data []byte) bool","type SyntaxError struct {\n\tmsg\tstring\t// description of error\n\tOffset\tint64\t// error occurred after reading Offset bytes\n}","type Decoder struct {\n\tr\tio.Reader\n\tbuf\t[]byte\n\td\tdecodeState\n\tscanp\tint\t// start of unread data in buf\n\tscanned\tint64\t// amount of data already scanned\n\tscan\tscanner\n\terr\terror\n\n\ttokenState\tint\n\ttokenStack\t[]int\n}","func NewDecoder(r io.Reader) *Decoder","type Encoder struct {\n\tw\t\tio.Writer\n\terr\t\terror\n\tescapeHTML\tbool\n\n\tindentBuf\t[]byte\n\tindentPrefix\tstring\n\tindentValue\tstring\n}","func NewEncoder(w io.Writer) *Encoder","type RawMessage []byte","","","type Block struct {\n\tType\tstring\t\t\t// The type, taken from the preamble (i.e. \"RSA PRIVATE KEY\").\n\tHeaders\tmap[string]string\t// Optional headers.\n\tBytes\t[]byte\t\t\t// The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\n}","func Decode(data []byte) (p *Block, rest []byte)","func Encode(out io.Writer, b *Block) error","func EncodeToMemory(b *Block) []byte","","func Marshal(v any) ([]byte, error)","type Marshaler interface {\n\tMarshalXML(e *Encoder, start StartElement) error\n}","type MarshalerAttr interface {\n\tMarshalXMLAttr(name Name) (Attr, error)\n}","func MarshalIndent(v any, prefix, indent string) ([]byte, error)","type Encoder struct {\n\tp printer\n}","func NewEncoder(w io.Writer) *Encoder","type UnsupportedTypeError struct {\n\tType reflect.Type\n}","func Unmarshal(data []byte, v any) error","","type Unmarshaler interface {\n\tUnmarshalXML(d *Decoder, start StartElement) error\n}","type UnmarshalerAttr interface {\n\tUnmarshalXMLAttr(attr Attr) error\n}","type TagPathError struct {\n\tStruct\t\treflect.Type\n\tField1, Tag1\tstring\n\tField2, Tag2\tstring\n}","type SyntaxError struct {\n\tMsg\tstring\n\tLine\tint\n}","type Name struct {\n\tSpace, Local string\n}","type Attr struct {\n\tName\tName\n\tValue\tstring\n}","","type StartElement struct {\n\tName\tName\n\tAttr\t[]Attr\n}","type EndElement struct {\n\tName Name\n}","type CharData []byte","type Comment []byte","type ProcInst struct {\n\tTarget\tstring\n\tInst\t[]byte\n}","type Directive []byte","func CopyToken(t Token) Token","type TokenReader interface {\n\tToken() (Token, error)\n}","type Decoder struct {\n\t// Strict defaults to true, enforcing the requirements\n\t// of the XML specification.\n\t// If set to false, the parser allows input containing common\n\t// mistakes:\n\t//\t* If an element is missing an end tag, the parser invents\n\t//\t  end tags as necessary to keep the return values from Token\n\t//\t  properly balanced.\n\t//\t* In attribute values and character data, unknown or malformed\n\t//\t  character entities (sequences beginning with \u0026) are left alone.\n\t//\n\t// Setting:\n\t//\n\t//\td.Strict = false\n\t//\td.AutoClose = xml.HTMLAutoClose\n\t//\td.Entity = xml.HTMLEntity\n\t//\n\t// creates a parser that can handle typical HTML.\n\t//\n\t// Strict mode does not enforce the requirements of the XML name spaces TR.\n\t// In particular it does not reject name space tags using undefined prefixes.\n\t// Such tags are recorded with the unknown prefix as the name space URL.\n\tStrict\tbool\n\n\t// When Strict == false, AutoClose indicates a set of elements to\n\t// consider closed immediately after they are opened, regardless\n\t// of whether an end element is present.\n\tAutoClose\t[]string\n\n\t// Entity can be used to map non-standard entity names to string replacements.\n\t// The parser behaves as if these standard mappings are present in the map,\n\t// regardless of the actual map content:\n\t//\n\t//\t\"lt\": \"\u003c\",\n\t//\t\"gt\": \"\u003e\",\n\t//\t\"amp\": \"\u0026\",\n\t//\t\"apos\": \"'\",\n\t//\t\"quot\": `\"`,\n\tEntity\tmap[string]string\n\n\t// CharsetReader, if non-nil, defines a function to generate\n\t// charset-conversion readers, converting from the provided\n\t// non-UTF-8 charset into UTF-8. If CharsetReader is nil or\n\t// returns an error, parsing stops with an error. One of the\n\t// CharsetReader's result values must be non-nil.\n\tCharsetReader\tfunc(charset string, input io.Reader) (io.Reader, error)\n\n\t// DefaultSpace sets the default name space used for unadorned tags,\n\t// as if the entire XML stream were wrapped in an element containing\n\t// the attribute xmlns=\"DefaultSpace\".\n\tDefaultSpace\tstring\n\n\tr\t\tio.ByteReader\n\tt\t\tTokenReader\n\tbuf\t\tbytes.Buffer\n\tsaved\t\t*bytes.Buffer\n\tstk\t\t*stack\n\tfree\t\t*stack\n\tneedClose\tbool\n\ttoClose\t\tName\n\tnextToken\tToken\n\tnextByte\tint\n\tns\t\tmap[string]string\n\terr\t\terror\n\tline\t\tint\n\tlinestart\tint64\n\toffset\t\tint64\n\tunmarshalDepth\tint\n}","func NewDecoder(r io.Reader) *Decoder","func NewTokenDecoder(t TokenReader) *Decoder","var HTMLEntity map[string]string","var HTMLAutoClose []string","func EscapeText(w io.Writer, s []byte) error","func Escape(w io.Writer, s []byte)","type Node interface {\n\tPos() token.Pos\t// position of first character belonging to the node\n\tEnd() token.Pos\t// position of first character immediately after the node\n}","type Expr interface {\n\tNode\n\texprNode()\n}","type Stmt interface {\n\tNode\n\tstmtNode()\n}","type Decl interface {\n\tNode\n\tdeclNode()\n}","type Comment struct {\n\tSlash\ttoken.Pos\t// position of \"/\" starting the comment\n\tText\tstring\t\t// comment text (excluding '\\n' for //-style comments)\n}","type CommentGroup struct {\n\tList []*Comment\t// len(List) \u003e 0\n}","type Field struct {\n\tDoc\t*CommentGroup\t// associated documentation; or nil\n\tNames\t[]*Ident\t// field/method/(type) parameter names; or nil\n\tType\tExpr\t\t// field/method/parameter type; or nil\n\tTag\t*BasicLit\t// field tag; or nil\n\tComment\t*CommentGroup\t// line comments; or nil\n}","type FieldList struct {\n\tOpening\ttoken.Pos\t// position of opening parenthesis/brace/bracket, if any\n\tList\t[]*Field\t// field list; or nil\n\tClosing\ttoken.Pos\t// position of closing parenthesis/brace/bracket, if any\n}","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","type (\n\t// A BadExpr node is a placeholder for an expression containing\n\t// syntax errors for which a correct expression node cannot be\n\t// created.\n\t//\n\tBadExpr\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad expression\n\t}\n\n\t// An Ident node represents an identifier.\n\tIdent\tstruct {\n\t\tNamePos\ttoken.Pos\t// identifier position\n\t\tName\tstring\t\t// identifier name\n\t\tObj\t*Object\t\t// denoted object, or nil. Deprecated: see Object.\n\t}\n\n\t// An Ellipsis node stands for the \"...\" type in a\n\t// parameter list or the \"...\" length in an array type.\n\t//\n\tEllipsis\tstruct {\n\t\tEllipsis\ttoken.Pos\t// position of \"...\"\n\t\tElt\t\tExpr\t\t// ellipsis element type (parameter lists only); or nil\n\t}\n\n\t// A BasicLit node represents a literal of basic type.\n\tBasicLit\tstruct {\n\t\tValuePos\ttoken.Pos\t// literal position\n\t\tKind\t\ttoken.Token\t// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\t\tValue\t\tstring\t\t// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n\t}\n\n\t// A FuncLit node represents a function literal.\n\tFuncLit\tstruct {\n\t\tType\t*FuncType\t// function type\n\t\tBody\t*BlockStmt\t// function body\n\t}\n\n\t// A CompositeLit node represents a composite literal.\n\tCompositeLit\tstruct {\n\t\tType\t\tExpr\t\t// literal type; or nil\n\t\tLbrace\t\ttoken.Pos\t// position of \"{\"\n\t\tElts\t\t[]Expr\t\t// list of composite elements; or nil\n\t\tRbrace\t\ttoken.Pos\t// position of \"}\"\n\t\tIncomplete\tbool\t\t// true if (source) expressions are missing in the Elts list\n\t}\n\n\t// A ParenExpr node represents a parenthesized expression.\n\tParenExpr\tstruct {\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tX\tExpr\t\t// parenthesized expression\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A SelectorExpr node represents an expression followed by a selector.\n\tSelectorExpr\tstruct {\n\t\tX\tExpr\t// expression\n\t\tSel\t*Ident\t// field selector\n\t}\n\n\t// An IndexExpr node represents an expression followed by an index.\n\tIndexExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndex\tExpr\t\t// index expression\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// An IndexListExpr node represents an expression followed by multiple\n\t// indices.\n\tIndexListExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tIndices\t[]Expr\t\t// index expressions\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A SliceExpr node represents an expression followed by slice indices.\n\tSliceExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLow\tExpr\t\t// begin of slice range; or nil\n\t\tHigh\tExpr\t\t// end of slice range; or nil\n\t\tMax\tExpr\t\t// maximum capacity of slice; or nil\n\t\tSlice3\tbool\t\t// true if 3-index slice (2 colons present)\n\t\tRbrack\ttoken.Pos\t// position of \"]\"\n\t}\n\n\t// A TypeAssertExpr node represents an expression followed by a\n\t// type assertion.\n\t//\n\tTypeAssertExpr\tstruct {\n\t\tX\tExpr\t\t// expression\n\t\tLparen\ttoken.Pos\t// position of \"(\"\n\t\tType\tExpr\t\t// asserted type; nil means type switch X.(type)\n\t\tRparen\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A CallExpr node represents an expression followed by an argument list.\n\tCallExpr\tstruct {\n\t\tFun\t\tExpr\t\t// function expression\n\t\tLparen\t\ttoken.Pos\t// position of \"(\"\n\t\tArgs\t\t[]Expr\t\t// function arguments; or nil\n\t\tEllipsis\ttoken.Pos\t// position of \"...\" (token.NoPos if there is no \"...\")\n\t\tRparen\t\ttoken.Pos\t// position of \")\"\n\t}\n\n\t// A StarExpr node represents an expression of the form \"*\" Expression.\n\t// Semantically it could be a unary \"*\" expression, or a pointer type.\n\t//\n\tStarExpr\tstruct {\n\t\tStar\ttoken.Pos\t// position of \"*\"\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A UnaryExpr node represents a unary expression.\n\t// Unary \"*\" expressions are represented via StarExpr nodes.\n\t//\n\tUnaryExpr\tstruct {\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tX\tExpr\t\t// operand\n\t}\n\n\t// A BinaryExpr node represents a binary expression.\n\tBinaryExpr\tstruct {\n\t\tX\tExpr\t\t// left operand\n\t\tOpPos\ttoken.Pos\t// position of Op\n\t\tOp\ttoken.Token\t// operator\n\t\tY\tExpr\t\t// right operand\n\t}\n\n\t// A KeyValueExpr node represents (key : value) pairs\n\t// in composite literals.\n\t//\n\tKeyValueExpr\tstruct {\n\t\tKey\tExpr\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tValue\tExpr\n\t}\n)","","const SEND ChanDir","const RECV","type (\n\t// An ArrayType node represents an array or slice type.\n\tArrayType\tstruct {\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLen\tExpr\t\t// Ellipsis node for [...]T array types, nil for slice types\n\t\tElt\tExpr\t\t// element type\n\t}\n\n\t// A StructType node represents a struct type.\n\tStructType\tstruct {\n\t\tStruct\t\ttoken.Pos\t// position of \"struct\" keyword\n\t\tFields\t\t*FieldList\t// list of field declarations\n\t\tIncomplete\tbool\t\t// true if (source) fields are missing in the Fields list\n\t}\n\n\t// A FuncType node represents a function type.\n\tFuncType\tstruct {\n\t\tFunc\t\ttoken.Pos\t// position of \"func\" keyword (token.NoPos if there is no \"func\")\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tParams\t\t*FieldList\t// (incoming) parameters; non-nil\n\t\tResults\t\t*FieldList\t// (outgoing) results; or nil\n\t}\n\n\t// An InterfaceType node represents an interface type.\n\tInterfaceType\tstruct {\n\t\tInterface\ttoken.Pos\t// position of \"interface\" keyword\n\t\tMethods\t\t*FieldList\t// list of embedded interfaces, methods, or types\n\t\tIncomplete\tbool\t\t// true if (source) methods or types are missing in the Methods list\n\t}\n\n\t// A MapType node represents a map type.\n\tMapType\tstruct {\n\t\tMap\ttoken.Pos\t// position of \"map\" keyword\n\t\tKey\tExpr\n\t\tValue\tExpr\n\t}\n\n\t// A ChanType node represents a channel type.\n\tChanType\tstruct {\n\t\tBegin\ttoken.Pos\t// position of \"chan\" keyword or \"\u003c-\" (whichever comes first)\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\" (token.NoPos if there is no \"\u003c-\")\n\t\tDir\tChanDir\t\t// channel direction\n\t\tValue\tExpr\t\t// value type\n\t}\n)","type (\n\t// An ArrayType node represents an array or slice type.\n\tArrayType\tstruct {\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLen\tExpr\t\t// Ellipsis node for [...]T array types, nil for slice types\n\t\tElt\tExpr\t\t// element type\n\t}\n\n\t// A StructType node represents a struct type.\n\tStructType\tstruct {\n\t\tStruct\t\ttoken.Pos\t// position of \"struct\" keyword\n\t\tFields\t\t*FieldList\t// list of field declarations\n\t\tIncomplete\tbool\t\t// true if (source) fields are missing in the Fields list\n\t}\n\n\t// A FuncType node represents a function type.\n\tFuncType\tstruct {\n\t\tFunc\t\ttoken.Pos\t// position of \"func\" keyword (token.NoPos if there is no \"func\")\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tParams\t\t*FieldList\t// (incoming) parameters; non-nil\n\t\tResults\t\t*FieldList\t// (outgoing) results; or nil\n\t}\n\n\t// An InterfaceType node represents an interface type.\n\tInterfaceType\tstruct {\n\t\tInterface\ttoken.Pos\t// position of \"interface\" keyword\n\t\tMethods\t\t*FieldList\t// list of embedded interfaces, methods, or types\n\t\tIncomplete\tbool\t\t// true if (source) methods or types are missing in the Methods list\n\t}\n\n\t// A MapType node represents a map type.\n\tMapType\tstruct {\n\t\tMap\ttoken.Pos\t// position of \"map\" keyword\n\t\tKey\tExpr\n\t\tValue\tExpr\n\t}\n\n\t// A ChanType node represents a channel type.\n\tChanType\tstruct {\n\t\tBegin\ttoken.Pos\t// position of \"chan\" keyword or \"\u003c-\" (whichever comes first)\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\" (token.NoPos if there is no \"\u003c-\")\n\t\tDir\tChanDir\t\t// channel direction\n\t\tValue\tExpr\t\t// value type\n\t}\n)","type (\n\t// An ArrayType node represents an array or slice type.\n\tArrayType\tstruct {\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLen\tExpr\t\t// Ellipsis node for [...]T array types, nil for slice types\n\t\tElt\tExpr\t\t// element type\n\t}\n\n\t// A StructType node represents a struct type.\n\tStructType\tstruct {\n\t\tStruct\t\ttoken.Pos\t// position of \"struct\" keyword\n\t\tFields\t\t*FieldList\t// list of field declarations\n\t\tIncomplete\tbool\t\t// true if (source) fields are missing in the Fields list\n\t}\n\n\t// A FuncType node represents a function type.\n\tFuncType\tstruct {\n\t\tFunc\t\ttoken.Pos\t// position of \"func\" keyword (token.NoPos if there is no \"func\")\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tParams\t\t*FieldList\t// (incoming) parameters; non-nil\n\t\tResults\t\t*FieldList\t// (outgoing) results; or nil\n\t}\n\n\t// An InterfaceType node represents an interface type.\n\tInterfaceType\tstruct {\n\t\tInterface\ttoken.Pos\t// position of \"interface\" keyword\n\t\tMethods\t\t*FieldList\t// list of embedded interfaces, methods, or types\n\t\tIncomplete\tbool\t\t// true if (source) methods or types are missing in the Methods list\n\t}\n\n\t// A MapType node represents a map type.\n\tMapType\tstruct {\n\t\tMap\ttoken.Pos\t// position of \"map\" keyword\n\t\tKey\tExpr\n\t\tValue\tExpr\n\t}\n\n\t// A ChanType node represents a channel type.\n\tChanType\tstruct {\n\t\tBegin\ttoken.Pos\t// position of \"chan\" keyword or \"\u003c-\" (whichever comes first)\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\" (token.NoPos if there is no \"\u003c-\")\n\t\tDir\tChanDir\t\t// channel direction\n\t\tValue\tExpr\t\t// value type\n\t}\n)","type (\n\t// An ArrayType node represents an array or slice type.\n\tArrayType\tstruct {\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLen\tExpr\t\t// Ellipsis node for [...]T array types, nil for slice types\n\t\tElt\tExpr\t\t// element type\n\t}\n\n\t// A StructType node represents a struct type.\n\tStructType\tstruct {\n\t\tStruct\t\ttoken.Pos\t// position of \"struct\" keyword\n\t\tFields\t\t*FieldList\t// list of field declarations\n\t\tIncomplete\tbool\t\t// true if (source) fields are missing in the Fields list\n\t}\n\n\t// A FuncType node represents a function type.\n\tFuncType\tstruct {\n\t\tFunc\t\ttoken.Pos\t// position of \"func\" keyword (token.NoPos if there is no \"func\")\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tParams\t\t*FieldList\t// (incoming) parameters; non-nil\n\t\tResults\t\t*FieldList\t// (outgoing) results; or nil\n\t}\n\n\t// An InterfaceType node represents an interface type.\n\tInterfaceType\tstruct {\n\t\tInterface\ttoken.Pos\t// position of \"interface\" keyword\n\t\tMethods\t\t*FieldList\t// list of embedded interfaces, methods, or types\n\t\tIncomplete\tbool\t\t// true if (source) methods or types are missing in the Methods list\n\t}\n\n\t// A MapType node represents a map type.\n\tMapType\tstruct {\n\t\tMap\ttoken.Pos\t// position of \"map\" keyword\n\t\tKey\tExpr\n\t\tValue\tExpr\n\t}\n\n\t// A ChanType node represents a channel type.\n\tChanType\tstruct {\n\t\tBegin\ttoken.Pos\t// position of \"chan\" keyword or \"\u003c-\" (whichever comes first)\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\" (token.NoPos if there is no \"\u003c-\")\n\t\tDir\tChanDir\t\t// channel direction\n\t\tValue\tExpr\t\t// value type\n\t}\n)","type (\n\t// An ArrayType node represents an array or slice type.\n\tArrayType\tstruct {\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLen\tExpr\t\t// Ellipsis node for [...]T array types, nil for slice types\n\t\tElt\tExpr\t\t// element type\n\t}\n\n\t// A StructType node represents a struct type.\n\tStructType\tstruct {\n\t\tStruct\t\ttoken.Pos\t// position of \"struct\" keyword\n\t\tFields\t\t*FieldList\t// list of field declarations\n\t\tIncomplete\tbool\t\t// true if (source) fields are missing in the Fields list\n\t}\n\n\t// A FuncType node represents a function type.\n\tFuncType\tstruct {\n\t\tFunc\t\ttoken.Pos\t// position of \"func\" keyword (token.NoPos if there is no \"func\")\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tParams\t\t*FieldList\t// (incoming) parameters; non-nil\n\t\tResults\t\t*FieldList\t// (outgoing) results; or nil\n\t}\n\n\t// An InterfaceType node represents an interface type.\n\tInterfaceType\tstruct {\n\t\tInterface\ttoken.Pos\t// position of \"interface\" keyword\n\t\tMethods\t\t*FieldList\t// list of embedded interfaces, methods, or types\n\t\tIncomplete\tbool\t\t// true if (source) methods or types are missing in the Methods list\n\t}\n\n\t// A MapType node represents a map type.\n\tMapType\tstruct {\n\t\tMap\ttoken.Pos\t// position of \"map\" keyword\n\t\tKey\tExpr\n\t\tValue\tExpr\n\t}\n\n\t// A ChanType node represents a channel type.\n\tChanType\tstruct {\n\t\tBegin\ttoken.Pos\t// position of \"chan\" keyword or \"\u003c-\" (whichever comes first)\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\" (token.NoPos if there is no \"\u003c-\")\n\t\tDir\tChanDir\t\t// channel direction\n\t\tValue\tExpr\t\t// value type\n\t}\n)","type (\n\t// An ArrayType node represents an array or slice type.\n\tArrayType\tstruct {\n\t\tLbrack\ttoken.Pos\t// position of \"[\"\n\t\tLen\tExpr\t\t// Ellipsis node for [...]T array types, nil for slice types\n\t\tElt\tExpr\t\t// element type\n\t}\n\n\t// A StructType node represents a struct type.\n\tStructType\tstruct {\n\t\tStruct\t\ttoken.Pos\t// position of \"struct\" keyword\n\t\tFields\t\t*FieldList\t// list of field declarations\n\t\tIncomplete\tbool\t\t// true if (source) fields are missing in the Fields list\n\t}\n\n\t// A FuncType node represents a function type.\n\tFuncType\tstruct {\n\t\tFunc\t\ttoken.Pos\t// position of \"func\" keyword (token.NoPos if there is no \"func\")\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tParams\t\t*FieldList\t// (incoming) parameters; non-nil\n\t\tResults\t\t*FieldList\t// (outgoing) results; or nil\n\t}\n\n\t// An InterfaceType node represents an interface type.\n\tInterfaceType\tstruct {\n\t\tInterface\ttoken.Pos\t// position of \"interface\" keyword\n\t\tMethods\t\t*FieldList\t// list of embedded interfaces, methods, or types\n\t\tIncomplete\tbool\t\t// true if (source) methods or types are missing in the Methods list\n\t}\n\n\t// A MapType node represents a map type.\n\tMapType\tstruct {\n\t\tMap\ttoken.Pos\t// position of \"map\" keyword\n\t\tKey\tExpr\n\t\tValue\tExpr\n\t}\n\n\t// A ChanType node represents a channel type.\n\tChanType\tstruct {\n\t\tBegin\ttoken.Pos\t// position of \"chan\" keyword or \"\u003c-\" (whichever comes first)\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\" (token.NoPos if there is no \"\u003c-\")\n\t\tDir\tChanDir\t\t// channel direction\n\t\tValue\tExpr\t\t// value type\n\t}\n)","func NewIdent(name string) *Ident","func IsExported(name string) bool","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// A BadStmt node is a placeholder for statements containing\n\t// syntax errors for which no correct statement nodes can be\n\t// created.\n\t//\n\tBadStmt\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad statement\n\t}\n\n\t// A DeclStmt node represents a declaration in a statement list.\n\tDeclStmt\tstruct {\n\t\tDecl Decl\t// *GenDecl with CONST, TYPE, or VAR token\n\t}\n\n\t// An EmptyStmt node represents an empty statement.\n\t// The \"position\" of the empty statement is the position\n\t// of the immediately following (explicit or implicit) semicolon.\n\t//\n\tEmptyStmt\tstruct {\n\t\tSemicolon\ttoken.Pos\t// position of following \";\"\n\t\tImplicit\tbool\t\t// if set, \";\" was omitted in the source\n\t}\n\n\t// A LabeledStmt node represents a labeled statement.\n\tLabeledStmt\tstruct {\n\t\tLabel\t*Ident\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tStmt\tStmt\n\t}\n\n\t// An ExprStmt node represents a (stand-alone) expression\n\t// in a statement list.\n\t//\n\tExprStmt\tstruct {\n\t\tX Expr\t// expression\n\t}\n\n\t// A SendStmt node represents a send statement.\n\tSendStmt\tstruct {\n\t\tChan\tExpr\n\t\tArrow\ttoken.Pos\t// position of \"\u003c-\"\n\t\tValue\tExpr\n\t}\n\n\t// An IncDecStmt node represents an increment or decrement statement.\n\tIncDecStmt\tstruct {\n\t\tX\tExpr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// INC or DEC\n\t}\n\n\t// An AssignStmt node represents an assignment or\n\t// a short variable declaration.\n\t//\n\tAssignStmt\tstruct {\n\t\tLhs\t[]Expr\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// assignment token, DEFINE\n\t\tRhs\t[]Expr\n\t}\n\n\t// A GoStmt node represents a go statement.\n\tGoStmt\tstruct {\n\t\tGo\ttoken.Pos\t// position of \"go\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A DeferStmt node represents a defer statement.\n\tDeferStmt\tstruct {\n\t\tDefer\ttoken.Pos\t// position of \"defer\" keyword\n\t\tCall\t*CallExpr\n\t}\n\n\t// A ReturnStmt node represents a return statement.\n\tReturnStmt\tstruct {\n\t\tReturn\ttoken.Pos\t// position of \"return\" keyword\n\t\tResults\t[]Expr\t\t// result expressions; or nil\n\t}\n\n\t// A BranchStmt node represents a break, continue, goto,\n\t// or fallthrough statement.\n\t//\n\tBranchStmt\tstruct {\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\t\tLabel\t*Ident\t\t// label name; or nil\n\t}\n\n\t// A BlockStmt node represents a braced statement list.\n\tBlockStmt\tstruct {\n\t\tLbrace\ttoken.Pos\t// position of \"{\"\n\t\tList\t[]Stmt\n\t\tRbrace\ttoken.Pos\t// position of \"}\", if any (may be absent due to syntax error)\n\t}\n\n\t// An IfStmt node represents an if statement.\n\tIfStmt\tstruct {\n\t\tIf\ttoken.Pos\t// position of \"if\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition\n\t\tBody\t*BlockStmt\n\t\tElse\tStmt\t// else branch; or nil\n\t}\n\n\t// A CaseClause represents a case of an expression or type switch statement.\n\tCaseClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tList\t[]Expr\t\t// list of expressions or types; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SwitchStmt node represents an expression switch statement.\n\tSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tTag\tExpr\t\t// tag expression; or nil\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A TypeSwitchStmt node represents a type switch statement.\n\tTypeSwitchStmt\tstruct {\n\t\tSwitch\ttoken.Pos\t// position of \"switch\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tAssign\tStmt\t\t// x := y.(type) or y.(type)\n\t\tBody\t*BlockStmt\t// CaseClauses only\n\t}\n\n\t// A CommClause node represents a case of a select statement.\n\tCommClause\tstruct {\n\t\tCase\ttoken.Pos\t// position of \"case\" or \"default\" keyword\n\t\tComm\tStmt\t\t// send or receive statement; nil means default case\n\t\tColon\ttoken.Pos\t// position of \":\"\n\t\tBody\t[]Stmt\t\t// statement list; or nil\n\t}\n\n\t// A SelectStmt node represents a select statement.\n\tSelectStmt\tstruct {\n\t\tSelect\ttoken.Pos\t// position of \"select\" keyword\n\t\tBody\t*BlockStmt\t// CommClauses only\n\t}\n\n\t// A ForStmt represents a for statement.\n\tForStmt\tstruct {\n\t\tFor\ttoken.Pos\t// position of \"for\" keyword\n\t\tInit\tStmt\t\t// initialization statement; or nil\n\t\tCond\tExpr\t\t// condition; or nil\n\t\tPost\tStmt\t\t// post iteration statement; or nil\n\t\tBody\t*BlockStmt\n\t}\n\n\t// A RangeStmt represents a for statement with a range clause.\n\tRangeStmt\tstruct {\n\t\tFor\t\ttoken.Pos\t// position of \"for\" keyword\n\t\tKey, Value\tExpr\t\t// Key, Value may be nil\n\t\tTokPos\t\ttoken.Pos\t// position of Tok; invalid if Key == nil\n\t\tTok\t\ttoken.Token\t// ILLEGAL if Key == nil, ASSIGN, DEFINE\n\t\tRange\t\ttoken.Pos\t// position of \"range\" keyword\n\t\tX\t\tExpr\t\t// value to range over\n\t\tBody\t\t*BlockStmt\n\t}\n)","type (\n\t// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n\tSpec\tinterface {\n\t\tNode\n\t\tspecNode()\n\t}\n\n\t// An ImportSpec node represents a single package import.\n\tImportSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t*Ident\t\t// local package name (including \".\"); or nil\n\t\tPath\t*BasicLit\t// import path\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t\tEndPos\ttoken.Pos\t// end of spec (overrides Path.Pos if nonzero)\n\t}\n\n\t// A ValueSpec node represents a constant or variable declaration\n\t// (ConstSpec or VarSpec production).\n\t//\n\tValueSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tNames\t[]*Ident\t// value names (len(Names) \u003e 0)\n\t\tType\tExpr\t\t// value type; or nil\n\t\tValues\t[]Expr\t\t// initial values; or nil\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t}\n\n\t// A TypeSpec node represents a type declaration (TypeSpec production).\n\tTypeSpec\tstruct {\n\t\tDoc\t\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t\t*Ident\t\t// type name\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tAssign\t\ttoken.Pos\t// position of '=', if any\n\t\tType\t\tExpr\t\t// *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n\t\tComment\t\t*CommentGroup\t// line comments; or nil\n\t}\n)","type (\n\t// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n\tSpec\tinterface {\n\t\tNode\n\t\tspecNode()\n\t}\n\n\t// An ImportSpec node represents a single package import.\n\tImportSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t*Ident\t\t// local package name (including \".\"); or nil\n\t\tPath\t*BasicLit\t// import path\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t\tEndPos\ttoken.Pos\t// end of spec (overrides Path.Pos if nonzero)\n\t}\n\n\t// A ValueSpec node represents a constant or variable declaration\n\t// (ConstSpec or VarSpec production).\n\t//\n\tValueSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tNames\t[]*Ident\t// value names (len(Names) \u003e 0)\n\t\tType\tExpr\t\t// value type; or nil\n\t\tValues\t[]Expr\t\t// initial values; or nil\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t}\n\n\t// A TypeSpec node represents a type declaration (TypeSpec production).\n\tTypeSpec\tstruct {\n\t\tDoc\t\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t\t*Ident\t\t// type name\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tAssign\t\ttoken.Pos\t// position of '=', if any\n\t\tType\t\tExpr\t\t// *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n\t\tComment\t\t*CommentGroup\t// line comments; or nil\n\t}\n)","type (\n\t// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n\tSpec\tinterface {\n\t\tNode\n\t\tspecNode()\n\t}\n\n\t// An ImportSpec node represents a single package import.\n\tImportSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t*Ident\t\t// local package name (including \".\"); or nil\n\t\tPath\t*BasicLit\t// import path\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t\tEndPos\ttoken.Pos\t// end of spec (overrides Path.Pos if nonzero)\n\t}\n\n\t// A ValueSpec node represents a constant or variable declaration\n\t// (ConstSpec or VarSpec production).\n\t//\n\tValueSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tNames\t[]*Ident\t// value names (len(Names) \u003e 0)\n\t\tType\tExpr\t\t// value type; or nil\n\t\tValues\t[]Expr\t\t// initial values; or nil\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t}\n\n\t// A TypeSpec node represents a type declaration (TypeSpec production).\n\tTypeSpec\tstruct {\n\t\tDoc\t\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t\t*Ident\t\t// type name\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tAssign\t\ttoken.Pos\t// position of '=', if any\n\t\tType\t\tExpr\t\t// *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n\t\tComment\t\t*CommentGroup\t// line comments; or nil\n\t}\n)","type (\n\t// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n\tSpec\tinterface {\n\t\tNode\n\t\tspecNode()\n\t}\n\n\t// An ImportSpec node represents a single package import.\n\tImportSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t*Ident\t\t// local package name (including \".\"); or nil\n\t\tPath\t*BasicLit\t// import path\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t\tEndPos\ttoken.Pos\t// end of spec (overrides Path.Pos if nonzero)\n\t}\n\n\t// A ValueSpec node represents a constant or variable declaration\n\t// (ConstSpec or VarSpec production).\n\t//\n\tValueSpec\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tNames\t[]*Ident\t// value names (len(Names) \u003e 0)\n\t\tType\tExpr\t\t// value type; or nil\n\t\tValues\t[]Expr\t\t// initial values; or nil\n\t\tComment\t*CommentGroup\t// line comments; or nil\n\t}\n\n\t// A TypeSpec node represents a type declaration (TypeSpec production).\n\tTypeSpec\tstruct {\n\t\tDoc\t\t*CommentGroup\t// associated documentation; or nil\n\t\tName\t\t*Ident\t\t// type name\n\t\tTypeParams\t*FieldList\t// type parameters; or nil\n\t\tAssign\t\ttoken.Pos\t// position of '=', if any\n\t\tType\t\tExpr\t\t// *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n\t\tComment\t\t*CommentGroup\t// line comments; or nil\n\t}\n)","type (\n\t// A BadDecl node is a placeholder for a declaration containing\n\t// syntax errors for which a correct declaration node cannot be\n\t// created.\n\t//\n\tBadDecl\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad declaration\n\t}\n\n\t// A GenDecl node (generic declaration node) represents an import,\n\t// constant, type or variable declaration. A valid Lparen position\n\t// (Lparen.IsValid()) indicates a parenthesized declaration.\n\t//\n\t// Relationship between Tok value and Specs element type:\n\t//\n\t//\ttoken.IMPORT  *ImportSpec\n\t//\ttoken.CONST   *ValueSpec\n\t//\ttoken.TYPE    *TypeSpec\n\t//\ttoken.VAR     *ValueSpec\n\t//\n\tGenDecl\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// IMPORT, CONST, TYPE, or VAR\n\t\tLparen\ttoken.Pos\t// position of '(', if any\n\t\tSpecs\t[]Spec\n\t\tRparen\ttoken.Pos\t// position of ')', if any\n\t}\n\n\t// A FuncDecl node represents a function declaration.\n\tFuncDecl\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tRecv\t*FieldList\t// receiver (methods); or nil (functions)\n\t\tName\t*Ident\t\t// function/method name\n\t\tType\t*FuncType\t// function signature: type and value parameters, results, and position of \"func\" keyword\n\t\tBody\t*BlockStmt\t// function body; or nil for external (non-Go) function\n\t}\n)","type (\n\t// A BadDecl node is a placeholder for a declaration containing\n\t// syntax errors for which a correct declaration node cannot be\n\t// created.\n\t//\n\tBadDecl\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad declaration\n\t}\n\n\t// A GenDecl node (generic declaration node) represents an import,\n\t// constant, type or variable declaration. A valid Lparen position\n\t// (Lparen.IsValid()) indicates a parenthesized declaration.\n\t//\n\t// Relationship between Tok value and Specs element type:\n\t//\n\t//\ttoken.IMPORT  *ImportSpec\n\t//\ttoken.CONST   *ValueSpec\n\t//\ttoken.TYPE    *TypeSpec\n\t//\ttoken.VAR     *ValueSpec\n\t//\n\tGenDecl\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// IMPORT, CONST, TYPE, or VAR\n\t\tLparen\ttoken.Pos\t// position of '(', if any\n\t\tSpecs\t[]Spec\n\t\tRparen\ttoken.Pos\t// position of ')', if any\n\t}\n\n\t// A FuncDecl node represents a function declaration.\n\tFuncDecl\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tRecv\t*FieldList\t// receiver (methods); or nil (functions)\n\t\tName\t*Ident\t\t// function/method name\n\t\tType\t*FuncType\t// function signature: type and value parameters, results, and position of \"func\" keyword\n\t\tBody\t*BlockStmt\t// function body; or nil for external (non-Go) function\n\t}\n)","type (\n\t// A BadDecl node is a placeholder for a declaration containing\n\t// syntax errors for which a correct declaration node cannot be\n\t// created.\n\t//\n\tBadDecl\tstruct {\n\t\tFrom, To token.Pos\t// position range of bad declaration\n\t}\n\n\t// A GenDecl node (generic declaration node) represents an import,\n\t// constant, type or variable declaration. A valid Lparen position\n\t// (Lparen.IsValid()) indicates a parenthesized declaration.\n\t//\n\t// Relationship between Tok value and Specs element type:\n\t//\n\t//\ttoken.IMPORT  *ImportSpec\n\t//\ttoken.CONST   *ValueSpec\n\t//\ttoken.TYPE    *TypeSpec\n\t//\ttoken.VAR     *ValueSpec\n\t//\n\tGenDecl\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tTokPos\ttoken.Pos\t// position of Tok\n\t\tTok\ttoken.Token\t// IMPORT, CONST, TYPE, or VAR\n\t\tLparen\ttoken.Pos\t// position of '(', if any\n\t\tSpecs\t[]Spec\n\t\tRparen\ttoken.Pos\t// position of ')', if any\n\t}\n\n\t// A FuncDecl node represents a function declaration.\n\tFuncDecl\tstruct {\n\t\tDoc\t*CommentGroup\t// associated documentation; or nil\n\t\tRecv\t*FieldList\t// receiver (methods); or nil (functions)\n\t\tName\t*Ident\t\t// function/method name\n\t\tType\t*FuncType\t// function signature: type and value parameters, results, and position of \"func\" keyword\n\t\tBody\t*BlockStmt\t// function body; or nil for external (non-Go) function\n\t}\n)","type File struct {\n\tDoc\t*CommentGroup\t// associated documentation; or nil\n\tPackage\ttoken.Pos\t// position of \"package\" keyword\n\tName\t*Ident\t\t// package name\n\tDecls\t[]Decl\t\t// top-level declarations; or nil\n\n\tFileStart, FileEnd\ttoken.Pos\t// start and end of entire file\n\tScope\t\t\t*Scope\t\t// package scope (this file only). Deprecated: see Object\n\tImports\t\t\t[]*ImportSpec\t// imports in this file\n\tUnresolved\t\t[]*Ident\t// unresolved identifiers in this file. Deprecated: see Object\n\tComments\t\t[]*CommentGroup\t// list of all comments in the source file\n\tGoVersion\t\tstring\t\t// minimum Go version required by //go:build or // +build directives\n}","type Package struct {\n\tName\tstring\t\t\t// package name\n\tScope\t*Scope\t\t\t// package scope across all files\n\tImports\tmap[string]*Object\t// map of package id -\u003e package object\n\tFiles\tmap[string]*File\t// Go source files by filename\n}","func IsGenerated(file *File) bool","func Unparen(e Expr) Expr","type CommentMap map[Node][]*CommentGroup","func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap","func FileExports(src *File) bool","func PackageExports(pkg *Package) bool","type Filter func(string) bool","func FilterDecl(decl Decl, f Filter) bool","func FilterFile(src *File, f Filter) bool","func FilterPackage(pkg *Package, f Filter) bool","","const FilterFuncDuplicates MergeMode","const FilterUnassociatedComments","const FilterImportDuplicates","func MergePackageFiles(pkg *Package, mode MergeMode) *File","func SortImports(fset *token.FileSet, f *File)","type FieldFilter func(name string, value reflect.Value) bool","func NotNilFilter(_ string, v reflect.Value) bool","func Fprint(w io.Writer, fset *token.FileSet, x any, f FieldFilter) error","func Print(fset *token.FileSet, x any) error","type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)","func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)","type Scope struct {\n\tOuter\t*Scope\n\tObjects\tmap[string]*Object\n}","func NewScope(outer *Scope) *Scope","type Object struct {\n\tKind\tObjKind\n\tName\tstring\t// declared name\n\tDecl\tany\t// corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil\n\tData\tany\t// object-specific data; or nil\n\tType\tany\t// placeholder for type information; may be nil\n}","func NewObj(kind ObjKind, name string) *Object","","const Bad ObjKind","const Pkg","const Con","const Typ","const Var","const Fun","const Lbl","type Visitor interface {\n\tVisit(node Node) (w Visitor)\n}","func Walk(v Visitor, node Node)","func Inspect(node Node, f func(Node) bool)","func Preorder(root Node) iter.Seq[Node]","type Context struct {\n\tGOARCH\tstring\t// target architecture\n\tGOOS\tstring\t// target operating system\n\tGOROOT\tstring\t// Go root\n\tGOPATH\tstring\t// Go paths\n\n\t// Dir is the caller's working directory, or the empty string to use\n\t// the current directory of the running process. In module mode, this is used\n\t// to locate the main module.\n\t//\n\t// If Dir is non-empty, directories passed to Import and ImportDir must\n\t// be absolute.\n\tDir\tstring\n\n\tCgoEnabled\tbool\t// whether cgo files are included\n\tUseAllFiles\tbool\t// use files regardless of go:build lines, file names\n\tCompiler\tstring\t// compiler to assume when computing target paths\n\n\t// The build, tool, and release tags specify build constraints\n\t// that should be considered satisfied when processing go:build lines.\n\t// Clients creating a new context may customize BuildTags, which\n\t// defaults to empty, but it is usually an error to customize ToolTags or ReleaseTags.\n\t// ToolTags defaults to build tags appropriate to the current Go toolchain configuration.\n\t// ReleaseTags defaults to the list of Go releases the current release is compatible with.\n\t// BuildTags is not set for the Default build Context.\n\t// In addition to the BuildTags, ToolTags, and ReleaseTags, build constraints\n\t// consider the values of GOARCH and GOOS as satisfied tags.\n\t// The last element in ReleaseTags is assumed to be the current release.\n\tBuildTags\t[]string\n\tToolTags\t[]string\n\tReleaseTags\t[]string\n\n\t// The install suffix specifies a suffix to use in the name of the installation\n\t// directory. By default it is empty, but custom builds that need to keep\n\t// their outputs separate can set InstallSuffix to do so. For example, when\n\t// using the race detector, the go command uses InstallSuffix = \"race\", so\n\t// that on a Linux/386 system, packages are written to a directory named\n\t// \"linux_386_race\" instead of the usual \"linux_386\".\n\tInstallSuffix\tstring\n\n\t// JoinPath joins the sequence of path fragments into a single path.\n\t// If JoinPath is nil, Import uses filepath.Join.\n\tJoinPath\tfunc(elem ...string) string\n\n\t// SplitPathList splits the path list into a slice of individual paths.\n\t// If SplitPathList is nil, Import uses filepath.SplitList.\n\tSplitPathList\tfunc(list string) []string\n\n\t// IsAbsPath reports whether path is an absolute path.\n\t// If IsAbsPath is nil, Import uses filepath.IsAbs.\n\tIsAbsPath\tfunc(path string) bool\n\n\t// IsDir reports whether the path names a directory.\n\t// If IsDir is nil, Import calls os.Stat and uses the result's IsDir method.\n\tIsDir\tfunc(path string) bool\n\n\t// HasSubdir reports whether dir is lexically a subdirectory of\n\t// root, perhaps multiple levels below. It does not try to check\n\t// whether dir exists.\n\t// If so, HasSubdir sets rel to a slash-separated path that\n\t// can be joined to root to produce a path equivalent to dir.\n\t// If HasSubdir is nil, Import uses an implementation built on\n\t// filepath.EvalSymlinks.\n\tHasSubdir\tfunc(root, dir string) (rel string, ok bool)\n\n\t// ReadDir returns a slice of fs.FileInfo, sorted by Name,\n\t// describing the content of the named directory.\n\t// If ReadDir is nil, Import uses os.ReadDir.\n\tReadDir\tfunc(dir string) ([]fs.FileInfo, error)\n\n\t// OpenFile opens a file (not a directory) for reading.\n\t// If OpenFile is nil, Import uses os.Open.\n\tOpenFile\tfunc(path string) (io.ReadCloser, error)\n}","var Default Context","","const FindOnly ImportMode","const AllowBinary","const ImportComment","const IgnoreVendor","type Package struct {\n\tDir\t\tstring\t\t// directory containing package sources\n\tName\t\tstring\t\t// package name\n\tImportComment\tstring\t\t// path in import comment on package statement\n\tDoc\t\tstring\t\t// documentation synopsis\n\tImportPath\tstring\t\t// import path of package (\"\" if unknown)\n\tRoot\t\tstring\t\t// root of Go tree where this package lives\n\tSrcRoot\t\tstring\t\t// package source root directory (\"\" if unknown)\n\tPkgRoot\t\tstring\t\t// package install root directory (\"\" if unknown)\n\tPkgTargetRoot\tstring\t\t// architecture dependent install root directory (\"\" if unknown)\n\tBinDir\t\tstring\t\t// command install directory (\"\" if unknown)\n\tGoroot\t\tbool\t\t// package found in Go root\n\tPkgObj\t\tstring\t\t// installed .a file\n\tAllTags\t\t[]string\t// tags that can influence file selection in this directory\n\tConflictDir\tstring\t\t// this directory shadows Dir in $GOPATH\n\tBinaryOnly\tbool\t\t// cannot be rebuilt from source (has //go:binary-only-package comment)\n\n\t// Source files\n\tGoFiles\t\t\t[]string\t// .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n\tCgoFiles\t\t[]string\t// .go source files that import \"C\"\n\tIgnoredGoFiles\t\t[]string\t// .go source files ignored for this build (including ignored _test.go files)\n\tInvalidGoFiles\t\t[]string\t// .go source files with detected problems (parse error, wrong package name, and so on)\n\tIgnoredOtherFiles\t[]string\t// non-.go source files ignored for this build\n\tCFiles\t\t\t[]string\t// .c source files\n\tCXXFiles\t\t[]string\t// .cc, .cpp and .cxx source files\n\tMFiles\t\t\t[]string\t// .m (Objective-C) source files\n\tHFiles\t\t\t[]string\t// .h, .hh, .hpp and .hxx source files\n\tFFiles\t\t\t[]string\t// .f, .F, .for and .f90 Fortran source files\n\tSFiles\t\t\t[]string\t// .s source files\n\tSwigFiles\t\t[]string\t// .swig files\n\tSwigCXXFiles\t\t[]string\t// .swigcxx files\n\tSysoFiles\t\t[]string\t// .syso system object files to add to archive\n\n\t// Cgo directives\n\tCgoCFLAGS\t[]string\t// Cgo CFLAGS directives\n\tCgoCPPFLAGS\t[]string\t// Cgo CPPFLAGS directives\n\tCgoCXXFLAGS\t[]string\t// Cgo CXXFLAGS directives\n\tCgoFFLAGS\t[]string\t// Cgo FFLAGS directives\n\tCgoLDFLAGS\t[]string\t// Cgo LDFLAGS directives\n\tCgoPkgConfig\t[]string\t// Cgo pkg-config directives\n\n\t// Test information\n\tTestGoFiles\t[]string\t// _test.go files in package\n\tXTestGoFiles\t[]string\t// _test.go files outside package\n\n\t// Go directive comments (//go:zzz...) found in source files.\n\tDirectives\t[]Directive\n\tTestDirectives\t[]Directive\n\tXTestDirectives\t[]Directive\n\n\t// Dependency information\n\tImports\t\t[]string\t\t\t// import paths from GoFiles, CgoFiles\n\tImportPos\tmap[string][]token.Position\t// line information for Imports\n\tTestImports\t[]string\t\t\t// import paths from TestGoFiles\n\tTestImportPos\tmap[string][]token.Position\t// line information for TestImports\n\tXTestImports\t[]string\t\t\t// import paths from XTestGoFiles\n\tXTestImportPos\tmap[string][]token.Position\t// line information for XTestImports\n\n\t// //go:embed patterns found in Go source files\n\t// For example, if a source file says\n\t//\t//go:embed a* b.c\n\t// then the list will contain those two strings as separate entries.\n\t// (See package embed for more details about //go:embed.)\n\tEmbedPatterns\t\t[]string\t\t\t// patterns from GoFiles, CgoFiles\n\tEmbedPatternPos\t\tmap[string][]token.Position\t// line information for EmbedPatterns\n\tTestEmbedPatterns\t[]string\t\t\t// patterns from TestGoFiles\n\tTestEmbedPatternPos\tmap[string][]token.Position\t// line information for TestEmbedPatterns\n\tXTestEmbedPatterns\t[]string\t\t\t// patterns from XTestGoFiles\n\tXTestEmbedPatternPos\tmap[string][]token.Position\t// line information for XTestEmbedPatternPos\n}","type Directive struct {\n\tText\tstring\t\t// full line comment including leading slashes\n\tPos\ttoken.Position\t// position of comment\n}","type NoGoError struct {\n\tDir string\n}","type MultiplePackageError struct {\n\tDir\t\tstring\t\t// directory containing files\n\tPackages\t[]string\t// package names found\n\tFiles\t\t[]string\t// corresponding files: Files[i] declares package Packages[i]\n}","func Import(path, srcDir string, mode ImportMode) (*Package, error)","func ImportDir(dir string, mode ImportMode) (*Package, error)","","func IsLocalImport(path string) bool","func ArchChar(goarch string) (string, error)","","const Unknown Kind","const Bool","const String","const Int","const Float","const Complex","type Value interface {\n\t// Kind returns the value kind.\n\tKind() Kind\n\n\t// String returns a short, quoted (human-readable) form of the value.\n\t// For numeric values, the result may be an approximation;\n\t// for String values the result may be a shortened string.\n\t// Use ExactString for a string representing a value exactly.\n\tString() string\n\n\t// ExactString returns an exact, quoted (human-readable) form of the value.\n\t// If the Value is of Kind String, use StringVal to obtain the unquoted string.\n\tExactString() string\n\n\t// Prevent external implementations.\n\timplementsValue()\n}","func MakeUnknown() Value","func MakeBool(b bool) Value","func MakeString(s string) Value","func MakeInt64(x int64) Value","func MakeUint64(x uint64) Value","func MakeFloat64(x float64) Value","func MakeFromLiteral(lit string, tok token.Token, zero uint) Value","func BoolVal(x Value) bool","func StringVal(x Value) string","func Int64Val(x Value) (int64, bool)","func Uint64Val(x Value) (uint64, bool)","func Float32Val(x Value) (float32, bool)","func Float64Val(x Value) (float64, bool)","func Val(x Value) any","func Make(x any) Value","func BitLen(x Value) int","func Sign(x Value) int","func Bytes(x Value) []byte","func MakeFromBytes(bytes []byte) Value","func Num(x Value) Value","func Denom(x Value) Value","func MakeImag(x Value) Value","func Real(x Value) Value","func Imag(x Value) Value","func ToInt(x Value) Value","func ToFloat(x Value) Value","func ToComplex(x Value) Value","func UnaryOp(op token.Token, y Value, prec uint) Value","func BinaryOp(x_ Value, op token.Token, y_ Value) Value","func Shift(x Value, op token.Token, s uint) Value","func Compare(x_ Value, op token.Token, y_ Value) bool","func ToHTML(w io.Writer, text string, words map[string]string)","func ToText(w io.Writer, text string, prefix, codePrefix string, width int)","type Package struct {\n\tDoc\t\tstring\n\tName\t\tstring\n\tImportPath\tstring\n\tImports\t\t[]string\n\tFilenames\t[]string\n\tNotes\t\tmap[string][]*Note\n\n\t// Deprecated: For backward compatibility Bugs is still populated,\n\t// but all new code should use Notes instead.\n\tBugs\t[]string\n\n\t// declarations\n\tConsts\t[]*Value\n\tTypes\t[]*Type\n\tVars\t[]*Value\n\tFuncs\t[]*Func\n\n\t// Examples is a sorted list of examples associated with\n\t// the package. Examples are extracted from _test.go files\n\t// provided to NewFromFiles.\n\tExamples\t[]*Example\n\n\timportByName\tmap[string]string\n\tsyms\t\tmap[string]bool\n}","type Value struct {\n\tDoc\tstring\n\tNames\t[]string\t// var or const names in declaration order\n\tDecl\t*ast.GenDecl\n\n\torder\tint\n}","type Type struct {\n\tDoc\tstring\n\tName\tstring\n\tDecl\t*ast.GenDecl\n\n\t// associated declarations\n\tConsts\t[]*Value\t// sorted list of constants of (mostly) this type\n\tVars\t[]*Value\t// sorted list of variables of (mostly) this type\n\tFuncs\t[]*Func\t\t// sorted list of functions returning this type\n\tMethods\t[]*Func\t\t// sorted list of methods (including embedded ones) of this type\n\n\t// Examples is a sorted list of examples associated with\n\t// this type. Examples are extracted from _test.go files\n\t// provided to NewFromFiles.\n\tExamples\t[]*Example\n}","type Func struct {\n\tDoc\tstring\n\tName\tstring\n\tDecl\t*ast.FuncDecl\n\n\t// methods\n\t// (for functions, these fields have the respective zero value)\n\tRecv\tstring\t// actual   receiver \"T\" or \"*T\" possibly followed by type parameters [P1, ..., Pn]\n\tOrig\tstring\t// original receiver \"T\" or \"*T\"\n\tLevel\tint\t// embedding level; 0 means not embedded\n\n\t// Examples is a sorted list of examples associated with this\n\t// function or method. Examples are extracted from _test.go files\n\t// provided to NewFromFiles.\n\tExamples\t[]*Example\n}","type Note struct {\n\tPos, End\ttoken.Pos\t// position range of the comment containing the marker\n\tUID\t\tstring\t\t// uid found with the marker\n\tBody\t\tstring\t\t// note body text\n}","","const AllDecls Mode","const AllMethods","const PreserveAST","func New(pkg *ast.Package, importPath string, mode Mode) *Package","func NewFromFiles(fset *token.FileSet, files []*ast.File, importPath string, opts ...any) (*Package, error)","type Example struct {\n\tName\t\tstring\t// name of the item being exemplified (including optional suffix)\n\tSuffix\t\tstring\t// example suffix, without leading '_' (only populated by NewFromFiles)\n\tDoc\t\tstring\t// example function doc string\n\tCode\t\tast.Node\n\tPlay\t\t*ast.File\t// a whole program version of the example\n\tComments\t[]*ast.CommentGroup\n\tOutput\t\tstring\t// expected output\n\tUnordered\tbool\n\tEmptyOutput\tbool\t// expect empty output\n\tOrder\t\tint\t// original source code order\n}","func Examples(testFiles ...*ast.File) []*Example","type Filter func(string) bool","func IsPredeclared(s string) bool","func Synopsis(text string) string","","func Node(dst io.Writer, fset *token.FileSet, node any) error","func Source(src []byte) ([]byte, error)","type Lookup func(path string) (io.ReadCloser, error)","func ForCompiler(fset *token.FileSet, compiler string, lookup Lookup) types.Importer","func For(compiler string, lookup Lookup) types.Importer","func Default() types.Importer","","const PackageClauseOnly Mode","const ImportsOnly","const ParseComments","const Trace","const DeclarationErrors","const SpuriousErrors","const SkipObjectResolution","","func ParseFile(fset *token.FileSet, filename string, src any, mode Mode) (f *ast.File, err error)","func ParseDir(fset *token.FileSet, path string, filter func(fs.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error)","func ParseExprFrom(fset *token.FileSet, filename string, src any, mode Mode) (expr ast.Expr, err error)","func ParseExpr(x string) (ast.Expr, error)","","const RawFormat Mode","const TabIndent","const UseSpaces","const SourcePos","type Config struct {\n\tMode\t\tMode\t// default: 0\n\tTabwidth\tint\t// default: 8\n\tIndent\t\tint\t// default: 0 (all code is indented at least by this much)\n}","type CommentedNode struct {\n\tNode\t\tany\t// *ast.File, or ast.Expr, ast.Decl, ast.Spec, or ast.Stmt\n\tComments\t[]*ast.CommentGroup\n}","func Fprint(output io.Writer, fset *token.FileSet, node any) error","type Error struct {\n\tPos\ttoken.Position\n\tMsg\tstring\n}","type ErrorList []*Error","func PrintError(w io.Writer, err error)","type ErrorHandler func(pos token.Position, msg string)","type Scanner struct {\n\t// immutable state\n\tfile\t*token.File\t// source file handle\n\tdir\tstring\t\t// directory portion of file.Name()\n\tsrc\t[]byte\t\t// source\n\terr\tErrorHandler\t// error reporting; or nil\n\tmode\tMode\t\t// scanning mode\n\n\t// scanning state\n\tch\t\trune\t\t// current character\n\toffset\t\tint\t\t// character offset\n\trdOffset\tint\t\t// reading offset (position after current character)\n\tlineOffset\tint\t\t// current line offset\n\tinsertSemi\tbool\t\t// insert a semicolon before next newline\n\tnlPos\t\ttoken.Pos\t// position of newline in preceding comment\n\n\t// public state - ok to modify\n\tErrorCount\tint\t// number of errors encountered\n}","","const ScanComments Mode","type Position struct {\n\tFilename\tstring\t// filename, if any\n\tOffset\t\tint\t// offset, starting at 0\n\tLine\t\tint\t// line number, starting at 1\n\tColumn\t\tint\t// column number, starting at 1 (byte count)\n}","","const NoPos Pos = 0","type File struct {\n\tname\tstring\t// file name as provided to AddFile\n\tbase\tint\t// Pos value range for this file is [base...base+size]\n\tsize\tint\t// file size as provided to AddFile\n\n\t// lines and infos are protected by mutex\n\tmutex\tsync.Mutex\n\tlines\t[]int\t// lines contains the offset of the first character for each line (the first entry is always 0)\n\tinfos\t[]lineInfo\n}","type FileSet struct {\n\tmutex\tsync.RWMutex\t\t// protects the file set\n\tbase\tint\t\t\t// base offset for the next file\n\tfiles\t[]*File\t\t\t// list of files in the order added to the set\n\tlast\tatomic.Pointer[File]\t// cache of last file looked up\n}","func NewFileSet() *FileSet","","const ILLEGAL Token","const EOF","const COMMENT","const IDENT","const INT","const FLOAT","const IMAG","const CHAR","const STRING","const ADD","const SUB","const MUL","const QUO","const REM","const AND","const OR","const XOR","const SHL","const SHR","const AND_NOT","const ADD_ASSIGN","const SUB_ASSIGN","const MUL_ASSIGN","const QUO_ASSIGN","const REM_ASSIGN","const AND_ASSIGN","const OR_ASSIGN","const XOR_ASSIGN","const SHL_ASSIGN","const SHR_ASSIGN","const AND_NOT_ASSIGN","const LAND","const LOR","const ARROW","const INC","const DEC","const EQL","const LSS","const GTR","const ASSIGN","const NOT","const NEQ","const LEQ","const GEQ","const DEFINE","const ELLIPSIS","const LPAREN","const LBRACK","const LBRACE","const COMMA","const PERIOD","const RPAREN","const RBRACK","const RBRACE","const SEMICOLON","const COLON","const BREAK","const CASE","const CHAN","const CONST","const CONTINUE","const DEFAULT","const DEFER","const ELSE","const FALLTHROUGH","const FOR","const FUNC","const GO","const GOTO","const IF","const IMPORT","const INTERFACE","const MAP","const PACKAGE","const RANGE","const RETURN","const SELECT","const STRUCT","const SWITCH","const TYPE","const VAR","const TILDE","const LowestPrec = 0","const UnaryPrec = 6","const HighestPrec = 7","func Lookup(ident string) Token","func IsExported(name string) bool","func IsKeyword(name string) bool","func IsIdentifier(name string) bool","type Alias struct {\n\tobj\t*TypeName\t// corresponding declared alias object\n\torig\t*Alias\t\t// original, uninstantiated alias\n\ttparams\t*TypeParamList\t// type parameters, or nil\n\ttargs\t*TypeList\t// type arguments, or nil\n\tfromRHS\tType\t\t// RHS of type alias declaration; may be an alias\n\tactual\tType\t\t// actual (aliased) type; never an alias\n}","func NewAlias(obj *TypeName, rhs Type) *Alias","func Unalias(t Type) Type","type Error struct {\n\tFset\t*token.FileSet\t// file set for interpretation of Pos\n\tPos\ttoken.Pos\t// error position\n\tMsg\tstring\t\t// error message\n\tSoft\tbool\t\t// if set, error is \"soft\"\n\n\t// go116code is a future API, unexported as the set of error codes is large\n\t// and likely to change significantly during experimentation. Tools wishing\n\t// to preview this feature may read go116code using reflection (see\n\t// errorcodes_test.go), but beware that there is no guarantee of future\n\t// compatibility.\n\tgo116code\tCode\n\tgo116start\ttoken.Pos\n\tgo116end\ttoken.Pos\n}","type ArgumentError struct {\n\tIndex\tint\n\tErr\terror\n}","type Importer interface {\n\t// Import returns the imported package for the given import path.\n\t// The semantics is like for ImporterFrom.ImportFrom except that\n\t// dir and mode are ignored (since they are not present).\n\tImport(path string) (*Package, error)\n}","","type ImporterFrom interface {\n\t// Importer is present for backward-compatibility. Calling\n\t// Import(path) is the same as calling ImportFrom(path, \"\", 0);\n\t// i.e., locally vendored packages may not be found.\n\t// The types package does not call Import if an ImporterFrom\n\t// is present.\n\tImporter\n\n\t// ImportFrom returns the imported package for the given import\n\t// path when imported by a package file located in dir.\n\t// If the import failed, besides returning an error, ImportFrom\n\t// is encouraged to cache and return a package anyway, if one\n\t// was created. This will reduce package inconsistencies and\n\t// follow-on type checker errors due to the missing package.\n\t// The mode value must be 0; it is reserved for future use.\n\t// Two calls to ImportFrom with the same path and dir must\n\t// return the same package.\n\tImportFrom(path, dir string, mode ImportMode) (*Package, error)\n}","type Config struct {\n\t// Context is the context used for resolving global identifiers. If nil, the\n\t// type checker will initialize this field with a newly created context.\n\tContext\t*Context\n\n\t// GoVersion describes the accepted Go language version. The string must\n\t// start with a prefix of the form \"go%d.%d\" (e.g. \"go1.20\", \"go1.21rc1\", or\n\t// \"go1.21.0\") or it must be empty; an empty string disables Go language\n\t// version checks. If the format is invalid, invoking the type checker will\n\t// result in an error.\n\tGoVersion\tstring\n\n\t// If IgnoreFuncBodies is set, function bodies are not\n\t// type-checked.\n\tIgnoreFuncBodies\tbool\n\n\t// If FakeImportC is set, `import \"C\"` (for packages requiring Cgo)\n\t// declares an empty \"C\" package and errors are omitted for qualified\n\t// identifiers referring to package C (which won't find an object).\n\t// This feature is intended for the standard library cmd/api tool.\n\t//\n\t// Caution: Effects may be unpredictable due to follow-on errors.\n\t//          Do not use casually!\n\tFakeImportC\tbool\n\n\t// If go115UsesCgo is set, the type checker expects the\n\t// _cgo_gotypes.go file generated by running cmd/cgo to be\n\t// provided as a package source file. Qualified identifiers\n\t// referring to package C will be resolved to cgo-provided\n\t// declarations within _cgo_gotypes.go.\n\t//\n\t// It is an error to set both FakeImportC and go115UsesCgo.\n\tgo115UsesCgo\tbool\n\n\t// If _Trace is set, a debug trace is printed to stdout.\n\t_Trace\tbool\n\n\t// If Error != nil, it is called with each error found\n\t// during type checking; err has dynamic type Error.\n\t// Secondary errors (for instance, to enumerate all types\n\t// involved in an invalid recursive type declaration) have\n\t// error strings that start with a '\\t' character.\n\t// If Error == nil, type-checking stops with the first\n\t// error found.\n\tError\tfunc(err error)\n\n\t// An importer is used to import packages referred to from\n\t// import declarations.\n\t// If the installed importer implements ImporterFrom, the type\n\t// checker calls ImportFrom instead of Import.\n\t// The type checker reports an error if an importer is needed\n\t// but none was installed.\n\tImporter\tImporter\n\n\t// If Sizes != nil, it provides the sizing functions for package unsafe.\n\t// Otherwise SizesFor(\"gc\", \"amd64\") is used instead.\n\tSizes\tSizes\n\n\t// If DisableUnusedImportCheck is set, packages are not checked\n\t// for unused imports.\n\tDisableUnusedImportCheck\tbool\n\n\t// If a non-empty _ErrorURL format string is provided, it is used\n\t// to format an error URL link that is appended to the first line\n\t// of an error message. ErrorURL must be a format string containing\n\t// exactly one \"%s\" format, e.g. \"[go.dev/e/%s]\".\n\t_ErrorURL\tstring\n\n\t// If EnableAlias is set, alias declarations produce an Alias type. Otherwise\n\t// the alias information is only in the type name, which points directly to\n\t// the actual (aliased) type.\n\t//\n\t// This setting must not differ among concurrent type-checking operations,\n\t// since it affects the behavior of Universe.Lookup(\"any\").\n\t//\n\t// This flag will eventually be removed (with Go 1.24 at the earliest).\n\t_EnableAlias\tbool\n}","type Info struct {\n\t// Types maps expressions to their types, and for constant\n\t// expressions, also their values. Invalid expressions are\n\t// omitted.\n\t//\n\t// For (possibly parenthesized) identifiers denoting built-in\n\t// functions, the recorded signatures are call-site specific:\n\t// if the call result is not a constant, the recorded type is\n\t// an argument-specific signature. Otherwise, the recorded type\n\t// is invalid.\n\t//\n\t// The Types map does not record the type of every identifier,\n\t// only those that appear where an arbitrary expression is\n\t// permitted. For instance, the identifier f in a selector\n\t// expression x.f is found only in the Selections map, the\n\t// identifier z in a variable declaration 'var z int' is found\n\t// only in the Defs map, and identifiers denoting packages in\n\t// qualified identifiers are collected in the Uses map.\n\tTypes\tmap[ast.Expr]TypeAndValue\n\n\t// Instances maps identifiers denoting generic types or functions to their\n\t// type arguments and instantiated type.\n\t//\n\t// For example, Instances will map the identifier for 'T' in the type\n\t// instantiation T[int, string] to the type arguments [int, string] and\n\t// resulting instantiated *Named type. Given a generic function\n\t// func F[A any](A), Instances will map the identifier for 'F' in the call\n\t// expression F(int(1)) to the inferred type arguments [int], and resulting\n\t// instantiated *Signature.\n\t//\n\t// Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs\n\t// results in an equivalent of Instances[id].Type.\n\tInstances\tmap[*ast.Ident]Instance\n\n\t// Defs maps identifiers to the objects they define (including\n\t// package names, dots \".\" of dot-imports, and blank \"_\" identifiers).\n\t// For identifiers that do not denote objects (e.g., the package name\n\t// in package clauses, or symbolic variables t in t := x.(type) of\n\t// type switch headers), the corresponding objects are nil.\n\t//\n\t// For an embedded field, Defs returns the field *Var it defines.\n\t//\n\t// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()\n\tDefs\tmap[*ast.Ident]Object\n\n\t// Uses maps identifiers to the objects they denote.\n\t//\n\t// For an embedded field, Uses returns the *TypeName it denotes.\n\t//\n\t// Invariant: Uses[id].Pos() != id.Pos()\n\tUses\tmap[*ast.Ident]Object\n\n\t// Implicits maps nodes to their implicitly declared objects, if any.\n\t// The following node and object types may appear:\n\t//\n\t//     node               declared object\n\t//\n\t//     *ast.ImportSpec    *PkgName for imports without renames\n\t//     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)\n\t//     *ast.Field         anonymous parameter *Var (incl. unnamed results)\n\t//\n\tImplicits\tmap[ast.Node]Object\n\n\t// Selections maps selector expressions (excluding qualified identifiers)\n\t// to their corresponding selections.\n\tSelections\tmap[*ast.SelectorExpr]*Selection\n\n\t// Scopes maps ast.Nodes to the scopes they define. Package scopes are not\n\t// associated with a specific node but with all files belonging to a package.\n\t// Thus, the package scope can be found in the type-checked Package object.\n\t// Scopes nest, with the Universe scope being the outermost scope, enclosing\n\t// the package scope, which contains (one or more) files scopes, which enclose\n\t// function scopes which in turn enclose statement and function literal scopes.\n\t// Note that even though package-level functions are declared in the package\n\t// scope, the function scopes are embedded in the file scope of the file\n\t// containing the function declaration.\n\t//\n\t// The Scope of a function contains the declarations of any\n\t// type parameters, parameters, and named results, plus any\n\t// local declarations in the body block.\n\t// It is coextensive with the complete extent of the\n\t// function's syntax ([*ast.FuncDecl] or [*ast.FuncLit]).\n\t// The Scopes mapping does not contain an entry for the\n\t// function body ([*ast.BlockStmt]); the function's scope is\n\t// associated with the [*ast.FuncType].\n\t//\n\t// The following node types may appear in Scopes:\n\t//\n\t//     *ast.File\n\t//     *ast.FuncType\n\t//     *ast.TypeSpec\n\t//     *ast.BlockStmt\n\t//     *ast.IfStmt\n\t//     *ast.SwitchStmt\n\t//     *ast.TypeSwitchStmt\n\t//     *ast.CaseClause\n\t//     *ast.CommClause\n\t//     *ast.ForStmt\n\t//     *ast.RangeStmt\n\t//\n\tScopes\tmap[ast.Node]*Scope\n\n\t// InitOrder is the list of package-level initializers in the order in which\n\t// they must be executed. Initializers referring to variables related by an\n\t// initialization dependency appear in topological order, the others appear\n\t// in source order. Variables without an initialization expression do not\n\t// appear in this list.\n\tInitOrder\t[]*Initializer\n\n\t// FileVersions maps a file to its Go version string.\n\t// If the file doesn't specify a version, the reported\n\t// string is Config.GoVersion.\n\t// Version strings begin with “go”, like “go1.21”, and\n\t// are suitable for use with the [go/version] package.\n\tFileVersions\tmap[*ast.File]string\n}","type TypeAndValue struct {\n\tmode\toperandMode\n\tType\tType\n\tValue\tconstant.Value\n}","type Instance struct {\n\tTypeArgs\t*TypeList\n\tType\t\tType\n}","type Initializer struct {\n\tLhs\t[]*Var\t// var Lhs = Rhs\n\tRhs\tast.Expr\n}","func AssertableTo(V *Interface, T Type) bool","func AssignableTo(V, T Type) bool","func ConvertibleTo(V, T Type) bool","func Implements(V Type, T *Interface) bool","func Satisfies(V Type, T *Interface) bool","func Identical(x, y Type) bool","func IdenticalIgnoreTags(x, y Type) bool","type Array struct {\n\tlen\tint64\n\telem\tType\n}","func NewArray(elem Type, len int64) *Array","","const Invalid BasicKind","const Bool","const Int","const Int8","const Int16","const Int32","const Int64","const Uint","const Uint8","const Uint16","const Uint32","const Uint64","const Uintptr","const Float32","const Float64","const Complex64","const Complex128","const String","const UnsafePointer","const UntypedBool","const UntypedInt","const UntypedRune","const UntypedFloat","const UntypedComplex","const UntypedString","const UntypedNil","","","","const IsBoolean BasicInfo","const IsInteger","const IsUnsigned","const IsFloat","const IsComplex","const IsString","const IsUntyped","","","","type Basic struct {\n\tkind\tBasicKind\n\tinfo\tBasicInfo\n\tname\tstring\n}","type Chan struct {\n\tdir\tChanDir\n\telem\tType\n}","","const SendRecv ChanDir","const SendOnly","const RecvOnly","func NewChan(dir ChanDir, elem Type) *Chan","type Checker struct {\n\t// package information\n\t// (initialized by NewChecker, valid for the life-time of checker)\n\tconf\t*Config\n\tctxt\t*Context\t// context for de-duplicating instances\n\tfset\t*token.FileSet\n\tpkg\t*Package\n\t*Info\n\tversion\tgoVersion\t\t// accepted language version\n\tnextID\tuint64\t\t\t// unique Id for type parameters (first valid Id is 1)\n\tobjMap\tmap[Object]*declInfo\t// maps package-level objects and (non-interface) methods to declaration info\n\timpMap\tmap[importKey]*Package\t// maps (import path, source directory) to (complete or fake) package\n\n\t// pkgPathMap maps package names to the set of distinct import paths we've\n\t// seen for that name, anywhere in the import graph. It is used for\n\t// disambiguating package names in error messages.\n\t//\n\t// pkgPathMap is allocated lazily, so that we don't pay the price of building\n\t// it on the happy path. seenPkgMap tracks the packages that we've already\n\t// walked.\n\tpkgPathMap\tmap[string]map[string]bool\n\tseenPkgMap\tmap[*Package]bool\n\n\t// information collected during type-checking of a set of package files\n\t// (initialized by Files, valid only for the duration of check.Files;\n\t// maps and lists are allocated on demand)\n\tfiles\t\t[]*ast.File\t\t\t// package files\n\tversions\tmap[*ast.File]string\t\t// maps files to version strings (each file has an entry); shared with Info.FileVersions if present\n\timports\t\t[]*PkgName\t\t\t// list of imported packages\n\tdotImportMap\tmap[dotImportKey]*PkgName\t// maps dot-imported objects to the package they were dot-imported through\n\trecvTParamMap\tmap[*ast.Ident]*TypeParam\t// maps blank receiver type parameters to their type\n\tbrokenAliases\tmap[*TypeName]bool\t\t// set of aliases with broken (not yet determined) types\n\tunionTypeSets\tmap[*Union]*_TypeSet\t\t// computed type sets for union types\n\tmono\t\tmonoGraph\t\t\t// graph for detecting non-monomorphizable instantiation loops\n\n\tfirstErr\terror\t\t\t// first error encountered\n\tmethods\t\tmap[*TypeName][]*Func\t// maps package scope type names to associated non-blank (non-interface) methods\n\tuntyped\t\tmap[ast.Expr]exprInfo\t// map of expressions without final type\n\tdelayed\t\t[]action\t\t// stack of delayed action segments; segments are processed in FIFO order\n\tobjPath\t\t[]Object\t\t// path of object dependencies during type inference (for cycle reporting)\n\tcleaners\t[]cleaner\t\t// list of types that may need a final cleanup at the end of type-checking\n\n\t// environment within which the current object is type-checked (valid only\n\t// for the duration of type-checking a specific object)\n\tenvironment\n\n\t// debugging\n\tindent\tint\t// indentation for tracing\n}","func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker","type Context struct {\n\tmu\t\tsync.Mutex\n\ttypeMap\t\tmap[string][]ctxtEntry\t// type hash -\u003e instances entries\n\tnextID\t\tint\t\t\t// next unique ID\n\toriginIDs\tmap[Type]int\t\t// origin type -\u003e unique ID\n}","func NewContext() *Context","func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)","func CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)","func ExprString(x ast.Expr) string","func WriteExpr(buf *bytes.Buffer, x ast.Expr)","func Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)","type Interface struct {\n\tcheck\t\t*Checker\t// for error reporting; nil once type set is computed\n\tmethods\t\t[]*Func\t\t// ordered list of explicitly declared methods\n\tembeddeds\t[]Type\t\t// ordered list of explicitly embedded elements\n\tembedPos\t*[]token.Pos\t// positions of embedded elements; or nil (for error messages) - use pointer to save space\n\timplicit\tbool\t\t// interface is wrapper for type set literal (non-interface T, ~T, or A|B)\n\tcomplete\tbool\t\t// indicates that obj, methods, and embeddeds are set and type set can be computed\n\n\ttset\t*_TypeSet\t// type set described by this interface, computed lazily\n}","func NewInterface(methods []*Func, embeddeds []*Named) *Interface","func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface","func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)","func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)","type Map struct {\n\tkey, elem Type\n}","func NewMap(key, elem Type) *Map","type MethodSet struct {\n\tlist []*Selection\n}","func NewMethodSet(T Type) *MethodSet","type Named struct {\n\tcheck\t*Checker\t// non-nil during type-checking; nil otherwise\n\tobj\t*TypeName\t// corresponding declared object for declared types; see above for instantiated types\n\n\t// fromRHS holds the type (on RHS of declaration) this *Named type is derived\n\t// from (for cycle reporting). Only used by validType, and therefore does not\n\t// require synchronization.\n\tfromRHS\tType\n\n\t// information for instantiated types; nil otherwise\n\tinst\t*instance\n\n\tmu\t\tsync.Mutex\t// guards all fields below\n\tstate_\t\tuint32\t\t// the current state of this type; must only be accessed atomically\n\tunderlying\tType\t\t// possibly a *Named during setup; never a *Named once set up completely\n\ttparams\t\t*TypeParamList\t// type parameters, or nil\n\n\t// methods declared for this type (not the method set of this type)\n\t// Signatures are type-checked lazily.\n\t// For non-instantiated types, this is a fully populated list of methods. For\n\t// instantiated types, methods are individually expanded when they are first\n\t// accessed.\n\tmethods\t[]*Func\n\n\t// loader may be provided to lazily load type parameters, underlying type, and methods.\n\tloader\tfunc(*Named) (tparams []*TypeParam, underlying Type, methods []*Func)\n}","func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named","type Object interface {\n\tParent() *Scope\t// scope in which this object is declared; nil for methods and struct fields\n\tPos() token.Pos\t// position of object identifier in declaration\n\tPkg() *Package\t// package to which this object belongs; nil for labels and objects in the Universe scope\n\tName() string\t// package local object name\n\tType() Type\t// object type\n\tExported() bool\t// reports whether the name starts with a capital letter\n\tId() string\t// object name if exported, qualified name if not exported (see func Id)\n\n\t// String returns a human-readable string of the object.\n\tString() string\n\n\t// order reflects a package-level object's source order: if object\n\t// a is before object b in the source, then a.order() \u003c b.order().\n\t// order returns a value \u003e 0 for package-level objects; it returns\n\t// 0 for all other objects (including objects in file scopes).\n\torder() uint32\n\n\t// color returns the object's color.\n\tcolor() color\n\n\t// setType sets the type of the object.\n\tsetType(Type)\n\n\t// setOrder sets the order number of the object. It must be \u003e 0.\n\tsetOrder(uint32)\n\n\t// setColor sets the object's color. It must not be white.\n\tsetColor(color color)\n\n\t// setParent sets the parent scope of the object.\n\tsetParent(*Scope)\n\n\t// sameId reports whether obj.Id() and Id(pkg, name) are the same.\n\t// If foldCase is true, names are considered equal if they are equal with case folding\n\t// and their packages are ignored (e.g., pkg1.m, pkg1.M, pkg2.m, and pkg2.M are all equal).\n\tsameId(pkg *Package, name string, foldCase bool) bool\n\n\t// scopePos returns the start position of the scope of this Object\n\tscopePos() token.Pos\n\n\t// setScopePos sets the start position of the scope for this Object.\n\tsetScopePos(pos token.Pos)\n}","func Id(pkg *Package, name string) string","type PkgName struct {\n\tobject\n\timported\t*Package\n\tused\t\tbool\t// set if the package was used\n}","func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName","type Const struct {\n\tobject\n\tval\tconstant.Value\n}","func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const","type TypeName struct {\n\tobject\n}","func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName","type Var struct {\n\tobject\n\tembedded\tbool\t// if set, the variable is an embedded struct field, and name is the type name\n\tisField\t\tbool\t// var is struct field\n\tused\t\tbool\t// set if the variable was used\n\torigin\t\t*Var\t// if non-nil, the Var from which this one was instantiated\n}","func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var","func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var","func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var","type Func struct {\n\tobject\n\thasPtrRecv_\tbool\t// only valid for methods that don't have a type yet; use hasPtrRecv() to read\n\torigin\t\t*Func\t// if non-nil, the Func from which this one was instantiated\n}","func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func","type Label struct {\n\tobject\n\tused\tbool\t// set if the label was used\n}","func NewLabel(pos token.Pos, pkg *Package, name string) *Label","type Builtin struct {\n\tobject\n\tid\tbuiltinId\n}","type Nil struct {\n\tobject\n}","func ObjectString(obj Object, qf Qualifier) string","type Package struct {\n\tpath\t\tstring\n\tname\t\tstring\n\tscope\t\t*Scope\n\timports\t\t[]*Package\n\tcomplete\tbool\n\tfake\t\tbool\t// scope lookup errors are silently dropped if package is fake (internal use only)\n\tcgo\t\tbool\t// uses of this package will be rewritten into uses of declarations from _cgo_gotypes.go\n\tgoVersion\tstring\t// minimum Go version required for package (by Config.GoVersion, typically from go.mod)\n}","func NewPackage(path, name string) *Package","type Pointer struct {\n\tbase Type\t// element type\n}","func NewPointer(elem Type) *Pointer","func IsInterface(t Type) bool","func Comparable(T Type) bool","func Default(t Type) Type","type Scope struct {\n\tparent\t\t*Scope\n\tchildren\t[]*Scope\n\tnumber\t\tint\t\t\t// parent.children[number-1] is this scope; 0 if there is no parent\n\telems\t\tmap[string]Object\t// lazily allocated\n\tpos, end\ttoken.Pos\t\t// scope extent; may be invalid\n\tcomment\t\tstring\t\t\t// for debugging only\n\tisFunc\t\tbool\t\t\t// set if this is a function scope (internal use only)\n}","func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope","","const FieldVal SelectionKind","const MethodVal","const MethodExpr","type Selection struct {\n\tkind\t\tSelectionKind\n\trecv\t\tType\t// type of x\n\tobj\t\tObject\t// object denoted by x.f\n\tindex\t\t[]int\t// path from x to x.f\n\tindirect\tbool\t// set if there was any pointer indirection on the path\n}","func SelectionString(s *Selection, qf Qualifier) string","type Signature struct {\n\t// We need to keep the scope in Signature (rather than passing it around\n\t// and store it in the Func Object) because when type-checking a function\n\t// literal we call the general type checker which returns a general Type.\n\t// We then unpack the *Signature and use the scope for the literal body.\n\trparams\t\t*TypeParamList\t// receiver type parameters from left to right, or nil\n\ttparams\t\t*TypeParamList\t// type parameters from left to right, or nil\n\tscope\t\t*Scope\t\t// function scope for package-local and non-instantiated signatures; nil otherwise\n\trecv\t\t*Var\t\t// nil if not a method\n\tparams\t\t*Tuple\t\t// (incoming) parameters from left to right; or nil\n\tresults\t\t*Tuple\t\t// (outgoing) results from left to right; or nil\n\tvariadic\tbool\t\t// true if the last parameter's type is of the form ...T (or string, for append built-in only)\n}","func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature","func NewSignatureType(recv *Var, recvTypeParams, typeParams []*TypeParam, params, results *Tuple, variadic bool) *Signature","type Sizes interface {\n\t// Alignof returns the alignment of a variable of type T.\n\t// Alignof must implement the alignment guarantees required by the spec.\n\t// The result must be \u003e= 1.\n\tAlignof(T Type) int64\n\n\t// Offsetsof returns the offsets of the given struct fields, in bytes.\n\t// Offsetsof must implement the offset guarantees required by the spec.\n\t// A negative entry in the result indicates that the struct is too large.\n\tOffsetsof(fields []*Var) []int64\n\n\t// Sizeof returns the size of a variable of type T.\n\t// Sizeof must implement the size guarantees required by the spec.\n\t// A negative result indicates that T is too large.\n\tSizeof(T Type) int64\n}","type StdSizes struct {\n\tWordSize\tint64\t// word size in bytes - must be \u003e= 4 (32bits)\n\tMaxAlign\tint64\t// maximum alignment in bytes - must be \u003e= 1\n}","func SizesFor(compiler, arch string) Sizes","type Slice struct {\n\telem Type\n}","func NewSlice(elem Type) *Slice","type Struct struct {\n\tfields\t[]*Var\t\t// fields != nil indicates the struct is set up (possibly with len(fields) == 0)\n\ttags\t[]string\t// field tags; nil if there are no tags\n}","func NewStruct(fields []*Var, tags []string) *Struct","type Tuple struct {\n\tvars []*Var\n}","func NewTuple(x ...*Var) *Tuple","type Type interface {\n\t// Underlying returns the underlying type of a type.\n\t// Underlying types are never Named, TypeParam, or Alias types.\n\t//\n\t// See https://go.dev/ref/spec#Underlying_types.\n\tUnderlying() Type\n\n\t// String returns a string representation of a type.\n\tString() string\n}","type TypeParamList struct{ tparams []*TypeParam }","type TypeList struct{ types []Type }","type TypeParam struct {\n\tcheck\t*Checker\t// for lazy type bound completion\n\tid\tuint64\t\t// unique id, for debugging only\n\tobj\t*TypeName\t// corresponding type name\n\tindex\tint\t\t// type parameter index in source order, starting at 0\n\tbound\tType\t\t// any type, but underlying is eventually *Interface for correct programs (see TypeParam.iface)\n}","func NewTypeParam(obj *TypeName, constraint Type) *TypeParam","type Qualifier func(*Package) string","func RelativeTo(pkg *Package) Qualifier","func TypeString(typ Type, qf Qualifier) string","func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)","func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)","type Union struct {\n\tterms []*Term\t// list of syntactical terms (not a canonicalized termlist)\n}","func NewUnion(terms []*Term) *Union","","func NewTerm(tilde bool, typ Type) *Term","var Universe *Scope","var Unsafe *Package","","func DefPredeclaredTestFuncs()","func Lang(x string) string","func Compare(x, y string) int","func IsValid(x string) bool","const Size = 4","func New() hash.Hash32","func Checksum(data []byte) uint32","const Size = 4","const IEEE = 0xedb88320","const Castagnoli = 0x82f63b78","const Koopman = 0xeb31d82e","type Table [256]uint32","","func MakeTable(poly uint32) *Table","func New(tab *Table) hash.Hash32","func NewIEEE() hash.Hash32","func Update(crc uint32, tab *Table, p []byte) uint32","func Checksum(data []byte, tab *Table) uint32","func ChecksumIEEE(data []byte) uint32","const Size = 8","const ISO = 0xD800000000000000","const ECMA = 0xC96C5795D7870F42","type Table [256]uint64","func MakeTable(poly uint64) *Table","func New(tab *Table) hash.Hash64","func Update(crc uint64, tab *Table, p []byte) uint64","func Checksum(data []byte, tab *Table) uint64","func New32() hash.Hash32","func New32a() hash.Hash32","func New64() hash.Hash64","func New64a() hash.Hash64","func New128() hash.Hash","func New128a() hash.Hash","type Seed struct {\n\ts uint64\n}","func Bytes(seed Seed, b []byte) uint64","func String(seed Seed, s string) uint64","type Hash struct {\n\t_\t[0]func()\t// not comparable\n\tseed\tSeed\t\t// initial seed used for this hash\n\tstate\tSeed\t\t// current hash of all flushed bytes\n\tbuf\t[bufSize]byte\t// unflushed byte buffer\n\tn\tint\t\t// number of unflushed bytes\n}","func MakeSeed() Seed","","","","","","","","type Error struct {\n\t// ErrorCode describes the kind of error.\n\tErrorCode\tErrorCode\n\t// Node is the node that caused the problem, if known.\n\t// If not nil, it overrides Name and Line.\n\tNode\tparse.Node\n\t// Name is the name of the template in which the error was encountered.\n\tName\tstring\n\t// Line is the line number of the error in the template source or 0.\n\tLine\tint\n\t// Description is a human-readable description of the problem.\n\tDescription\tstring\n}","","const OK ErrorCode","const ErrAmbigContext","const ErrBadHTML","const ErrBranchEnd","const ErrEndContext","const ErrNoSuchTemplate","const ErrOutputContext","const ErrPartialCharset","const ErrPartialEscape","const ErrRangeLoopReentry","const ErrSlashAmbig","const ErrPredefinedEscaper","const ErrJSTemplate","func HTMLEscape(w io.Writer, b []byte)","func HTMLEscapeString(s string) string","func HTMLEscaper(args ...any) string","func JSEscape(w io.Writer, b []byte)","func JSEscapeString(s string) string","func JSEscaper(args ...any) string","func URLQueryEscaper(args ...any) string","type Template struct {\n\t// Sticky error if escaping fails, or escapeOK if succeeded.\n\tescapeErr\terror\n\t// We could embed the text/template field, but it's safer not to because\n\t// we need to keep our version of the name space and the underlying\n\t// template's in sync.\n\ttext\t*template.Template\n\t// The underlying template's parse tree, updated to be HTML-safe.\n\tTree\t\t*parse.Tree\n\t*nameSpace\t// common to all associated templates\n}","func New(name string) *Template","type FuncMap = template.FuncMap","func Must(t *Template, err error) *Template","func ParseFiles(filenames ...string) (*Template, error)","func ParseGlob(pattern string) (*Template, error)","func IsTrue(val any) (truth, ok bool)","func ParseFS(fs fs.FS, patterns ...string) (*Template, error)","type Color interface {\n\t// RGBA returns the alpha-premultiplied red, green, blue and alpha values\n\t// for the color. Each value ranges within [0, 0xffff], but is represented\n\t// by a uint32 so that multiplying by a blend factor up to 0xffff will not\n\t// overflow.\n\t//\n\t// An alpha-premultiplied color component c has been scaled by alpha (a),\n\t// so has valid values 0 \u003c= c \u003c= a.\n\tRGBA() (r, g, b, a uint32)\n}","type RGBA struct {\n\tR, G, B, A uint8\n}","type RGBA64 struct {\n\tR, G, B, A uint16\n}","type NRGBA struct {\n\tR, G, B, A uint8\n}","type NRGBA64 struct {\n\tR, G, B, A uint16\n}","type Alpha struct {\n\tA uint8\n}","type Alpha16 struct {\n\tA uint16\n}","type Gray struct {\n\tY uint8\n}","type Gray16 struct {\n\tY uint16\n}","type Model interface {\n\tConvert(c Color) Color\n}","func ModelFunc(f func(Color) Color) Model","var RGBAModel Model","var RGBA64Model Model","var NRGBAModel Model","var NRGBA64Model Model","var AlphaModel Model","var Alpha16Model Model","var GrayModel Model","var Gray16Model Model","type Palette []Color","","","","","func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8)","func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8)","type YCbCr struct {\n\tY, Cb, Cr uint8\n}","var YCbCrModel Model","type NYCbCrA struct {\n\tYCbCr\n\tA\tuint8\n}","var NYCbCrAModel Model","func RGBToCMYK(r, g, b uint8) (uint8, uint8, uint8, uint8)","func CMYKToRGB(c, m, y, k uint8) (uint8, uint8, uint8)","type CMYK struct {\n\tC, M, Y, K uint8\n}","var CMYKModel Model","type Image interface {\n\timage.Image\n\tSet(x, y int, c color.Color)\n}","type RGBA64Image interface {\n\timage.RGBA64Image\n\tSet(x, y int, c color.Color)\n\tSetRGBA64(x, y int, c color.RGBA64)\n}","type Quantizer interface {\n\t// Quantize appends up to cap(p) - len(p) colors to p and returns the\n\t// updated palette suitable for converting m to a paletted image.\n\tQuantize(p color.Palette, m image.Image) color.Palette\n}","","const Over Op","const Src","type Drawer interface {\n\t// Draw aligns r.Min in dst with sp in src and then replaces the\n\t// rectangle r in dst with the result of drawing src on dst.\n\tDraw(dst Image, r image.Rectangle, src image.Image, sp image.Point)\n}","var FloydSteinberg Drawer","func Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)","func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)","const DisposalNone = 0x01","const DisposalBackground = 0x02","const DisposalPrevious = 0x03","func Decode(r io.Reader) (image.Image, error)","type GIF struct {\n\tImage\t[]*image.Paletted\t// The successive images.\n\tDelay\t[]int\t\t\t// The successive delay times, one per frame, in 100ths of a second.\n\t// LoopCount controls the number of times an animation will be\n\t// restarted during display.\n\t// A LoopCount of 0 means to loop forever.\n\t// A LoopCount of -1 means to show each frame only once.\n\t// Otherwise, the animation is looped LoopCount+1 times.\n\tLoopCount\tint\n\t// Disposal is the successive disposal methods, one per frame. For\n\t// backwards compatibility, a nil Disposal is valid to pass to EncodeAll,\n\t// and implies that each frame's disposal method is 0 (no disposal\n\t// specified).\n\tDisposal\t[]byte\n\t// Config is the global color table (palette), width and height. A nil or\n\t// empty-color.Palette Config.ColorModel means that each frame has its own\n\t// color table and there is no global color table. Each frame's bounds must\n\t// be within the rectangle defined by the two points (0, 0) and\n\t// (Config.Width, Config.Height).\n\t//\n\t// For backwards compatibility, a zero-valued Config is valid to pass to\n\t// EncodeAll, and implies that the overall GIF's width and height equals\n\t// the first frame's bounds' Rectangle.Max point.\n\tConfig\timage.Config\n\t// BackgroundIndex is the background index in the global color table, for\n\t// use with the DisposalBackground disposal method.\n\tBackgroundIndex\tbyte\n}","func DecodeAll(r io.Reader) (*GIF, error)","func DecodeConfig(r io.Reader) (image.Config, error)","type Options struct {\n\t// NumColors is the maximum number of colors used in the image.\n\t// It ranges from 1 to 256.\n\tNumColors\tint\n\n\t// Quantizer is used to produce a palette with size NumColors.\n\t// palette.Plan9 is used in place of a nil Quantizer.\n\tQuantizer\tdraw.Quantizer\n\n\t// Drawer is used to convert the source image to the desired palette.\n\t// draw.FloydSteinberg is used in place of a nil Drawer.\n\tDrawer\tdraw.Drawer\n}","func EncodeAll(w io.Writer, g *GIF) error","func Encode(w io.Writer, m image.Image, o *Options) error","","","type Reader interface {\n\tio.ByteReader\n\tio.Reader\n}","func Decode(r io.Reader) (image.Image, error)","func DecodeConfig(r io.Reader) (image.Config, error)","const DefaultQuality = 75","type Options struct {\n\tQuality int\n}","func Encode(w io.Writer, m image.Image, o *Options) error","","","func Decode(r io.Reader) (image.Image, error)","func DecodeConfig(r io.Reader) (image.Config, error)","type Encoder struct {\n\tCompressionLevel\tCompressionLevel\n\n\t// BufferPool optionally specifies a buffer pool to get temporary\n\t// EncoderBuffers when encoding an image.\n\tBufferPool\tEncoderBufferPool\n}","type EncoderBufferPool interface {\n\tGet() *EncoderBuffer\n\tPut(*EncoderBuffer)\n}","","","const DefaultCompression CompressionLevel = 0","const NoCompression CompressionLevel","const BestSpeed CompressionLevel","const BestCompression CompressionLevel","func Encode(w io.Writer, m image.Image) error","type Index struct {\n\tdata\t[]byte\n\tsa\tints\t// suffix array for data; sa.len() == len(data)\n}","func New(data []byte) *Index","func FormatFileInfo(info FileInfo) string","func FormatDirEntry(dir DirEntry) string","type FS interface {\n\t// Open opens the named file.\n\t//\n\t// When Open returns an error, it should be of type *PathError\n\t// with the Op field set to \"open\", the Path field set to name,\n\t// and the Err field describing the problem.\n\t//\n\t// Open should reject attempts to open names that do not satisfy\n\t// ValidPath(name), returning a *PathError with Err set to\n\t// ErrInvalid or ErrNotExist.\n\tOpen(name string) (File, error)\n}","func ValidPath(name string) bool","type File interface {\n\tStat() (FileInfo, error)\n\tRead([]byte) (int, error)\n\tClose() error\n}","type DirEntry interface {\n\t// Name returns the name of the file (or subdirectory) described by the entry.\n\t// This name is only the final element of the path (the base name), not the entire path.\n\t// For example, Name would return \"hello.go\" not \"home/gopher/hello.go\".\n\tName() string\n\n\t// IsDir reports whether the entry describes a directory.\n\tIsDir() bool\n\n\t// Type returns the type bits for the entry.\n\t// The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method.\n\tType() FileMode\n\n\t// Info returns the FileInfo for the file or subdirectory described by the entry.\n\t// The returned FileInfo may be from the time of the original directory read\n\t// or from the time of the call to Info. If the file has been removed or renamed\n\t// since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist).\n\t// If the entry denotes a symbolic link, Info reports the information about the link itself,\n\t// not the link's target.\n\tInfo() (FileInfo, error)\n}","type ReadDirFile interface {\n\tFile\n\n\t// ReadDir reads the contents of the directory and returns\n\t// a slice of up to n DirEntry values in directory order.\n\t// Subsequent calls on the same file will yield further DirEntry values.\n\t//\n\t// If n \u003e 0, ReadDir returns at most n DirEntry structures.\n\t// In this case, if ReadDir returns an empty slice, it will return\n\t// a non-nil error explaining why.\n\t// At the end of a directory, the error is io.EOF.\n\t// (ReadDir must return io.EOF itself, not an error wrapping io.EOF.)\n\t//\n\t// If n \u003c= 0, ReadDir returns all the DirEntry values from the directory\n\t// in a single slice. In this case, if ReadDir succeeds (reads all the way\n\t// to the end of the directory), it returns the slice and a nil error.\n\t// If it encounters an error before the end of the directory,\n\t// ReadDir returns the DirEntry list read until that point and a non-nil error.\n\tReadDir(n int) ([]DirEntry, error)\n}","","","","","","type FileInfo interface {\n\tName() string\t\t// base name of the file\n\tSize() int64\t\t// length in bytes for regular files; system-dependent for others\n\tMode() FileMode\t\t// file mode bits\n\tModTime() time.Time\t// modification time\n\tIsDir() bool\t\t// abbreviation for Mode().IsDir()\n\tSys() any\t\t// underlying data source (can return nil)\n}","","const ModeDir FileMode","const ModeAppend","const ModeExclusive","const ModeTemporary","const ModeSymlink","const ModeDevice","const ModeNamedPipe","const ModeSocket","const ModeSetuid","const ModeSetgid","const ModeCharDevice","const ModeSticky","const ModeIrregular","","const ModePerm FileMode = 0777","type PathError struct {\n\tOp\tstring\n\tPath\tstring\n\tErr\terror\n}","type GlobFS interface {\n\tFS\n\n\t// Glob returns the names of all files matching pattern,\n\t// providing an implementation of the top-level\n\t// Glob function.\n\tGlob(pattern string) ([]string, error)\n}","func Glob(fsys FS, pattern string) (matches []string, err error)","type ReadDirFS interface {\n\tFS\n\n\t// ReadDir reads the named directory\n\t// and returns a list of directory entries sorted by filename.\n\tReadDir(name string) ([]DirEntry, error)\n}","func ReadDir(fsys FS, name string) ([]DirEntry, error)","func FileInfoToDirEntry(info FileInfo) DirEntry","type ReadFileFS interface {\n\tFS\n\n\t// ReadFile reads the named file and returns its contents.\n\t// A successful call returns a nil error, not io.EOF.\n\t// (Because ReadFile reads the whole file, the expected EOF\n\t// from the final Read is not treated as an error to be reported.)\n\t//\n\t// The caller is permitted to modify the returned byte slice.\n\t// This method should return a copy of the underlying data.\n\tReadFile(name string) ([]byte, error)\n}","func ReadFile(fsys FS, name string) ([]byte, error)","type StatFS interface {\n\tFS\n\n\t// Stat returns a FileInfo describing the file.\n\t// If there is an error, it should be of type *PathError.\n\tStat(name string) (FileInfo, error)\n}","func Stat(fsys FS, name string) (FileInfo, error)","type SubFS interface {\n\tFS\n\n\t// Sub returns an FS corresponding to the subtree rooted at dir.\n\tSub(dir string) (FS, error)\n}","func Sub(fsys FS, dir string) (FS, error)","","","type WalkDirFunc func(path string, d DirEntry, err error) error","func WalkDir(fsys FS, root string, fn WalkDirFunc) error","func ReadAll(r io.Reader) ([]byte, error)","func ReadFile(filename string) ([]byte, error)","func WriteFile(filename string, data []byte, perm fs.FileMode) error","func ReadDir(dirname string) ([]fs.FileInfo, error)","func NopCloser(r io.Reader) io.ReadCloser","var Discard io.Writer","func TempFile(dir, pattern string) (f *os.File, err error)","func TempDir(dir, pattern string) (name string, err error)","type Attr struct {\n\tKey\tstring\n\tValue\tValue\n}","func String(key, value string) Attr","func Int64(key string, value int64) Attr","func Int(key string, value int) Attr","func Uint64(key string, v uint64) Attr","func Float64(key string, v float64) Attr","func Bool(key string, v bool) Attr","func Time(key string, v time.Time) Attr","func Duration(key string, v time.Duration) Attr","func Group(key string, args ...any) Attr","func Any(key string, value any) Attr","type Handler interface {\n\t// Enabled reports whether the handler handles records at the given level.\n\t// The handler ignores records whose level is lower.\n\t// It is called early, before any arguments are processed,\n\t// to save effort if the log event should be discarded.\n\t// If called from a Logger method, the first argument is the context\n\t// passed to that method, or context.Background() if nil was passed\n\t// or the method does not take a context.\n\t// The context is passed so Enabled can use its values\n\t// to make a decision.\n\tEnabled(context.Context, Level) bool\n\n\t// Handle handles the Record.\n\t// It will only be called when Enabled returns true.\n\t// The Context argument is as for Enabled.\n\t// It is present solely to provide Handlers access to the context's values.\n\t// Canceling the context should not affect record processing.\n\t// (Among other things, log messages may be necessary to debug a\n\t// cancellation-related problem.)\n\t//\n\t// Handle methods that produce output should observe the following rules:\n\t//   - If r.Time is the zero time, ignore the time.\n\t//   - If r.PC is zero, ignore it.\n\t//   - Attr's values should be resolved.\n\t//   - If an Attr's key and value are both the zero value, ignore the Attr.\n\t//     This can be tested with attr.Equal(Attr{}).\n\t//   - If a group's key is empty, inline the group's Attrs.\n\t//   - If a group has no Attrs (even if it has a non-empty key),\n\t//     ignore it.\n\tHandle(context.Context, Record) error\n\n\t// WithAttrs returns a new Handler whose attributes consist of\n\t// both the receiver's attributes and the arguments.\n\t// The Handler owns the slice: it may retain, modify or discard it.\n\tWithAttrs(attrs []Attr) Handler\n\n\t// WithGroup returns a new Handler with the given group appended to\n\t// the receiver's existing groups.\n\t// The keys of all subsequent attributes, whether added by With or in a\n\t// Record, should be qualified by the sequence of group names.\n\t//\n\t// How this qualification happens is up to the Handler, so long as\n\t// this Handler's attribute keys differ from those of another Handler\n\t// with a different sequence of group names.\n\t//\n\t// A Handler should treat WithGroup as starting a Group of Attrs that ends\n\t// at the end of the log event. That is,\n\t//\n\t//     logger.WithGroup(\"s\").LogAttrs(ctx, level, msg, slog.Int(\"a\", 1), slog.Int(\"b\", 2))\n\t//\n\t// should behave like\n\t//\n\t//     logger.LogAttrs(ctx, level, msg, slog.Group(\"s\", slog.Int(\"a\", 1), slog.Int(\"b\", 2)))\n\t//\n\t// If the name is empty, WithGroup returns the receiver.\n\tWithGroup(name string) Handler\n}","type HandlerOptions struct {\n\t// AddSource causes the handler to compute the source code position\n\t// of the log statement and add a SourceKey attribute to the output.\n\tAddSource\tbool\n\n\t// Level reports the minimum record level that will be logged.\n\t// The handler discards records with lower levels.\n\t// If Level is nil, the handler assumes LevelInfo.\n\t// The handler calls Level.Level for each record processed;\n\t// to adjust the minimum level dynamically, use a LevelVar.\n\tLevel\tLeveler\n\n\t// ReplaceAttr is called to rewrite each non-group attribute before it is logged.\n\t// The attribute's value has been resolved (see [Value.Resolve]).\n\t// If ReplaceAttr returns a zero Attr, the attribute is discarded.\n\t//\n\t// The built-in attributes with keys \"time\", \"level\", \"source\", and \"msg\"\n\t// are passed to this function, except that time is omitted\n\t// if zero, and source is omitted if AddSource is false.\n\t//\n\t// The first argument is a list of currently open groups that contain the\n\t// Attr. It must not be retained or modified. ReplaceAttr is never called\n\t// for Group attributes, only their contents. For example, the attribute\n\t// list\n\t//\n\t//     Int(\"a\", 1), Group(\"g\", Int(\"b\", 2)), Int(\"c\", 3)\n\t//\n\t// results in consecutive calls to ReplaceAttr with the following arguments:\n\t//\n\t//     nil, Int(\"a\", 1)\n\t//     []string{\"g\"}, Int(\"b\", 2)\n\t//     nil, Int(\"c\", 3)\n\t//\n\t// ReplaceAttr can be used to change the default keys of the built-in\n\t// attributes, convert types (for example, to replace a `time.Time` with the\n\t// integer seconds since the Unix epoch), sanitize personal information, or\n\t// remove attributes from the output.\n\tReplaceAttr\tfunc(groups []string, a Attr) Attr\n}","const TimeKey = \"time\"","const LevelKey = \"level\"","const MessageKey = \"msg\"","const SourceKey = \"source\"","type JSONHandler struct {\n\t*commonHandler\n}","func NewJSONHandler(w io.Writer, opts *HandlerOptions) *JSONHandler","","const LevelDebug Level","const LevelInfo Level = 0","const LevelWarn Level = 4","const LevelError Level = 8","type LevelVar struct {\n\tval atomic.Int64\n}","type Leveler interface {\n\tLevel() Level\n}","func SetLogLoggerLevel(level Level) (oldLevel Level)","func Default() *Logger","func SetDefault(l *Logger)","type Logger struct {\n\thandler Handler\t// for structured logging\n}","func New(h Handler) *Logger","func With(args ...any) *Logger","func NewLogLogger(h Handler, level Level) *log.Logger","func Debug(msg string, args ...any)","func DebugContext(ctx context.Context, msg string, args ...any)","func Info(msg string, args ...any)","func InfoContext(ctx context.Context, msg string, args ...any)","func Warn(msg string, args ...any)","func WarnContext(ctx context.Context, msg string, args ...any)","func Error(msg string, args ...any)","func ErrorContext(ctx context.Context, msg string, args ...any)","func Log(ctx context.Context, level Level, msg string, args ...any)","func LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)","type Record struct {\n\t// The time at which the output method (Log, Info, etc.) was called.\n\tTime\ttime.Time\n\n\t// The log message.\n\tMessage\tstring\n\n\t// The level of the event.\n\tLevel\tLevel\n\n\t// The program counter at the time the record was constructed, as determined\n\t// by runtime.Callers. If zero, no program counter is available.\n\t//\n\t// The only valid use for this value is as an argument to\n\t// [runtime.CallersFrames]. In particular, it must not be passed to\n\t// [runtime.FuncForPC].\n\tPC\tuintptr\n\n\t// Allocation optimization: an inline array sized to hold\n\t// the majority of log calls (based on examination of open-source\n\t// code). It holds the start of the list of Attrs.\n\tfront\t[nAttrsInline]Attr\n\n\t// The number of Attrs in front.\n\tnFront\tint\n\n\t// The list of Attrs except for those in front.\n\t// Invariants:\n\t//   - len(back) \u003e 0 iff nFront == len(front)\n\t//   - Unused array elements are zero. Used to detect mistakes.\n\tback\t[]Attr\n}","func NewRecord(t time.Time, level Level, msg string, pc uintptr) Record","type Source struct {\n\t// Function is the package path-qualified function name containing the\n\t// source line. If non-empty, this string uniquely identifies a single\n\t// function in the program. This may be the empty string if not known.\n\tFunction\tstring\t`json:\"function\"`\n\t// File and Line are the file name and line number (1-based) of the source\n\t// line. These may be the empty string and zero, respectively, if not known.\n\tFile\tstring\t`json:\"file\"`\n\tLine\tint\t`json:\"line\"`\n}","type TextHandler struct {\n\t*commonHandler\n}","func NewTextHandler(w io.Writer, opts *HandlerOptions) *TextHandler","type Value struct {\n\t_\t[0]func()\t// disallow ==\n\t// num holds the value for Kinds Int64, Uint64, Float64, Bool and Duration,\n\t// the string length for KindString, and nanoseconds since the epoch for KindTime.\n\tnum\tuint64\n\t// If any is of type Kind, then the value is in num as described above.\n\t// If any is of type *time.Location, then the Kind is Time and time.Time value\n\t// can be constructed from the Unix nanos in num and the location (monotonic time\n\t// is not preserved).\n\t// If any is of type stringptr, then the Kind is String and the string value\n\t// consists of the length in num and the pointer in any.\n\t// Otherwise, the Kind is Any and any is the value.\n\t// (This implies that Attrs cannot store values of type Kind, *time.Location\n\t// or stringptr.)\n\tany\tany\n}","","const KindAny Kind","const KindBool","const KindDuration","const KindFloat64","const KindInt64","const KindString","const KindTime","const KindUint64","const KindGroup","const KindLogValuer","func StringValue(value string) Value","func IntValue(v int) Value","func Int64Value(v int64) Value","func Uint64Value(v uint64) Value","func Float64Value(v float64) Value","func BoolValue(v bool) Value","func TimeValue(v time.Time) Value","func DurationValue(v time.Duration) Value","func GroupValue(as ...Attr) Value","func AnyValue(v any) Value","type LogValuer interface {\n\tLogValue() Value\n}","","const LOG_EMERG Priority","const LOG_ALERT","const LOG_CRIT","const LOG_ERR","const LOG_WARNING","const LOG_NOTICE","const LOG_INFO","const LOG_DEBUG","const LOG_KERN Priority","const LOG_USER","const LOG_MAIL","const LOG_DAEMON","const LOG_AUTH","const LOG_SYSLOG","const LOG_LPR","const LOG_NEWS","const LOG_UUCP","const LOG_CRON","const LOG_AUTHPRIV","const LOG_FTP","const LOG_LOCAL0","const LOG_LOCAL1","const LOG_LOCAL2","const LOG_LOCAL3","const LOG_LOCAL4","const LOG_LOCAL5","const LOG_LOCAL6","const LOG_LOCAL7","type Writer struct {\n\tpriority\tPriority\n\ttag\t\tstring\n\thostname\tstring\n\tnetwork\t\tstring\n\traddr\t\tstring\n\n\tmu\tsync.Mutex\t// guards conn\n\tconn\tserverConn\n}","func New(priority Priority, tag string) (*Writer, error)","func Dial(network, raddr string, priority Priority, tag string) (*Writer, error)","func NewLogger(p Priority, logFlag int) (*log.Logger, error)","","type Float struct {\n\tprec\tuint32\n\tmode\tRoundingMode\n\tacc\tAccuracy\n\tform\tform\n\tneg\tbool\n\tmant\tnat\n\texp\tint32\n}","type ErrNaN struct {\n\tmsg string\n}","func NewFloat(x float64) *Float","","","","","const ToNearestEven RoundingMode","const ToNearestAway","const ToZero","const AwayFromZero","const ToNegativeInf","const ToPositiveInf","","const Below Accuracy","const Exact Accuracy = 0","const Above Accuracy","func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)","type Int struct {\n\tneg\tbool\t// sign\n\tabs\tnat\t// absolute value of the integer\n}","func NewInt(x int64) *Int","func Jacobi(x, y *Int) int","","type Rat struct {\n\t// To make zero values for Rat work w/o initialization,\n\t// a zero value of b (len(b) == 0) acts like b == 1. At\n\t// the earliest opportunity (when an assignment to the Rat\n\t// is made), such uninitialized denominators are set to 1.\n\t// a.neg determines the sign of the Rat, b.neg is ignored.\n\ta, b Int\n}","func NewRat(a, b int64) *Rat","","func LeadingZeros(x uint) int","func LeadingZeros8(x uint8) int","func LeadingZeros16(x uint16) int","func LeadingZeros32(x uint32) int","func LeadingZeros64(x uint64) int","func TrailingZeros(x uint) int","func TrailingZeros8(x uint8) int","func TrailingZeros16(x uint16) int","func TrailingZeros32(x uint32) int","func TrailingZeros64(x uint64) int","func OnesCount(x uint) int","func OnesCount8(x uint8) int","func OnesCount16(x uint16) int","func OnesCount32(x uint32) int","func OnesCount64(x uint64) int","func RotateLeft(x uint, k int) uint","func RotateLeft8(x uint8, k int) uint8","func RotateLeft16(x uint16, k int) uint16","func RotateLeft32(x uint32, k int) uint32","func RotateLeft64(x uint64, k int) uint64","func Reverse(x uint) uint","func Reverse8(x uint8) uint8","func Reverse16(x uint16) uint16","func Reverse32(x uint32) uint32","func Reverse64(x uint64) uint64","func ReverseBytes(x uint) uint","func ReverseBytes16(x uint16) uint16","func ReverseBytes32(x uint32) uint32","func ReverseBytes64(x uint64) uint64","func Len(x uint) int","func Len8(x uint8) int","func Len16(x uint16) (n int)","func Len32(x uint32) (n int)","func Len64(x uint64) (n int)","func Add(x, y, carry uint) (sum, carryOut uint)","func Add32(x, y, carry uint32) (sum, carryOut uint32)","func Add64(x, y, carry uint64) (sum, carryOut uint64)","func Sub(x, y, borrow uint) (diff, borrowOut uint)","func Sub32(x, y, borrow uint32) (diff, borrowOut uint32)","func Sub64(x, y, borrow uint64) (diff, borrowOut uint64)","func Mul(x, y uint) (hi, lo uint)","func Mul32(x, y uint32) (hi, lo uint32)","func Mul64(x, y uint64) (hi, lo uint64)","func Div(hi, lo, y uint) (quo, rem uint)","func Div32(hi, lo, y uint32) (quo, rem uint32)","func Div64(hi, lo, y uint64) (quo, rem uint64)","func Rem(hi, lo, y uint) uint","func Rem32(hi, lo, y uint32) uint32","func Rem64(hi, lo, y uint64) uint64","func Abs(x complex128) float64","func Asin(x complex128) complex128","func Asinh(x complex128) complex128","func Acos(x complex128) complex128","func Acosh(x complex128) complex128","func Atan(x complex128) complex128","func Atanh(x complex128) complex128","func Conj(x complex128) complex128","func Exp(x complex128) complex128","func IsInf(x complex128) bool","func Inf() complex128","func IsNaN(x complex128) bool","func NaN() complex128","func Log(x complex128) complex128","func Log10(x complex128) complex128","func Phase(x complex128) float64","func Polar(x complex128) (r, θ float64)","func Pow(x, y complex128) complex128","func Rect(r, θ float64) complex128","func Sin(x complex128) complex128","func Sinh(x complex128) complex128","func Cos(x complex128) complex128","func Cosh(x complex128) complex128","func Sqrt(x complex128) complex128","func Tan(x complex128) complex128","func Tanh(x complex128) complex128","func Cot(x complex128) complex128","type Source interface {\n\tInt63() int64\n\tSeed(seed int64)\n}","type Source64 interface {\n\tSource\n\tUint64() uint64\n}","func NewSource(seed int64) Source","type Rand struct {\n\tsrc\tSource\n\ts64\tSource64\t// non-nil if src is source64\n\n\t// readVal contains remainder of 63-bit integer used for bytes\n\t// generation during most recent Read call.\n\t// It is saved so next Read call can start where the previous\n\t// one finished.\n\treadVal\tint64\n\t// readPos indicates the number of low-order bytes of readVal\n\t// that are still valid.\n\treadPos\tint8\n}","func New(src Source) *Rand","func Seed(seed int64)","func Int63() int64","func Uint32() uint32","func Uint64() uint64","func Int31() int32","func Int() int","func Int63n(n int64) int64","func Int31n(n int32) int32","func Intn(n int) int","func Float64() float64","func Float32() float32","func Perm(n int) []int","func Shuffle(n int, swap func(i, j int))","func Read(p []byte) (n int, err error)","func NormFloat64() float64","func ExpFloat64() float64","type Zipf struct {\n\tr\t\t*Rand\n\timax\t\tfloat64\n\tv\t\tfloat64\n\tq\t\tfloat64\n\ts\t\tfloat64\n\toneminusQ\tfloat64\n\toneminusQinv\tfloat64\n\thxm\t\tfloat64\n\thx0minusHxm\tfloat64\n}","func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf","","type Form struct {\n\tValue\tmap[string][]string\n\tFile\tmap[string][]*FileHeader\n}","type FileHeader struct {\n\tFilename\tstring\n\tHeader\t\ttextproto.MIMEHeader\n\tSize\t\tint64\n\n\tcontent\t\t[]byte\n\ttmpfile\t\tstring\n\ttmpoff\t\tint64\n\ttmpshared\tbool\n}","type File interface {\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tio.Closer\n}","type Part struct {\n\t// The headers of the body, if any, with the keys canonicalized\n\t// in the same fashion that the Go http.Request headers are.\n\t// For example, \"foo-bar\" changes case to \"Foo-Bar\"\n\tHeader\ttextproto.MIMEHeader\n\n\tmr\t*Reader\n\n\tdisposition\t\tstring\n\tdispositionParams\tmap[string]string\n\n\t// r is either a reader directly reading from mr, or it's a\n\t// wrapper around such a reader, decoding the\n\t// Content-Transfer-Encoding\n\tr\tio.Reader\n\n\tn\tint\t// known data bytes waiting in mr.bufReader\n\ttotal\tint64\t// total data bytes read already\n\terr\terror\t// error to return when n == 0\n\treadErr\terror\t// read error observed from mr.bufReader\n}","func NewReader(r io.Reader, boundary string) *Reader","type Reader struct {\n\tbufReader\t*bufio.Reader\n\ttempDir\t\tstring\t// used in tests\n\n\tcurrentPart\t*Part\n\tpartsRead\tint\n\n\tnl\t\t\t[]byte\t// \"\\r\\n\" or \"\\n\" (set after seeing first boundary line)\n\tnlDashBoundary\t\t[]byte\t// nl + \"--boundary\"\n\tdashBoundaryDash\t[]byte\t// \"--boundary--\"\n\tdashBoundary\t\t[]byte\t// \"--boundary\"\n}","type Writer struct {\n\tw\t\tio.Writer\n\tboundary\tstring\n\tlastpart\t*part\n}","func NewWriter(w io.Writer) *Writer","type Reader struct {\n\tbr\t*bufio.Reader\n\trerr\terror\t// last read error\n\tline\t[]byte\t// to be consumed before more of br\n}","func NewReader(r io.Reader) *Reader","type Writer struct {\n\t// Binary mode treats the writer's input as pure binary and processes end of\n\t// line bytes as binary data.\n\tBinary\tbool\n\n\tw\tio.Writer\n\ti\tint\n\tline\t[78]byte\n\tcr\tbool\n}","func NewWriter(w io.Writer) *Writer","type Client struct {\n\t// Transport specifies the mechanism by which individual\n\t// HTTP requests are made.\n\t// If nil, DefaultTransport is used.\n\tTransport\tRoundTripper\n\n\t// CheckRedirect specifies the policy for handling redirects.\n\t// If CheckRedirect is not nil, the client calls it before\n\t// following an HTTP redirect. The arguments req and via are\n\t// the upcoming request and the requests made already, oldest\n\t// first. If CheckRedirect returns an error, the Client's Get\n\t// method returns both the previous Response (with its Body\n\t// closed) and CheckRedirect's error (wrapped in a url.Error)\n\t// instead of issuing the Request req.\n\t// As a special case, if CheckRedirect returns ErrUseLastResponse,\n\t// then the most recent response is returned with its body\n\t// unclosed, along with a nil error.\n\t//\n\t// If CheckRedirect is nil, the Client uses its default policy,\n\t// which is to stop after 10 consecutive requests.\n\tCheckRedirect\tfunc(req *Request, via []*Request) error\n\n\t// Jar specifies the cookie jar.\n\t//\n\t// The Jar is used to insert relevant cookies into every\n\t// outbound Request and is updated with the cookie values\n\t// of every inbound Response. The Jar is consulted for every\n\t// redirect that the Client follows.\n\t//\n\t// If Jar is nil, cookies are only sent if they are explicitly\n\t// set on the Request.\n\tJar\tCookieJar\n\n\t// Timeout specifies a time limit for requests made by this\n\t// Client. The timeout includes connection time, any\n\t// redirects, and reading the response body. The timer remains\n\t// running after Get, Head, Post, or Do return and will\n\t// interrupt reading of the Response.Body.\n\t//\n\t// A Timeout of zero means no timeout.\n\t//\n\t// The Client cancels requests to the underlying Transport\n\t// as if the Request's Context ended.\n\t//\n\t// For compatibility, the Client will also use the deprecated\n\t// CancelRequest method on Transport if found. New\n\t// RoundTripper implementations should use the Request's Context\n\t// for cancellation instead of implementing CancelRequest.\n\tTimeout\ttime.Duration\n}","","type RoundTripper interface {\n\t// RoundTrip executes a single HTTP transaction, returning\n\t// a Response for the provided Request.\n\t//\n\t// RoundTrip should not attempt to interpret the response. In\n\t// particular, RoundTrip must return err == nil if it obtained\n\t// a response, regardless of the response's HTTP status code.\n\t// A non-nil err should be reserved for failure to obtain a\n\t// response. Similarly, RoundTrip should not attempt to\n\t// handle higher-level protocol details such as redirects,\n\t// authentication, or cookies.\n\t//\n\t// RoundTrip should not modify the request, except for\n\t// consuming and closing the Request's Body. RoundTrip may\n\t// read fields of the request in a separate goroutine. Callers\n\t// should not mutate or reuse the request until the Response's\n\t// Body has been closed.\n\t//\n\t// RoundTrip must always close the body, including on errors,\n\t// but depending on the implementation may do so in a separate\n\t// goroutine even after RoundTrip returns. This means that\n\t// callers wanting to reuse the body for subsequent requests\n\t// must arrange to wait for the Close call before doing so.\n\t//\n\t// The Request's URL and Header fields must be initialized.\n\tRoundTrip(*Request) (*Response, error)\n}","","func Get(url string) (resp *Response, err error)","","func Post(url, contentType string, body io.Reader) (resp *Response, err error)","func PostForm(url string, data url.Values) (resp *Response, err error)","func Head(url string) (resp *Response, err error)","type Cookie struct {\n\tName\tstring\n\tValue\tstring\n\tQuoted\tbool\t// indicates whether the Value was originally quoted\n\n\tPath\t\tstring\t\t// optional\n\tDomain\t\tstring\t\t// optional\n\tExpires\t\ttime.Time\t// optional\n\tRawExpires\tstring\t\t// for reading cookies only\n\n\t// MaxAge=0 means no 'Max-Age' attribute specified.\n\t// MaxAge\u003c0 means delete cookie now, equivalently 'Max-Age: 0'\n\t// MaxAge\u003e0 means Max-Age attribute present and given in seconds\n\tMaxAge\t\tint\n\tSecure\t\tbool\n\tHttpOnly\tbool\n\tSameSite\tSameSite\n\tPartitioned\tbool\n\tRaw\t\tstring\n\tUnparsed\t[]string\t// Raw text of unparsed attribute-value pairs\n}","","const SameSiteDefaultMode SameSite","const SameSiteLaxMode","const SameSiteStrictMode","const SameSiteNoneMode","func ParseCookie(line string) ([]*Cookie, error)","func ParseSetCookie(line string) (*Cookie, error)","func SetCookie(w ResponseWriter, cookie *Cookie)","func NewFileTransport(fs FileSystem) RoundTripper","func NewFileTransportFS(fsys fs.FS) RoundTripper","","type FileSystem interface {\n\tOpen(name string) (File, error)\n}","type File interface {\n\tio.Closer\n\tio.Reader\n\tio.Seeker\n\tReaddir(count int) ([]fs.FileInfo, error)\n\tStat() (fs.FileInfo, error)\n}","func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)","func ServeFile(w ResponseWriter, r *Request, name string)","func ServeFileFS(w ResponseWriter, r *Request, fsys fs.FS, name string)","func FS(fsys fs.FS) FileSystem","func FileServer(root FileSystem) Handler","func FileServerFS(root fs.FS) Handler","type Header map[string][]string","func ParseTime(text string) (t time.Time, err error)","func CanonicalHeaderKey(s string) string","","type PushOptions struct {\n\t// Method specifies the HTTP method for the promised request.\n\t// If set, it must be \"GET\" or \"HEAD\". Empty means \"GET\".\n\tMethod\tstring\n\n\t// Header specifies additional promised request headers. This cannot\n\t// include HTTP/2 pseudo header fields like \":path\" and \":scheme\",\n\t// which will be added automatically.\n\tHeader\tHeader\n}","type Pusher interface {\n\t// Push initiates an HTTP/2 server push. This constructs a synthetic\n\t// request using the given target and options, serializes that request\n\t// into a PUSH_PROMISE frame, then dispatches that request using the\n\t// server's request handler. If opts is nil, default options are used.\n\t//\n\t// The target must either be an absolute path (like \"/path\") or an absolute\n\t// URL that contains a valid host and the same scheme as the parent request.\n\t// If the target is a path, it will inherit the scheme and host of the\n\t// parent request.\n\t//\n\t// The HTTP/2 spec disallows recursive pushes and cross-authority pushes.\n\t// Push may or may not detect these invalid pushes; however, invalid\n\t// pushes will be detected and canceled by conforming clients.\n\t//\n\t// Handlers that wish to push URL X should call Push before sending any\n\t// data that may trigger a request for URL X. This avoids a race where the\n\t// client issues requests for X before receiving the PUSH_PROMISE for X.\n\t//\n\t// Push will run in a separate goroutine making the order of arrival\n\t// non-deterministic. Any required synchronization needs to be implemented\n\t// by the caller.\n\t//\n\t// Push returns ErrNotSupported if the client has disabled push or if push\n\t// is not supported on the underlying connection.\n\tPush(target string, opts *PushOptions) error\n}","type CookieJar interface {\n\t// SetCookies handles the receipt of the cookies in a reply for the\n\t// given URL.  It may or may not choose to save the cookies, depending\n\t// on the jar's policy and implementation.\n\tSetCookies(u *url.URL, cookies []*Cookie)\n\n\t// Cookies returns the cookies to send in a request for the given URL.\n\t// It is up to the implementation to honor the standard cookie use\n\t// restrictions such as in RFC 6265.\n\tCookies(u *url.URL) []*Cookie\n}","const MethodGet = \"GET\"","const MethodHead = \"HEAD\"","const MethodPost = \"POST\"","const MethodPut = \"PUT\"","const MethodPatch = \"PATCH\"","const MethodDelete = \"DELETE\"","const MethodConnect = \"CONNECT\"","const MethodOptions = \"OPTIONS\"","const MethodTrace = \"TRACE\"","","type ProtocolError struct {\n\tErrorString string\n}","","","","","","","","type Request struct {\n\t// Method specifies the HTTP method (GET, POST, PUT, etc.).\n\t// For client requests, an empty string means GET.\n\tMethod\tstring\n\n\t// URL specifies either the URI being requested (for server\n\t// requests) or the URL to access (for client requests).\n\t//\n\t// For server requests, the URL is parsed from the URI\n\t// supplied on the Request-Line as stored in RequestURI.  For\n\t// most requests, fields other than Path and RawQuery will be\n\t// empty. (See RFC 7230, Section 5.3)\n\t//\n\t// For client requests, the URL's Host specifies the server to\n\t// connect to, while the Request's Host field optionally\n\t// specifies the Host header value to send in the HTTP\n\t// request.\n\tURL\t*url.URL\n\n\t// The protocol version for incoming server requests.\n\t//\n\t// For client requests, these fields are ignored. The HTTP\n\t// client code always uses either HTTP/1.1 or HTTP/2.\n\t// See the docs on Transport for details.\n\tProto\t\tstring\t// \"HTTP/1.0\"\n\tProtoMajor\tint\t// 1\n\tProtoMinor\tint\t// 0\n\n\t// Header contains the request header fields either received\n\t// by the server or to be sent by the client.\n\t//\n\t// If a server received a request with header lines,\n\t//\n\t//\tHost: example.com\n\t//\taccept-encoding: gzip, deflate\n\t//\tAccept-Language: en-us\n\t//\tfOO: Bar\n\t//\tfoo: two\n\t//\n\t// then\n\t//\n\t//\tHeader = map[string][]string{\n\t//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n\t//\t\t\"Accept-Language\": {\"en-us\"},\n\t//\t\t\"Foo\": {\"Bar\", \"two\"},\n\t//\t}\n\t//\n\t// For incoming requests, the Host header is promoted to the\n\t// Request.Host field and removed from the Header map.\n\t//\n\t// HTTP defines that header names are case-insensitive. The\n\t// request parser implements this by using CanonicalHeaderKey,\n\t// making the first character and any characters following a\n\t// hyphen uppercase and the rest lowercase.\n\t//\n\t// For client requests, certain headers such as Content-Length\n\t// and Connection are automatically written when needed and\n\t// values in Header may be ignored. See the documentation\n\t// for the Request.Write method.\n\tHeader\tHeader\n\n\t// Body is the request's body.\n\t//\n\t// For client requests, a nil body means the request has no\n\t// body, such as a GET request. The HTTP Client's Transport\n\t// is responsible for calling the Close method.\n\t//\n\t// For server requests, the Request Body is always non-nil\n\t// but will return EOF immediately when no body is present.\n\t// The Server will close the request body. The ServeHTTP\n\t// Handler does not need to.\n\t//\n\t// Body must allow Read to be called concurrently with Close.\n\t// In particular, calling Close should unblock a Read waiting\n\t// for input.\n\tBody\tio.ReadCloser\n\n\t// GetBody defines an optional func to return a new copy of\n\t// Body. It is used for client requests when a redirect requires\n\t// reading the body more than once. Use of GetBody still\n\t// requires setting Body.\n\t//\n\t// For server requests, it is unused.\n\tGetBody\tfunc() (io.ReadCloser, error)\n\n\t// ContentLength records the length of the associated content.\n\t// The value -1 indicates that the length is unknown.\n\t// Values \u003e= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\t//\n\t// For client requests, a value of 0 with a non-nil Body is\n\t// also treated as unknown.\n\tContentLength\tint64\n\n\t// TransferEncoding lists the transfer encodings from outermost to\n\t// innermost. An empty list denotes the \"identity\" encoding.\n\t// TransferEncoding can usually be ignored; chunked encoding is\n\t// automatically added and removed as necessary when sending and\n\t// receiving requests.\n\tTransferEncoding\t[]string\n\n\t// Close indicates whether to close the connection after\n\t// replying to this request (for servers) or after sending this\n\t// request and reading its response (for clients).\n\t//\n\t// For server requests, the HTTP server handles this automatically\n\t// and this field is not needed by Handlers.\n\t//\n\t// For client requests, setting this field prevents re-use of\n\t// TCP connections between requests to the same hosts, as if\n\t// Transport.DisableKeepAlives were set.\n\tClose\tbool\n\n\t// For server requests, Host specifies the host on which the\n\t// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this\n\t// is either the value of the \"Host\" header or the host name\n\t// given in the URL itself. For HTTP/2, it is the value of the\n\t// \":authority\" pseudo-header field.\n\t// It may be of the form \"host:port\". For international domain\n\t// names, Host may be in Punycode or Unicode form. Use\n\t// golang.org/x/net/idna to convert it to either format if\n\t// needed.\n\t// To prevent DNS rebinding attacks, server Handlers should\n\t// validate that the Host header has a value for which the\n\t// Handler considers itself authoritative. The included\n\t// ServeMux supports patterns registered to particular host\n\t// names and thus protects its registered Handlers.\n\t//\n\t// For client requests, Host optionally overrides the Host\n\t// header to send. If empty, the Request.Write method uses\n\t// the value of URL.Host. Host may contain an international\n\t// domain name.\n\tHost\tstring\n\n\t// Form contains the parsed form data, including both the URL\n\t// field's query parameters and the PATCH, POST, or PUT form data.\n\t// This field is only available after ParseForm is called.\n\t// The HTTP client ignores Form and uses Body instead.\n\tForm\turl.Values\n\n\t// PostForm contains the parsed form data from PATCH, POST\n\t// or PUT body parameters.\n\t//\n\t// This field is only available after ParseForm is called.\n\t// The HTTP client ignores PostForm and uses Body instead.\n\tPostForm\turl.Values\n\n\t// MultipartForm is the parsed multipart form, including file uploads.\n\t// This field is only available after ParseMultipartForm is called.\n\t// The HTTP client ignores MultipartForm and uses Body instead.\n\tMultipartForm\t*multipart.Form\n\n\t// Trailer specifies additional headers that are sent after the request\n\t// body.\n\t//\n\t// For server requests, the Trailer map initially contains only the\n\t// trailer keys, with nil values. (The client declares which trailers it\n\t// will later send.)  While the handler is reading from Body, it must\n\t// not reference Trailer. After reading from Body returns EOF, Trailer\n\t// can be read again and will contain non-nil values, if they were sent\n\t// by the client.\n\t//\n\t// For client requests, Trailer must be initialized to a map containing\n\t// the trailer keys to later send. The values may be nil or their final\n\t// values. The ContentLength must be 0 or -1, to send a chunked request.\n\t// After the HTTP request is sent the map values can be updated while\n\t// the request body is read. Once the body returns EOF, the caller must\n\t// not mutate Trailer.\n\t//\n\t// Few HTTP clients, servers, or proxies support HTTP trailers.\n\tTrailer\tHeader\n\n\t// RemoteAddr allows HTTP servers and other software to record\n\t// the network address that sent the request, usually for\n\t// logging. This field is not filled in by ReadRequest and\n\t// has no defined format. The HTTP server in this package\n\t// sets RemoteAddr to an \"IP:port\" address before invoking a\n\t// handler.\n\t// This field is ignored by the HTTP client.\n\tRemoteAddr\tstring\n\n\t// RequestURI is the unmodified request-target of the\n\t// Request-Line (RFC 7230, Section 3.1.1) as sent by the client\n\t// to a server. Usually the URL field should be used instead.\n\t// It is an error to set this field in an HTTP client request.\n\tRequestURI\tstring\n\n\t// TLS allows HTTP servers and other software to record\n\t// information about the TLS connection on which the request\n\t// was received. This field is not filled in by ReadRequest.\n\t// The HTTP server in this package sets the field for\n\t// TLS-enabled connections before invoking a handler;\n\t// otherwise it leaves the field nil.\n\t// This field is ignored by the HTTP client.\n\tTLS\t*tls.ConnectionState\n\n\t// Cancel is an optional channel whose closure indicates that the client\n\t// request should be regarded as canceled. Not all implementations of\n\t// RoundTripper may support Cancel.\n\t//\n\t// For server requests, this field is not applicable.\n\t//\n\t// Deprecated: Set the Request's context with NewRequestWithContext\n\t// instead. If a Request's Cancel field and context are both\n\t// set, it is undefined whether Cancel is respected.\n\tCancel\t\u003c-chan struct{}\n\n\t// Response is the redirect response which caused this request\n\t// to be created. This field is only populated during client\n\t// redirects.\n\tResponse\t*Response\n\n\t// Pattern is the [ServeMux] pattern that matched the request.\n\t// It is empty if the request was not matched against a pattern.\n\tPattern\tstring\n\n\t// ctx is either the client or server context. It should only\n\t// be modified via copying the whole Request using Clone or WithContext.\n\t// It is unexported to prevent people from using Context wrong\n\t// and mutating the contexts held by callers of the same request.\n\tctx\tcontext.Context\n\n\t// The following fields are for requests matched by ServeMux.\n\tpat\t\t*pattern\t\t// the pattern that matched\n\tmatches\t\t[]string\t\t// values for the matching wildcards in pat\n\totherValues\tmap[string]string\t// for calls to SetPathValue that don't match a wildcard\n}","","func ParseHTTPVersion(vers string) (major, minor int, ok bool)","func NewRequest(method, url string, body io.Reader) (*Request, error)","func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)","func ReadRequest(b *bufio.Reader) (*Request, error)","func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser","type MaxBytesError struct {\n\tLimit int64\n}","type Response struct {\n\tStatus\t\tstring\t// e.g. \"200 OK\"\n\tStatusCode\tint\t// e.g. 200\n\tProto\t\tstring\t// e.g. \"HTTP/1.0\"\n\tProtoMajor\tint\t// e.g. 1\n\tProtoMinor\tint\t// e.g. 0\n\n\t// Header maps header keys to values. If the response had multiple\n\t// headers with the same key, they may be concatenated, with comma\n\t// delimiters.  (RFC 7230, section 3.2.2 requires that multiple headers\n\t// be semantically equivalent to a comma-delimited sequence.) When\n\t// Header values are duplicated by other fields in this struct (e.g.,\n\t// ContentLength, TransferEncoding, Trailer), the field values are\n\t// authoritative.\n\t//\n\t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n\tHeader\tHeader\n\n\t// Body represents the response body.\n\t//\n\t// The response body is streamed on demand as the Body field\n\t// is read. If the network connection fails or the server\n\t// terminates the response, Body.Read calls return an error.\n\t//\n\t// The http Client and Transport guarantee that Body is always\n\t// non-nil, even on responses without a body or responses with\n\t// a zero-length body. It is the caller's responsibility to\n\t// close Body. The default HTTP client's Transport may not\n\t// reuse HTTP/1.x \"keep-alive\" TCP connections if the Body is\n\t// not read to completion and closed.\n\t//\n\t// The Body is automatically dechunked if the server replied\n\t// with a \"chunked\" Transfer-Encoding.\n\t//\n\t// As of Go 1.12, the Body will also implement io.Writer\n\t// on a successful \"101 Switching Protocols\" response,\n\t// as used by WebSockets and HTTP/2's \"h2c\" mode.\n\tBody\tio.ReadCloser\n\n\t// ContentLength records the length of the associated content. The\n\t// value -1 indicates that the length is unknown. Unless Request.Method\n\t// is \"HEAD\", values \u003e= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\tContentLength\tint64\n\n\t// Contains transfer encodings from outer-most to inner-most. Value is\n\t// nil, means that \"identity\" encoding is used.\n\tTransferEncoding\t[]string\n\n\t// Close records whether the header directed that the connection be\n\t// closed after reading Body. The value is advice for clients: neither\n\t// ReadResponse nor Response.Write ever closes a connection.\n\tClose\tbool\n\n\t// Uncompressed reports whether the response was sent compressed but\n\t// was decompressed by the http package. When true, reading from\n\t// Body yields the uncompressed content instead of the compressed\n\t// content actually set from the server, ContentLength is set to -1,\n\t// and the \"Content-Length\" and \"Content-Encoding\" fields are deleted\n\t// from the responseHeader. To get the original response from\n\t// the server, set Transport.DisableCompression to true.\n\tUncompressed\tbool\n\n\t// Trailer maps trailer keys to values in the same\n\t// format as Header.\n\t//\n\t// The Trailer initially contains only nil values, one for\n\t// each key specified in the server's \"Trailer\" header\n\t// value. Those values are not added to Header.\n\t//\n\t// Trailer must not be accessed concurrently with Read calls\n\t// on the Body.\n\t//\n\t// After Body.Read has returned io.EOF, Trailer will contain\n\t// any trailer values sent by the server.\n\tTrailer\tHeader\n\n\t// Request is the request that was sent to obtain this Response.\n\t// Request's Body is nil (having already been consumed).\n\t// This is only populated for Client requests.\n\tRequest\t*Request\n\n\t// TLS contains information about the TLS connection on which the\n\t// response was received. It is nil for unencrypted responses.\n\t// The pointer is shared between responses and should not be\n\t// modified.\n\tTLS\t*tls.ConnectionState\n}","","func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)","type ResponseController struct {\n\trw ResponseWriter\n}","func NewResponseController(rw ResponseWriter) *ResponseController","","","","","type Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}","type ResponseWriter interface {\n\t// Header returns the header map that will be sent by\n\t// [ResponseWriter.WriteHeader]. The [Header] map also is the mechanism with which\n\t// [Handler] implementations can set HTTP trailers.\n\t//\n\t// Changing the header map after a call to [ResponseWriter.WriteHeader] (or\n\t// [ResponseWriter.Write]) has no effect unless the HTTP status code was of the\n\t// 1xx class or the modified headers are trailers.\n\t//\n\t// There are two ways to set Trailers. The preferred way is to\n\t// predeclare in the headers which trailers you will later\n\t// send by setting the \"Trailer\" header to the names of the\n\t// trailer keys which will come later. In this case, those\n\t// keys of the Header map are treated as if they were\n\t// trailers. See the example. The second way, for trailer\n\t// keys not known to the [Handler] until after the first [ResponseWriter.Write],\n\t// is to prefix the [Header] map keys with the [TrailerPrefix]\n\t// constant value.\n\t//\n\t// To suppress automatic response headers (such as \"Date\"), set\n\t// their value to nil.\n\tHeader() Header\n\n\t// Write writes the data to the connection as part of an HTTP reply.\n\t//\n\t// If [ResponseWriter.WriteHeader] has not yet been called, Write calls\n\t// WriteHeader(http.StatusOK) before writing the data. If the Header\n\t// does not contain a Content-Type line, Write adds a Content-Type set\n\t// to the result of passing the initial 512 bytes of written data to\n\t// [DetectContentType]. Additionally, if the total size of all written\n\t// data is under a few KB and there are no Flush calls, the\n\t// Content-Length header is added automatically.\n\t//\n\t// Depending on the HTTP protocol version and the client, calling\n\t// Write or WriteHeader may prevent future reads on the\n\t// Request.Body. For HTTP/1.x requests, handlers should read any\n\t// needed request body data before writing the response. Once the\n\t// headers have been flushed (due to either an explicit Flusher.Flush\n\t// call or writing enough data to trigger a flush), the request body\n\t// may be unavailable. For HTTP/2 requests, the Go HTTP server permits\n\t// handlers to continue to read the request body while concurrently\n\t// writing the response. However, such behavior may not be supported\n\t// by all HTTP/2 clients. Handlers should read before writing if\n\t// possible to maximize compatibility.\n\tWrite([]byte) (int, error)\n\n\t// WriteHeader sends an HTTP response header with the provided\n\t// status code.\n\t//\n\t// If WriteHeader is not called explicitly, the first call to Write\n\t// will trigger an implicit WriteHeader(http.StatusOK).\n\t// Thus explicit calls to WriteHeader are mainly used to\n\t// send error codes or 1xx informational responses.\n\t//\n\t// The provided code must be a valid HTTP 1xx-5xx status code.\n\t// Any number of 1xx headers may be written, followed by at most\n\t// one 2xx-5xx header. 1xx headers are sent immediately, but 2xx-5xx\n\t// headers may be buffered. Use the Flusher interface to send\n\t// buffered data. The header map is cleared when 2xx-5xx headers are\n\t// sent, but not with 1xx headers.\n\t//\n\t// The server will automatically send a 100 (Continue) header\n\t// on the first read from the request body if the request has\n\t// an \"Expect: 100-continue\" header.\n\tWriteHeader(statusCode int)\n}","type Flusher interface {\n\t// Flush sends any buffered data to the client.\n\tFlush()\n}","type Hijacker interface {\n\t// Hijack lets the caller take over the connection.\n\t// After a call to Hijack the HTTP server library\n\t// will not do anything else with the connection.\n\t//\n\t// It becomes the caller's responsibility to manage\n\t// and close the connection.\n\t//\n\t// The returned net.Conn may have read or write deadlines\n\t// already set, depending on the configuration of the\n\t// Server. It is the caller's responsibility to set\n\t// or clear those deadlines as needed.\n\t//\n\t// The returned bufio.Reader may contain unprocessed buffered\n\t// data from the client.\n\t//\n\t// After a call to Hijack, the original Request.Body must not\n\t// be used. The original Request's Context remains valid and\n\t// is not canceled until the Request's ServeHTTP method\n\t// returns.\n\tHijack() (net.Conn, *bufio.ReadWriter, error)\n}","type CloseNotifier interface {\n\t// CloseNotify returns a channel that receives at most a\n\t// single value (true) when the client connection has gone\n\t// away.\n\t//\n\t// CloseNotify may wait to notify until Request.Body has been\n\t// fully read.\n\t//\n\t// After the Handler has returned, there is no guarantee\n\t// that the channel receives a value.\n\t//\n\t// If the protocol is HTTP/1.1 and CloseNotify is called while\n\t// processing an idempotent request (such as GET) while\n\t// HTTP/1.1 pipelining is in use, the arrival of a subsequent\n\t// pipelined request may cause a value to be sent on the\n\t// returned channel. In practice HTTP/1.1 pipelining is not\n\t// enabled in browsers and not seen often in the wild. If this\n\t// is a problem, use HTTP/2 or only use CloseNotify on methods\n\t// such as POST.\n\tCloseNotify() \u003c-chan bool\n}","","","const TrailerPrefix = \"Trailer:\"","","const TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\"","","type HandlerFunc func(ResponseWriter, *Request)","func Error(w ResponseWriter, error string, code int)","func NotFound(w ResponseWriter, r *Request)","func NotFoundHandler() Handler","func StripPrefix(prefix string, h Handler) Handler","func Redirect(w ResponseWriter, r *Request, url string, code int)","func RedirectHandler(url string, code int) Handler","type ServeMux struct {\n\tmu\t\tsync.RWMutex\n\ttree\t\troutingNode\n\tindex\t\troutingIndex\n\tpatterns\t[]*pattern\t// TODO(jba): remove if possible\n\tmux121\t\tserveMux121\t// used only when GODEBUG=httpmuxgo121=1\n}","func NewServeMux() *ServeMux","","func Handle(pattern string, handler Handler)","func HandleFunc(pattern string, handler func(ResponseWriter, *Request))","func Serve(l net.Listener, handler Handler) error","func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error","type Server struct {\n\t// Addr optionally specifies the TCP address for the server to listen on,\n\t// in the form \"host:port\". If empty, \":http\" (port 80) is used.\n\t// The service names are defined in RFC 6335 and assigned by IANA.\n\t// See net.Dial for details of the address format.\n\tAddr\tstring\n\n\tHandler\tHandler\t// handler to invoke, http.DefaultServeMux if nil\n\n\t// DisableGeneralOptionsHandler, if true, passes \"OPTIONS *\" requests to the Handler,\n\t// otherwise responds with 200 OK and Content-Length: 0.\n\tDisableGeneralOptionsHandler\tbool\n\n\t// TLSConfig optionally provides a TLS configuration for use\n\t// by ServeTLS and ListenAndServeTLS. Note that this value is\n\t// cloned by ServeTLS and ListenAndServeTLS, so it's not\n\t// possible to modify the configuration with methods like\n\t// tls.Config.SetSessionTicketKeys. To use\n\t// SetSessionTicketKeys, use Server.Serve with a TLS Listener\n\t// instead.\n\tTLSConfig\t*tls.Config\n\n\t// ReadTimeout is the maximum duration for reading the entire\n\t// request, including the body. A zero or negative value means\n\t// there will be no timeout.\n\t//\n\t// Because ReadTimeout does not let Handlers make per-request\n\t// decisions on each request body's acceptable deadline or\n\t// upload rate, most users will prefer to use\n\t// ReadHeaderTimeout. It is valid to use them both.\n\tReadTimeout\ttime.Duration\n\n\t// ReadHeaderTimeout is the amount of time allowed to read\n\t// request headers. The connection's read deadline is reset\n\t// after reading the headers and the Handler can decide what\n\t// is considered too slow for the body. If zero, the value of\n\t// ReadTimeout is used. If negative, or if zero and ReadTimeout\n\t// is zero or negative, there is no timeout.\n\tReadHeaderTimeout\ttime.Duration\n\n\t// WriteTimeout is the maximum duration before timing out\n\t// writes of the response. It is reset whenever a new\n\t// request's header is read. Like ReadTimeout, it does not\n\t// let Handlers make decisions on a per-request basis.\n\t// A zero or negative value means there will be no timeout.\n\tWriteTimeout\ttime.Duration\n\n\t// IdleTimeout is the maximum amount of time to wait for the\n\t// next request when keep-alives are enabled. If zero, the value\n\t// of ReadTimeout is used. If negative, or if zero and ReadTimeout\n\t// is zero or negative, there is no timeout.\n\tIdleTimeout\ttime.Duration\n\n\t// MaxHeaderBytes controls the maximum number of bytes the\n\t// server will read parsing the request header's keys and\n\t// values, including the request line. It does not limit the\n\t// size of the request body.\n\t// If zero, DefaultMaxHeaderBytes is used.\n\tMaxHeaderBytes\tint\n\n\t// TLSNextProto optionally specifies a function to take over\n\t// ownership of the provided TLS connection when an ALPN\n\t// protocol upgrade has occurred. The map key is the protocol\n\t// name negotiated. The Handler argument should be used to\n\t// handle HTTP requests and will initialize the Request's TLS\n\t// and RemoteAddr if not already set. The connection is\n\t// automatically closed when the function returns.\n\t// If TLSNextProto is not nil, HTTP/2 support is not enabled\n\t// automatically.\n\tTLSNextProto\tmap[string]func(*Server, *tls.Conn, Handler)\n\n\t// ConnState specifies an optional callback function that is\n\t// called when a client connection changes state. See the\n\t// ConnState type and associated constants for details.\n\tConnState\tfunc(net.Conn, ConnState)\n\n\t// ErrorLog specifies an optional logger for errors accepting\n\t// connections, unexpected behavior from handlers, and\n\t// underlying FileSystem errors.\n\t// If nil, logging is done via the log package's standard logger.\n\tErrorLog\t*log.Logger\n\n\t// BaseContext optionally specifies a function that returns\n\t// the base context for incoming requests on this server.\n\t// The provided Listener is the specific Listener that's\n\t// about to start accepting requests.\n\t// If BaseContext is nil, the default is context.Background().\n\t// If non-nil, it must return a non-nil context.\n\tBaseContext\tfunc(net.Listener) context.Context\n\n\t// ConnContext optionally specifies a function that modifies\n\t// the context used for a new connection c. The provided ctx\n\t// is derived from the base context and has a ServerContextKey\n\t// value.\n\tConnContext\tfunc(ctx context.Context, c net.Conn) context.Context\n\n\tinShutdown\tatomic.Bool\t// true when server is in shutdown\n\n\tdisableKeepAlives\tatomic.Bool\n\tnextProtoOnce\t\tsync.Once\t// guards setupHTTP2_* init\n\tnextProtoErr\t\terror\t\t// result of http2.ConfigureServer if used\n\n\tmu\t\tsync.Mutex\n\tlisteners\tmap[*net.Listener]struct{}\n\tactiveConn\tmap[*conn]struct{}\n\tonShutdown\t[]func()\n\n\tlistenerGroup\tsync.WaitGroup\n}","","const StateNew ConnState","const StateActive","const StateIdle","const StateHijacked","const StateClosed","func AllowQuerySemicolons(h Handler) Handler","","func ListenAndServe(addr string, handler Handler) error","func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error","func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler","","func MaxBytesHandler(h Handler, n int64) Handler","func DetectContentType(data []byte) string","const StatusContinue = 100","const StatusSwitchingProtocols = 101","const StatusProcessing = 102","const StatusEarlyHints = 103","const StatusOK = 200","const StatusCreated = 201","const StatusAccepted = 202","const StatusNonAuthoritativeInfo = 203","const StatusNoContent = 204","const StatusResetContent = 205","const StatusPartialContent = 206","const StatusMultiStatus = 207","const StatusAlreadyReported = 208","const StatusIMUsed = 226","const StatusMultipleChoices = 300","const StatusMovedPermanently = 301","const StatusFound = 302","const StatusSeeOther = 303","const StatusNotModified = 304","const StatusUseProxy = 305","const StatusTemporaryRedirect = 307","const StatusPermanentRedirect = 308","const StatusBadRequest = 400","const StatusUnauthorized = 401","const StatusPaymentRequired = 402","const StatusForbidden = 403","const StatusNotFound = 404","const StatusMethodNotAllowed = 405","const StatusNotAcceptable = 406","const StatusProxyAuthRequired = 407","const StatusRequestTimeout = 408","const StatusConflict = 409","const StatusGone = 410","const StatusLengthRequired = 411","const StatusPreconditionFailed = 412","const StatusRequestEntityTooLarge = 413","const StatusRequestURITooLong = 414","const StatusUnsupportedMediaType = 415","const StatusRequestedRangeNotSatisfiable = 416","const StatusExpectationFailed = 417","const StatusTeapot = 418","const StatusMisdirectedRequest = 421","const StatusUnprocessableEntity = 422","const StatusLocked = 423","const StatusFailedDependency = 424","const StatusTooEarly = 425","const StatusUpgradeRequired = 426","const StatusPreconditionRequired = 428","const StatusTooManyRequests = 429","const StatusRequestHeaderFieldsTooLarge = 431","const StatusUnavailableForLegalReasons = 451","const StatusInternalServerError = 500","const StatusNotImplemented = 501","const StatusBadGateway = 502","const StatusServiceUnavailable = 503","const StatusGatewayTimeout = 504","const StatusHTTPVersionNotSupported = 505","const StatusVariantAlsoNegotiates = 506","const StatusInsufficientStorage = 507","const StatusLoopDetected = 508","const StatusNotExtended = 510","const StatusNetworkAuthenticationRequired = 511","func StatusText(code int) string","","","var DefaultTransport RoundTripper","const DefaultMaxIdleConnsPerHost = 2","type Transport struct {\n\tidleMu\t\tsync.Mutex\n\tcloseIdle\tbool\t\t\t\t\t// user has requested to close all idle conns\n\tidleConn\tmap[connectMethodKey][]*persistConn\t// most recently used at end\n\tidleConnWait\tmap[connectMethodKey]wantConnQueue\t// waiting getConns\n\tidleLRU\t\tconnLRU\n\n\treqMu\t\tsync.Mutex\n\treqCanceler\tmap[*Request]context.CancelCauseFunc\n\n\taltMu\t\tsync.Mutex\t// guards changing altProto only\n\taltProto\tatomic.Value\t// of nil or map[string]RoundTripper, key is URI scheme\n\n\tconnsPerHostMu\t\tsync.Mutex\n\tconnsPerHost\t\tmap[connectMethodKey]int\n\tconnsPerHostWait\tmap[connectMethodKey]wantConnQueue\t// waiting getConns\n\tdialsInProgress\t\twantConnQueue\n\n\t// Proxy specifies a function to return a proxy for a given\n\t// Request. If the function returns a non-nil error, the\n\t// request is aborted with the provided error.\n\t//\n\t// The proxy type is determined by the URL scheme. \"http\",\n\t// \"https\", \"socks5\", and \"socks5h\" are supported. If the scheme is empty,\n\t// \"http\" is assumed.\n\t// \"socks5\" is treated the same as \"socks5h\".\n\t//\n\t// If the proxy URL contains a userinfo subcomponent,\n\t// the proxy request will pass the username and password\n\t// in a Proxy-Authorization header.\n\t//\n\t// If Proxy is nil or returns a nil *URL, no proxy is used.\n\tProxy\tfunc(*Request) (*url.URL, error)\n\n\t// OnProxyConnectResponse is called when the Transport gets an HTTP response from\n\t// a proxy for a CONNECT request. It's called before the check for a 200 OK response.\n\t// If it returns an error, the request fails with that error.\n\tOnProxyConnectResponse\tfunc(ctx context.Context, proxyURL *url.URL, connectReq *Request, connectRes *Response) error\n\n\t// DialContext specifies the dial function for creating unencrypted TCP connections.\n\t// If DialContext is nil (and the deprecated Dial below is also nil),\n\t// then the transport dials using package net.\n\t//\n\t// DialContext runs concurrently with calls to RoundTrip.\n\t// A RoundTrip call that initiates a dial may end up using\n\t// a connection dialed previously when the earlier connection\n\t// becomes idle before the later DialContext completes.\n\tDialContext\tfunc(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// Dial specifies the dial function for creating unencrypted TCP connections.\n\t//\n\t// Dial runs concurrently with calls to RoundTrip.\n\t// A RoundTrip call that initiates a dial may end up using\n\t// a connection dialed previously when the earlier connection\n\t// becomes idle before the later Dial completes.\n\t//\n\t// Deprecated: Use DialContext instead, which allows the transport\n\t// to cancel dials as soon as they are no longer needed.\n\t// If both are set, DialContext takes priority.\n\tDial\tfunc(network, addr string) (net.Conn, error)\n\n\t// DialTLSContext specifies an optional dial function for creating\n\t// TLS connections for non-proxied HTTPS requests.\n\t//\n\t// If DialTLSContext is nil (and the deprecated DialTLS below is also nil),\n\t// DialContext and TLSClientConfig are used.\n\t//\n\t// If DialTLSContext is set, the Dial and DialContext hooks are not used for HTTPS\n\t// requests and the TLSClientConfig and TLSHandshakeTimeout\n\t// are ignored. The returned net.Conn is assumed to already be\n\t// past the TLS handshake.\n\tDialTLSContext\tfunc(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// DialTLS specifies an optional dial function for creating\n\t// TLS connections for non-proxied HTTPS requests.\n\t//\n\t// Deprecated: Use DialTLSContext instead, which allows the transport\n\t// to cancel dials as soon as they are no longer needed.\n\t// If both are set, DialTLSContext takes priority.\n\tDialTLS\tfunc(network, addr string) (net.Conn, error)\n\n\t// TLSClientConfig specifies the TLS configuration to use with\n\t// tls.Client.\n\t// If nil, the default configuration is used.\n\t// If non-nil, HTTP/2 support may not be enabled by default.\n\tTLSClientConfig\t*tls.Config\n\n\t// TLSHandshakeTimeout specifies the maximum amount of time to\n\t// wait for a TLS handshake. Zero means no timeout.\n\tTLSHandshakeTimeout\ttime.Duration\n\n\t// DisableKeepAlives, if true, disables HTTP keep-alives and\n\t// will only use the connection to the server for a single\n\t// HTTP request.\n\t//\n\t// This is unrelated to the similarly named TCP keep-alives.\n\tDisableKeepAlives\tbool\n\n\t// DisableCompression, if true, prevents the Transport from\n\t// requesting compression with an \"Accept-Encoding: gzip\"\n\t// request header when the Request contains no existing\n\t// Accept-Encoding value. If the Transport requests gzip on\n\t// its own and gets a gzipped response, it's transparently\n\t// decoded in the Response.Body. However, if the user\n\t// explicitly requested gzip it is not automatically\n\t// uncompressed.\n\tDisableCompression\tbool\n\n\t// MaxIdleConns controls the maximum number of idle (keep-alive)\n\t// connections across all hosts. Zero means no limit.\n\tMaxIdleConns\tint\n\n\t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n\t// (keep-alive) connections to keep per-host. If zero,\n\t// DefaultMaxIdleConnsPerHost is used.\n\tMaxIdleConnsPerHost\tint\n\n\t// MaxConnsPerHost optionally limits the total number of\n\t// connections per host, including connections in the dialing,\n\t// active, and idle states. On limit violation, dials will block.\n\t//\n\t// Zero means no limit.\n\tMaxConnsPerHost\tint\n\n\t// IdleConnTimeout is the maximum amount of time an idle\n\t// (keep-alive) connection will remain idle before closing\n\t// itself.\n\t// Zero means no limit.\n\tIdleConnTimeout\ttime.Duration\n\n\t// ResponseHeaderTimeout, if non-zero, specifies the amount of\n\t// time to wait for a server's response headers after fully\n\t// writing the request (including its body, if any). This\n\t// time does not include the time to read the response body.\n\tResponseHeaderTimeout\ttime.Duration\n\n\t// ExpectContinueTimeout, if non-zero, specifies the amount of\n\t// time to wait for a server's first response headers after fully\n\t// writing the request headers if the request has an\n\t// \"Expect: 100-continue\" header. Zero means no timeout and\n\t// causes the body to be sent immediately, without\n\t// waiting for the server to approve.\n\t// This time does not include the time to send the request header.\n\tExpectContinueTimeout\ttime.Duration\n\n\t// TLSNextProto specifies how the Transport switches to an\n\t// alternate protocol (such as HTTP/2) after a TLS ALPN\n\t// protocol negotiation. If Transport dials a TLS connection\n\t// with a non-empty protocol name and TLSNextProto contains a\n\t// map entry for that key (such as \"h2\"), then the func is\n\t// called with the request's authority (such as \"example.com\"\n\t// or \"example.com:1234\") and the TLS connection. The function\n\t// must return a RoundTripper that then handles the request.\n\t// If TLSNextProto is not nil, HTTP/2 support is not enabled\n\t// automatically.\n\tTLSNextProto\tmap[string]func(authority string, c *tls.Conn) RoundTripper\n\n\t// ProxyConnectHeader optionally specifies headers to send to\n\t// proxies during CONNECT requests.\n\t// To set the header dynamically, see GetProxyConnectHeader.\n\tProxyConnectHeader\tHeader\n\n\t// GetProxyConnectHeader optionally specifies a func to return\n\t// headers to send to proxyURL during a CONNECT request to the\n\t// ip:port target.\n\t// If it returns an error, the Transport's RoundTrip fails with\n\t// that error. It can return (nil, nil) to not add headers.\n\t// If GetProxyConnectHeader is non-nil, ProxyConnectHeader is\n\t// ignored.\n\tGetProxyConnectHeader\tfunc(ctx context.Context, proxyURL *url.URL, target string) (Header, error)\n\n\t// MaxResponseHeaderBytes specifies a limit on how many\n\t// response bytes are allowed in the server's response\n\t// header.\n\t//\n\t// Zero means to use a default limit.\n\tMaxResponseHeaderBytes\tint64\n\n\t// WriteBufferSize specifies the size of the write buffer used\n\t// when writing to the transport.\n\t// If zero, a default (currently 4KB) is used.\n\tWriteBufferSize\tint\n\n\t// ReadBufferSize specifies the size of the read buffer used\n\t// when reading from the transport.\n\t// If zero, a default (currently 4KB) is used.\n\tReadBufferSize\tint\n\n\t// nextProtoOnce guards initialization of TLSNextProto and\n\t// h2transport (via onceSetNextProtoDefaults)\n\tnextProtoOnce\t\tsync.Once\n\th2transport\t\th2Transport\t// non-nil if http2 wired up\n\ttlsNextProtoWasNil\tbool\t\t// whether TLSNextProto was nil when the Once fired\n\n\t// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero\n\t// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.\n\t// By default, use of any those fields conservatively disables HTTP/2.\n\t// To use a custom dialer or TLS config and still attempt HTTP/2\n\t// upgrades, set this to true.\n\tForceAttemptHTTP2\tbool\n}","func ProxyFromEnvironment(req *Request) (*url.URL, error)","func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)","","type Message struct {\n\tHeader\tHeader\n\tBody\tio.Reader\n}","func ReadMessage(r io.Reader) (msg *Message, err error)","func ParseDate(date string) (time.Time, error)","type Header map[string][]string","","type Address struct {\n\tName\tstring\t// Proper name; may be empty.\n\tAddress\tstring\t// user@domain\n}","func ParseAddress(address string) (*Address, error)","func ParseAddressList(list string) ([]*Address, error)","type AddressParser struct {\n\t// WordDecoder optionally specifies a decoder for RFC 2047 encoded-words.\n\tWordDecoder *mime.WordDecoder\n}","type Addr struct {\n\t// addr is the hi and lo bits of an IPv6 address. If z==z4,\n\t// hi and lo contain the IPv4-mapped IPv6 address.\n\t//\n\t// hi and lo are constructed by interpreting a 16-byte IPv6\n\t// address as a big-endian 128-bit number. The most significant\n\t// bits of that number go into hi, the rest into lo.\n\t//\n\t// For example, 0011:2233:4455:6677:8899:aabb:ccdd:eeff is stored as:\n\t//  addr.hi = 0x0011223344556677\n\t//  addr.lo = 0x8899aabbccddeeff\n\t//\n\t// We store IPs like this, rather than as [16]byte, because it\n\t// turns most operations on IPs into arithmetic and bit-twiddling\n\t// operations on 64-bit registers, which is much faster than\n\t// bytewise processing.\n\taddr\tuint128\n\n\t// Details about the address, wrapped up together and canonicalized.\n\tz\tunique.Handle[addrDetail]\n}","func IPv6LinkLocalAllNodes() Addr","func IPv6LinkLocalAllRouters() Addr","func IPv6Loopback() Addr","func IPv6Unspecified() Addr","func IPv4Unspecified() Addr","func AddrFrom4(addr [4]byte) Addr","func AddrFrom16(addr [16]byte) Addr","func ParseAddr(s string) (Addr, error)","func MustParseAddr(s string) Addr","func AddrFromSlice(slice []byte) (ip Addr, ok bool)","type AddrPort struct {\n\tip\tAddr\n\tport\tuint16\n}","func AddrPortFrom(ip Addr, port uint16) AddrPort","func ParseAddrPort(s string) (AddrPort, error)","func MustParseAddrPort(s string) AddrPort","type Prefix struct {\n\tip\tAddr\n\n\t// bitsPlusOne stores the prefix bit length plus one.\n\t// A Prefix is valid if and only if bitsPlusOne is non-zero.\n\tbitsPlusOne\tuint8\n}","func PrefixFrom(ip Addr, bits int) Prefix","func ParsePrefix(s string) (Prefix, error)","func MustParsePrefix(s string) Prefix","","","type Call struct {\n\tServiceMethod\tstring\t\t// The name of the service and method to call.\n\tArgs\t\tany\t\t// The argument to the function (*struct).\n\tReply\t\tany\t\t// The reply from the function (*struct).\n\tError\t\terror\t\t// After completion, the error status.\n\tDone\t\tchan *Call\t// Receives *Call when Go is complete.\n}","type Client struct {\n\tcodec\tClientCodec\n\n\treqMutex\tsync.Mutex\t// protects following\n\trequest\t\tRequest\n\n\tmutex\t\tsync.Mutex\t// protects following\n\tseq\t\tuint64\n\tpending\t\tmap[uint64]*Call\n\tclosing\t\tbool\t// user has called Close\n\tshutdown\tbool\t// server has told us to stop\n}","type ClientCodec interface {\n\tWriteRequest(*Request, any) error\n\tReadResponseHeader(*Response) error\n\tReadResponseBody(any) error\n\n\tClose() error\n}","func NewClient(conn io.ReadWriteCloser) *Client","func NewClientWithCodec(codec ClientCodec) *Client","func DialHTTP(network, address string) (*Client, error)","func DialHTTPPath(network, address, path string) (*Client, error)","func Dial(network, address string) (*Client, error)","const DefaultRPCPath = \"/_goRPC_\"","const DefaultDebugPath = \"/debug/rpc\"","type Request struct {\n\tServiceMethod\tstring\t\t// format: \"Service.Method\"\n\tSeq\t\tuint64\t\t// sequence number chosen by client\n\tnext\t\t*Request\t// for free list in Server\n}","type Response struct {\n\tServiceMethod\tstring\t\t// echoes that of the Request\n\tSeq\t\tuint64\t\t// echoes that of the request\n\tError\t\tstring\t\t// error, if any.\n\tnext\t\t*Response\t// for free list in Server\n}","type Server struct {\n\tserviceMap\tsync.Map\t// map[string]*service\n\treqLock\t\tsync.Mutex\t// protects freeReq\n\tfreeReq\t\t*Request\n\trespLock\tsync.Mutex\t// protects freeResp\n\tfreeResp\t*Response\n}","func NewServer() *Server","","func Register(rcvr any) error","func RegisterName(name string, rcvr any) error","type ServerCodec interface {\n\tReadRequestHeader(*Request) error\n\tReadRequestBody(any) error\n\tWriteResponse(*Response, any) error\n\n\t// Close can be called multiple times and must be idempotent.\n\tClose() error\n}","func ServeConn(conn io.ReadWriteCloser)","func ServeCodec(codec ServerCodec)","func ServeRequest(codec ServerCodec) error","func Accept(lis net.Listener)","func HandleHTTP()","type Auth interface {\n\t// Start begins an authentication with a server.\n\t// It returns the name of the authentication protocol\n\t// and optionally data to include in the initial AUTH message\n\t// sent to the server.\n\t// If it returns a non-nil error, the SMTP client aborts\n\t// the authentication attempt and closes the connection.\n\tStart(server *ServerInfo) (proto string, toServer []byte, err error)\n\n\t// Next continues the authentication. The server has just sent\n\t// the fromServer data. If more is true, the server expects a\n\t// response, which Next should return as toServer; otherwise\n\t// Next should return toServer == nil.\n\t// If Next returns a non-nil error, the SMTP client aborts\n\t// the authentication attempt and closes the connection.\n\tNext(fromServer []byte, more bool) (toServer []byte, err error)\n}","type ServerInfo struct {\n\tName\tstring\t\t// SMTP server name\n\tTLS\tbool\t\t// using TLS, with valid certificate for Name\n\tAuth\t[]string\t// advertised authentication mechanisms\n}","func PlainAuth(identity, username, password, host string) Auth","func CRAMMD5Auth(username, secret string) Auth","type Client struct {\n\t// Text is the textproto.Conn used by the Client. It is exported to allow for\n\t// clients to add extensions.\n\tText\t*textproto.Conn\n\t// keep a reference to the connection so it can be used to create a TLS\n\t// connection later\n\tconn\tnet.Conn\n\t// whether the Client is using TLS\n\ttls\t\tbool\n\tserverName\tstring\n\t// map of supported extensions\n\text\tmap[string]string\n\t// supported auth mechanisms\n\tauth\t\t[]string\n\tlocalName\tstring\t// the name to use in HELO/EHLO\n\tdidHello\tbool\t// whether we've said HELO/EHLO\n\thelloError\terror\t// the error from the hello\n}","func Dial(addr string) (*Client, error)","func NewClient(conn net.Conn, host string) (*Client, error)","func SendMail(addr string, a Auth, from string, to []string, msg []byte) error","type MIMEHeader map[string][]string","type Pipeline struct {\n\tmu\t\tsync.Mutex\n\tid\t\tuint\n\trequest\t\tsequencer\n\tresponse\tsequencer\n}","type Reader struct {\n\tR\t*bufio.Reader\n\tdot\t*dotReader\n\tbuf\t[]byte\t// a re-usable buffer for readContinuedLineSlice\n}","func NewReader(r *bufio.Reader) *Reader","func CanonicalMIMEHeaderKey(s string) string","type Error struct {\n\tCode\tint\n\tMsg\tstring\n}","","type Conn struct {\n\tReader\n\tWriter\n\tPipeline\n\tconn\tio.ReadWriteCloser\n}","func NewConn(conn io.ReadWriteCloser) *Conn","func Dial(network, addr string) (*Conn, error)","func TrimString(s string) string","func TrimBytes(b []byte) []byte","type Writer struct {\n\tW\t*bufio.Writer\n\tdot\t*dotWriter\n}","func NewWriter(w *bufio.Writer) *Writer","type Error struct {\n\tOp\tstring\n\tURL\tstring\n\tErr\terror\n}","","","func QueryUnescape(s string) (string, error)","func PathUnescape(s string) (string, error)","func QueryEscape(s string) string","func PathEscape(s string) string","type URL struct {\n\tScheme\t\tstring\n\tOpaque\t\tstring\t\t// encoded opaque data\n\tUser\t\t*Userinfo\t// username and password information\n\tHost\t\tstring\t\t// host or host:port (see Hostname and Port methods)\n\tPath\t\tstring\t\t// path (relative paths may omit leading slash)\n\tRawPath\t\tstring\t\t// encoded path hint (see EscapedPath method)\n\tOmitHost\tbool\t\t// do not emit empty host (authority)\n\tForceQuery\tbool\t\t// append a query ('?') even if RawQuery is empty\n\tRawQuery\tstring\t\t// encoded query values, without '?'\n\tFragment\tstring\t\t// fragment for references, without '#'\n\tRawFragment\tstring\t\t// encoded fragment hint (see EscapedFragment method)\n}","func User(username string) *Userinfo","func UserPassword(username, password string) *Userinfo","type Userinfo struct {\n\tusername\tstring\n\tpassword\tstring\n\tpasswordSet\tbool\n}","func Parse(rawURL string) (*URL, error)","func ParseRequestURI(rawURL string) (*URL, error)","type Values map[string][]string","func ParseQuery(query string) (Values, error)","func JoinPath(base string, elem ...string) (result string, err error)","type Error struct {\n\t// Name is the file name for which the error occurred.\n\tName\tstring\n\t// Err is the underlying error.\n\tErr\terror\n}","","type Cmd struct {\n\t// Path is the path of the command to run.\n\t//\n\t// This is the only field that must be set to a non-zero\n\t// value. If Path is relative, it is evaluated relative\n\t// to Dir.\n\tPath\tstring\n\n\t// Args holds command line arguments, including the command as Args[0].\n\t// If the Args field is empty or nil, Run uses {Path}.\n\t//\n\t// In typical use, both Path and Args are set by calling Command.\n\tArgs\t[]string\n\n\t// Env specifies the environment of the process.\n\t// Each entry is of the form \"key=value\".\n\t// If Env is nil, the new process uses the current process's\n\t// environment.\n\t// If Env contains duplicate environment keys, only the last\n\t// value in the slice for each duplicate key is used.\n\t// As a special case on Windows, SYSTEMROOT is always added if\n\t// missing and not explicitly set to the empty string.\n\tEnv\t[]string\n\n\t// Dir specifies the working directory of the command.\n\t// If Dir is the empty string, Run runs the command in the\n\t// calling process's current directory.\n\tDir\tstring\n\n\t// Stdin specifies the process's standard input.\n\t//\n\t// If Stdin is nil, the process reads from the null device (os.DevNull).\n\t//\n\t// If Stdin is an *os.File, the process's standard input is connected\n\t// directly to that file.\n\t//\n\t// Otherwise, during the execution of the command a separate\n\t// goroutine reads from Stdin and delivers that data to the command\n\t// over a pipe. In this case, Wait does not complete until the goroutine\n\t// stops copying, either because it has reached the end of Stdin\n\t// (EOF or a read error), or because writing to the pipe returned an error,\n\t// or because a nonzero WaitDelay was set and expired.\n\tStdin\tio.Reader\n\n\t// Stdout and Stderr specify the process's standard output and error.\n\t//\n\t// If either is nil, Run connects the corresponding file descriptor\n\t// to the null device (os.DevNull).\n\t//\n\t// If either is an *os.File, the corresponding output from the process\n\t// is connected directly to that file.\n\t//\n\t// Otherwise, during the execution of the command a separate goroutine\n\t// reads from the process over a pipe and delivers that data to the\n\t// corresponding Writer. In this case, Wait does not complete until the\n\t// goroutine reaches EOF or encounters an error or a nonzero WaitDelay\n\t// expires.\n\t//\n\t// If Stdout and Stderr are the same writer, and have a type that can\n\t// be compared with ==, at most one goroutine at a time will call Write.\n\tStdout\tio.Writer\n\tStderr\tio.Writer\n\n\t// ExtraFiles specifies additional open files to be inherited by the\n\t// new process. It does not include standard input, standard output, or\n\t// standard error. If non-nil, entry i becomes file descriptor 3+i.\n\t//\n\t// ExtraFiles is not supported on Windows.\n\tExtraFiles\t[]*os.File\n\n\t// SysProcAttr holds optional, operating system-specific attributes.\n\t// Run passes it to os.StartProcess as the os.ProcAttr's Sys field.\n\tSysProcAttr\t*syscall.SysProcAttr\n\n\t// Process is the underlying process, once started.\n\tProcess\t*os.Process\n\n\t// ProcessState contains information about an exited process.\n\t// If the process was started successfully, Wait or Run will\n\t// populate its ProcessState when the command completes.\n\tProcessState\t*os.ProcessState\n\n\t// ctx is the context passed to CommandContext, if any.\n\tctx\tcontext.Context\n\n\tErr\terror\t// LookPath error, if any.\n\n\t// If Cancel is non-nil, the command must have been created with\n\t// CommandContext and Cancel will be called when the command's\n\t// Context is done. By default, CommandContext sets Cancel to\n\t// call the Kill method on the command's Process.\n\t//\n\t// Typically a custom Cancel will send a signal to the command's\n\t// Process, but it may instead take other actions to initiate cancellation,\n\t// such as closing a stdin or stdout pipe or sending a shutdown request on a\n\t// network socket.\n\t//\n\t// If the command exits with a success status after Cancel is\n\t// called, and Cancel does not return an error equivalent to\n\t// os.ErrProcessDone, then Wait and similar methods will return a non-nil\n\t// error: either an error wrapping the one returned by Cancel,\n\t// or the error from the Context.\n\t// (If the command exits with a non-success status, or Cancel\n\t// returns an error that wraps os.ErrProcessDone, Wait and similar methods\n\t// continue to return the command's usual exit status.)\n\t//\n\t// If Cancel is set to nil, nothing will happen immediately when the command's\n\t// Context is done, but a nonzero WaitDelay will still take effect. That may\n\t// be useful, for example, to work around deadlocks in commands that do not\n\t// support shutdown signals but are expected to always finish quickly.\n\t//\n\t// Cancel will not be called if Start returns a non-nil error.\n\tCancel\tfunc() error\n\n\t// If WaitDelay is non-zero, it bounds the time spent waiting on two sources\n\t// of unexpected delay in Wait: a child process that fails to exit after the\n\t// associated Context is canceled, and a child process that exits but leaves\n\t// its I/O pipes unclosed.\n\t//\n\t// The WaitDelay timer starts when either the associated Context is done or a\n\t// call to Wait observes that the child process has exited, whichever occurs\n\t// first. When the delay has elapsed, the command shuts down the child process\n\t// and/or its I/O pipes.\n\t//\n\t// If the child process has failed to exit — perhaps because it ignored or\n\t// failed to receive a shutdown signal from a Cancel function, or because no\n\t// Cancel function was set — then it will be terminated using os.Process.Kill.\n\t//\n\t// Then, if the I/O pipes communicating with the child process are still open,\n\t// those pipes are closed in order to unblock any goroutines currently blocked\n\t// on Read or Write calls.\n\t//\n\t// If pipes are closed due to WaitDelay, no Cancel call has occurred,\n\t// and the command has otherwise exited with a successful status, Wait and\n\t// similar methods will return ErrWaitDelay instead of nil.\n\t//\n\t// If WaitDelay is zero (the default), I/O pipes will be read until EOF,\n\t// which might not occur until orphaned subprocesses of the command have\n\t// also closed their descriptors for the pipes.\n\tWaitDelay\ttime.Duration\n\n\t// childIOFiles holds closers for any of the child process's\n\t// stdin, stdout, and/or stderr files that were opened by the Cmd itself\n\t// (not supplied by the caller). These should be closed as soon as they\n\t// are inherited by the child process.\n\tchildIOFiles\t[]io.Closer\n\n\t// parentIOPipes holds closers for the parent's end of any pipes\n\t// connected to the child's stdin, stdout, and/or stderr streams\n\t// that were opened by the Cmd itself (not supplied by the caller).\n\t// These should be closed after Wait sees the command and copying\n\t// goroutines exit, or after WaitDelay has expired.\n\tparentIOPipes\t[]io.Closer\n\n\t// goroutine holds a set of closures to execute to copy data\n\t// to and/or from the command's I/O pipes.\n\tgoroutine\t[]func() error\n\n\t// If goroutineErr is non-nil, it receives the first error from a copying\n\t// goroutine once all such goroutines have completed.\n\t// goroutineErr is set to nil once its error has been received.\n\tgoroutineErr\t\u003c-chan error\n\n\t// If ctxResult is non-nil, it receives the result of watchCtx exactly once.\n\tctxResult\t\u003c-chan ctxResult\n\n\t// The stack saved when the Command was created, if GODEBUG contains\n\t// execwait=2. Used for debugging leaks.\n\tcreatedByStack\t[]byte\n\n\t// For a security release long ago, we created x/sys/execabs,\n\t// which manipulated the unexported lookPathErr error field\n\t// in this struct. For Go 1.19 we exported the field as Err error,\n\t// above, but we have to keep lookPathErr around for use by\n\t// old programs building against new toolchains.\n\t// The String and Start methods look for an error in lookPathErr\n\t// in preference to Err, to preserve the errors that execabs sets.\n\t//\n\t// In general we don't guarantee misuse of reflect like this,\n\t// but the misuse of reflect was by us, the best of various bad\n\t// options to fix the security problem, and people depend on\n\t// those old copies of execabs continuing to work.\n\t// The result is that we have to leave this variable around for the\n\t// rest of time, a compatibility scar.\n\t//\n\t// See https://go.dev/blog/path-security\n\t// and https://go.dev/issue/43724 for more context.\n\tlookPathErr\terror\n\n\t// cachedLookExtensions caches the result of calling lookExtensions.\n\t// It is set when Command is called with an absolute path, letting it do\n\t// the work of resolving the extension, so Start doesn't need to do it again.\n\t// This is only used on Windows.\n\tcachedLookExtensions\tstruct{ in, out string }\n}","func Command(name string, arg ...string) *Cmd","func CommandContext(ctx context.Context, name string, arg ...string) *Cmd","type ExitError struct {\n\t*os.ProcessState\n\n\t// Stderr holds a subset of the standard error output from the\n\t// Cmd.Output method if standard error was not otherwise being\n\t// collected.\n\t//\n\t// If the error output is long, Stderr may contain only a prefix\n\t// and suffix of the output, with the middle replaced with\n\t// text about the number of omitted bytes.\n\t//\n\t// Stderr is provided for debugging, for inclusion in error messages.\n\t// Users with other needs should redirect Cmd.Stderr as needed.\n\tStderr\t[]byte\n}","","","func LookPath(file string) (string, error)","func Ignore(sig ...os.Signal)","func Ignored(sig os.Signal) bool","func Notify(c chan\u003c- os.Signal, sig ...os.Signal)","func Reset(sig ...os.Signal)","func Stop(c chan\u003c- os.Signal)","func NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)","func Current() (*User, error)","func Lookup(username string) (*User, error)","func LookupId(uid string) (*User, error)","func LookupGroup(name string) (*Group, error)","func LookupGroupId(gid string) (*Group, error)","type User struct {\n\t// Uid is the user ID.\n\t// On POSIX systems, this is a decimal number representing the uid.\n\t// On Windows, this is a security identifier (SID) in a string format.\n\t// On Plan 9, this is the contents of /dev/user.\n\tUid\tstring\n\t// Gid is the primary group ID.\n\t// On POSIX systems, this is a decimal number representing the gid.\n\t// On Windows, this is a SID in a string format.\n\t// On Plan 9, this is the contents of /dev/user.\n\tGid\tstring\n\t// Username is the login name.\n\tUsername\tstring\n\t// Name is the user's real or display name.\n\t// It might be blank.\n\t// On POSIX systems, this is the first (or only) entry in the GECOS field\n\t// list.\n\t// On Windows, this is the user's display name.\n\t// On Plan 9, this is the contents of /dev/user.\n\tName\tstring\n\t// HomeDir is the path to the user's home directory (if they have one).\n\tHomeDir\tstring\n}","type Group struct {\n\tGid\tstring\t// group ID\n\tName\tstring\t// group name\n}","","","","","","func Match(pattern, name string) (matched bool, err error)","func Glob(pattern string) (matches []string, err error)","","","func Clean(path string) string","func IsLocal(path string) bool","func Localize(path string) (string, error)","func ToSlash(path string) string","func FromSlash(path string) string","func SplitList(path string) []string","func Split(path string) (dir, file string)","func Join(elem ...string) string","func Ext(path string) string","func EvalSymlinks(path string) (string, error)","func IsAbs(path string) bool","func Abs(path string) (string, error)","func Rel(basepath, targpath string) (string, error)","var SkipDir error","var SkipAll error","type WalkFunc func(path string, info fs.FileInfo, err error) error","func WalkDir(root string, fn fs.WalkDirFunc) error","func Walk(root string, fn WalkFunc) error","func Base(path string) string","func Dir(path string) string","func VolumeName(path string) string","func HasPrefix(p, prefix string) bool","func Compile(re *Regexp) (*Prog, error)","type Error struct {\n\tCode\tErrorCode\n\tExpr\tstring\n}","","const ErrInternalError ErrorCode = \"regexp/syntax: internal error\"","const ErrInvalidCharClass ErrorCode = \"invalid character class\"","const ErrInvalidCharRange ErrorCode = \"invalid character class range\"","const ErrInvalidEscape ErrorCode = \"invalid escape sequence\"","const ErrInvalidNamedCapture ErrorCode = \"invalid named capture\"","const ErrInvalidPerlOp ErrorCode = \"invalid or unsupported Perl syntax\"","const ErrInvalidRepeatOp ErrorCode = \"invalid nested repetition operator\"","const ErrInvalidRepeatSize ErrorCode = \"invalid repeat count\"","const ErrInvalidUTF8 ErrorCode = \"invalid UTF-8\"","const ErrMissingBracket ErrorCode = \"missing closing ]\"","const ErrMissingParen ErrorCode = \"missing closing )\"","const ErrMissingRepeatArgument ErrorCode = \"missing argument to repetition operator\"","const ErrTrailingBackslash ErrorCode = \"trailing backslash at end of expression\"","const ErrUnexpectedParen ErrorCode = \"unexpected )\"","const ErrNestingDepth ErrorCode = \"expression nests too deeply\"","const ErrLarge ErrorCode = \"expression too large\"","","const FoldCase Flags","const Literal","const ClassNL","const DotNL","const OneLine","const NonGreedy","const PerlX","const UnicodeGroups","const WasDollar","const Simple","","","const POSIX Flags = 0","func Parse(s string, flags Flags) (*Regexp, error)","type Prog struct {\n\tInst\t[]Inst\n\tStart\tint\t// index of start instruction\n\tNumCap\tint\t// number of InstCapture insts in re\n}","","const InstAlt InstOp","const InstAltMatch","const InstCapture","const InstEmptyWidth","const InstMatch","const InstFail","const InstNop","const InstRune","const InstRune1","const InstRuneAny","const InstRuneAnyNotNL","","const EmptyBeginLine EmptyOp","const EmptyEndLine","const EmptyBeginText","const EmptyEndText","const EmptyWordBoundary","const EmptyNoWordBoundary","func EmptyOpContext(r1, r2 rune) EmptyOp","func IsWordChar(r rune) bool","type Inst struct {\n\tOp\tInstOp\n\tOut\tuint32\t// all but InstMatch, InstFail\n\tArg\tuint32\t// InstAlt, InstAltMatch, InstCapture, InstEmptyWidth\n\tRune\t[]rune\n}","type Regexp struct {\n\tOp\t\tOp\t// operator\n\tFlags\t\tFlags\n\tSub\t\t[]*Regexp\t// subexpressions, if any\n\tSub0\t\t[1]*Regexp\t// storage for short Sub\n\tRune\t\t[]rune\t\t// matched runes, for OpLiteral, OpCharClass\n\tRune0\t\t[2]rune\t\t// storage for short Rune\n\tMin, Max\tint\t\t// min, max for OpRepeat\n\tCap\t\tint\t\t// capturing index, for OpCapture\n\tName\t\tstring\t\t// capturing name, for OpCapture\n}","","const OpNoMatch Op","const OpEmptyMatch","const OpLiteral","const OpCharClass","const OpAnyCharNotNL","const OpAnyChar","const OpBeginLine","const OpEndLine","const OpBeginText","const OpEndText","const OpWordBoundary","const OpNoWordBoundary","const OpCapture","const OpStar","const OpPlus","const OpQuest","const OpRepeat","const OpConcat","const OpAlternate","type Incomplete struct {\n\t_ sys.NotInHeap\n}","","func NewHandle(v any) Handle","func WriteMetaDir(dir string) error","func WriteMeta(w io.Writer) error","func WriteCountersDir(dir string) error","func WriteCounters(w io.Writer) error","func ClearCounters() error","type GCStats struct {\n\tLastGC\t\ttime.Time\t// time of last collection\n\tNumGC\t\tint64\t\t// number of garbage collections\n\tPauseTotal\ttime.Duration\t// total pause for all collections\n\tPause\t\t[]time.Duration\t// pause history, most recent first\n\tPauseEnd\t[]time.Time\t// pause end times history, most recent first\n\tPauseQuantiles\t[]time.Duration\n}","func ReadGCStats(stats *GCStats)","func SetGCPercent(percent int) int","func FreeOSMemory()","func SetMaxStack(bytes int) int","func SetMaxThreads(threads int) int","func SetPanicOnFault(enabled bool) bool","func WriteHeapDump(fd uintptr)","func SetTraceback(level string)","func SetMemoryLimit(limit int64) int64","func ReadBuildInfo() (info *BuildInfo, ok bool)","type BuildInfo struct {\n\t// GoVersion is the version of the Go toolchain that built the binary\n\t// (for example, \"go1.19.2\").\n\tGoVersion\tstring\n\n\t// Path is the package path of the main package for the binary\n\t// (for example, \"golang.org/x/tools/cmd/stringer\").\n\tPath\tstring\n\n\t// Main describes the module that contains the main package for the binary.\n\tMain\tModule\n\n\t// Deps describes all the dependency modules, both direct and indirect,\n\t// that contributed packages to the build of this binary.\n\tDeps\t[]*Module\n\n\t// Settings describes the build settings used to build the binary.\n\tSettings\t[]BuildSetting\n}","type Module struct {\n\tPath\tstring\t// module path\n\tVersion\tstring\t// module version\n\tSum\tstring\t// checksum\n\tReplace\t*Module\t// replaced by this module\n}","type BuildSetting struct {\n\t// Key and Value describe the build setting.\n\t// Key must not contain an equals sign, space, tab, or newline.\n\t// Value must not contain newlines ('\\n').\n\tKey, Value string\n}","func ParseBuildInfo(data string) (bi *BuildInfo, err error)","func PrintStack()","func Stack() []byte","type CrashOptions struct {\n}","func SetCrashOutput(f *os.File, opts CrashOptions) error","type Description struct {\n\t// Name is the full name of the metric which includes the unit.\n\t//\n\t// The format of the metric may be described by the following regular expression.\n\t//\n\t// \t^(?P\u003cname\u003e/[^:]+):(?P\u003cunit\u003e[^:*/]+(?:[*/][^:*/]+)*)$\n\t//\n\t// The format splits the name into two components, separated by a colon: a path which always\n\t// starts with a /, and a machine-parseable unit. The name may contain any valid Unicode\n\t// codepoint in between / characters, but by convention will try to stick to lowercase\n\t// characters and hyphens. An example of such a path might be \"/memory/heap/free\".\n\t//\n\t// The unit is by convention a series of lowercase English unit names (singular or plural)\n\t// without prefixes delimited by '*' or '/'. The unit names may contain any valid Unicode\n\t// codepoint that is not a delimiter.\n\t// Examples of units might be \"seconds\", \"bytes\", \"bytes/second\", \"cpu-seconds\",\n\t// \"byte*cpu-seconds\", and \"bytes/second/second\".\n\t//\n\t// For histograms, multiple units may apply. For instance, the units of the buckets and\n\t// the count. By convention, for histograms, the units of the count are always \"samples\"\n\t// with the type of sample evident by the metric's name, while the unit in the name\n\t// specifies the buckets' unit.\n\t//\n\t// A complete name might look like \"/memory/heap/free:bytes\".\n\tName\tstring\n\n\t// Description is an English language sentence describing the metric.\n\tDescription\tstring\n\n\t// Kind is the kind of value for this metric.\n\t//\n\t// The purpose of this field is to allow users to filter out metrics whose values are\n\t// types which their application may not understand.\n\tKind\tValueKind\n\n\t// Cumulative is whether or not the metric is cumulative. If a cumulative metric is just\n\t// a single number, then it increases monotonically. If the metric is a distribution,\n\t// then each bucket count increases monotonically.\n\t//\n\t// This flag thus indicates whether or not it's useful to compute a rate from this value.\n\tCumulative\tbool\n}","func All() []Description","type Float64Histogram struct {\n\t// Counts contains the weights for each histogram bucket.\n\t//\n\t// Given N buckets, Count[n] is the weight of the range\n\t// [bucket[n], bucket[n+1]), for 0 \u003c= n \u003c N.\n\tCounts\t[]uint64\n\n\t// Buckets contains the boundaries of the histogram buckets, in increasing order.\n\t//\n\t// Buckets[0] is the inclusive lower bound of the minimum bucket while\n\t// Buckets[len(Buckets)-1] is the exclusive upper bound of the maximum bucket.\n\t// Hence, there are len(Buckets)-1 counts. Furthermore, len(Buckets) != 1, always,\n\t// since at least two boundaries are required to describe one bucket (and 0\n\t// boundaries are used to describe 0 buckets).\n\t//\n\t// Buckets[0] is permitted to have value -Inf and Buckets[len(Buckets)-1] is\n\t// permitted to have value Inf.\n\t//\n\t// For a given metric name, the value of Buckets is guaranteed not to change\n\t// between calls until program exit.\n\t//\n\t// This slice value is permitted to alias with other Float64Histograms' Buckets\n\t// fields, so the values within should only ever be read. If they need to be\n\t// modified, the user must make a copy.\n\tBuckets\t[]float64\n}","type Sample struct {\n\t// Name is the name of the metric sampled.\n\t//\n\t// It must correspond to a name in one of the metric descriptions\n\t// returned by All.\n\tName\tstring\n\n\t// Value is the value of the metric sample.\n\tValue\tValue\n}","func Read(m []Sample)","","const KindBad ValueKind","const KindUint64","const KindFloat64","const KindFloat64Histogram","type Value struct {\n\tkind\tValueKind\n\tscalar\tuint64\t\t// contains scalar values for scalar Kinds.\n\tpointer\tunsafe.Pointer\t// contains non-scalar values.\n}","type LabelSet struct {\n\tlist []label\n}","func WithLabels(ctx context.Context, labels LabelSet) context.Context","func Labels(args ...string) LabelSet","func Label(ctx context.Context, key string) (string, bool)","func ForLabels(ctx context.Context, f func(key, value string) bool)","type Profile struct {\n\tname\tstring\n\tmu\tsync.Mutex\n\tm\tmap[any][]uintptr\n\tcount\tfunc() int\n\twrite\tfunc(io.Writer, int) error\n}","func NewProfile(name string) *Profile","func Lookup(name string) *Profile","func Profiles() []*Profile","func WriteHeapProfile(w io.Writer) error","func StartCPUProfile(w io.Writer) error","func StopCPUProfile()","func SetGoroutineLabels(ctx context.Context)","func Do(ctx context.Context, labels LabelSet, f func(context.Context))","func NewTask(pctx context.Context, taskType string) (ctx context.Context, task *Task)","type Task struct {\n\tid uint64\n}","func Log(ctx context.Context, category, message string)","func Logf(ctx context.Context, category, format string, args ...any)","func WithRegion(ctx context.Context, regionType string, fn func())","func StartRegion(ctx context.Context, regionType string) *Region","type Region struct {\n\tid\t\tuint64\n\tregionType\tstring\n}","func IsEnabled() bool","func Start(w io.Writer) error","func Stop()","func SwapInt32(addr *int32, new int32) (old int32)","func SwapInt64(addr *int64, new int64) (old int64)","func SwapUint32(addr *uint32, new uint32) (old uint32)","func SwapUint64(addr *uint64, new uint64) (old uint64)","func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)","func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)","func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)","func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)","func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)","func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)","func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)","func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)","func AddInt32(addr *int32, delta int32) (new int32)","func AddUint32(addr *uint32, delta uint32) (new uint32)","func AddInt64(addr *int64, delta int64) (new int64)","func AddUint64(addr *uint64, delta uint64) (new uint64)","func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)","func AndInt32(addr *int32, mask int32) (old int32)","func AndUint32(addr *uint32, mask uint32) (old uint32)","func AndInt64(addr *int64, mask int64) (old int64)","func AndUint64(addr *uint64, mask uint64) (old uint64)","func AndUintptr(addr *uintptr, mask uintptr) (old uintptr)","func OrInt32(addr *int32, mask int32) (old int32)","func OrUint32(addr *uint32, mask uint32) (old uint32)","func OrInt64(addr *int64, mask int64) (old int64)","func OrUint64(addr *uint64, mask uint64) (old uint64)","func OrUintptr(addr *uintptr, mask uintptr) (old uintptr)","func LoadInt32(addr *int32) (val int32)","func LoadInt64(addr *int64) (val int64)","func LoadUint32(addr *uint32) (val uint32)","func LoadUint64(addr *uint64) (val uint64)","func LoadUintptr(addr *uintptr) (val uintptr)","func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)","func StoreInt32(addr *int32, val int32)","func StoreInt64(addr *int64, val int64)","func StoreUint32(addr *uint32, val uint32)","func StoreUint64(addr *uint64, val uint64)","func StoreUintptr(addr *uintptr, val uintptr)","func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)","type Bool struct {\n\t_\tnoCopy\n\tv\tuint32\n}","type Pointer[T any] struct {\n\t// Mention *T in a field to disallow conversion between Pointer types.\n\t// See go.dev/issue/56603 for more details.\n\t// Use *T, not T, to avoid spurious recursive type definition errors.\n\t_\t[0]*T\n\n\t_\tnoCopy\n\tv\tunsafe.Pointer\n}","type Int32 struct {\n\t_\tnoCopy\n\tv\tint32\n}","type Int64 struct {\n\t_\tnoCopy\n\t_\talign64\n\tv\tint64\n}","type Uint32 struct {\n\t_\tnoCopy\n\tv\tuint32\n}","type Uint64 struct {\n\t_\tnoCopy\n\t_\talign64\n\tv\tuint64\n}","type Uintptr struct {\n\t_\tnoCopy\n\tv\tuintptr\n}","type Value struct {\n\tv any\n}","type Func struct {\n\tValue\t// the JavaScript function that invokes the Go function\n\tid\tuint32\n}","func FuncOf(fn func(this Value, args []Value) any) Func","type Value struct {\n\t_\t[0]func()\t// uncomparable; to make == not compile\n\tref\tref\t\t// identifies a JavaScript value, see ref type\n\tgcPtr\t*ref\t\t// used to trigger the finalizer when the Value is not referenced any more\n}","type Error struct {\n\t// Value is the underlying JavaScript error value.\n\tValue\n}","func Undefined() Value","func Null() Value","func Global() Value","func ValueOf(x any) Value","","const TypeUndefined Type","const TypeNull","const TypeBoolean","const TypeNumber","const TypeString","const TypeSymbol","const TypeObject","const TypeFunction","type ValueError struct {\n\tMethod\tstring\n\tType\tType\n}","func CopyBytesToGo(dst []byte, src Value) int","func CopyBytesToJS(dst Value, src []byte) int","type MapFS map[string]*MapFile","type MapFile struct {\n\tData\t[]byte\t\t// file content\n\tMode\tfs.FileMode\t// fs.FileInfo.Mode\n\tModTime\ttime.Time\t// fs.FileInfo.ModTime\n\tSys\tany\t\t// fs.FileInfo.Sys\n}","func TestFS(fsys fs.FS, expected ...string) error","func NewWriteLogger(prefix string, w io.Writer) io.Writer","func NewReadLogger(prefix string, r io.Reader) io.Reader","func OneByteReader(r io.Reader) io.Reader","func HalfReader(r io.Reader) io.Reader","func DataErrReader(r io.Reader) io.Reader","","func TimeoutReader(r io.Reader) io.Reader","func ErrReader(err error) io.Reader","func TestReader(r io.Reader, content []byte) error","func TruncateWriter(w io.Writer, n int64) io.Writer","type Generator interface {\n\t// Generate returns a random instance of the type on which it is a\n\t// method using the size as a size hint.\n\tGenerate(rand *rand.Rand, size int) reflect.Value\n}","func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)","type Config struct {\n\t// MaxCount sets the maximum number of iterations.\n\t// If zero, MaxCountScale is used.\n\tMaxCount\tint\n\t// MaxCountScale is a non-negative scale factor applied to the\n\t// default maximum.\n\t// A count of zero implies the default, which is usually 100\n\t// but can be set by the -quickchecks flag.\n\tMaxCountScale\tfloat64\n\t// Rand specifies a source of random numbers.\n\t// If nil, a default pseudo-random source will be used.\n\tRand\t*rand.Rand\n\t// Values specifies a function to generate a slice of\n\t// arbitrary reflect.Values that are congruent with the\n\t// arguments to the function being tested.\n\t// If nil, the top-level Value function is used to generate them.\n\tValues\tfunc([]reflect.Value, *rand.Rand)\n}","","type CheckError struct {\n\tCount\tint\n\tIn\t[]any\n}","type CheckEqualError struct {\n\tCheckError\n\tOut1\t[]any\n\tOut2\t[]any\n}","func Check(f any, config *Config) error","func CheckEqual(f, g any, config *Config) error","func TestHandler(h slog.Handler, results func() []map[string]any) error","func Run(t *testing.T, newHandler func(*testing.T) slog.Handler, result func(*testing.T) map[string]any)","type Position struct {\n\tFilename\tstring\t// filename, if any\n\tOffset\t\tint\t// byte offset, starting at 0\n\tLine\t\tint\t// line number, starting at 1\n\tColumn\t\tint\t// column number, starting at 1 (character count per line)\n}","","","","","","","","","","","const Ident","const Int","const Float","const Char","const String","const RawString","const Comment","func TokenString(tok rune) string","","type Scanner struct {\n\t// Input\n\tsrc\tio.Reader\n\n\t// Source buffer\n\tsrcBuf\t[bufLen + 1]byte\t// +1 for sentinel for common case of s.next()\n\tsrcPos\tint\t\t\t// reading position (srcBuf index)\n\tsrcEnd\tint\t\t\t// source end (srcBuf index)\n\n\t// Source position\n\tsrcBufOffset\tint\t// byte offset of srcBuf[0] in source\n\tline\t\tint\t// line count\n\tcolumn\t\tint\t// character count\n\tlastLineLen\tint\t// length of last line in characters (for correct column reporting)\n\tlastCharLen\tint\t// length of last character in bytes\n\n\t// Token text buffer\n\t// Typically, token text is stored completely in srcBuf, but in general\n\t// the token text's head may be buffered in tokBuf while the token text's\n\t// tail is stored in srcBuf.\n\ttokBuf\tbytes.Buffer\t// token text head that is not in srcBuf anymore\n\ttokPos\tint\t\t// token text tail position (srcBuf index); valid if \u003e= 0\n\ttokEnd\tint\t\t// token text tail end (srcBuf index)\n\n\t// One character look-ahead\n\tch\trune\t// character before current srcPos\n\n\t// Error is called for each error encountered. If no Error\n\t// function is set, the error is reported to os.Stderr.\n\tError\tfunc(s *Scanner, msg string)\n\n\t// ErrorCount is incremented by one for each error encountered.\n\tErrorCount\tint\n\n\t// The Mode field controls which tokens are recognized. For instance,\n\t// to recognize Ints, set the ScanInts bit in Mode. The field may be\n\t// changed at any time.\n\tMode\tuint\n\n\t// The Whitespace field controls which characters are recognized\n\t// as white space. To recognize a character ch \u003c= ' ' as white space,\n\t// set the ch'th bit in Whitespace (the Scanner's behavior is undefined\n\t// for values ch \u003e ' '). The field may be changed at any time.\n\tWhitespace\tuint64\n\n\t// IsIdentRune is a predicate controlling the characters accepted\n\t// as the ith rune in an identifier. The set of valid characters\n\t// must not intersect with the set of white space characters.\n\t// If no IsIdentRune function is set, regular Go identifiers are\n\t// accepted instead. The field may be changed at any time.\n\tIsIdentRune\tfunc(ch rune, i int) bool\n\n\t// Start position of most recently scanned token; set by Scan.\n\t// Calling Init or Next invalidates the position (Line == 0).\n\t// The Filename field is always left untouched by the Scanner.\n\t// If an error is reported (via Error) and Position is invalid,\n\t// the scanner is not inside a token. Call Pos to obtain an error\n\t// position in that case, or to obtain the position immediately\n\t// after the most recently scanned token.\n\tPosition\n}","type Writer struct {\n\t// configuration\n\toutput\t\tio.Writer\n\tminwidth\tint\n\ttabwidth\tint\n\tpadding\t\tint\n\tpadbytes\t[8]byte\n\tflags\t\tuint\n\n\t// current state\n\tbuf\t[]byte\t\t// collected text excluding tabs or line breaks\n\tpos\tint\t\t// buffer position up to which cell.width of incomplete cell has been computed\n\tcell\tcell\t\t// current incomplete cell; cell.width is up to buf[pos] excluding ignored sections\n\tendChar\tbyte\t\t// terminating char of escaped sequence (Escape for escapes, '\u003e', ';' for HTML tags/entities, or 0)\n\tlines\t[][]cell\t// list of lines; each line is a list of cells\n\twidths\t[]int\t\t// list of column widths in runes - re-used during formatting\n}","const FilterHTML uint","const StripEscape","const AlignRight","const DiscardEmptyColumns","const TabIndent","const Debug","const Escape = '\\xff'","func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer","type ExecError struct {\n\tName\tstring\t// Name of template.\n\tErr\terror\t// Pre-formatted error.\n}","func IsTrue(val any) (truth, ok bool)","type FuncMap map[string]any","func HTMLEscape(w io.Writer, b []byte)","func HTMLEscapeString(s string) string","func HTMLEscaper(args ...any) string","func JSEscape(w io.Writer, b []byte)","func JSEscapeString(s string) string","func JSEscaper(args ...any) string","func URLQueryEscaper(args ...any) string","func Must(t *Template, err error) *Template","func ParseFiles(filenames ...string) (*Template, error)","func ParseGlob(pattern string) (*Template, error)","func ParseFS(fsys fs.FS, patterns ...string) (*Template, error)","type Template struct {\n\tname\tstring\n\t*parse.Tree\n\t*common\n\tleftDelim\tstring\n\trightDelim\tstring\n}","func New(name string) *Template","func IsSurrogate(r rune) bool","func DecodeRune(r1, r2 rune) rune","func EncodeRune(r rune) (r1, r2 rune)","func RuneLen(r rune) int","func Encode(s []rune) []uint16","func AppendRune(a []uint16, r rune) []uint16","func Decode(s []uint16) []rune","const RuneError = '\\uFFFD'","const RuneSelf = 0x80","const MaxRune = '\\U0010FFFF'","const UTFMax = 4","func FullRune(p []byte) bool","func FullRuneInString(s string) bool","func DecodeRune(p []byte) (r rune, size int)","func DecodeRuneInString(s string) (r rune, size int)","func DecodeLastRune(p []byte) (r rune, size int)","func DecodeLastRuneInString(s string) (r rune, size int)","func RuneLen(r rune) int","func EncodeRune(p []byte, r rune) int","func AppendRune(p []byte, r rune) []byte","func RuneCount(p []byte) int","func RuneCountInString(s string) (n int)","func RuneStart(b byte) bool","func Valid(p []byte) bool","func ValidString(s string) bool","func ValidRune(r rune) bool","type AlgorithmIdentifier struct {\n\tAlgorithm\tasn1.ObjectIdentifier\n\tParameters\tasn1.RawValue\t`asn1:\"optional\"`\n}","type RDNSequence []RelativeDistinguishedNameSET","type RelativeDistinguishedNameSET []AttributeTypeAndValue","type AttributeTypeAndValue struct {\n\tType\tasn1.ObjectIdentifier\n\tValue\tany\n}","type AttributeTypeAndValueSET struct {\n\tType\tasn1.ObjectIdentifier\n\tValue\t[][]AttributeTypeAndValue\t`asn1:\"set\"`\n}","type Extension struct {\n\tId\t\tasn1.ObjectIdentifier\n\tCritical\tbool\t`asn1:\"optional\"`\n\tValue\t\t[]byte\n}","type Name struct {\n\tCountry, Organization, OrganizationalUnit\t[]string\n\tLocality, Province\t\t\t\t[]string\n\tStreetAddress, PostalCode\t\t\t[]string\n\tSerialNumber, CommonName\t\t\tstring\n\n\t// Names contains all parsed attributes. When parsing distinguished names,\n\t// this can be used to extract non-standard attributes that are not parsed\n\t// by this package. When marshaling to RDNSequences, the Names field is\n\t// ignored, see ExtraNames.\n\tNames\t[]AttributeTypeAndValue\n\n\t// ExtraNames contains attributes to be copied, raw, into any marshaled\n\t// distinguished names. Values override any attributes with the same OID.\n\t// The ExtraNames field is not populated when parsing, see Names.\n\tExtraNames\t[]AttributeTypeAndValue\n}","type CertificateList struct {\n\tTBSCertList\t\tTBSCertificateList\n\tSignatureAlgorithm\tAlgorithmIdentifier\n\tSignatureValue\t\tasn1.BitString\n}","type TBSCertificateList struct {\n\tRaw\t\t\tasn1.RawContent\n\tVersion\t\t\tint\t`asn1:\"optional,default:0\"`\n\tSignature\t\tAlgorithmIdentifier\n\tIssuer\t\t\tRDNSequence\n\tThisUpdate\t\ttime.Time\n\tNextUpdate\t\ttime.Time\t\t`asn1:\"optional\"`\n\tRevokedCertificates\t[]RevokedCertificate\t`asn1:\"optional\"`\n\tExtensions\t\t[]Extension\t\t`asn1:\"tag:0,optional,explicit\"`\n}","type RevokedCertificate struct {\n\tSerialNumber\t*big.Int\n\tRevocationTime\ttime.Time\n\tExtensions\t[]Extension\t`asn1:\"optional\"`\n}","","type NamedValue struct {\n\t// If the Name is not empty it should be used for the parameter identifier and\n\t// not the ordinal position.\n\t//\n\t// Name will not have a symbol prefix.\n\tName\tstring\n\n\t// Ordinal position of the parameter starting from one and is always set.\n\tOrdinal\tint\n\n\t// Value is the parameter value.\n\tValue\tValue\n}","type Driver interface {\n\t// Open returns a new connection to the database.\n\t// The name is a string in a driver-specific format.\n\t//\n\t// Open may return a cached connection (one previously\n\t// closed), but doing so is unnecessary; the sql package\n\t// maintains a pool of idle connections for efficient re-use.\n\t//\n\t// The returned connection is only used by one goroutine at a\n\t// time.\n\tOpen(name string) (Conn, error)\n}","type DriverContext interface {\n\t// OpenConnector must parse the name in the same format that Driver.Open\n\t// parses the name parameter.\n\tOpenConnector(name string) (Connector, error)\n}","type Connector interface {\n\t// Connect returns a connection to the database.\n\t// Connect may return a cached connection (one previously\n\t// closed), but doing so is unnecessary; the sql package\n\t// maintains a pool of idle connections for efficient re-use.\n\t//\n\t// The provided context.Context is for dialing purposes only\n\t// (see net.DialContext) and should not be stored or used for\n\t// other purposes. A default timeout should still be used\n\t// when dialing as a connection pool may call Connect\n\t// asynchronously to any query.\n\t//\n\t// The returned connection is only used by one goroutine at a\n\t// time.\n\tConnect(context.Context) (Conn, error)\n\n\t// Driver returns the underlying Driver of the Connector,\n\t// mainly to maintain compatibility with the Driver method\n\t// on sql.DB.\n\tDriver() Driver\n}","","","type Pinger interface {\n\tPing(ctx context.Context) error\n}","type Execer interface {\n\tExec(query string, args []Value) (Result, error)\n}","type ExecerContext interface {\n\tExecContext(ctx context.Context, query string, args []NamedValue) (Result, error)\n}","type Queryer interface {\n\tQuery(query string, args []Value) (Rows, error)\n}","type QueryerContext interface {\n\tQueryContext(ctx context.Context, query string, args []NamedValue) (Rows, error)\n}","type Conn interface {\n\t// Prepare returns a prepared statement, bound to this connection.\n\tPrepare(query string) (Stmt, error)\n\n\t// Close invalidates and potentially stops any current\n\t// prepared statements and transactions, marking this\n\t// connection as no longer in use.\n\t//\n\t// Because the sql package maintains a free pool of\n\t// connections and only calls Close when there's a surplus of\n\t// idle connections, it shouldn't be necessary for drivers to\n\t// do their own connection caching.\n\t//\n\t// Drivers must ensure all network calls made by Close\n\t// do not block indefinitely (e.g. apply a timeout).\n\tClose() error\n\n\t// Begin starts and returns a new transaction.\n\t//\n\t// Deprecated: Drivers should implement ConnBeginTx instead (or additionally).\n\tBegin() (Tx, error)\n}","type ConnPrepareContext interface {\n\t// PrepareContext returns a prepared statement, bound to this connection.\n\t// context is for the preparation of the statement,\n\t// it must not store the context within the statement itself.\n\tPrepareContext(ctx context.Context, query string) (Stmt, error)\n}","","type TxOptions struct {\n\tIsolation\tIsolationLevel\n\tReadOnly\tbool\n}","type ConnBeginTx interface {\n\t// BeginTx starts and returns a new transaction.\n\t// If the context is canceled by the user the sql package will\n\t// call Tx.Rollback before discarding and closing the connection.\n\t//\n\t// This must check opts.Isolation to determine if there is a set\n\t// isolation level. If the driver does not support a non-default\n\t// level and one is set or if there is a non-default isolation level\n\t// that is not supported, an error must be returned.\n\t//\n\t// This must also check opts.ReadOnly to determine if the read-only\n\t// value is true to either set the read-only transaction property if supported\n\t// or return an error if it is not supported.\n\tBeginTx(ctx context.Context, opts TxOptions) (Tx, error)\n}","type SessionResetter interface {\n\t// ResetSession is called prior to executing a query on the connection\n\t// if the connection has been used before. If the driver returns ErrBadConn\n\t// the connection is discarded.\n\tResetSession(ctx context.Context) error\n}","type Validator interface {\n\t// IsValid is called prior to placing the connection into the\n\t// connection pool. The connection will be discarded if false is returned.\n\tIsValid() bool\n}","type Result interface {\n\t// LastInsertId returns the database's auto-generated ID\n\t// after, for example, an INSERT into a table with primary\n\t// key.\n\tLastInsertId() (int64, error)\n\n\t// RowsAffected returns the number of rows affected by the\n\t// query.\n\tRowsAffected() (int64, error)\n}","type Stmt interface {\n\t// Close closes the statement.\n\t//\n\t// As of Go 1.1, a Stmt will not be closed if it's in use\n\t// by any queries.\n\t//\n\t// Drivers must ensure all network calls made by Close\n\t// do not block indefinitely (e.g. apply a timeout).\n\tClose() error\n\n\t// NumInput returns the number of placeholder parameters.\n\t//\n\t// If NumInput returns \u003e= 0, the sql package will sanity check\n\t// argument counts from callers and return errors to the caller\n\t// before the statement's Exec or Query methods are called.\n\t//\n\t// NumInput may also return -1, if the driver doesn't know\n\t// its number of placeholders. In that case, the sql package\n\t// will not sanity check Exec or Query argument counts.\n\tNumInput() int\n\n\t// Exec executes a query that doesn't return rows, such\n\t// as an INSERT or UPDATE.\n\t//\n\t// Deprecated: Drivers should implement StmtExecContext instead (or additionally).\n\tExec(args []Value) (Result, error)\n\n\t// Query executes a query that may return rows, such as a\n\t// SELECT.\n\t//\n\t// Deprecated: Drivers should implement StmtQueryContext instead (or additionally).\n\tQuery(args []Value) (Rows, error)\n}","type StmtExecContext interface {\n\t// ExecContext executes a query that doesn't return rows, such\n\t// as an INSERT or UPDATE.\n\t//\n\t// ExecContext must honor the context timeout and return when it is canceled.\n\tExecContext(ctx context.Context, args []NamedValue) (Result, error)\n}","type StmtQueryContext interface {\n\t// QueryContext executes a query that may return rows, such as a\n\t// SELECT.\n\t//\n\t// QueryContext must honor the context timeout and return when it is canceled.\n\tQueryContext(ctx context.Context, args []NamedValue) (Rows, error)\n}","","type NamedValueChecker interface {\n\t// CheckNamedValue is called before passing arguments to the driver\n\t// and is called in place of any ColumnConverter. CheckNamedValue must do type\n\t// validation and conversion as appropriate for the driver.\n\tCheckNamedValue(*NamedValue) error\n}","type ColumnConverter interface {\n\t// ColumnConverter returns a ValueConverter for the provided\n\t// column index. If the type of a specific column isn't known\n\t// or shouldn't be handled specially, [DefaultParameterConverter]\n\t// can be returned.\n\tColumnConverter(idx int) ValueConverter\n}","type Rows interface {\n\t// Columns returns the names of the columns. The number of\n\t// columns of the result is inferred from the length of the\n\t// slice. If a particular column name isn't known, an empty\n\t// string should be returned for that entry.\n\tColumns() []string\n\n\t// Close closes the rows iterator.\n\tClose() error\n\n\t// Next is called to populate the next row of data into\n\t// the provided slice. The provided slice will be the same\n\t// size as the Columns() are wide.\n\t//\n\t// Next should return io.EOF when there are no more rows.\n\t//\n\t// The dest should not be written to outside of Next. Care\n\t// should be taken when closing Rows not to modify\n\t// a buffer held in dest.\n\tNext(dest []Value) error\n}","type RowsNextResultSet interface {\n\tRows\n\n\t// HasNextResultSet is called at the end of the current result set and\n\t// reports whether there is another result set after the current one.\n\tHasNextResultSet() bool\n\n\t// NextResultSet advances the driver to the next result set even\n\t// if there are remaining rows in the current result set.\n\t//\n\t// NextResultSet should return io.EOF when there are no more result sets.\n\tNextResultSet() error\n}","type RowsColumnTypeScanType interface {\n\tRows\n\tColumnTypeScanType(index int) reflect.Type\n}","type RowsColumnTypeDatabaseTypeName interface {\n\tRows\n\tColumnTypeDatabaseTypeName(index int) string\n}","type RowsColumnTypeLength interface {\n\tRows\n\tColumnTypeLength(index int) (length int64, ok bool)\n}","type RowsColumnTypeNullable interface {\n\tRows\n\tColumnTypeNullable(index int) (nullable, ok bool)\n}","type RowsColumnTypePrecisionScale interface {\n\tRows\n\tColumnTypePrecisionScale(index int) (precision, scale int64, ok bool)\n}","type Tx interface {\n\tCommit() error\n\tRollback() error\n}","","var ResultNoRows noRows","type ValueConverter interface {\n\t// ConvertValue converts a value to a driver Value.\n\tConvertValue(v any) (Value, error)\n}","type Valuer interface {\n\t// Value returns a driver Value.\n\t// Value must not panic.\n\tValue() (Value, error)\n}","var Bool boolType","var Int32 int32Type","var String stringType","type Null struct {\n\tConverter ValueConverter\n}","type NotNull struct {\n\tConverter ValueConverter\n}","func IsValue(v any) bool","func IsScanValue(v any) bool","var DefaultParameterConverter defaultConverter","type Expr interface {\n\t// String returns the string form of the expression,\n\t// using the boolean syntax used in //go:build lines.\n\tString() string\n\n\t// Eval reports whether the expression evaluates to true.\n\t// It calls ok(tag) as needed to find out whether a given build tag\n\t// is satisfied by the current build configuration.\n\tEval(ok func(tag string) bool) bool\n\n\t// The presence of an isExpr method explicitly marks the type as an Expr.\n\t// Only implementations in this package should be used as Exprs.\n\tisExpr()\n}","type TagExpr struct {\n\tTag string\t// for example, “linux” or “cgo”\n}","type NotExpr struct {\n\tX Expr\n}","type AndExpr struct {\n\tX, Y Expr\n}","type OrExpr struct {\n\tX, Y Expr\n}","type SyntaxError struct {\n\tOffset\tint\t// byte offset in input where error was detected\n\tErr\tstring\t// description of error\n}","func Parse(line string) (Expr, error)","func IsGoBuild(line string) bool","func IsPlusBuild(line string) bool","func PlusBuildLines(x Expr) ([]string, error)","func GoVersion(x Expr) string","type Doc struct {\n\t// Content is the sequence of content blocks in the comment.\n\tContent\t[]Block\n\n\t// Links is the link definitions in the comment.\n\tLinks\t[]*LinkDef\n}","type LinkDef struct {\n\tText\tstring\t// the link text\n\tURL\tstring\t// the link URL\n\tUsed\tbool\t// whether the comment uses the definition\n}","type Block interface {\n\tblock()\n}","type Heading struct {\n\tText []Text\t// the heading text\n}","type List struct {\n\t// Items is the list items.\n\tItems\t[]*ListItem\n\n\t// ForceBlankBefore indicates that the list must be\n\t// preceded by a blank line when reformatting the comment,\n\t// overriding the usual conditions. See the BlankBefore method.\n\t//\n\t// The comment parser sets ForceBlankBefore for any list\n\t// that is preceded by a blank line, to make sure\n\t// the blank line is preserved when printing.\n\tForceBlankBefore\tbool\n\n\t// ForceBlankBetween indicates that list items must be\n\t// separated by blank lines when reformatting the comment,\n\t// overriding the usual conditions. See the BlankBetween method.\n\t//\n\t// The comment parser sets ForceBlankBetween for any list\n\t// that has a blank line between any two of its items, to make sure\n\t// the blank lines are preserved when printing.\n\tForceBlankBetween\tbool\n}","type ListItem struct {\n\t// Number is a decimal string in a numbered list\n\t// or an empty string in a bullet list.\n\tNumber\tstring\t// \"1\", \"2\", ...; \"\" for bullet list\n\n\t// Content is the list content.\n\t// Currently, restrictions in the parser and printer\n\t// require every element of Content to be a *Paragraph.\n\tContent\t[]Block\t// Content of this item.\n}","type Paragraph struct {\n\tText []Text\n}","type Code struct {\n\t// Text is the preformatted text, ending with a newline character.\n\t// It may be multiple lines, each of which ends with a newline character.\n\t// It is never empty, nor does it start or end with a blank line.\n\tText string\n}","type Text interface {\n\ttext()\n}","","","type Link struct {\n\tAuto\tbool\t// is this an automatic (implicit) link of a literal URL?\n\tText\t[]Text\t// text of link\n\tURL\tstring\t// target URL of link\n}","type DocLink struct {\n\tText\t[]Text\t// text of link\n\n\t// ImportPath, Recv, and Name identify the Go package or symbol\n\t// that is the link target. The potential combinations of\n\t// non-empty fields are:\n\t//  - ImportPath: a link to another package\n\t//  - ImportPath, Name: a link to a const, func, type, or var in another package\n\t//  - ImportPath, Recv, Name: a link to a method in another package\n\t//  - Name: a link to a const, func, type, or var in this package\n\t//  - Recv, Name: a link to a method in this package\n\tImportPath\tstring\t// import path\n\tRecv\t\tstring\t// receiver type, without any pointer star, for methods\n\tName\t\tstring\t// const, func, type, var, or method name\n}","type Parser struct {\n\t// Words is a map of Go identifier words that\n\t// should be italicized and potentially linked.\n\t// If Words[w] is the empty string, then the word w\n\t// is only italicized. Otherwise it is linked, using\n\t// Words[w] as the link target.\n\t// Words corresponds to the [go/doc.ToHTML] words parameter.\n\tWords\tmap[string]string\n\n\t// LookupPackage resolves a package name to an import path.\n\t//\n\t// If LookupPackage(name) returns ok == true, then [name]\n\t// (or [name.Sym] or [name.Sym.Method])\n\t// is considered a documentation link to importPath's package docs.\n\t// It is valid to return \"\", true, in which case name is considered\n\t// to refer to the current package.\n\t//\n\t// If LookupPackage(name) returns ok == false,\n\t// then [name] (or [name.Sym] or [name.Sym.Method])\n\t// will not be considered a documentation link,\n\t// except in the case where name is the full (but single-element) import path\n\t// of a package in the standard library, such as in [math] or [io.Reader].\n\t// LookupPackage is still called for such names,\n\t// in order to permit references to imports of other packages\n\t// with the same package names.\n\t//\n\t// Setting LookupPackage to nil is equivalent to setting it to\n\t// a function that always returns \"\", false.\n\tLookupPackage\tfunc(name string) (importPath string, ok bool)\n\n\t// LookupSym reports whether a symbol name or method name\n\t// exists in the current package.\n\t//\n\t// If LookupSym(\"\", \"Name\") returns true, then [Name]\n\t// is considered a documentation link for a const, func, type, or var.\n\t//\n\t// Similarly, if LookupSym(\"Recv\", \"Name\") returns true,\n\t// then [Recv.Name] is considered a documentation link for\n\t// type Recv's method Name.\n\t//\n\t// Setting LookupSym to nil is equivalent to setting it to a function\n\t// that always returns false.\n\tLookupSym\tfunc(recv, name string) (ok bool)\n}","func DefaultLookupPackage(name string) (importPath string, ok bool)","type Printer struct {\n\t// HeadingLevel is the nesting level used for\n\t// HTML and Markdown headings.\n\t// If HeadingLevel is zero, it defaults to level 3,\n\t// meaning to use \u003ch3\u003e and ###.\n\tHeadingLevel\tint\n\n\t// HeadingID is a function that computes the heading ID\n\t// (anchor tag) to use for the heading h when generating\n\t// HTML and Markdown. If HeadingID returns an empty string,\n\t// then the heading ID is omitted.\n\t// If HeadingID is nil, h.DefaultID is used.\n\tHeadingID\tfunc(h *Heading) string\n\n\t// DocLinkURL is a function that computes the URL for the given DocLink.\n\t// If DocLinkURL is nil, then link.DefaultURL(p.DocLinkBaseURL) is used.\n\tDocLinkURL\tfunc(link *DocLink) string\n\n\t// DocLinkBaseURL is used when DocLinkURL is nil,\n\t// passed to [DocLink.DefaultURL] to construct a DocLink's URL.\n\t// See that method's documentation for details.\n\tDocLinkBaseURL\tstring\n\n\t// TextPrefix is a prefix to print at the start of every line\n\t// when generating text output using the Text method.\n\tTextPrefix\tstring\n\n\t// TextCodePrefix is the prefix to print at the start of each\n\t// preformatted (code block) line when generating text output,\n\t// instead of (not in addition to) TextPrefix.\n\t// If TextCodePrefix is the empty string, it defaults to TextPrefix+\"\\t\".\n\tTextCodePrefix\tstring\n\n\t// TextWidth is the maximum width text line to generate,\n\t// measured in Unicode code points,\n\t// excluding TextPrefix and the newline character.\n\t// If TextWidth is zero, it defaults to 80 minus the number of code points in TextPrefix.\n\t// If TextWidth is negative, there is no limit.\n\tTextWidth\tint\n}","","","type ChaCha8 struct {\n\tstate\tchacha8rand.State\n\n\t// The last readLen bytes of readBuf are still to be consumed by Read.\n\treadBuf\t[8]byte\n\treadLen\tint\t// 0 \u003c= readLen \u003c= 8\n}","func NewChaCha8(seed [32]byte) *ChaCha8","type PCG struct {\n\thi\tuint64\n\tlo\tuint64\n}","func NewPCG(seed1, seed2 uint64) *PCG","type Source interface {\n\tUint64() uint64\n}","type Rand struct {\n\tsrc Source\n}","func New(src Source) *Rand","func Int64() int64","func Uint32() uint32","func Uint64N(n uint64) uint64","func Uint32N(n uint32) uint32","func Uint64() uint64","func Int32() int32","func Int() int","func Uint() uint","func Int64N(n int64) int64","func Int32N(n int32) int32","func IntN(n int) int","func UintN(n uint) uint","func N[Int intType](n Int) Int","func Float64() float64","func Float32() float32","func Perm(n int) []int","func Shuffle(n int, swap func(i, j int))","func NormFloat64() float64","func ExpFloat64() float64","type Zipf struct {\n\tr\t\t*Rand\n\timax\t\tfloat64\n\tv\t\tfloat64\n\tq\t\tfloat64\n\ts\t\tfloat64\n\toneminusQ\tfloat64\n\toneminusQinv\tfloat64\n\thxm\t\tfloat64\n\thx0minusHxm\tfloat64\n}","func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf","func Request() (*http.Request, error)","func RequestFromMap(params map[string]string) (*http.Request, error)","func Serve(handler http.Handler) error","type Handler struct {\n\tPath\tstring\t// path to the CGI executable\n\tRoot\tstring\t// root URI prefix of handler or empty for \"/\"\n\n\t// Dir specifies the CGI executable's working directory.\n\t// If Dir is empty, the base directory of Path is used.\n\t// If Path has no base directory, the current working\n\t// directory is used.\n\tDir\tstring\n\n\tEnv\t\t[]string\t// extra environment variables to set, if any, as \"key=value\"\n\tInheritEnv\t[]string\t// environment variables to inherit from host, as \"key\"\n\tLogger\t\t*log.Logger\t// optional log for errors or nil to use log.Print\n\tArgs\t\t[]string\t// optional arguments to pass to child process\n\tStderr\t\tio.Writer\t// optional stderr for the child process; nil means os.Stderr\n\n\t// PathLocationHandler specifies the root http Handler that\n\t// should handle internal redirects when the CGI process\n\t// returns a Location header value starting with a \"/\", as\n\t// specified in RFC 3875 § 6.3.2. This will likely be\n\t// http.DefaultServeMux.\n\t//\n\t// If nil, a CGI response with a local URI path is instead sent\n\t// back to the client and not redirected internally.\n\tPathLocationHandler\thttp.Handler\n}","type PublicSuffixList interface {\n\t// PublicSuffix returns the public suffix of domain.\n\t//\n\t// TODO: specify which of the caller and callee is responsible for IP\n\t// addresses, for leading and trailing dots, for case sensitivity, and\n\t// for IDN/Punycode.\n\tPublicSuffix(domain string) string\n\n\t// String returns a description of the source of this public suffix\n\t// list. The description will typically contain something like a time\n\t// stamp or version number.\n\tString() string\n}","type Options struct {\n\t// PublicSuffixList is the public suffix list that determines whether\n\t// an HTTP server can set a cookie for a domain.\n\t//\n\t// A nil value is valid and may be useful for testing but it is not\n\t// secure: it means that the HTTP server for foo.co.uk can set a cookie\n\t// for bar.co.uk.\n\tPublicSuffixList PublicSuffixList\n}","type Jar struct {\n\tpsList\tPublicSuffixList\n\n\t// mu locks the remaining fields.\n\tmu\tsync.Mutex\n\n\t// entries is a set of entries, keyed by their eTLD+1 and subkeyed by\n\t// their name/domain/path.\n\tentries\tmap[string]map[string]entry\n\n\t// nextSeqNum is the next sequence number assigned to a new cookie\n\t// created SetCookies.\n\tnextSeqNum\tuint64\n}","func New(o *Options) (*Jar, error)","","","func Serve(l net.Listener, handler http.Handler) error","func ProcessEnv(r *http.Request) map[string]string","func NewRequest(method, target string, body io.Reader) *http.Request","func NewRequestWithContext(ctx context.Context, method, target string, body io.Reader) *http.Request","type ResponseRecorder struct {\n\t// Code is the HTTP response code set by WriteHeader.\n\t//\n\t// Note that if a Handler never calls WriteHeader or Write,\n\t// this might end up being 0, rather than the implicit\n\t// http.StatusOK. To get the implicit value, use the Result\n\t// method.\n\tCode\tint\n\n\t// HeaderMap contains the headers explicitly set by the Handler.\n\t// It is an internal detail.\n\t//\n\t// Deprecated: HeaderMap exists for historical compatibility\n\t// and should not be used. To access the headers returned by a handler,\n\t// use the Response.Header map as returned by the Result method.\n\tHeaderMap\thttp.Header\n\n\t// Body is the buffer to which the Handler's Write calls are sent.\n\t// If nil, the Writes are silently discarded.\n\tBody\t*bytes.Buffer\n\n\t// Flushed is whether the Handler called Flush.\n\tFlushed\tbool\n\n\tresult\t\t*http.Response\t// cache of Result's return value\n\tsnapHeader\thttp.Header\t// snapshot of HeaderMap at first Write\n\twroteHeader\tbool\n}","func NewRecorder() *ResponseRecorder","const DefaultRemoteAddr = \"1.2.3.4\"","type Server struct {\n\tURL\t\tstring\t// base URL of form http://ipaddr:port with no trailing slash\n\tListener\tnet.Listener\n\n\t// EnableHTTP2 controls whether HTTP/2 is enabled\n\t// on the server. It must be set between calling\n\t// NewUnstartedServer and calling Server.StartTLS.\n\tEnableHTTP2\tbool\n\n\t// TLS is the optional TLS configuration, populated with a new config\n\t// after TLS is started. If set on an unstarted server before StartTLS\n\t// is called, existing fields are copied into the new config.\n\tTLS\t*tls.Config\n\n\t// Config may be changed after calling NewUnstartedServer and\n\t// before Start or StartTLS.\n\tConfig\t*http.Server\n\n\t// certificate is a parsed version of the TLS config certificate, if present.\n\tcertificate\t*x509.Certificate\n\n\t// wg counts the number of outstanding HTTP requests on this server.\n\t// Close blocks until all requests are finished.\n\twg\tsync.WaitGroup\n\n\tmu\tsync.Mutex\t// guards closed and conns\n\tclosed\tbool\n\tconns\tmap[net.Conn]http.ConnState\t// except terminal states\n\n\t// client is configured for use with the server.\n\t// Its transport is automatically closed when Close is called.\n\tclient\t*http.Client\n}","func NewServer(handler http.Handler) *Server","func NewUnstartedServer(handler http.Handler) *Server","func NewTLSServer(handler http.Handler) *Server","func ContextClientTrace(ctx context.Context) *ClientTrace","func WithClientTrace(ctx context.Context, trace *ClientTrace) context.Context","type ClientTrace struct {\n\t// GetConn is called before a connection is created or\n\t// retrieved from an idle pool. The hostPort is the\n\t// \"host:port\" of the target or proxy. GetConn is called even\n\t// if there's already an idle cached connection available.\n\tGetConn\tfunc(hostPort string)\n\n\t// GotConn is called after a successful connection is\n\t// obtained. There is no hook for failure to obtain a\n\t// connection; instead, use the error from\n\t// Transport.RoundTrip.\n\tGotConn\tfunc(GotConnInfo)\n\n\t// PutIdleConn is called when the connection is returned to\n\t// the idle pool. If err is nil, the connection was\n\t// successfully returned to the idle pool. If err is non-nil,\n\t// it describes why not. PutIdleConn is not called if\n\t// connection reuse is disabled via Transport.DisableKeepAlives.\n\t// PutIdleConn is called before the caller's Response.Body.Close\n\t// call returns.\n\t// For HTTP/2, this hook is not currently used.\n\tPutIdleConn\tfunc(err error)\n\n\t// GotFirstResponseByte is called when the first byte of the response\n\t// headers is available.\n\tGotFirstResponseByte\tfunc()\n\n\t// Got100Continue is called if the server replies with a \"100\n\t// Continue\" response.\n\tGot100Continue\tfunc()\n\n\t// Got1xxResponse is called for each 1xx informational response header\n\t// returned before the final non-1xx response. Got1xxResponse is called\n\t// for \"100 Continue\" responses, even if Got100Continue is also defined.\n\t// If it returns an error, the client request is aborted with that error value.\n\tGot1xxResponse\tfunc(code int, header textproto.MIMEHeader) error\n\n\t// DNSStart is called when a DNS lookup begins.\n\tDNSStart\tfunc(DNSStartInfo)\n\n\t// DNSDone is called when a DNS lookup ends.\n\tDNSDone\tfunc(DNSDoneInfo)\n\n\t// ConnectStart is called when a new connection's Dial begins.\n\t// If net.Dialer.DualStack (IPv6 \"Happy Eyeballs\") support is\n\t// enabled, this may be called multiple times.\n\tConnectStart\tfunc(network, addr string)\n\n\t// ConnectDone is called when a new connection's Dial\n\t// completes. The provided err indicates whether the\n\t// connection completed successfully.\n\t// If net.Dialer.DualStack (\"Happy Eyeballs\") support is\n\t// enabled, this may be called multiple times.\n\tConnectDone\tfunc(network, addr string, err error)\n\n\t// TLSHandshakeStart is called when the TLS handshake is started. When\n\t// connecting to an HTTPS site via an HTTP proxy, the handshake happens\n\t// after the CONNECT request is processed by the proxy.\n\tTLSHandshakeStart\tfunc()\n\n\t// TLSHandshakeDone is called after the TLS handshake with either the\n\t// successful handshake's connection state, or a non-nil error on handshake\n\t// failure.\n\tTLSHandshakeDone\tfunc(tls.ConnectionState, error)\n\n\t// WroteHeaderField is called after the Transport has written\n\t// each request header. At the time of this call the values\n\t// might be buffered and not yet written to the network.\n\tWroteHeaderField\tfunc(key string, value []string)\n\n\t// WroteHeaders is called after the Transport has written\n\t// all request headers.\n\tWroteHeaders\tfunc()\n\n\t// Wait100Continue is called if the Request specified\n\t// \"Expect: 100-continue\" and the Transport has written the\n\t// request headers but is waiting for \"100 Continue\" from the\n\t// server before writing the request body.\n\tWait100Continue\tfunc()\n\n\t// WroteRequest is called with the result of writing the\n\t// request and any body. It may be called multiple times\n\t// in the case of retried requests.\n\tWroteRequest\tfunc(WroteRequestInfo)\n}","type WroteRequestInfo struct {\n\t// Err is any error encountered while writing the Request.\n\tErr error\n}","type DNSStartInfo struct {\n\tHost string\n}","type DNSDoneInfo struct {\n\t// Addrs are the IPv4 and/or IPv6 addresses found in the DNS\n\t// lookup. The contents of the slice should not be mutated.\n\tAddrs\t[]net.IPAddr\n\n\t// Err is any error that occurred during the DNS lookup.\n\tErr\terror\n\n\t// Coalesced is whether the Addrs were shared with another\n\t// caller who was doing the same DNS lookup concurrently.\n\tCoalesced\tbool\n}","type GotConnInfo struct {\n\t// Conn is the connection that was obtained. It is owned by\n\t// the http.Transport and should not be read, written or\n\t// closed by users of ClientTrace.\n\tConn\tnet.Conn\n\n\t// Reused is whether this connection has been previously\n\t// used for another HTTP request.\n\tReused\tbool\n\n\t// WasIdle is whether this connection was obtained from an\n\t// idle pool.\n\tWasIdle\tbool\n\n\t// IdleTime reports how long the connection was previously\n\t// idle, if WasIdle is true.\n\tIdleTime\ttime.Duration\n}","func DumpRequestOut(req *http.Request, body bool) ([]byte, error)","func DumpRequest(req *http.Request, body bool) ([]byte, error)","func DumpResponse(resp *http.Response, body bool) ([]byte, error)","func NewChunkedReader(r io.Reader) io.Reader","func NewChunkedWriter(w io.Writer) io.WriteCloser","","","","","type ServerConn struct {\n\tmu\t\tsync.Mutex\t// read-write protects the following fields\n\tc\t\tnet.Conn\n\tr\t\t*bufio.Reader\n\tre, we\t\terror\t// read/write errors\n\tlastbody\tio.ReadCloser\n\tnread, nwritten\tint\n\tpipereq\t\tmap[*http.Request]uint\n\n\tpipe\ttextproto.Pipeline\n}","func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn","type ClientConn struct {\n\tmu\t\tsync.Mutex\t// read-write protects the following fields\n\tc\t\tnet.Conn\n\tr\t\t*bufio.Reader\n\tre, we\t\terror\t// read/write errors\n\tlastbody\tio.ReadCloser\n\tnread, nwritten\tint\n\tpipereq\t\tmap[*http.Request]uint\n\n\tpipe\t\ttextproto.Pipeline\n\twriteReq\tfunc(*http.Request, io.Writer) error\n}","func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn","func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn","type ProxyRequest struct {\n\t// In is the request received by the proxy.\n\t// The Rewrite function must not modify In.\n\tIn\t*http.Request\n\n\t// Out is the request which will be sent by the proxy.\n\t// The Rewrite function may modify or replace this request.\n\t// Hop-by-hop headers are removed from this request\n\t// before Rewrite is called.\n\tOut\t*http.Request\n}","type ReverseProxy struct {\n\t// Rewrite must be a function which modifies\n\t// the request into a new request to be sent\n\t// using Transport. Its response is then copied\n\t// back to the original client unmodified.\n\t// Rewrite must not access the provided ProxyRequest\n\t// or its contents after returning.\n\t//\n\t// The Forwarded, X-Forwarded, X-Forwarded-Host,\n\t// and X-Forwarded-Proto headers are removed from the\n\t// outbound request before Rewrite is called. See also\n\t// the ProxyRequest.SetXForwarded method.\n\t//\n\t// Unparsable query parameters are removed from the\n\t// outbound request before Rewrite is called.\n\t// The Rewrite function may copy the inbound URL's\n\t// RawQuery to the outbound URL to preserve the original\n\t// parameter string. Note that this can lead to security\n\t// issues if the proxy's interpretation of query parameters\n\t// does not match that of the downstream server.\n\t//\n\t// At most one of Rewrite or Director may be set.\n\tRewrite\tfunc(*ProxyRequest)\n\n\t// Director is a function which modifies\n\t// the request into a new request to be sent\n\t// using Transport. Its response is then copied\n\t// back to the original client unmodified.\n\t// Director must not access the provided Request\n\t// after returning.\n\t//\n\t// By default, the X-Forwarded-For header is set to the\n\t// value of the client IP address. If an X-Forwarded-For\n\t// header already exists, the client IP is appended to the\n\t// existing values. As a special case, if the header\n\t// exists in the Request.Header map but has a nil value\n\t// (such as when set by the Director func), the X-Forwarded-For\n\t// header is not modified.\n\t//\n\t// To prevent IP spoofing, be sure to delete any pre-existing\n\t// X-Forwarded-For header coming from the client or\n\t// an untrusted proxy.\n\t//\n\t// Hop-by-hop headers are removed from the request after\n\t// Director returns, which can remove headers added by\n\t// Director. Use a Rewrite function instead to ensure\n\t// modifications to the request are preserved.\n\t//\n\t// Unparsable query parameters are removed from the outbound\n\t// request if Request.Form is set after Director returns.\n\t//\n\t// At most one of Rewrite or Director may be set.\n\tDirector\tfunc(*http.Request)\n\n\t// The transport used to perform proxy requests.\n\t// If nil, http.DefaultTransport is used.\n\tTransport\thttp.RoundTripper\n\n\t// FlushInterval specifies the flush interval\n\t// to flush to the client while copying the\n\t// response body.\n\t// If zero, no periodic flushing is done.\n\t// A negative value means to flush immediately\n\t// after each write to the client.\n\t// The FlushInterval is ignored when ReverseProxy\n\t// recognizes a response as a streaming response, or\n\t// if its ContentLength is -1; for such responses, writes\n\t// are flushed to the client immediately.\n\tFlushInterval\ttime.Duration\n\n\t// ErrorLog specifies an optional logger for errors\n\t// that occur when attempting to proxy the request.\n\t// If nil, logging is done via the log package's standard logger.\n\tErrorLog\t*log.Logger\n\n\t// BufferPool optionally specifies a buffer pool to\n\t// get byte slices for use by io.CopyBuffer when\n\t// copying HTTP response bodies.\n\tBufferPool\tBufferPool\n\n\t// ModifyResponse is an optional function that modifies the\n\t// Response from the backend. It is called if the backend\n\t// returns a response at all, with any HTTP status code.\n\t// If the backend is unreachable, the optional ErrorHandler is\n\t// called without any call to ModifyResponse.\n\t//\n\t// If ModifyResponse returns an error, ErrorHandler is called\n\t// with its error value. If ErrorHandler is nil, its default\n\t// implementation is used.\n\tModifyResponse\tfunc(*http.Response) error\n\n\t// ErrorHandler is an optional function that handles errors\n\t// reaching the backend or errors from ModifyResponse.\n\t//\n\t// If nil, the default is to log the provided error and return\n\t// a 502 Status Bad Gateway response.\n\tErrorHandler\tfunc(http.ResponseWriter, *http.Request, error)\n}","type BufferPool interface {\n\tGet() []byte\n\tPut([]byte)\n}","func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy","func Cmdline(w http.ResponseWriter, r *http.Request)","func Profile(w http.ResponseWriter, r *http.Request)","func Trace(w http.ResponseWriter, r *http.Request)","func Symbol(w http.ResponseWriter, r *http.Request)","func Handler(name string) http.Handler","func Index(w http.ResponseWriter, r *http.Request)","func NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec","func NewClient(conn io.ReadWriteCloser) *rpc.Client","func Dial(network, address string) (*rpc.Client, error)","func NewServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec","func ServeConn(conn io.ReadWriteCloser)","type Node interface {\n\tType() NodeType\n\tString() string\n\t// Copy does a deep copy of the Node and all its components.\n\t// To avoid type assertions, some XxxNodes also have specialized\n\t// CopyXxx methods that return *XxxNode.\n\tCopy() Node\n\tPosition() Pos\t// byte position of start of node in full original input string\n\t// tree returns the containing *Tree.\n\t// It is unexported so all implementations of Node are in this package.\n\ttree() *Tree\n\t// writeTo writes the String output to the builder.\n\twriteTo(*strings.Builder)\n}","","","const NodeText NodeType","const NodeAction","const NodeBool","const NodeChain","const NodeCommand","const NodeDot","const NodeField","const NodeIdentifier","const NodeIf","const NodeList","const NodeNil","const NodeNumber","const NodePipe","const NodeRange","const NodeString","const NodeTemplate","const NodeVariable","const NodeWith","const NodeComment","const NodeBreak","const NodeContinue","type ListNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tNodes\t[]Node\t// The element nodes in lexical order.\n}","type TextNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tText\t[]byte\t// The text; may span newlines.\n}","type CommentNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tText\tstring\t// Comment text.\n}","type PipeNode struct {\n\tNodeType\n\tPos\n\ttr\t\t*Tree\n\tLine\t\tint\t\t// The line number in the input. Deprecated: Kept for compatibility.\n\tIsAssign\tbool\t\t// The variables are being assigned, not declared.\n\tDecl\t\t[]*VariableNode\t// Variables in lexical order.\n\tCmds\t\t[]*CommandNode\t// The commands in lexical order.\n}","type ActionNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tLine\tint\t\t// The line number in the input. Deprecated: Kept for compatibility.\n\tPipe\t*PipeNode\t// The pipeline in the action.\n}","type CommandNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tArgs\t[]Node\t// Arguments in lexical order: Identifier, field, or constant.\n}","type IdentifierNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tIdent\tstring\t// The identifier's name.\n}","func NewIdentifier(ident string) *IdentifierNode","type VariableNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tIdent\t[]string\t// Variable name and fields in lexical order.\n}","type DotNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n}","type NilNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n}","type FieldNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tIdent\t[]string\t// The identifiers in lexical order.\n}","type ChainNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tNode\tNode\n\tField\t[]string\t// The identifiers in lexical order.\n}","type BoolNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tTrue\tbool\t// The value of the boolean constant.\n}","type NumberNode struct {\n\tNodeType\n\tPos\n\ttr\t\t*Tree\n\tIsInt\t\tbool\t\t// Number has an integral value.\n\tIsUint\t\tbool\t\t// Number has an unsigned integral value.\n\tIsFloat\t\tbool\t\t// Number has a floating-point value.\n\tIsComplex\tbool\t\t// Number is complex.\n\tInt64\t\tint64\t\t// The signed integer value.\n\tUint64\t\tuint64\t\t// The unsigned integer value.\n\tFloat64\t\tfloat64\t\t// The floating-point value.\n\tComplex128\tcomplex128\t// The complex value.\n\tText\t\tstring\t\t// The original textual representation from the input.\n}","type StringNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tQuoted\tstring\t// The original text of the string, with quotes.\n\tText\tstring\t// The string, after quote processing.\n}","type BranchNode struct {\n\tNodeType\n\tPos\n\ttr\t\t*Tree\n\tLine\t\tint\t\t// The line number in the input. Deprecated: Kept for compatibility.\n\tPipe\t\t*PipeNode\t// The pipeline to be evaluated.\n\tList\t\t*ListNode\t// What to execute if the value is non-empty.\n\tElseList\t*ListNode\t// What to execute if the value is empty (nil if absent).\n}","type IfNode struct {\n\tBranchNode\n}","type BreakNode struct {\n\ttr\t*Tree\n\tNodeType\n\tPos\n\tLine\tint\n}","type ContinueNode struct {\n\ttr\t*Tree\n\tNodeType\n\tPos\n\tLine\tint\n}","type RangeNode struct {\n\tBranchNode\n}","type WithNode struct {\n\tBranchNode\n}","type TemplateNode struct {\n\tNodeType\n\tPos\n\ttr\t*Tree\n\tLine\tint\t\t// The line number in the input. Deprecated: Kept for compatibility.\n\tName\tstring\t\t// The name of the template (unquoted).\n\tPipe\t*PipeNode\t// The command to evaluate as dot for the template.\n}","type Tree struct {\n\tName\t\tstring\t\t// name of the template represented by the tree.\n\tParseName\tstring\t\t// name of the top-level template during parsing, for error messages.\n\tRoot\t\t*ListNode\t// top-level root of the tree.\n\tMode\t\tMode\t\t// parsing mode.\n\ttext\t\tstring\t\t// text parsed to create the template (or its parent)\n\t// Parsing only; cleared after parse.\n\tfuncs\t\t[]map[string]any\n\tlex\t\t*lexer\n\ttoken\t\t[3]item\t// three-token lookahead for parser.\n\tpeekCount\tint\n\tvars\t\t[]string\t// variables defined at the moment.\n\ttreeSet\t\tmap[string]*Tree\n\tactionLine\tint\t// line of left delim starting action\n\trangeDepth\tint\n}","","const ParseComments Mode","const SkipFuncCheck","func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error)","func New(name string, funcs ...map[string]any) *Tree","func IsEmptyTree(n Node) bool","const KeySize = 32","const NonceSize = 12","const NonceSizeX = 24","type Cipher struct {\n\t// The ChaCha20 state is 16 words: 4 constant, 8 of key, 1 of counter\n\t// (incremented after each block), and 3 of nonce.\n\tkey\t[8]uint32\n\tcounter\tuint32\n\tnonce\t[3]uint32\n\n\t// The last len bytes of buf are leftover key stream bytes from the previous\n\t// XORKeyStream invocation. The size of buf depends on how many blocks are\n\t// computed at a time by xorKeyStreamBlocks.\n\tbuf\t[bufSize]byte\n\tlen\tint\n\n\t// overflow is set when the counter overflowed, no more blocks can be\n\t// generated, and the next XORKeyStream call should panic.\n\toverflow\tbool\n\n\t// The counter-independent results of the first round are cached after they\n\t// are computed the first time.\n\tprecompDone\t\tbool\n\tp1, p5, p9, p13\t\tuint32\n\tp2, p6, p10, p14\tuint32\n\tp3, p7, p11, p15\tuint32\n}","func NewUnauthenticatedCipher(key, nonce []byte) (*Cipher, error)","func HChaCha20(key, nonce []byte) ([]byte, error)","const KeySize = 32","const NonceSize = 12","const NonceSizeX = 24","const Overhead = 16","func New(key []byte) (cipher.AEAD, error)","func NewX(key []byte) (cipher.AEAD, error)","type Builder struct {\n\terr\t\terror\n\tresult\t\t[]byte\n\tfixedSize\tbool\n\tchild\t\t*Builder\n\toffset\t\tint\n\tpendingLenLen\tint\n\tpendingIsASN1\tbool\n\tinContinuation\t*bool\n}","func NewBuilder(buffer []byte) *Builder","func NewFixedBuilder(buffer []byte) *Builder","type BuilderContinuation func(child *Builder)","type BuildError struct {\n\tErr error\n}","type MarshalingValue interface {\n\t// Marshal is called by Builder.AddValue. It receives a pointer to a builder\n\t// to marshal itself into. It may return an error that occurred during\n\t// marshaling, such as unset or invalid values.\n\tMarshal(b *Builder) error\n}","type String []byte","func Extract(hash func() hash.Hash, secret, salt []byte) []byte","func Expand(hash func() hash.Hash, pseudorandomKey, info []byte) io.Reader","func New(hash func() hash.Hash, secret, salt, info []byte) io.Reader","func New224() hash.Hash","func New256() hash.Hash","func New384() hash.Hash","func New512() hash.Hash","func NewLegacyKeccak256() hash.Hash","func NewLegacyKeccak512() hash.Hash","func Sum224(data []byte) (digest [28]byte)","func Sum256(data []byte) (digest [32]byte)","func Sum384(data []byte) (digest [48]byte)","func Sum512(data []byte) (digest [64]byte)","type ShakeHash interface {\n\thash.Hash\n\n\t// Read reads more output from the hash; reading affects the hash's\n\t// state. (ShakeHash.Read is thus very different from Hash.Sum)\n\t// It never returns an error, but subsequent calls to Write or Sum\n\t// will panic.\n\tio.Reader\n\n\t// Clone returns a copy of the ShakeHash in its current state.\n\tClone() ShakeHash\n}","func NewShake128() ShakeHash","func NewShake256() ShakeHash","func NewCShake128(N, S []byte) ShakeHash","func NewCShake256(N, S []byte) ShakeHash","func ShakeSum128(hash, data []byte)","func ShakeSum256(hash, data []byte)","func ToASCII(s string) (string, error)","func ToUnicode(s string) (string, error)","type Option func(*options)","func Transitional(transitional bool) Option","func VerifyDNSLength(verify bool) Option","func RemoveLeadingDots(remove bool) Option","func ValidateLabels(enable bool) Option","func CheckHyphens(enable bool) Option","func CheckJoiners(enable bool) Option","func StrictDomainName(use bool) Option","func BidiRule() Option","func ValidateForRegistration() Option","func MapForLookup() Option","type Profile struct {\n\toptions\n}","func New(o ...Option) *Profile","var Punycode *Profile","var Lookup *Profile","var Display *Profile","var Registration *Profile","const UnicodeVersion = \"9.0.0\"","type MakePipe func() (c1, c2 net.Conn, stop func(), err error)","func TestConn(t *testing.T, mp MakePipe)","func SupportsIPv4() bool","func SupportsIPv6() bool","func SupportsRawSocket() bool","func TestableNetwork(network string) bool","func TestableAddress(network, address string) bool","func NewLocalListener(network string) (net.Listener, error)","func NewLocalPacketListener(network string) (net.PacketConn, error)","func LocalPath() (string, error)","func MulticastSource(network string, ifi *net.Interface) (net.IP, error)","func LoopbackInterface() (*net.Interface, error)","func RoutedInterface(network string, flags net.Flags) (*net.Interface, error)","var Initialized bool","type CacheLinePad struct{ _ [cacheLineSize]byte }","var X86 struct {\n\t_\t\t\tCacheLinePad\n\tHasAES\t\t\tbool\t// AES hardware implementation (AES NI)\n\tHasADX\t\t\tbool\t// Multi-precision add-carry instruction extensions\n\tHasAVX\t\t\tbool\t// Advanced vector extension\n\tHasAVX2\t\t\tbool\t// Advanced vector extension 2\n\tHasAVX512\t\tbool\t// Advanced vector extension 512\n\tHasAVX512F\t\tbool\t// Advanced vector extension 512 Foundation Instructions\n\tHasAVX512CD\t\tbool\t// Advanced vector extension 512 Conflict Detection Instructions\n\tHasAVX512ER\t\tbool\t// Advanced vector extension 512 Exponential and Reciprocal Instructions\n\tHasAVX512PF\t\tbool\t// Advanced vector extension 512 Prefetch Instructions\n\tHasAVX512VL\t\tbool\t// Advanced vector extension 512 Vector Length Extensions\n\tHasAVX512BW\t\tbool\t// Advanced vector extension 512 Byte and Word Instructions\n\tHasAVX512DQ\t\tbool\t// Advanced vector extension 512 Doubleword and Quadword Instructions\n\tHasAVX512IFMA\t\tbool\t// Advanced vector extension 512 Integer Fused Multiply Add\n\tHasAVX512VBMI\t\tbool\t// Advanced vector extension 512 Vector Byte Manipulation Instructions\n\tHasAVX5124VNNIW\t\tbool\t// Advanced vector extension 512 Vector Neural Network Instructions Word variable precision\n\tHasAVX5124FMAPS\t\tbool\t// Advanced vector extension 512 Fused Multiply Accumulation Packed Single precision\n\tHasAVX512VPOPCNTDQ\tbool\t// Advanced vector extension 512 Double and quad word population count instructions\n\tHasAVX512VPCLMULQDQ\tbool\t// Advanced vector extension 512 Vector carry-less multiply operations\n\tHasAVX512VNNI\t\tbool\t// Advanced vector extension 512 Vector Neural Network Instructions\n\tHasAVX512GFNI\t\tbool\t// Advanced vector extension 512 Galois field New Instructions\n\tHasAVX512VAES\t\tbool\t// Advanced vector extension 512 Vector AES instructions\n\tHasAVX512VBMI2\t\tbool\t// Advanced vector extension 512 Vector Byte Manipulation Instructions 2\n\tHasAVX512BITALG\t\tbool\t// Advanced vector extension 512 Bit Algorithms\n\tHasAVX512BF16\t\tbool\t// Advanced vector extension 512 BFloat16 Instructions\n\tHasAMXTile\t\tbool\t// Advanced Matrix Extension Tile instructions\n\tHasAMXInt8\t\tbool\t// Advanced Matrix Extension Int8 instructions\n\tHasAMXBF16\t\tbool\t// Advanced Matrix Extension BFloat16 instructions\n\tHasBMI1\t\t\tbool\t// Bit manipulation instruction set 1\n\tHasBMI2\t\t\tbool\t// Bit manipulation instruction set 2\n\tHasCX16\t\t\tbool\t// Compare and exchange 16 Bytes\n\tHasERMS\t\t\tbool\t// Enhanced REP for MOVSB and STOSB\n\tHasFMA\t\t\tbool\t// Fused-multiply-add instructions\n\tHasOSXSAVE\t\tbool\t// OS supports XSAVE/XRESTOR for saving/restoring XMM registers.\n\tHasPCLMULQDQ\t\tbool\t// PCLMULQDQ instruction - most often used for AES-GCM\n\tHasPOPCNT\t\tbool\t// Hamming weight instruction POPCNT.\n\tHasRDRAND\t\tbool\t// RDRAND instruction (on-chip random number generator)\n\tHasRDSEED\t\tbool\t// RDSEED instruction (on-chip random number generator)\n\tHasSSE2\t\t\tbool\t// Streaming SIMD extension 2 (always available on amd64)\n\tHasSSE3\t\t\tbool\t// Streaming SIMD extension 3\n\tHasSSSE3\t\tbool\t// Supplemental streaming SIMD extension 3\n\tHasSSE41\t\tbool\t// Streaming SIMD extension 4 and 4.1\n\tHasSSE42\t\tbool\t// Streaming SIMD extension 4 and 4.2\n\t_\t\t\tCacheLinePad\n}","var ARM64 struct {\n\t_\t\tCacheLinePad\n\tHasFP\t\tbool\t// Floating-point instruction set (always available)\n\tHasASIMD\tbool\t// Advanced SIMD (always available)\n\tHasEVTSTRM\tbool\t// Event stream support\n\tHasAES\t\tbool\t// AES hardware implementation\n\tHasPMULL\tbool\t// Polynomial multiplication instruction set\n\tHasSHA1\t\tbool\t// SHA1 hardware implementation\n\tHasSHA2\t\tbool\t// SHA2 hardware implementation\n\tHasCRC32\tbool\t// CRC32 hardware implementation\n\tHasATOMICS\tbool\t// Atomic memory operation instruction set\n\tHasFPHP\t\tbool\t// Half precision floating-point instruction set\n\tHasASIMDHP\tbool\t// Advanced SIMD half precision instruction set\n\tHasCPUID\tbool\t// CPUID identification scheme registers\n\tHasASIMDRDM\tbool\t// Rounding double multiply add/subtract instruction set\n\tHasJSCVT\tbool\t// Javascript conversion from floating-point to integer\n\tHasFCMA\t\tbool\t// Floating-point multiplication and addition of complex numbers\n\tHasLRCPC\tbool\t// Release Consistent processor consistent support\n\tHasDCPOP\tbool\t// Persistent memory support\n\tHasSHA3\t\tbool\t// SHA3 hardware implementation\n\tHasSM3\t\tbool\t// SM3 hardware implementation\n\tHasSM4\t\tbool\t// SM4 hardware implementation\n\tHasASIMDDP\tbool\t// Advanced SIMD double precision instruction set\n\tHasSHA512\tbool\t// SHA512 hardware implementation\n\tHasSVE\t\tbool\t// Scalable Vector Extensions\n\tHasSVE2\t\tbool\t// Scalable Vector Extensions 2\n\tHasASIMDFHM\tbool\t// Advanced SIMD multiplication FP16 to FP32\n\t_\t\tCacheLinePad\n}","var ARM struct {\n\t_\t\tCacheLinePad\n\tHasSWP\t\tbool\t// SWP instruction support\n\tHasHALF\t\tbool\t// Half-word load and store support\n\tHasTHUMB\tbool\t// ARM Thumb instruction set\n\tHas26BIT\tbool\t// Address space limited to 26-bits\n\tHasFASTMUL\tbool\t// 32-bit operand, 64-bit result multiplication support\n\tHasFPA\t\tbool\t// Floating point arithmetic support\n\tHasVFP\t\tbool\t// Vector floating point support\n\tHasEDSP\t\tbool\t// DSP Extensions support\n\tHasJAVA\t\tbool\t// Java instruction set\n\tHasIWMMXT\tbool\t// Intel Wireless MMX technology support\n\tHasCRUNCH\tbool\t// MaverickCrunch context switching and handling\n\tHasTHUMBEE\tbool\t// Thumb EE instruction set\n\tHasNEON\t\tbool\t// NEON instruction set\n\tHasVFPv3\tbool\t// Vector floating point version 3 support\n\tHasVFPv3D16\tbool\t// Vector floating point version 3 D8-D15\n\tHasTLS\t\tbool\t// Thread local storage support\n\tHasVFPv4\tbool\t// Vector floating point version 4 support\n\tHasIDIVA\tbool\t// Integer divide instruction support in ARM mode\n\tHasIDIVT\tbool\t// Integer divide instruction support in Thumb mode\n\tHasVFPD32\tbool\t// Vector floating point version 3 D15-D31\n\tHasLPAE\t\tbool\t// Large Physical Address Extensions\n\tHasEVTSTRM\tbool\t// Event stream support\n\tHasAES\t\tbool\t// AES hardware implementation\n\tHasPMULL\tbool\t// Polynomial multiplication instruction set\n\tHasSHA1\t\tbool\t// SHA1 hardware implementation\n\tHasSHA2\t\tbool\t// SHA2 hardware implementation\n\tHasCRC32\tbool\t// CRC32 hardware implementation\n\t_\t\tCacheLinePad\n}","var MIPS64X struct {\n\t_\tCacheLinePad\n\tHasMSA\tbool\t// MIPS SIMD architecture\n\t_\tCacheLinePad\n}","var PPC64 struct {\n\t_\t\tCacheLinePad\n\tHasDARN\t\tbool\t// Hardware random number generator (requires kernel enablement)\n\tHasSCV\t\tbool\t// Syscall vectored (requires kernel enablement)\n\tIsPOWER8\tbool\t// ISA v2.07 (POWER8)\n\tIsPOWER9\tbool\t// ISA v3.00 (POWER9), implies IsPOWER8\n\t_\t\tCacheLinePad\n}","var S390X struct {\n\t_\t\tCacheLinePad\n\tHasZARCH\tbool\t// z/Architecture mode is active [mandatory]\n\tHasSTFLE\tbool\t// store facility list extended\n\tHasLDISP\tbool\t// long (20-bit) displacements\n\tHasEIMM\t\tbool\t// 32-bit immediates\n\tHasDFP\t\tbool\t// decimal floating point\n\tHasETF3EH\tbool\t// ETF-3 enhanced\n\tHasMSA\t\tbool\t// message security assist (CPACF)\n\tHasAES\t\tbool\t// KM-AES{128,192,256} functions\n\tHasAESCBC\tbool\t// KMC-AES{128,192,256} functions\n\tHasAESCTR\tbool\t// KMCTR-AES{128,192,256} functions\n\tHasAESGCM\tbool\t// KMA-GCM-AES{128,192,256} functions\n\tHasGHASH\tbool\t// KIMD-GHASH function\n\tHasSHA1\t\tbool\t// K{I,L}MD-SHA-1 functions\n\tHasSHA256\tbool\t// K{I,L}MD-SHA-256 functions\n\tHasSHA512\tbool\t// K{I,L}MD-SHA-512 functions\n\tHasSHA3\t\tbool\t// K{I,L}MD-SHA3-{224,256,384,512} and K{I,L}MD-SHAKE-{128,256} functions\n\tHasVX\t\tbool\t// vector facility\n\tHasVXE\t\tbool\t// vector-enhancements facility 1\n\t_\t\tCacheLinePad\n}","","","","","type Transformer interface {\n\t// Transform writes to dst the transformed bytes read from src, and\n\t// returns the number of dst bytes written and src bytes read. The\n\t// atEOF argument tells whether src represents the last bytes of the\n\t// input.\n\t//\n\t// Callers should always process the nDst bytes produced and account\n\t// for the nSrc bytes consumed before considering the error err.\n\t//\n\t// A nil error means that all of the transformed bytes (whether freshly\n\t// transformed from src or left over from previous Transform calls)\n\t// were written to dst. A nil error can be returned regardless of\n\t// whether atEOF is true. If err is nil then nSrc must equal len(src);\n\t// the converse is not necessarily true.\n\t//\n\t// ErrShortDst means that dst was too short to receive all of the\n\t// transformed bytes. ErrShortSrc means that src had insufficient data\n\t// to complete the transformation. If both conditions apply, then\n\t// either error may be returned. Other than the error conditions listed\n\t// here, implementations are free to report other errors that arise.\n\tTransform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error)\n\n\t// Reset resets the state and allows a Transformer to be reused.\n\tReset()\n}","type SpanningTransformer interface {\n\tTransformer\n\n\t// Span returns a position in src such that transforming src[:n] results in\n\t// identical output src[:n] for these bytes. It does not necessarily return\n\t// the largest such n. The atEOF argument tells whether src represents the\n\t// last bytes of the input.\n\t//\n\t// Callers should always account for the n bytes consumed before\n\t// considering the error err.\n\t//\n\t// A nil error means that all input bytes are known to be identical to the\n\t// output produced by the Transformer. A nil error can be returned\n\t// regardless of whether atEOF is true. If err is nil, then n must\n\t// equal len(src); the converse is not necessarily true.\n\t//\n\t// ErrEndOfSpan means that the Transformer output may differ from the\n\t// input after n bytes. Note that n may be len(src), meaning that the output\n\t// would contain additional bytes after otherwise identical output.\n\t// ErrShortSrc means that src had insufficient data to determine whether the\n\t// remaining bytes would change. Other than the error conditions listed\n\t// here, implementations are free to report other errors that arise.\n\t//\n\t// Calling Span can modify the Transformer state as a side effect. In\n\t// effect, it does the transformation just as calling Transform would, only\n\t// without copying to a destination buffer and only up to a point it can\n\t// determine the input and output bytes are the same. This is obviously more\n\t// limited than calling Transform, but can be more efficient in terms of\n\t// copying and allocating buffers. Calls to Span and Transform may be\n\t// interleaved.\n\tSpan(src []byte, atEOF bool) (n int, err error)\n}","type NopResetter struct{}","type Reader struct {\n\tr\tio.Reader\n\tt\tTransformer\n\terr\terror\n\n\t// dst[dst0:dst1] contains bytes that have been transformed by t but\n\t// not yet copied out via Read.\n\tdst\t\t[]byte\n\tdst0, dst1\tint\n\n\t// src[src0:src1] contains bytes that have been read from r but not\n\t// yet transformed through t.\n\tsrc\t\t[]byte\n\tsrc0, src1\tint\n\n\t// transformComplete is whether the transformation is complete,\n\t// regardless of whether or not it was successful.\n\ttransformComplete\tbool\n}","func NewReader(r io.Reader, t Transformer) *Reader","type Writer struct {\n\tw\tio.Writer\n\tt\tTransformer\n\tdst\t[]byte\n\n\t// src[:n] contains bytes that have not yet passed through t.\n\tsrc\t[]byte\n\tn\tint\n}","func NewWriter(w io.Writer, t Transformer) *Writer","var Discard Transformer","var Nop SpanningTransformer","func Chain(t ...Transformer) Transformer","func RemoveFunc(f func(r rune) bool) Transformer","func String(t Transformer, s string) (result string, n int, err error)","func Bytes(t Transformer, b []byte) (result []byte, n int, err error)","func Append(t Transformer, dst, src []byte) (result []byte, n int, err error)","","","","","","","","","","","","","","","","","","","const TypeA Type = 1","const TypeNS Type = 2","const TypeCNAME Type = 5","const TypeSOA Type = 6","const TypePTR Type = 12","const TypeMX Type = 15","const TypeTXT Type = 16","const TypeAAAA Type = 28","const TypeSRV Type = 33","const TypeOPT Type = 41","const TypeWKS Type = 11","const TypeHINFO Type = 13","const TypeMINFO Type = 14","const TypeAXFR Type = 252","const TypeALL Type = 255","","const ClassINET Class = 1","const ClassCSNET Class = 2","const ClassCHAOS Class = 3","const ClassHESIOD Class = 4","const ClassANY Class = 255","","","const RCodeSuccess RCode = 0","const RCodeFormatError RCode = 1","const RCodeServerFailure RCode = 2","const RCodeNameError RCode = 3","const RCodeNotImplemented RCode = 4","const RCodeRefused RCode = 5","","","type Header struct {\n\tID\t\t\tuint16\n\tResponse\t\tbool\n\tOpCode\t\t\tOpCode\n\tAuthoritative\t\tbool\n\tTruncated\t\tbool\n\tRecursionDesired\tbool\n\tRecursionAvailable\tbool\n\tAuthenticData\t\tbool\n\tCheckingDisabled\tbool\n\tRCode\t\t\tRCode\n}","type Message struct {\n\tHeader\n\tQuestions\t[]Question\n\tAnswers\t\t[]Resource\n\tAuthorities\t[]Resource\n\tAdditionals\t[]Resource\n}","type Resource struct {\n\tHeader\tResourceHeader\n\tBody\tResourceBody\n}","type ResourceBody interface {\n\t// pack packs a Resource except for its header.\n\tpack(msg []byte, compression map[string]uint16, compressionOff int) ([]byte, error)\n\n\t// realType returns the actual type of the Resource. This is used to\n\t// fill in the header Type field.\n\trealType() Type\n\n\t// GoString implements fmt.GoStringer.GoString.\n\tGoString() string\n}","type Parser struct {\n\tmsg\t[]byte\n\theader\theader\n\n\tsection\t\tsection\n\toff\t\tint\n\tindex\t\tint\n\tresHeaderValid\tbool\n\tresHeaderOffset\tint\n\tresHeaderType\tType\n\tresHeaderLength\tuint16\n}","type Builder struct {\n\t// msg is the storage for the message being built.\n\tmsg\t[]byte\n\n\t// section keeps track of the current section being built.\n\tsection\tsection\n\n\t// header keeps track of what should go in the header when Finish is\n\t// called.\n\theader\theader\n\n\t// start is the starting index of the bytes allocated in msg for header.\n\tstart\tint\n\n\t// compression is a mapping from name suffixes to their starting index\n\t// in msg.\n\tcompression\tmap[string]uint16\n}","func NewBuilder(buf []byte, h Header) Builder","type ResourceHeader struct {\n\t// Name is the domain name for which this resource record pertains.\n\tName\tName\n\n\t// Type is the type of DNS resource record.\n\t//\n\t// This field will be set automatically during packing.\n\tType\tType\n\n\t// Class is the class of network to which this DNS resource record\n\t// pertains.\n\tClass\tClass\n\n\t// TTL is the length of time (measured in seconds) which this resource\n\t// record is valid for (time to live). All Resources in a set should\n\t// have the same TTL (RFC 2181 Section 5.2).\n\tTTL\tuint32\n\n\t// Length is the length of data in the resource record after the header.\n\t//\n\t// This field will be set automatically during packing.\n\tLength\tuint16\n}","type Name struct {\n\tData\t[255]byte\n\tLength\tuint8\n}","func NewName(name string) (Name, error)","func MustNewName(name string) Name","type Question struct {\n\tName\tName\n\tType\tType\n\tClass\tClass\n}","type CNAMEResource struct {\n\tCNAME Name\n}","type MXResource struct {\n\tPref\tuint16\n\tMX\tName\n}","type NSResource struct {\n\tNS Name\n}","type PTRResource struct {\n\tPTR Name\n}","type SOAResource struct {\n\tNS\tName\n\tMBox\tName\n\tSerial\tuint32\n\tRefresh\tuint32\n\tRetry\tuint32\n\tExpire\tuint32\n\n\t// MinTTL the is the default TTL of Resources records which did not\n\t// contain a TTL value and the TTL of negative responses. (RFC 2308\n\t// Section 4)\n\tMinTTL\tuint32\n}","type TXTResource struct {\n\tTXT []string\n}","type SRVResource struct {\n\tPriority\tuint16\n\tWeight\t\tuint16\n\tPort\t\tuint16\n\tTarget\t\tName\t// Not compressed as per RFC 2782.\n}","type AResource struct {\n\tA [4]byte\n}","type AAAAResource struct {\n\tAAAA [16]byte\n}","type OPTResource struct {\n\tOptions []Option\n}","type Option struct {\n\tCode\tuint16\t// option code\n\tData\t[]byte\n}","type UnknownResource struct {\n\tType\tType\n\tData\t[]byte\n}","func ValidTrailerHeader(name string) bool","func IsTokenRune(r rune) bool","func HeaderValuesContainsToken(values []string, token string) bool","func ValidHeaderFieldName(v string) bool","func ValidHostHeader(h string) bool","func ValidHeaderFieldValue(v string) bool","func PunycodeHostPort(v string) (string, error)","type Config struct {\n\t// HTTPProxy represents the value of the HTTP_PROXY or\n\t// http_proxy environment variable. It will be used as the proxy\n\t// URL for HTTP requests unless overridden by NoProxy.\n\tHTTPProxy\tstring\n\n\t// HTTPSProxy represents the HTTPS_PROXY or https_proxy\n\t// environment variable. It will be used as the proxy URL for\n\t// HTTPS requests unless overridden by NoProxy.\n\tHTTPSProxy\tstring\n\n\t// NoProxy represents the NO_PROXY or no_proxy environment\n\t// variable. It specifies a string that contains comma-separated values\n\t// specifying hosts that should be excluded from proxying. Each value is\n\t// represented by an IP address prefix (1.2.3.4), an IP address prefix in\n\t// CIDR notation (1.2.3.4/8), a domain name, or a special DNS label (*).\n\t// An IP address prefix and domain name can also include a literal port\n\t// number (1.2.3.4:80).\n\t// A domain name matches that name and all subdomains. A domain name with\n\t// a leading \".\" matches subdomains only. For example \"foo.com\" matches\n\t// \"foo.com\" and \"bar.foo.com\"; \".y.com\" matches \"x.y.com\" but not \"y.com\".\n\t// A single asterisk (*) indicates that no proxying should be done.\n\t// A best effort is made to parse the string and errors are\n\t// ignored.\n\tNoProxy\tstring\n\n\t// CGI holds whether the current process is running\n\t// as a CGI handler (FromEnvironment infers this from the\n\t// presence of a REQUEST_METHOD environment variable).\n\t// When this is set, ProxyForURL will return an error\n\t// when HTTPProxy applies, because a client could be\n\t// setting HTTP_PROXY maliciously. See https://golang.org/s/cgihttpproxy.\n\tCGI\tbool\n}","func FromEnvironment() *Config","type Encoder struct {\n\tdynTab\tdynamicTable\n\t// minSize is the minimum table size set by\n\t// SetMaxDynamicTableSize after the previous Header Table Size\n\t// Update.\n\tminSize\tuint32\n\t// maxSizeLimit is the maximum table size this encoder\n\t// supports. This will protect the encoder from too large\n\t// size.\n\tmaxSizeLimit\tuint32\n\t// tableSizeUpdate indicates whether \"Header Table Size\n\t// Update\" is required.\n\ttableSizeUpdate\tbool\n\tw\t\tio.Writer\n\tbuf\t\t[]byte\n}","func NewEncoder(w io.Writer) *Encoder","type DecodingError struct {\n\tErr error\n}","","type HeaderField struct {\n\tName, Value\tstring\n\n\t// Sensitive means that this header field should never be\n\t// indexed.\n\tSensitive\tbool\n}","type Decoder struct {\n\tdynTab\tdynamicTable\n\temit\tfunc(f HeaderField)\n\n\temitEnabled\tbool\t// whether calls to emit are enabled\n\tmaxStrLen\tint\t// 0 means unlimited\n\n\t// buf is the unparsed buffer. It's only written to\n\t// saveBuf if it was truncated in the middle of a header\n\t// block. Because it's usually not owned, we can only\n\t// process it under Write.\n\tbuf\t[]byte\t// not owned; only valid during Write\n\n\t// saveBuf is previous data passed to Write which we weren't able\n\t// to fully parse before. Unlike buf, we own this data.\n\tsaveBuf\tbytes.Buffer\n\n\tfirstField\tbool\t// processing the first field of the header block\n}","func NewDecoder(maxDynamicTableSize uint32, emitFunc func(f HeaderField)) *Decoder","","func HuffmanDecode(w io.Writer, v []byte) (int, error)","func HuffmanDecodeToString(v []byte) (string, error)","","func AppendHuffmanString(dst []byte, s string) []byte","func HuffmanEncodeLength(s string) uint64","","func Direction(b []byte) bidi.Direction","func DirectionString(s string) bidi.Direction","func Valid(b []byte) bool","func ValidString(s string) bool","func New() *Transformer","type Transformer struct {\n\tstate\truleState\n\thasRTL\tbool\n\tseen\tuint16\n}","","const LeftToRight Direction","const RightToLeft","const Mixed","const Neutral","type Option func(*options)","func DefaultDirection(d Direction) Option","type Paragraph struct {\n\tp\t\t[]byte\n\to\t\tOrdering\n\topts\t\t[]Option\n\ttypes\t\t[]Class\n\tpairTypes\t[]bracketType\n\tpairValues\t[]rune\n\trunes\t\t[]rune\n\toptions\t\toptions\n}","type Ordering struct {\n\trunes\t\t[][]rune\n\tdirections\t[]Direction\n\tstartpos\t[]int\n}","type Run struct {\n\trunes\t\t[]rune\n\tdirection\tDirection\n\tstartpos\tint\n}","func AppendReverse(out, in []byte) []byte","func ReverseString(s string) string","type Properties struct {\n\tentry\tuint8\n\tlast\tuint8\n}","func LookupRune(r rune) (p Properties, size int)","func Lookup(s []byte) (p Properties, sz int)","func LookupString(s string) (p Properties, sz int)","const UnicodeVersion = \"9.0.0\"","","const L Class","const R","const EN","const ES","const ET","const AN","const CS","const B","const S","const WS","const ON","const BN","const NSM","const AL","const Control","const LRO","const RLO","const LRE","const RLE","const PDF","const LRI","const RLI","const FSI","const PDI","const GraphemeJoiner = \"\\u034F\"","type Properties struct {\n\tpos\tuint8\t// start position in reorderBuffer; used in composition.go\n\tsize\tuint8\t// length of UTF-8 encoding of this rune\n\tccc\tuint8\t// leading canonical combining class (ccc if not decomposition)\n\ttccc\tuint8\t// trailing canonical combining class (ccc if not decomposition)\n\tnLead\tuint8\t// number of leading non-starters.\n\tflags\tqcInfo\t// quick check flags\n\tindex\tuint16\n}","","type Iter struct {\n\trb\treorderBuffer\n\tbuf\t[maxByteBufferSize]byte\n\tinfo\tProperties\t// first character saved from previous iteration\n\tnext\titerFunc\t// implementation of next depends on form\n\tasciiF\titerFunc\n\n\tp\t\tint\t// current position in input source\n\tmultiSeg\t[]byte\t// remainder of multi-segment decomposition\n}","","const NFC Form","const NFD","const NFKC","const NFKD","const Version = \"9.0.0\"",""],"insertTexts":["ErrInvalidUnreadByte","ErrInvalidUnreadRune","ErrBufferFull","ErrNegativeCount","Reader{}","NewReaderSize(${1:rd}, ${2:size})","NewReader(${1:rd})","Writer{}","NewWriterSize(${1:w}, ${2:size})","NewWriter(${1:w})","ReadWriter{}","NewReadWriter(${1:r}, ${2:w})","Scanner{}","SplitFunc","ErrTooLong","ErrNegativeAdvance","ErrAdvanceTooFar","ErrBadReadCount","MaxScanTokenSize","NewScanner(${1:r})","ErrFinalToken","ScanBytes(${1:data}, ${2:atEOF})","ScanRunes(${1:data}, ${2:atEOF})","ScanLines(${1:data}, ${2:atEOF})","ScanWords(${1:data}, ${2:atEOF})","bool","true","false","uint8","uint16","uint32","uint64","int8","int16","int32","int64","float32","float64","complex64","complex128","string","int","uint","uintptr","byte","rune","any","comparable","iota","nil","append(${1:slice}, ${2:elems})","copy(${1:dst}, ${2:src})","delete(${1:m}, ${2:key})","len(${1:v})","cap(${1:v})","make(${1:t}, ${2:size})","max[${1:T}](${2:x}, ${3:y})","min[${1:T}](${2:x}, ${3:y})","new()","complex(${1:r}, ${2:i})","real(${1:c})","imag(${1:c})","clear[${1:T}](${2:t})","close(${1:c})","panic(${1:v})","recover()","print(${1:args})","println(${1:args})","error","Buffer{}","ErrTooLarge","MinRead","NewBuffer(${1:buf})","NewBufferString(${1:s})","Equal(${1:a}, ${2:b})","Compare(${1:a}, ${2:b})","Count(${1:s}, ${2:sep})","Contains(${1:b}, ${2:subslice})","ContainsAny(${1:b}, ${2:chars})","ContainsRune(${1:b}, ${2:r})","ContainsFunc(${1:b}, ${2:f})","IndexByte(${1:b}, ${2:c})","LastIndex(${1:s}, ${2:sep})","LastIndexByte(${1:s}, ${2:c})","IndexRune(${1:s}, ${2:r})","IndexAny(${1:s}, ${2:chars})","LastIndexAny(${1:s}, ${2:chars})","SplitN(${1:s}, ${2:sep}, ${3:n})","SplitAfterN(${1:s}, ${2:sep}, ${3:n})","Split(${1:s}, ${2:sep})","SplitAfter(${1:s}, ${2:sep})","Fields(${1:s})","FieldsFunc(${1:s}, ${2:f})","Join(${1:s}, ${2:sep})","HasPrefix(${1:s}, ${2:prefix})","HasSuffix(${1:s}, ${2:suffix})","Map(${1:mapping}, ${2:s})","Repeat(${1:b}, ${2:count})","ToUpper(${1:s})","ToLower(${1:s})","ToTitle(${1:s})","ToUpperSpecial(${1:c}, ${2:s})","ToLowerSpecial(${1:c}, ${2:s})","ToTitleSpecial(${1:c}, ${2:s})","ToValidUTF8(${1:s}, ${2:replacement})","Title(${1:s})","TrimLeftFunc(${1:s}, ${2:f})","TrimRightFunc(${1:s}, ${2:f})","TrimFunc(${1:s}, ${2:f})","TrimPrefix(${1:s}, ${2:prefix})","TrimSuffix(${1:s}, ${2:suffix})","IndexFunc(${1:s}, ${2:f})","LastIndexFunc(${1:s}, ${2:f})","Trim(${1:s}, ${2:cutset})","TrimLeft(${1:s}, ${2:cutset})","TrimRight(${1:s}, ${2:cutset})","TrimSpace(${1:s})","Runes(${1:s})","Replace(${1:s}, ${2:old}, ${3:new}, ${4:n})","ReplaceAll(${1:s}, ${2:old}, ${3:new})","EqualFold(${1:s}, ${2:t})","Index(${1:s}, ${2:sep})","Cut(${1:s}, ${2:sep})","Clone(${1:b})","CutPrefix(${1:s}, ${2:prefix})","CutSuffix(${1:s}, ${2:suffix})","Reader{}","NewReader(${1:b})","Ordered","Less[${1:T}](${2:x}, ${3:y})","Compare[${1:T}](${2:x}, ${3:y})","Or[${1:T}](${2:vals})","Context","Canceled","DeadlineExceeded","Background()","TODO()","CancelFunc","WithCancel(${1:parent})","CancelCauseFunc","WithCancelCause(${1:parent})","Cause(${1:c})","AfterFunc(${1:ctx}, ${2:f})","WithoutCancel(${1:parent})","WithDeadline(${1:parent}, ${2:d})","WithDeadlineCause(${1:parent}, ${2:d}, ${3:cause})","WithTimeout(${1:parent}, ${2:timeout})","WithTimeoutCause(${1:parent}, ${2:timeout}, ${3:cause})","WithValue(${1:parent}, ${2:key}, ${3:val})","Hash","MD4","MD5","SHA1","SHA224","SHA256","SHA384","SHA512","MD5SHA1","RIPEMD160","SHA3_224","SHA3_256","SHA3_384","SHA3_512","SHA512_224","SHA512_256","BLAKE2s_256","BLAKE2b_256","BLAKE2b_384","BLAKE2b_512","RegisterHash(${1:h}, ${2:f})","PublicKey","PrivateKey","Signer","SignerOpts","Decrypter","DecrypterOpts","FS{}","BinaryMarshaler","BinaryUnmarshaler","TextMarshaler","TextUnmarshaler","New(${1:text})","ErrUnsupported","Join(${1:errs})","Unwrap(${1:err})","Is(${1:err}, ${2:target})","As(${1:err}, ${2:target})","Var","Int{}","Float{}","Map{}","KeyValue{}","String{}","Func","Publish(${1:name}, ${2:v})","Get(${1:name})","NewInt(${1:name})","NewFloat(${1:name})","NewMap(${1:name})","NewString(${1:name})","Do(${1:f})","Handler()","ErrHelp","Value","Getter","ErrorHandling","ContinueOnError","ExitOnError","PanicOnError","FlagSet{}","Flag{}","VisitAll(${1:fn})","Visit(${1:fn})","Lookup(${1:name})","Set(${1:name}, ${2:value})","UnquoteUsage(${1:flag})","PrintDefaults()","Usage","NFlag()","Arg(${1:i})","NArg()","Args()","BoolVar(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Bool(${1:name}, ${2:value}, ${3:usage})","IntVar(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Int(${1:name}, ${2:value}, ${3:usage})","Int64Var(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Int64(${1:name}, ${2:value}, ${3:usage})","UintVar(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Uint(${1:name}, ${2:value}, ${3:usage})","Uint64Var(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Uint64(${1:name}, ${2:value}, ${3:usage})","StringVar(${1:p}, ${2:name}, ${3:value}, ${4:usage})","String(${1:name}, ${2:value}, ${3:usage})","Float64Var(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Float64(${1:name}, ${2:value}, ${3:usage})","DurationVar(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Duration(${1:name}, ${2:value}, ${3:usage})","TextVar(${1:p}, ${2:name}, ${3:value}, ${4:usage})","Func(${1:name}, ${2:usage}, ${3:fn})","BoolFunc(${1:name}, ${2:usage}, ${3:fn})","Var(${1:value}, ${2:name}, ${3:usage})","Parse()","Parsed()","CommandLine","NewFlagSet(${1:name}, ${2:errorHandling})","Errorf(${1:format}, ${2:a})","State","Formatter","Stringer","GoStringer","FormatString(${1:state}, ${2:verb})","Fprintf(${1:w}, ${2:format}, ${3:a})","Printf(${1:format}, ${2:a})","Sprintf(${1:format}, ${2:a})","Appendf(${1:b}, ${2:format}, ${3:a})","Fprint(${1:w}, ${2:a})","Print(${1:a})","Sprint(${1:a})","Append(${1:b}, ${2:a})","Fprintln(${1:w}, ${2:a})","Println(${1:a})","Sprintln(${1:a})","Appendln(${1:b}, ${2:a})","ScanState","Scanner","Scan(${1:a})","Scanln(${1:a})","Scanf(${1:format}, ${2:a})","Sscan(${1:str}, ${2:a})","Sscanln(${1:str}, ${2:a})","Sscanf(${1:str}, ${2:format}, ${3:a})","Fscan(${1:r}, ${2:a})","Fscanln(${1:r}, ${2:a})","Fscanf(${1:r}, ${2:format}, ${3:a})","Hash","Hash32","Hash64","EscapeString(${1:s})","UnescapeString(${1:s})","ErrFormat","RegisterFormat(${1:name}, ${2:magic}, ${3:decode}, ${4:decodeConfig})","Decode(${1:r})","DecodeConfig(${1:r})","Point{}","ZP","Pt(${1:X}, ${2:Y})","Rectangle{}","ZR","Rect(${1:x0}, ${2:y0}, ${3:x1}, ${4:y1})","Config{}","Image","RGBA64Image","PalettedImage","RGBA{}","NewRGBA(${1:r})","RGBA64{}","NewRGBA64(${1:r})","NRGBA{}","NewNRGBA(${1:r})","NRGBA64{}","NewNRGBA64(${1:r})","Alpha{}","NewAlpha(${1:r})","Alpha16{}","NewAlpha16(${1:r})","Gray{}","NewGray(${1:r})","Gray16{}","NewGray16(${1:r})","CMYK{}","NewCMYK(${1:r})","Paletted{}","NewPaletted(${1:r}, ${2:p})","Black","White","Transparent","Opaque","Uniform{}","NewUniform(${1:c})","YCbCrSubsampleRatio","YCbCrSubsampleRatio444","YCbCrSubsampleRatio422","YCbCrSubsampleRatio420","YCbCrSubsampleRatio440","YCbCrSubsampleRatio411","YCbCrSubsampleRatio410","YCbCr{}","NewYCbCr(${1:r}, ${2:subsampleRatio})","NYCbCrA{}","NewNYCbCrA(${1:r}, ${2:subsampleRatio})","SeekStart","SeekCurrent","SeekEnd","ErrShortWrite","ErrShortBuffer","EOF","ErrUnexpectedEOF","ErrNoProgress","Reader","Writer","Closer","Seeker","ReadWriter","ReadCloser","WriteCloser","ReadWriteCloser","ReadSeeker","ReadSeekCloser","WriteSeeker","ReadWriteSeeker","ReaderFrom","WriterTo","ReaderAt","WriterAt","ByteReader","ByteScanner","ByteWriter","RuneReader","RuneScanner","StringWriter","WriteString(${1:w}, ${2:s})","ReadAtLeast(${1:r}, ${2:buf}, ${3:min})","ReadFull(${1:r}, ${2:buf})","CopyN(${1:dst}, ${2:src}, ${3:n})","Copy(${1:dst}, ${2:src})","CopyBuffer(${1:dst}, ${2:src}, ${3:buf})","LimitReader(${1:r}, ${2:n})","LimitedReader{}","NewSectionReader(${1:r}, ${2:off}, ${3:n})","SectionReader{}","OffsetWriter{}","NewOffsetWriter(${1:w}, ${2:off})","TeeReader(${1:r}, ${2:w})","Discard","NopCloser(${1:r})","ReadAll(${1:r})","MultiReader(${1:readers})","MultiWriter(${1:writers})","ErrClosedPipe","PipeReader{}","PipeWriter{}","Pipe()","Seq","Seq2","Pull[${1:V}](${2:seq})","Pull2[${1:K}, ${2:V}](${3:seq})","Ldate","Ltime","Lmicroseconds","Llongfile","Lshortfile","LUTC","Lmsgprefix","LstdFlags","Logger{}","New(${1:out}, ${2:prefix}, ${3:flag})","Default()","SetOutput(${1:w})","Flags()","SetFlags(${1:flag})","Prefix()","SetPrefix(${1:prefix})","Writer()","Print(${1:v})","Printf(${1:format}, ${2:v})","Println(${1:v})","Fatal(${1:v})","Fatalf(${1:format}, ${2:v})","Fatalln(${1:v})","Panic(${1:v})","Panicf(${1:format}, ${2:v})","Panicln(${1:v})","Output(${1:calldepth}, ${2:s})","All[${1:Map}, ${2:K}, ${3:V}](${4:m})","Keys[${1:Map}, ${2:K}, ${3:V}](${4:m})","Values[${1:Map}, ${2:K}, ${3:V}](${4:m})","Insert[${1:Map}, ${2:K}, ${3:V}](${4:m}, ${5:seq})","Collect[${1:K}, ${2:V}](${3:seq})","Equal[${1:M1}, ${2:M2}, ${3:K}, ${4:V}](${5:m1}, ${6:m2})","EqualFunc[${1:M1}, ${2:M2}, ${3:K}, ${4:V1}, ${5:V2}](${6:m1}, ${7:m2}, ${8:eq})","Clone[${1:M}, ${2:K}, ${3:V}](${4:m})","Copy[${1:M1}, ${2:M2}, ${3:K}, ${4:V}](${5:dst}, ${6:src})","DeleteFunc[${1:M}, ${2:K}, ${3:V}](${4:m}, ${5:del})","Abs(${1:x})","Acosh(${1:x})","Asin(${1:x})","Acos(${1:x})","Asinh(${1:x})","Atan(${1:x})","Atan2(${1:y}, ${2:x})","Atanh(${1:x})","Inf(${1:sign})","NaN()","IsNaN(${1:f})","IsInf(${1:f}, ${2:sign})","Cbrt(${1:x})","E","Pi","Phi","Sqrt2","SqrtE","SqrtPi","SqrtPhi","Ln2","Log2E","Ln10","Log10E","MaxFloat32","SmallestNonzeroFloat32","MaxFloat64","SmallestNonzeroFloat64","MaxInt","MinInt","MaxInt8","MinInt8","MaxInt16","MinInt16","MaxInt32","MinInt32","MaxInt64","MinInt64","MaxUint","MaxUint8","MaxUint16","MaxUint32","MaxUint64","Copysign(${1:f}, ${2:sign})","Dim(${1:x}, ${2:y})","Max(${1:x}, ${2:y})","Min(${1:x}, ${2:y})","Erf(${1:x})","Erfc(${1:x})","Erfinv(${1:x})","Erfcinv(${1:x})","Exp(${1:x})","Exp2(${1:x})","Expm1(${1:x})","Floor(${1:x})","Ceil(${1:x})","Trunc(${1:x})","Round(${1:x})","RoundToEven(${1:x})","FMA(${1:x}, ${2:y}, ${3:z})","Frexp(${1:f})","Gamma(${1:x})","Hypot(${1:p}, ${2:q})","J0(${1:x})","Y0(${1:x})","J1(${1:x})","Y1(${1:x})","Jn(${1:n}, ${2:x})","Yn(${1:n}, ${2:x})","Ldexp(${1:frac}, ${2:exp})","Lgamma(${1:x})","Log(${1:x})","Log10(${1:x})","Log2(${1:x})","Log1p(${1:x})","Logb(${1:x})","Ilogb(${1:x})","Mod(${1:x}, ${2:y})","Modf(${1:f})","Nextafter32(${1:x}, ${2:y})","Nextafter(${1:x}, ${2:y})","Pow(${1:x}, ${2:y})","Pow10(${1:n})","Remainder(${1:x}, ${2:y})","Signbit(${1:x})","Cos(${1:x})","Sin(${1:x})","Sincos(${1:x})","Sinh(${1:x})","Cosh(${1:x})","Sqrt(${1:x})","Tan(${1:x})","Tanh(${1:x})","Float32bits(${1:f})","Float32frombits(${1:b})","Float64bits(${1:f})","Float64frombits(${1:b})","WordEncoder","BEncoding","QEncoding","WordDecoder{}","FormatMediaType(${1:t}, ${2:param})","ErrInvalidMediaParameter","ParseMediaType(${1:v})","TypeByExtension(${1:ext})","ExtensionsByType(${1:typ})","AddExtensionType(${1:ext}, ${2:typ})","Dialer{}","Dial(${1:network}, ${2:address})","DialTimeout(${1:network}, ${2:address}, ${3:timeout})","ListenConfig{}","Listen(${1:network}, ${2:address})","ListenPacket(${1:network}, ${2:address})","SRV{}","MX{}","NS{}","FileConn(${1:f})","FileListener(${1:f})","FilePacketConn(${1:f})","Interface{}","Flags","FlagUp","FlagBroadcast","FlagLoopback","FlagPointToPoint","FlagMulticast","FlagRunning","Interfaces()","InterfaceAddrs()","InterfaceByIndex(${1:index})","InterfaceByName(${1:name})","IPv4len","IPv6len","IP","IPMask","IPNet{}","IPv4(${1:a}, ${2:b}, ${3:c}, ${4:d})","IPv4Mask(${1:a}, ${2:b}, ${3:c}, ${4:d})","CIDRMask(${1:ones}, ${2:bits})","IPv4bcast","IPv4allsys","IPv4allrouter","IPv4zero","IPv6zero","IPv6unspecified","IPv6loopback","IPv6interfacelocalallnodes","IPv6linklocalallnodes","IPv6linklocalallrouters","ParseIP(${1:s})","ParseCIDR(${1:s})","IPAddr{}","ResolveIPAddr(${1:network}, ${2:address})","IPConn{}","DialIP(${1:network}, ${2:laddr}, ${3:raddr})","ListenIP(${1:network}, ${2:laddr})","SplitHostPort(${1:hostport})","JoinHostPort(${1:host}, ${2:port})","DefaultResolver","Resolver{}","LookupHost(${1:host})","LookupIP(${1:host})","LookupPort(${1:network}, ${2:service})","LookupCNAME(${1:host})","LookupSRV(${1:service}, ${2:proto}, ${3:name})","LookupMX(${1:name})","LookupNS(${1:name})","LookupTXT(${1:name})","LookupAddr(${1:addr})","HardwareAddr","ParseMAC(${1:s})","Addr","Conn","PacketConn","Listener","Error","ErrWriteToConnected","OpError{}","ParseError{}","AddrError{}","UnknownNetworkError","InvalidAddrError","DNSConfigError{}","DNSError{}","ErrClosed","Buffers","Pipe()","TCPAddr{}","ResolveTCPAddr(${1:network}, ${2:address})","TCPAddrFromAddrPort(${1:addr})","TCPConn{}","KeepAliveConfig{}","DialTCP(${1:network}, ${2:laddr}, ${3:raddr})","TCPListener{}","ListenTCP(${1:network}, ${2:laddr})","UDPAddr{}","ResolveUDPAddr(${1:network}, ${2:address})","UDPAddrFromAddrPort(${1:addr})","UDPConn{}","DialUDP(${1:network}, ${2:laddr}, ${3:raddr})","ListenUDP(${1:network}, ${2:laddr})","ListenMulticastUDP(${1:network}, ${2:ifi}, ${3:gaddr})","UnixAddr{}","ResolveUnixAddr(${1:network}, ${2:address})","UnixConn{}","DialUnix(${1:network}, ${2:laddr}, ${3:raddr})","UnixListener{}","ListenUnix(${1:network}, ${2:laddr})","ListenUnixgram(${1:network}, ${2:laddr})","DirEntry","ReadDir(${1:name})","CopyFS(${1:dir}, ${2:fsys})","Expand(${1:s}, ${2:mapping})","ExpandEnv(${1:s})","Getenv(${1:key})","LookupEnv(${1:key})","Setenv(${1:key}, ${2:value})","Unsetenv(${1:key})","Clearenv()","Environ()","ErrInvalid","ErrPermission","ErrExist","ErrNotExist","ErrClosed","ErrNoDeadline","ErrDeadlineExceeded","PathError","SyscallError{}","NewSyscallError(${1:syscall}, ${2:err})","IsExist(${1:err})","IsNotExist(${1:err})","IsPermission(${1:err})","IsTimeout(${1:err})","ErrProcessDone","Process{}","ProcAttr{}","Signal","Getpid()","Getppid()","FindProcess(${1:pid})","StartProcess(${1:name}, ${2:argv}, ${3:attr})","Interrupt","Kill","ProcessState{}","Executable()","Stdin","Stdout","Stderr","O_RDONLY","O_WRONLY","O_RDWR","O_APPEND","O_CREATE","O_EXCL","O_SYNC","O_TRUNC","SEEK_SET","SEEK_CUR","SEEK_END","LinkError{}","Mkdir(${1:name}, ${2:perm})","Chdir(${1:dir})","Open(${1:name})","Create(${1:name})","OpenFile(${1:name}, ${2:flag}, ${3:perm})","Rename(${1:oldpath}, ${2:newpath})","Readlink(${1:name})","TempDir()","UserCacheDir()","UserConfigDir()","UserHomeDir()","Chmod(${1:name}, ${2:mode})","DirFS(${1:dir})","ReadFile(${1:name})","WriteFile(${1:name}, ${2:data}, ${3:perm})","Chown(${1:name}, ${2:uid}, ${3:gid})","Lchown(${1:name}, ${2:uid}, ${3:gid})","Chtimes(${1:name}, ${2:atime}, ${3:mtime})","NewFile(${1:fd}, ${2:name})","DevNull","Truncate(${1:name}, ${2:size})","Remove(${1:name})","Link(${1:oldname}, ${2:newname})","Symlink(${1:oldname}, ${2:newname})","Getwd()","MkdirAll(${1:path}, ${2:perm})","RemoveAll(${1:path})","PathSeparator","PathListSeparator","IsPathSeparator(${1:c})","Pipe()","Args","Getuid()","Geteuid()","Getgid()","Getegid()","Getgroups()","Exit(${1:code})","Stat(${1:name})","Lstat(${1:name})","Hostname()","CreateTemp(${1:dir}, ${2:pattern})","MkdirTemp(${1:dir}, ${2:pattern})","Getpagesize()","File{}","FileInfo","FileMode","ModeDir","ModeAppend","ModeExclusive","ModeTemporary","ModeSymlink","ModeDevice","ModeNamedPipe","ModeSocket","ModeSetuid","ModeSetgid","ModeCharDevice","ModeSticky","ModeIrregular","ModeType","ModePerm","SameFile(${1:fi1}, ${2:fi2})","ErrBadPattern","Match(${1:pattern}, ${2:name})","Clean(${1:path})","Split(${1:path})","Join(${1:elem})","Ext(${1:path})","Base(${1:path})","IsAbs(${1:path})","Dir(${1:path})","Plugin{}","Open(${1:path})","Symbol","DeepEqual(${1:x}, ${2:y})","MakeFunc(${1:typ}, ${2:fn})","Swapper(${1:slice})","Type","Kind","Invalid","Bool","Int","Int8","Int16","Int32","Int64","Uint","Uint8","Uint16","Uint32","Uint64","Uintptr","Float32","Float64","Complex64","Complex128","Array","Chan","Func","Interface","Map","Pointer","Slice","String","Struct","UnsafePointer","Ptr","ChanDir","RecvDir","SendDir","BothDir","Method{}","StructField{}","StructTag","TypeOf(${1:i})","PtrTo(${1:t})","PointerTo(${1:t})","ChanOf(${1:dir}, ${2:t})","MapOf(${1:key}, ${2:elem})","FuncOf(${1:in}, ${2:out}, ${3:variadic})","SliceOf(${1:t})","StructOf(${1:fields})","ArrayOf(${1:length}, ${2:elem})","TypeFor[${1:T}]()","Value{}","ValueError{}","MapIter{}","StringHeader{}","SliceHeader{}","Append(${1:s}, ${2:x})","AppendSlice(${1:s}, ${2:t})","Copy(${1:dst}, ${2:src})","SelectDir","SelectSend","SelectRecv","SelectDefault","SelectCase{}","Select(${1:cases})","MakeSlice(${1:typ}, ${2:len}, ${3:cap})","SliceAt(${1:typ}, ${2:p}, ${3:n})","MakeChan(${1:typ}, ${2:buffer})","MakeMap(${1:typ})","MakeMapWithSize(${1:typ}, ${2:n})","Indirect(${1:v})","ValueOf(${1:i})","Zero(${1:typ})","New(${1:typ})","NewAt(${1:typ}, ${2:p})","VisibleFields(${1:t})","Regexp{}","Compile(${1:expr})","CompilePOSIX(${1:expr})","MustCompile(${1:str})","MustCompilePOSIX(${1:str})","MatchReader(${1:pattern}, ${2:r})","MatchString(${1:pattern}, ${2:s})","Match(${1:pattern}, ${2:b})","QuoteMeta(${1:s})","Compiler","SetCPUProfileRate(${1:hz})","CPUProfile()","GOMAXPROCS(${1:n})","NumCPU()","NumCgoCall()","NumGoroutine()","Error","TypeAssertionError{}","Caller(${1:skip})","Callers(${1:skip}, ${2:pc})","GOROOT()","Version()","GOOS","GOARCH","SetFinalizer(${1:obj}, ${2:finalizer})","KeepAlive(${1:x})","GC()","SetBlockProfileRate(${1:rate})","SetMutexProfileFraction(${1:rate})","StackRecord{}","MemProfileRate","MemProfileRecord{}","MemProfile(${1:p}, ${2:inuseZero})","BlockProfileRecord{}","BlockProfile(${1:p})","MutexProfile(${1:p})","ThreadCreateProfile(${1:p})","GoroutineProfile(${1:p})","Stack(${1:buf}, ${2:all})","MemStats{}","ReadMemStats(${1:m})","Goexit()","PanicNilError{}","Pinner{}","Gosched()","Breakpoint()","LockOSThread()","UnlockOSThread()","Frames{}","Frame{}","CallersFrames(${1:callers})","Func{}","FuncForPC(${1:pc})","StartTrace()","StopTrace()","ReadTrace()","SetCgoTraceback(${1:version}, ${2:traceback}, ${3:context}, ${4:symbolizer})","All[${1:Slice}, ${2:E}](${3:s})","Backward[${1:Slice}, ${2:E}](${3:s})","Values[${1:Slice}, ${2:E}](${3:s})","AppendSeq[${1:Slice}, ${2:E}](${3:s}, ${4:seq})","Collect[${1:E}](${2:seq})","Sorted[${1:E}](${2:seq})","SortedFunc[${1:E}](${2:seq}, ${3:cmp})","SortedStableFunc[${1:E}](${2:seq}, ${3:cmp})","Chunk[${1:Slice}, ${2:E}](${3:s}, ${4:n})","Equal[${1:S}, ${2:E}](${3:s1}, ${4:s2})","EqualFunc[${1:S1}, ${2:S2}, ${3:E1}, ${4:E2}](${5:s1}, ${6:s2}, ${7:eq})","Compare[${1:S}, ${2:E}](${3:s1}, ${4:s2})","CompareFunc[${1:S1}, ${2:S2}, ${3:E1}, ${4:E2}](${5:s1}, ${6:s2}, ${7:cmp})","Index[${1:S}, ${2:E}](${3:s}, ${4:v})","IndexFunc[${1:S}, ${2:E}](${3:s}, ${4:f})","Contains[${1:S}, ${2:E}](${3:s}, ${4:v})","ContainsFunc[${1:S}, ${2:E}](${3:s}, ${4:f})","Insert[${1:S}, ${2:E}](${3:s}, ${4:i}, ${5:v})","Delete[${1:S}, ${2:E}](${3:s}, ${4:i}, ${5:j})","DeleteFunc[${1:S}, ${2:E}](${3:s}, ${4:del})","Replace[${1:S}, ${2:E}](${3:s}, ${4:i}, ${5:j}, ${6:v})","Clone[${1:S}, ${2:E}](${3:s})","Compact[${1:S}, ${2:E}](${3:s})","CompactFunc[${1:S}, ${2:E}](${3:s}, ${4:eq})","Grow[${1:S}, ${2:E}](${3:s}, ${4:n})","Clip[${1:S}, ${2:E}](${3:s})","Reverse[${1:S}, ${2:E}](${3:s})","Concat[${1:S}, ${2:E}](${3:slices})","Repeat[${1:S}, ${2:E}](${3:x}, ${4:count})","Sort[${1:S}, ${2:E}](${3:x})","SortFunc[${1:S}, ${2:E}](${3:x}, ${4:cmp})","SortStableFunc[${1:S}, ${2:E}](${3:x}, ${4:cmp})","IsSorted[${1:S}, ${2:E}](${3:x})","IsSortedFunc[${1:S}, ${2:E}](${3:x}, ${4:cmp})","Min[${1:S}, ${2:E}](${3:x})","MinFunc[${1:S}, ${2:E}](${3:x}, ${4:cmp})","Max[${1:S}, ${2:E}](${3:x})","MaxFunc[${1:S}, ${2:E}](${3:x}, ${4:cmp})","BinarySearch[${1:S}, ${2:E}](${3:x}, ${4:target})","BinarySearchFunc[${1:S}, ${2:E}, ${3:T}](${4:x}, ${5:target}, ${6:cmp})","Search(${1:n}, ${2:f})","Find(${1:n}, ${2:cmp})","SearchInts(${1:a}, ${2:x})","SearchFloat64s(${1:a}, ${2:x})","SearchStrings(${1:a}, ${2:x})","Slice(${1:x}, ${2:less})","SliceStable(${1:x}, ${2:less})","SliceIsSorted(${1:x}, ${2:less})","Interface","Sort(${1:data})","Reverse(${1:data})","IsSorted(${1:data})","IntSlice","Float64Slice","StringSlice","Ints(${1:x})","Float64s(${1:x})","Strings(${1:x})","IntsAreSorted(${1:x})","Float64sAreSorted(${1:x})","StringsAreSorted(${1:x})","Stable(${1:data})","ParseBool(${1:str})","FormatBool(${1:b})","AppendBool(${1:dst}, ${2:b})","ParseComplex(${1:s}, ${2:bitSize})","ParseFloat(${1:s}, ${2:bitSize})","ErrRange","ErrSyntax","NumError{}","IntSize","ParseUint(${1:s}, ${2:base}, ${3:bitSize})","ParseInt(${1:s}, ${2:base}, ${3:bitSize})","Atoi(${1:s})","FormatComplex(${1:c}, ${2:fmt}, ${3:prec}, ${4:bitSize})","FormatFloat(${1:f}, ${2:fmt}, ${3:prec}, ${4:bitSize})","AppendFloat(${1:dst}, ${2:f}, ${3:fmt}, ${4:prec}, ${5:bitSize})","FormatUint(${1:i}, ${2:base})","FormatInt(${1:i}, ${2:base})","Itoa(${1:i})","AppendInt(${1:dst}, ${2:i}, ${3:base})","AppendUint(${1:dst}, ${2:i}, ${3:base})","Quote(${1:s})","AppendQuote(${1:dst}, ${2:s})","QuoteToASCII(${1:s})","AppendQuoteToASCII(${1:dst}, ${2:s})","QuoteToGraphic(${1:s})","AppendQuoteToGraphic(${1:dst}, ${2:s})","QuoteRune(${1:r})","AppendQuoteRune(${1:dst}, ${2:r})","QuoteRuneToASCII(${1:r})","AppendQuoteRuneToASCII(${1:dst}, ${2:r})","QuoteRuneToGraphic(${1:r})","AppendQuoteRuneToGraphic(${1:dst}, ${2:r})","CanBackquote(${1:s})","UnquoteChar(${1:s}, ${2:quote})","QuotedPrefix(${1:s})","Unquote(${1:s})","IsPrint(${1:r})","IsGraphic(${1:r})","Builder{}","Clone(${1:s})","Compare(${1:a}, ${2:b})","Reader{}","NewReader(${1:s})","Replacer{}","NewReplacer(${1:oldnew})","Count(${1:s}, ${2:substr})","Contains(${1:s}, ${2:substr})","ContainsAny(${1:s}, ${2:chars})","ContainsRune(${1:s}, ${2:r})","ContainsFunc(${1:s}, ${2:f})","LastIndex(${1:s}, ${2:substr})","IndexByte(${1:s}, ${2:c})","IndexRune(${1:s}, ${2:r})","IndexAny(${1:s}, ${2:chars})","LastIndexAny(${1:s}, ${2:chars})","LastIndexByte(${1:s}, ${2:c})","SplitN(${1:s}, ${2:sep}, ${3:n})","SplitAfterN(${1:s}, ${2:sep}, ${3:n})","Split(${1:s}, ${2:sep})","SplitAfter(${1:s}, ${2:sep})","Fields(${1:s})","FieldsFunc(${1:s}, ${2:f})","Join(${1:elems}, ${2:sep})","HasPrefix(${1:s}, ${2:prefix})","HasSuffix(${1:s}, ${2:suffix})","Map(${1:mapping}, ${2:s})","Repeat(${1:s}, ${2:count})","ToUpper(${1:s})","ToLower(${1:s})","ToTitle(${1:s})","ToUpperSpecial(${1:c}, ${2:s})","ToLowerSpecial(${1:c}, ${2:s})","ToTitleSpecial(${1:c}, ${2:s})","ToValidUTF8(${1:s}, ${2:replacement})","Title(${1:s})","TrimLeftFunc(${1:s}, ${2:f})","TrimRightFunc(${1:s}, ${2:f})","TrimFunc(${1:s}, ${2:f})","IndexFunc(${1:s}, ${2:f})","LastIndexFunc(${1:s}, ${2:f})","Trim(${1:s}, ${2:cutset})","TrimLeft(${1:s}, ${2:cutset})","TrimRight(${1:s}, ${2:cutset})","TrimSpace(${1:s})","TrimPrefix(${1:s}, ${2:prefix})","TrimSuffix(${1:s}, ${2:suffix})","Replace(${1:s}, ${2:old}, ${3:new}, ${4:n})","ReplaceAll(${1:s}, ${2:old}, ${3:new})","EqualFold(${1:s}, ${2:t})","Index(${1:s}, ${2:substr})","Cut(${1:s}, ${2:sep})","CutPrefix(${1:s}, ${2:prefix})","CutSuffix(${1:s}, ${2:suffix})","HostLayout{}","Cond{}","NewCond(${1:l})","Map{}","Mutex{}","Locker","Once{}","OnceFunc(${1:f})","OnceValue[${1:T}](${2:f})","OnceValues[${1:T1}, ${2:T2}](${3:f})","Pool{}","RWMutex{}","WaitGroup{}","ParseDirent(${1:buf}, ${2:max}, ${3:names})","Unsetenv(${1:key})","Getenv(${1:key})","Setenv(${1:key}, ${2:value})","Clearenv()","Environ()","CLONE_VM","CLONE_FS","CLONE_FILES","CLONE_SIGHAND","CLONE_PIDFD","CLONE_PTRACE","CLONE_VFORK","CLONE_PARENT","CLONE_THREAD","CLONE_NEWNS","CLONE_SYSVSEM","CLONE_SETTLS","CLONE_PARENT_SETTID","CLONE_CHILD_CLEARTID","CLONE_DETACHED","CLONE_UNTRACED","CLONE_CHILD_SETTID","CLONE_NEWCGROUP","CLONE_NEWUTS","CLONE_NEWIPC","CLONE_NEWUSER","CLONE_NEWPID","CLONE_NEWNET","CLONE_IO","CLONE_CLEAR_SIGHAND","CLONE_INTO_CGROUP","CLONE_NEWTIME","SysProcIDMap{}","SysProcAttr{}","ForkLock","StringSlicePtr(${1:ss})","SlicePtrFromStrings(${1:ss})","CloseOnExec(${1:fd})","SetNonblock(${1:fd}, ${2:nonblocking})","Credential{}","ProcAttr{}","ForkExec(${1:argv0}, ${2:argv}, ${3:attr})","StartProcess(${1:argv0}, ${2:argv}, ${3:attr})","Exec(${1:argv0}, ${2:argv}, ${3:envv})","FcntlFlock(${1:fd}, ${2:cmd}, ${3:lk})","LsfStmt(${1:code}, ${2:k})","LsfJump(${1:code}, ${2:k}, ${3:jt}, ${4:jf})","LsfSocket(${1:ifindex}, ${2:proto})","SetLsfPromisc(${1:name}, ${2:m})","AttachLsf(${1:fd}, ${2:i})","DetachLsf(${1:fd})","RawConn","Conn","NetlinkRouteRequest{}","NetlinkRIB(${1:proto}, ${2:family})","NetlinkMessage{}","ParseNetlinkMessage(${1:b})","NetlinkRouteAttr{}","ParseNetlinkRouteAttr(${1:m})","Setrlimit(${1:resource}, ${2:rlim})","UnixCredentials(${1:ucred})","ParseUnixCredentials(${1:m})","CmsgLen(${1:datalen})","CmsgSpace(${1:datalen})","SocketControlMessage{}","ParseSocketControlMessage(${1:b})","UnixRights(${1:fds})","ParseUnixRights(${1:m})","StringByteSlice(${1:s})","ByteSliceFromString(${1:s})","StringBytePtr(${1:s})","BytePtrFromString(${1:s})","Getpagesize()","Exit(${1:code})","RawSyscall(${1:trap}, ${2:a1}, ${3:a2}, ${4:a3})","RawSyscall6(${1:trap}, ${2:a1}, ${3:a2}, ${4:a3}, ${5:a4}, ${6:a5}, ${7:a6})","Syscall(${1:trap}, ${2:a1}, ${3:a2}, ${4:a3})","Syscall6(${1:trap}, ${2:a1}, ${3:a2}, ${4:a3}, ${5:a4}, ${6:a5}, ${7:a6})","Access(${1:path}, ${2:mode})","Chmod(${1:path}, ${2:mode})","Chown(${1:path}, ${2:uid}, ${3:gid})","Creat(${1:path}, ${2:mode})","EpollCreate(${1:size})","Faccessat(${1:dirfd}, ${2:path}, ${3:mode}, ${4:flags})","Fchmodat(${1:dirfd}, ${2:path}, ${3:mode}, ${4:flags})","Link(${1:oldpath}, ${2:newpath})","Mkdir(${1:path}, ${2:mode})","Mknod(${1:path}, ${2:mode}, ${3:dev})","Open(${1:path}, ${2:mode}, ${3:perm})","Openat(${1:dirfd}, ${2:path}, ${3:flags}, ${4:mode})","Pipe(${1:p})","Pipe2(${1:p}, ${2:flags})","Readlink(${1:path}, ${2:buf})","Rename(${1:oldpath}, ${2:newpath})","Rmdir(${1:path})","Symlink(${1:oldpath}, ${2:newpath})","Unlink(${1:path})","Unlinkat(${1:dirfd}, ${2:path})","Utimes(${1:path}, ${2:tv})","UtimesNano(${1:path}, ${2:ts})","Futimesat(${1:dirfd}, ${2:path}, ${3:tv})","Futimes(${1:fd}, ${2:tv})","ImplementsGetwd","Getwd()","Getgroups()","Setgroups(${1:gids})","WaitStatus","Wait4(${1:pid}, ${2:wstatus}, ${3:options}, ${4:rusage})","Mkfifo(${1:path}, ${2:mode})","SockaddrLinklayer{}","SockaddrNetlink{}","Accept4(${1:fd}, ${2:flags})","Getsockname(${1:fd})","GetsockoptInet4Addr(${1:fd}, ${2:level}, ${3:opt})","GetsockoptIPMreq(${1:fd}, ${2:level}, ${3:opt})","GetsockoptIPMreqn(${1:fd}, ${2:level}, ${3:opt})","GetsockoptIPv6Mreq(${1:fd}, ${2:level}, ${3:opt})","GetsockoptIPv6MTUInfo(${1:fd}, ${2:level}, ${3:opt})","GetsockoptICMPv6Filter(${1:fd}, ${2:level}, ${3:opt})","GetsockoptUcred(${1:fd}, ${2:level}, ${3:opt})","SetsockoptIPMreqn(${1:fd}, ${2:level}, ${3:opt}, ${4:mreq})","BindToDevice(${1:fd}, ${2:device})","PtracePeekText(${1:pid}, ${2:addr}, ${3:out})","PtracePeekData(${1:pid}, ${2:addr}, ${3:out})","PtracePokeText(${1:pid}, ${2:addr}, ${3:data})","PtracePokeData(${1:pid}, ${2:addr}, ${3:data})","PtraceGetRegs(${1:pid}, ${2:regsout})","PtraceSetRegs(${1:pid}, ${2:regs})","PtraceSetOptions(${1:pid}, ${2:options})","PtraceGetEventMsg(${1:pid})","PtraceCont(${1:pid}, ${2:signal})","PtraceSyscall(${1:pid}, ${2:signal})","PtraceSingleStep(${1:pid})","PtraceAttach(${1:pid})","PtraceDetach(${1:pid})","Reboot(${1:cmd})","ReadDirent(${1:fd}, ${2:buf})","Mount(${1:source}, ${2:target}, ${3:fstype}, ${4:flags}, ${5:data})","Getpgrp()","AllThreadsSyscall(${1:trap}, ${2:a1}, ${3:a2}, ${4:a3})","AllThreadsSyscall6(${1:trap}, ${2:a1}, ${3:a2}, ${4:a3}, ${5:a4}, ${6:a5}, ${7:a6})","Setegid(${1:egid})","Seteuid(${1:euid})","Setgid(${1:gid})","Setregid(${1:rgid}, ${2:egid})","Setresgid(${1:rgid}, ${2:egid}, ${3:sgid})","Setresuid(${1:ruid}, ${2:euid}, ${3:suid})","Setreuid(${1:ruid}, ${2:euid})","Setuid(${1:uid})","Mmap(${1:fd}, ${2:offset}, ${3:length}, ${4:prot}, ${5:flags})","Munmap(${1:b})","Accept(${1:fd})","Stat(${1:path}, ${2:stat})","Lchown(${1:path}, ${2:uid}, ${3:gid})","Lstat(${1:path}, ${2:stat})","Gettimeofday(${1:tv})","Time(${1:t})","Stdin","Stdout","Stderr","Errno","Signal","Read(${1:fd}, ${2:p})","Write(${1:fd}, ${2:p})","Pread(${1:fd}, ${2:p}, ${3:offset})","Pwrite(${1:fd}, ${2:p}, ${3:offset})","SocketDisableIPv6","Sockaddr","SockaddrInet4{}","SockaddrInet6{}","SockaddrUnix{}","Bind(${1:fd}, ${2:sa})","Connect(${1:fd}, ${2:sa})","Getpeername(${1:fd})","GetsockoptInt(${1:fd}, ${2:level}, ${3:opt})","Recvfrom(${1:fd}, ${2:p}, ${3:flags})","Recvmsg(${1:fd}, ${2:p}, ${3:oob}, ${4:flags})","Sendmsg(${1:fd}, ${2:p}, ${3:oob}, ${4:to}, ${5:flags})","SendmsgN(${1:fd}, ${2:p}, ${3:oob}, ${4:to}, ${5:flags})","Sendto(${1:fd}, ${2:p}, ${3:flags}, ${4:to})","SetsockoptByte(${1:fd}, ${2:level}, ${3:opt}, ${4:value})","SetsockoptInt(${1:fd}, ${2:level}, ${3:opt}, ${4:value})","SetsockoptInet4Addr(${1:fd}, ${2:level}, ${3:opt}, ${4:value})","SetsockoptIPMreq(${1:fd}, ${2:level}, ${3:opt}, ${4:mreq})","SetsockoptIPv6Mreq(${1:fd}, ${2:level}, ${3:opt}, ${4:mreq})","SetsockoptICMPv6Filter(${1:fd}, ${2:level}, ${3:opt}, ${4:filter})","SetsockoptLinger(${1:fd}, ${2:level}, ${3:opt}, ${4:l})","SetsockoptString(${1:fd}, ${2:level}, ${3:opt}, ${4:s})","SetsockoptTimeval(${1:fd}, ${2:level}, ${3:opt}, ${4:tv})","Socket(${1:domain}, ${2:typ}, ${3:proto})","Socketpair(${1:domain}, ${2:typ}, ${3:proto})","Sendfile(${1:outfd}, ${2:infd}, ${3:offset}, ${4:count})","TimespecToNsec(${1:ts})","NsecToTimespec(${1:nsec})","TimevalToNsec(${1:tv})","NsecToTimeval(${1:nsec})","AF_ALG","AF_APPLETALK","AF_ASH","AF_ATMPVC","AF_ATMSVC","AF_AX25","AF_BLUETOOTH","AF_BRIDGE","AF_CAIF","AF_CAN","AF_DECnet","AF_ECONET","AF_FILE","AF_IEEE802154","AF_INET","AF_INET6","AF_IPX","AF_IRDA","AF_ISDN","AF_IUCV","AF_KEY","AF_LLC","AF_LOCAL","AF_MAX","AF_NETBEUI","AF_NETLINK","AF_NETROM","AF_PACKET","AF_PHONET","AF_PPPOX","AF_RDS","AF_ROSE","AF_ROUTE","AF_RXRPC","AF_SECURITY","AF_SNA","AF_TIPC","AF_UNIX","AF_UNSPEC","AF_WANPIPE","AF_X25","ARPHRD_ADAPT","ARPHRD_APPLETLK","ARPHRD_ARCNET","ARPHRD_ASH","ARPHRD_ATM","ARPHRD_AX25","ARPHRD_BIF","ARPHRD_CHAOS","ARPHRD_CISCO","ARPHRD_CSLIP","ARPHRD_CSLIP6","ARPHRD_DDCMP","ARPHRD_DLCI","ARPHRD_ECONET","ARPHRD_EETHER","ARPHRD_ETHER","ARPHRD_EUI64","ARPHRD_FCAL","ARPHRD_FCFABRIC","ARPHRD_FCPL","ARPHRD_FCPP","ARPHRD_FDDI","ARPHRD_FRAD","ARPHRD_HDLC","ARPHRD_HIPPI","ARPHRD_HWX25","ARPHRD_IEEE1394","ARPHRD_IEEE802","ARPHRD_IEEE80211","ARPHRD_IEEE80211_PRISM","ARPHRD_IEEE80211_RADIOTAP","ARPHRD_IEEE802154","ARPHRD_IEEE802154_PHY","ARPHRD_IEEE802_TR","ARPHRD_INFINIBAND","ARPHRD_IPDDP","ARPHRD_IPGRE","ARPHRD_IRDA","ARPHRD_LAPB","ARPHRD_LOCALTLK","ARPHRD_LOOPBACK","ARPHRD_METRICOM","ARPHRD_NETROM","ARPHRD_NONE","ARPHRD_PIMREG","ARPHRD_PPP","ARPHRD_PRONET","ARPHRD_RAWHDLC","ARPHRD_ROSE","ARPHRD_RSRVD","ARPHRD_SIT","ARPHRD_SKIP","ARPHRD_SLIP","ARPHRD_SLIP6","ARPHRD_TUNNEL","ARPHRD_TUNNEL6","ARPHRD_VOID","ARPHRD_X25","BPF_A","BPF_ABS","BPF_ADD","BPF_ALU","BPF_AND","BPF_B","BPF_DIV","BPF_H","BPF_IMM","BPF_IND","BPF_JA","BPF_JEQ","BPF_JGE","BPF_JGT","BPF_JMP","BPF_JSET","BPF_K","BPF_LD","BPF_LDX","BPF_LEN","BPF_LSH","BPF_MAJOR_VERSION","BPF_MAXINSNS","BPF_MEM","BPF_MEMWORDS","BPF_MINOR_VERSION","BPF_MISC","BPF_MSH","BPF_MUL","BPF_NEG","BPF_OR","BPF_RET","BPF_RSH","BPF_ST","BPF_STX","BPF_SUB","BPF_TAX","BPF_TXA","BPF_W","BPF_X","DT_BLK","DT_CHR","DT_DIR","DT_FIFO","DT_LNK","DT_REG","DT_SOCK","DT_UNKNOWN","DT_WHT","EPOLLERR","EPOLLET","EPOLLHUP","EPOLLIN","EPOLLMSG","EPOLLONESHOT","EPOLLOUT","EPOLLPRI","EPOLLRDBAND","EPOLLRDHUP","EPOLLRDNORM","EPOLLWRBAND","EPOLLWRNORM","EPOLL_CLOEXEC","EPOLL_CTL_ADD","EPOLL_CTL_DEL","EPOLL_CTL_MOD","EPOLL_NONBLOCK","ETH_P_1588","ETH_P_8021Q","ETH_P_802_2","ETH_P_802_3","ETH_P_AARP","ETH_P_ALL","ETH_P_AOE","ETH_P_ARCNET","ETH_P_ARP","ETH_P_ATALK","ETH_P_ATMFATE","ETH_P_ATMMPOA","ETH_P_AX25","ETH_P_BPQ","ETH_P_CAIF","ETH_P_CAN","ETH_P_CONTROL","ETH_P_CUST","ETH_P_DDCMP","ETH_P_DEC","ETH_P_DIAG","ETH_P_DNA_DL","ETH_P_DNA_RC","ETH_P_DNA_RT","ETH_P_DSA","ETH_P_ECONET","ETH_P_EDSA","ETH_P_FCOE","ETH_P_FIP","ETH_P_HDLC","ETH_P_IEEE802154","ETH_P_IEEEPUP","ETH_P_IEEEPUPAT","ETH_P_IP","ETH_P_IPV6","ETH_P_IPX","ETH_P_IRDA","ETH_P_LAT","ETH_P_LINK_CTL","ETH_P_LOCALTALK","ETH_P_LOOP","ETH_P_MOBITEX","ETH_P_MPLS_MC","ETH_P_MPLS_UC","ETH_P_PAE","ETH_P_PAUSE","ETH_P_PHONET","ETH_P_PPPTALK","ETH_P_PPP_DISC","ETH_P_PPP_MP","ETH_P_PPP_SES","ETH_P_PUP","ETH_P_PUPAT","ETH_P_RARP","ETH_P_SCA","ETH_P_SLOW","ETH_P_SNAP","ETH_P_TEB","ETH_P_TIPC","ETH_P_TRAILER","ETH_P_TR_802_2","ETH_P_WAN_PPP","ETH_P_WCCP","ETH_P_X25","FD_CLOEXEC","FD_SETSIZE","F_DUPFD","F_DUPFD_CLOEXEC","F_EXLCK","F_GETFD","F_GETFL","F_GETLEASE","F_GETLK","F_GETLK64","F_GETOWN","F_GETOWN_EX","F_GETPIPE_SZ","F_GETSIG","F_LOCK","F_NOTIFY","F_OK","F_RDLCK","F_SETFD","F_SETFL","F_SETLEASE","F_SETLK","F_SETLK64","F_SETLKW","F_SETLKW64","F_SETOWN","F_SETOWN_EX","F_SETPIPE_SZ","F_SETSIG","F_SHLCK","F_TEST","F_TLOCK","F_ULOCK","F_UNLCK","F_WRLCK","ICMPV6_FILTER","IFA_F_DADFAILED","IFA_F_DEPRECATED","IFA_F_HOMEADDRESS","IFA_F_NODAD","IFA_F_OPTIMISTIC","IFA_F_PERMANENT","IFA_F_SECONDARY","IFA_F_TEMPORARY","IFA_F_TENTATIVE","IFA_MAX","IFF_ALLMULTI","IFF_AUTOMEDIA","IFF_BROADCAST","IFF_DEBUG","IFF_DYNAMIC","IFF_LOOPBACK","IFF_MASTER","IFF_MULTICAST","IFF_NOARP","IFF_NOTRAILERS","IFF_NO_PI","IFF_ONE_QUEUE","IFF_POINTOPOINT","IFF_PORTSEL","IFF_PROMISC","IFF_RUNNING","IFF_SLAVE","IFF_TAP","IFF_TUN","IFF_TUN_EXCL","IFF_UP","IFF_VNET_HDR","IFNAMSIZ","IN_ACCESS","IN_ALL_EVENTS","IN_ATTRIB","IN_CLASSA_HOST","IN_CLASSA_MAX","IN_CLASSA_NET","IN_CLASSA_NSHIFT","IN_CLASSB_HOST","IN_CLASSB_MAX","IN_CLASSB_NET","IN_CLASSB_NSHIFT","IN_CLASSC_HOST","IN_CLASSC_NET","IN_CLASSC_NSHIFT","IN_CLOEXEC","IN_CLOSE","IN_CLOSE_NOWRITE","IN_CLOSE_WRITE","IN_CREATE","IN_DELETE","IN_DELETE_SELF","IN_DONT_FOLLOW","IN_EXCL_UNLINK","IN_IGNORED","IN_ISDIR","IN_LOOPBACKNET","IN_MASK_ADD","IN_MODIFY","IN_MOVE","IN_MOVED_FROM","IN_MOVED_TO","IN_MOVE_SELF","IN_NONBLOCK","IN_ONESHOT","IN_ONLYDIR","IN_OPEN","IN_Q_OVERFLOW","IN_UNMOUNT","IPPROTO_AH","IPPROTO_COMP","IPPROTO_DCCP","IPPROTO_DSTOPTS","IPPROTO_EGP","IPPROTO_ENCAP","IPPROTO_ESP","IPPROTO_FRAGMENT","IPPROTO_GRE","IPPROTO_HOPOPTS","IPPROTO_ICMP","IPPROTO_ICMPV6","IPPROTO_IDP","IPPROTO_IGMP","IPPROTO_IP","IPPROTO_IPIP","IPPROTO_IPV6","IPPROTO_MTP","IPPROTO_NONE","IPPROTO_PIM","IPPROTO_PUP","IPPROTO_RAW","IPPROTO_ROUTING","IPPROTO_RSVP","IPPROTO_SCTP","IPPROTO_TCP","IPPROTO_TP","IPPROTO_UDP","IPPROTO_UDPLITE","IPV6_2292DSTOPTS","IPV6_2292HOPLIMIT","IPV6_2292HOPOPTS","IPV6_2292PKTINFO","IPV6_2292PKTOPTIONS","IPV6_2292RTHDR","IPV6_ADDRFORM","IPV6_ADD_MEMBERSHIP","IPV6_AUTHHDR","IPV6_CHECKSUM","IPV6_DROP_MEMBERSHIP","IPV6_DSTOPTS","IPV6_HOPLIMIT","IPV6_HOPOPTS","IPV6_IPSEC_POLICY","IPV6_JOIN_ANYCAST","IPV6_JOIN_GROUP","IPV6_LEAVE_ANYCAST","IPV6_LEAVE_GROUP","IPV6_MTU","IPV6_MTU_DISCOVER","IPV6_MULTICAST_HOPS","IPV6_MULTICAST_IF","IPV6_MULTICAST_LOOP","IPV6_NEXTHOP","IPV6_PKTINFO","IPV6_PMTUDISC_DO","IPV6_PMTUDISC_DONT","IPV6_PMTUDISC_PROBE","IPV6_PMTUDISC_WANT","IPV6_RECVDSTOPTS","IPV6_RECVERR","IPV6_RECVHOPLIMIT","IPV6_RECVHOPOPTS","IPV6_RECVPKTINFO","IPV6_RECVRTHDR","IPV6_RECVTCLASS","IPV6_ROUTER_ALERT","IPV6_RTHDR","IPV6_RTHDRDSTOPTS","IPV6_RTHDR_LOOSE","IPV6_RTHDR_STRICT","IPV6_RTHDR_TYPE_0","IPV6_RXDSTOPTS","IPV6_RXHOPOPTS","IPV6_TCLASS","IPV6_UNICAST_HOPS","IPV6_V6ONLY","IPV6_XFRM_POLICY","IP_ADD_MEMBERSHIP","IP_ADD_SOURCE_MEMBERSHIP","IP_BLOCK_SOURCE","IP_DEFAULT_MULTICAST_LOOP","IP_DEFAULT_MULTICAST_TTL","IP_DF","IP_DROP_MEMBERSHIP","IP_DROP_SOURCE_MEMBERSHIP","IP_FREEBIND","IP_HDRINCL","IP_IPSEC_POLICY","IP_MAXPACKET","IP_MAX_MEMBERSHIPS","IP_MF","IP_MINTTL","IP_MSFILTER","IP_MSS","IP_MTU","IP_MTU_DISCOVER","IP_MULTICAST_IF","IP_MULTICAST_LOOP","IP_MULTICAST_TTL","IP_OFFMASK","IP_OPTIONS","IP_ORIGDSTADDR","IP_PASSSEC","IP_PKTINFO","IP_PKTOPTIONS","IP_PMTUDISC","IP_PMTUDISC_DO","IP_PMTUDISC_DONT","IP_PMTUDISC_PROBE","IP_PMTUDISC_WANT","IP_RECVERR","IP_RECVOPTS","IP_RECVORIGDSTADDR","IP_RECVRETOPTS","IP_RECVTOS","IP_RECVTTL","IP_RETOPTS","IP_RF","IP_ROUTER_ALERT","IP_TOS","IP_TRANSPARENT","IP_TTL","IP_UNBLOCK_SOURCE","IP_XFRM_POLICY","LINUX_REBOOT_CMD_CAD_OFF","LINUX_REBOOT_CMD_CAD_ON","LINUX_REBOOT_CMD_HALT","LINUX_REBOOT_CMD_KEXEC","LINUX_REBOOT_CMD_POWER_OFF","LINUX_REBOOT_CMD_RESTART","LINUX_REBOOT_CMD_RESTART2","LINUX_REBOOT_CMD_SW_SUSPEND","LINUX_REBOOT_MAGIC1","LINUX_REBOOT_MAGIC2","LOCK_EX","LOCK_NB","LOCK_SH","LOCK_UN","MADV_DOFORK","MADV_DONTFORK","MADV_DONTNEED","MADV_HUGEPAGE","MADV_HWPOISON","MADV_MERGEABLE","MADV_NOHUGEPAGE","MADV_NORMAL","MADV_RANDOM","MADV_REMOVE","MADV_SEQUENTIAL","MADV_UNMERGEABLE","MADV_WILLNEED","MAP_32BIT","MAP_ANON","MAP_ANONYMOUS","MAP_DENYWRITE","MAP_EXECUTABLE","MAP_FILE","MAP_FIXED","MAP_GROWSDOWN","MAP_HUGETLB","MAP_LOCKED","MAP_NONBLOCK","MAP_NORESERVE","MAP_POPULATE","MAP_PRIVATE","MAP_SHARED","MAP_STACK","MAP_TYPE","MCL_CURRENT","MCL_FUTURE","MNT_DETACH","MNT_EXPIRE","MNT_FORCE","MSG_CMSG_CLOEXEC","MSG_CONFIRM","MSG_CTRUNC","MSG_DONTROUTE","MSG_DONTWAIT","MSG_EOR","MSG_ERRQUEUE","MSG_FASTOPEN","MSG_FIN","MSG_MORE","MSG_NOSIGNAL","MSG_OOB","MSG_PEEK","MSG_PROXY","MSG_RST","MSG_SYN","MSG_TRUNC","MSG_TRYHARD","MSG_WAITALL","MSG_WAITFORONE","MS_ACTIVE","MS_ASYNC","MS_BIND","MS_DIRSYNC","MS_INVALIDATE","MS_I_VERSION","MS_KERNMOUNT","MS_MANDLOCK","MS_MGC_MSK","MS_MGC_VAL","MS_MOVE","MS_NOATIME","MS_NODEV","MS_NODIRATIME","MS_NOEXEC","MS_NOSUID","MS_NOUSER","MS_POSIXACL","MS_PRIVATE","MS_RDONLY","MS_REC","MS_RELATIME","MS_REMOUNT","MS_RMT_MASK","MS_SHARED","MS_SILENT","MS_SLAVE","MS_STRICTATIME","MS_SYNC","MS_SYNCHRONOUS","MS_UNBINDABLE","NAME_MAX","NETLINK_ADD_MEMBERSHIP","NETLINK_AUDIT","NETLINK_BROADCAST_ERROR","NETLINK_CONNECTOR","NETLINK_DNRTMSG","NETLINK_DROP_MEMBERSHIP","NETLINK_ECRYPTFS","NETLINK_FIB_LOOKUP","NETLINK_FIREWALL","NETLINK_GENERIC","NETLINK_INET_DIAG","NETLINK_IP6_FW","NETLINK_ISCSI","NETLINK_KOBJECT_UEVENT","NETLINK_NETFILTER","NETLINK_NFLOG","NETLINK_NO_ENOBUFS","NETLINK_PKTINFO","NETLINK_ROUTE","NETLINK_SCSITRANSPORT","NETLINK_SELINUX","NETLINK_UNUSED","NETLINK_USERSOCK","NETLINK_XFRM","NLA_ALIGNTO","NLA_F_NESTED","NLA_F_NET_BYTEORDER","NLA_HDRLEN","NLMSG_ALIGNTO","NLMSG_DONE","NLMSG_ERROR","NLMSG_HDRLEN","NLMSG_MIN_TYPE","NLMSG_NOOP","NLMSG_OVERRUN","NLM_F_ACK","NLM_F_APPEND","NLM_F_ATOMIC","NLM_F_CREATE","NLM_F_DUMP","NLM_F_ECHO","NLM_F_EXCL","NLM_F_MATCH","NLM_F_MULTI","NLM_F_REPLACE","NLM_F_REQUEST","NLM_F_ROOT","O_ACCMODE","O_APPEND","O_ASYNC","O_CLOEXEC","O_CREAT","O_DIRECT","O_DIRECTORY","O_DSYNC","O_EXCL","O_FSYNC","O_LARGEFILE","O_NDELAY","O_NOATIME","O_NOCTTY","O_NOFOLLOW","O_NONBLOCK","O_RDONLY","O_RDWR","O_RSYNC","O_SYNC","O_TRUNC","O_WRONLY","PACKET_ADD_MEMBERSHIP","PACKET_BROADCAST","PACKET_DROP_MEMBERSHIP","PACKET_FASTROUTE","PACKET_HOST","PACKET_LOOPBACK","PACKET_MR_ALLMULTI","PACKET_MR_MULTICAST","PACKET_MR_PROMISC","PACKET_MULTICAST","PACKET_OTHERHOST","PACKET_OUTGOING","PACKET_RECV_OUTPUT","PACKET_RX_RING","PACKET_STATISTICS","PRIO_PGRP","PRIO_PROCESS","PRIO_USER","PROT_EXEC","PROT_GROWSDOWN","PROT_GROWSUP","PROT_NONE","PROT_READ","PROT_WRITE","PR_CAPBSET_DROP","PR_CAPBSET_READ","PR_ENDIAN_BIG","PR_ENDIAN_LITTLE","PR_ENDIAN_PPC_LITTLE","PR_FPEMU_NOPRINT","PR_FPEMU_SIGFPE","PR_FP_EXC_ASYNC","PR_FP_EXC_DISABLED","PR_FP_EXC_DIV","PR_FP_EXC_INV","PR_FP_EXC_NONRECOV","PR_FP_EXC_OVF","PR_FP_EXC_PRECISE","PR_FP_EXC_RES","PR_FP_EXC_SW_ENABLE","PR_FP_EXC_UND","PR_GET_DUMPABLE","PR_GET_ENDIAN","PR_GET_FPEMU","PR_GET_FPEXC","PR_GET_KEEPCAPS","PR_GET_NAME","PR_GET_PDEATHSIG","PR_GET_SECCOMP","PR_GET_SECUREBITS","PR_GET_TIMERSLACK","PR_GET_TIMING","PR_GET_TSC","PR_GET_UNALIGN","PR_MCE_KILL","PR_MCE_KILL_CLEAR","PR_MCE_KILL_DEFAULT","PR_MCE_KILL_EARLY","PR_MCE_KILL_GET","PR_MCE_KILL_LATE","PR_MCE_KILL_SET","PR_SET_DUMPABLE","PR_SET_ENDIAN","PR_SET_FPEMU","PR_SET_FPEXC","PR_SET_KEEPCAPS","PR_SET_NAME","PR_SET_PDEATHSIG","PR_SET_PTRACER","PR_SET_SECCOMP","PR_SET_SECUREBITS","PR_SET_TIMERSLACK","PR_SET_TIMING","PR_SET_TSC","PR_SET_UNALIGN","PR_TASK_PERF_EVENTS_DISABLE","PR_TASK_PERF_EVENTS_ENABLE","PR_TIMING_STATISTICAL","PR_TIMING_TIMESTAMP","PR_TSC_ENABLE","PR_TSC_SIGSEGV","PR_UNALIGN_NOPRINT","PR_UNALIGN_SIGBUS","PTRACE_ARCH_PRCTL","PTRACE_ATTACH","PTRACE_CONT","PTRACE_DETACH","PTRACE_EVENT_CLONE","PTRACE_EVENT_EXEC","PTRACE_EVENT_EXIT","PTRACE_EVENT_FORK","PTRACE_EVENT_VFORK","PTRACE_EVENT_VFORK_DONE","PTRACE_GETEVENTMSG","PTRACE_GETFPREGS","PTRACE_GETFPXREGS","PTRACE_GETREGS","PTRACE_GETREGSET","PTRACE_GETSIGINFO","PTRACE_GET_THREAD_AREA","PTRACE_KILL","PTRACE_OLDSETOPTIONS","PTRACE_O_MASK","PTRACE_O_TRACECLONE","PTRACE_O_TRACEEXEC","PTRACE_O_TRACEEXIT","PTRACE_O_TRACEFORK","PTRACE_O_TRACESYSGOOD","PTRACE_O_TRACEVFORK","PTRACE_O_TRACEVFORKDONE","PTRACE_PEEKDATA","PTRACE_PEEKTEXT","PTRACE_PEEKUSR","PTRACE_POKEDATA","PTRACE_POKETEXT","PTRACE_POKEUSR","PTRACE_SETFPREGS","PTRACE_SETFPXREGS","PTRACE_SETOPTIONS","PTRACE_SETREGS","PTRACE_SETREGSET","PTRACE_SETSIGINFO","PTRACE_SET_THREAD_AREA","PTRACE_SINGLEBLOCK","PTRACE_SINGLESTEP","PTRACE_SYSCALL","PTRACE_SYSEMU","PTRACE_SYSEMU_SINGLESTEP","PTRACE_TRACEME","RLIMIT_AS","RLIMIT_CORE","RLIMIT_CPU","RLIMIT_DATA","RLIMIT_FSIZE","RLIMIT_NOFILE","RLIMIT_STACK","RLIM_INFINITY","RTAX_ADVMSS","RTAX_CWND","RTAX_FEATURES","RTAX_FEATURE_ALLFRAG","RTAX_FEATURE_ECN","RTAX_FEATURE_SACK","RTAX_FEATURE_TIMESTAMP","RTAX_HOPLIMIT","RTAX_INITCWND","RTAX_INITRWND","RTAX_LOCK","RTAX_MAX","RTAX_MTU","RTAX_REORDERING","RTAX_RTO_MIN","RTAX_RTT","RTAX_RTTVAR","RTAX_SSTHRESH","RTAX_UNSPEC","RTAX_WINDOW","RTA_ALIGNTO","RTA_MAX","RTCF_DIRECTSRC","RTCF_DOREDIRECT","RTCF_LOG","RTCF_MASQ","RTCF_NAT","RTCF_VALVE","RTF_ADDRCLASSMASK","RTF_ADDRCONF","RTF_ALLONLINK","RTF_BROADCAST","RTF_CACHE","RTF_DEFAULT","RTF_DYNAMIC","RTF_FLOW","RTF_GATEWAY","RTF_HOST","RTF_INTERFACE","RTF_IRTT","RTF_LINKRT","RTF_LOCAL","RTF_MODIFIED","RTF_MSS","RTF_MTU","RTF_MULTICAST","RTF_NAT","RTF_NOFORWARD","RTF_NONEXTHOP","RTF_NOPMTUDISC","RTF_POLICY","RTF_REINSTATE","RTF_REJECT","RTF_STATIC","RTF_THROW","RTF_UP","RTF_WINDOW","RTF_XRESOLVE","RTM_BASE","RTM_DELACTION","RTM_DELADDR","RTM_DELADDRLABEL","RTM_DELLINK","RTM_DELNEIGH","RTM_DELQDISC","RTM_DELROUTE","RTM_DELRULE","RTM_DELTCLASS","RTM_DELTFILTER","RTM_F_CLONED","RTM_F_EQUALIZE","RTM_F_NOTIFY","RTM_F_PREFIX","RTM_GETACTION","RTM_GETADDR","RTM_GETADDRLABEL","RTM_GETANYCAST","RTM_GETDCB","RTM_GETLINK","RTM_GETMULTICAST","RTM_GETNEIGH","RTM_GETNEIGHTBL","RTM_GETQDISC","RTM_GETROUTE","RTM_GETRULE","RTM_GETTCLASS","RTM_GETTFILTER","RTM_MAX","RTM_NEWACTION","RTM_NEWADDR","RTM_NEWADDRLABEL","RTM_NEWLINK","RTM_NEWNDUSEROPT","RTM_NEWNEIGH","RTM_NEWNEIGHTBL","RTM_NEWPREFIX","RTM_NEWQDISC","RTM_NEWROUTE","RTM_NEWRULE","RTM_NEWTCLASS","RTM_NEWTFILTER","RTM_NR_FAMILIES","RTM_NR_MSGTYPES","RTM_SETDCB","RTM_SETLINK","RTM_SETNEIGHTBL","RTNH_ALIGNTO","RTNH_F_DEAD","RTNH_F_ONLINK","RTNH_F_PERVASIVE","RTN_MAX","RTPROT_BIRD","RTPROT_BOOT","RTPROT_DHCP","RTPROT_DNROUTED","RTPROT_GATED","RTPROT_KERNEL","RTPROT_MRT","RTPROT_NTK","RTPROT_RA","RTPROT_REDIRECT","RTPROT_STATIC","RTPROT_UNSPEC","RTPROT_XORP","RTPROT_ZEBRA","RT_CLASS_DEFAULT","RT_CLASS_LOCAL","RT_CLASS_MAIN","RT_CLASS_MAX","RT_CLASS_UNSPEC","RUSAGE_CHILDREN","RUSAGE_SELF","RUSAGE_THREAD","SCM_CREDENTIALS","SCM_RIGHTS","SCM_TIMESTAMP","SCM_TIMESTAMPING","SCM_TIMESTAMPNS","SHUT_RD","SHUT_RDWR","SHUT_WR","SIOCADDDLCI","SIOCADDMULTI","SIOCADDRT","SIOCATMARK","SIOCDARP","SIOCDELDLCI","SIOCDELMULTI","SIOCDELRT","SIOCDEVPRIVATE","SIOCDIFADDR","SIOCDRARP","SIOCGARP","SIOCGIFADDR","SIOCGIFBR","SIOCGIFBRDADDR","SIOCGIFCONF","SIOCGIFCOUNT","SIOCGIFDSTADDR","SIOCGIFENCAP","SIOCGIFFLAGS","SIOCGIFHWADDR","SIOCGIFINDEX","SIOCGIFMAP","SIOCGIFMEM","SIOCGIFMETRIC","SIOCGIFMTU","SIOCGIFNAME","SIOCGIFNETMASK","SIOCGIFPFLAGS","SIOCGIFSLAVE","SIOCGIFTXQLEN","SIOCGPGRP","SIOCGRARP","SIOCGSTAMP","SIOCGSTAMPNS","SIOCPROTOPRIVATE","SIOCRTMSG","SIOCSARP","SIOCSIFADDR","SIOCSIFBR","SIOCSIFBRDADDR","SIOCSIFDSTADDR","SIOCSIFENCAP","SIOCSIFFLAGS","SIOCSIFHWADDR","SIOCSIFHWBROADCAST","SIOCSIFLINK","SIOCSIFMAP","SIOCSIFMEM","SIOCSIFMETRIC","SIOCSIFMTU","SIOCSIFNAME","SIOCSIFNETMASK","SIOCSIFPFLAGS","SIOCSIFSLAVE","SIOCSIFTXQLEN","SIOCSPGRP","SIOCSRARP","SOCK_CLOEXEC","SOCK_DCCP","SOCK_DGRAM","SOCK_NONBLOCK","SOCK_PACKET","SOCK_RAW","SOCK_RDM","SOCK_SEQPACKET","SOCK_STREAM","SOL_AAL","SOL_ATM","SOL_DECNET","SOL_ICMPV6","SOL_IP","SOL_IPV6","SOL_IRDA","SOL_PACKET","SOL_RAW","SOL_SOCKET","SOL_TCP","SOL_X25","SOMAXCONN","SO_ACCEPTCONN","SO_ATTACH_FILTER","SO_BINDTODEVICE","SO_BROADCAST","SO_BSDCOMPAT","SO_DEBUG","SO_DETACH_FILTER","SO_DOMAIN","SO_DONTROUTE","SO_ERROR","SO_KEEPALIVE","SO_LINGER","SO_MARK","SO_NO_CHECK","SO_OOBINLINE","SO_PASSCRED","SO_PASSSEC","SO_PEERCRED","SO_PEERNAME","SO_PEERSEC","SO_PRIORITY","SO_PROTOCOL","SO_RCVBUF","SO_RCVBUFFORCE","SO_RCVLOWAT","SO_RCVTIMEO","SO_REUSEADDR","SO_RXQ_OVFL","SO_SECURITY_AUTHENTICATION","SO_SECURITY_ENCRYPTION_NETWORK","SO_SECURITY_ENCRYPTION_TRANSPORT","SO_SNDBUF","SO_SNDBUFFORCE","SO_SNDLOWAT","SO_SNDTIMEO","SO_TIMESTAMP","SO_TIMESTAMPING","SO_TIMESTAMPNS","SO_TYPE","S_BLKSIZE","S_IEXEC","S_IFBLK","S_IFCHR","S_IFDIR","S_IFIFO","S_IFLNK","S_IFMT","S_IFREG","S_IFSOCK","S_IREAD","S_IRGRP","S_IROTH","S_IRUSR","S_IRWXG","S_IRWXO","S_IRWXU","S_ISGID","S_ISUID","S_ISVTX","S_IWGRP","S_IWOTH","S_IWRITE","S_IWUSR","S_IXGRP","S_IXOTH","S_IXUSR","TCIFLUSH","TCIOFLUSH","TCOFLUSH","TCP_CONGESTION","TCP_CORK","TCP_DEFER_ACCEPT","TCP_INFO","TCP_KEEPCNT","TCP_KEEPIDLE","TCP_KEEPINTVL","TCP_LINGER2","TCP_MAXSEG","TCP_MAXWIN","TCP_MAX_WINSHIFT","TCP_MD5SIG","TCP_MD5SIG_MAXKEYLEN","TCP_MSS","TCP_NODELAY","TCP_QUICKACK","TCP_SYNCNT","TCP_WINDOW_CLAMP","TIOCCBRK","TIOCCONS","TIOCEXCL","TIOCGDEV","TIOCGETD","TIOCGICOUNT","TIOCGLCKTRMIOS","TIOCGPGRP","TIOCGPTN","TIOCGRS485","TIOCGSERIAL","TIOCGSID","TIOCGSOFTCAR","TIOCGWINSZ","TIOCINQ","TIOCLINUX","TIOCMBIC","TIOCMBIS","TIOCMGET","TIOCMIWAIT","TIOCMSET","TIOCM_CAR","TIOCM_CD","TIOCM_CTS","TIOCM_DSR","TIOCM_DTR","TIOCM_LE","TIOCM_RI","TIOCM_RNG","TIOCM_RTS","TIOCM_SR","TIOCM_ST","TIOCNOTTY","TIOCNXCL","TIOCOUTQ","TIOCPKT","TIOCPKT_DATA","TIOCPKT_DOSTOP","TIOCPKT_FLUSHREAD","TIOCPKT_FLUSHWRITE","TIOCPKT_IOCTL","TIOCPKT_NOSTOP","TIOCPKT_START","TIOCPKT_STOP","TIOCSBRK","TIOCSCTTY","TIOCSERCONFIG","TIOCSERGETLSR","TIOCSERGETMULTI","TIOCSERGSTRUCT","TIOCSERGWILD","TIOCSERSETMULTI","TIOCSERSWILD","TIOCSER_TEMT","TIOCSETD","TIOCSIG","TIOCSLCKTRMIOS","TIOCSPGRP","TIOCSPTLCK","TIOCSRS485","TIOCSSERIAL","TIOCSSOFTCAR","TIOCSTI","TIOCSWINSZ","TUNATTACHFILTER","TUNDETACHFILTER","TUNGETFEATURES","TUNGETIFF","TUNGETSNDBUF","TUNGETVNETHDRSZ","TUNSETDEBUG","TUNSETGROUP","TUNSETIFF","TUNSETLINK","TUNSETNOCSUM","TUNSETOFFLOAD","TUNSETOWNER","TUNSETPERSIST","TUNSETSNDBUF","TUNSETTXFILTER","TUNSETVNETHDRSZ","WALL","WCLONE","WCONTINUED","WEXITED","WNOHANG","WNOTHREAD","WNOWAIT","WORDSIZE","WSTOPPED","WUNTRACED","E2BIG","EACCES","EADDRINUSE","EADDRNOTAVAIL","EADV","EAFNOSUPPORT","EAGAIN","EALREADY","EBADE","EBADF","EBADFD","EBADMSG","EBADR","EBADRQC","EBADSLT","EBFONT","EBUSY","ECANCELED","ECHILD","ECHRNG","ECOMM","ECONNABORTED","ECONNREFUSED","ECONNRESET","EDEADLK","EDEADLOCK","EDESTADDRREQ","EDOM","EDOTDOT","EDQUOT","EEXIST","EFAULT","EFBIG","EHOSTDOWN","EHOSTUNREACH","EIDRM","EILSEQ","EINPROGRESS","EINTR","EINVAL","EIO","EISCONN","EISDIR","EISNAM","EKEYEXPIRED","EKEYREJECTED","EKEYREVOKED","EL2HLT","EL2NSYNC","EL3HLT","EL3RST","ELIBACC","ELIBBAD","ELIBEXEC","ELIBMAX","ELIBSCN","ELNRNG","ELOOP","EMEDIUMTYPE","EMFILE","EMLINK","EMSGSIZE","EMULTIHOP","ENAMETOOLONG","ENAVAIL","ENETDOWN","ENETRESET","ENETUNREACH","ENFILE","ENOANO","ENOBUFS","ENOCSI","ENODATA","ENODEV","ENOENT","ENOEXEC","ENOKEY","ENOLCK","ENOLINK","ENOMEDIUM","ENOMEM","ENOMSG","ENONET","ENOPKG","ENOPROTOOPT","ENOSPC","ENOSR","ENOSTR","ENOSYS","ENOTBLK","ENOTCONN","ENOTDIR","ENOTEMPTY","ENOTNAM","ENOTRECOVERABLE","ENOTSOCK","ENOTSUP","ENOTTY","ENOTUNIQ","ENXIO","EOPNOTSUPP","EOVERFLOW","EOWNERDEAD","EPERM","EPFNOSUPPORT","EPIPE","EPROTO","EPROTONOSUPPORT","EPROTOTYPE","ERANGE","EREMCHG","EREMOTE","EREMOTEIO","ERESTART","ERFKILL","EROFS","ESHUTDOWN","ESOCKTNOSUPPORT","ESPIPE","ESRCH","ESRMNT","ESTALE","ESTRPIPE","ETIME","ETIMEDOUT","ETOOMANYREFS","ETXTBSY","EUCLEAN","EUNATCH","EUSERS","EWOULDBLOCK","EXDEV","EXFULL","SIGABRT","SIGALRM","SIGBUS","SIGCHLD","SIGCLD","SIGCONT","SIGFPE","SIGHUP","SIGILL","SIGINT","SIGIO","SIGIOT","SIGKILL","SIGPIPE","SIGPOLL","SIGPROF","SIGPWR","SIGQUIT","SIGSEGV","SIGSTKFLT","SIGSTOP","SIGSYS","SIGTERM","SIGTRAP","SIGTSTP","SIGTTIN","SIGTTOU","SIGUNUSED","SIGURG","SIGUSR1","SIGUSR2","SIGVTALRM","SIGWINCH","SIGXCPU","SIGXFSZ","Getcwd(${1:buf})","Acct(${1:path})","Adjtimex(${1:buf})","Chdir(${1:path})","Chroot(${1:path})","Close(${1:fd})","Dup(${1:oldfd})","Dup3(${1:oldfd}, ${2:newfd}, ${3:flags})","EpollCreate1(${1:flag})","EpollCtl(${1:epfd}, ${2:op}, ${3:fd}, ${4:event})","Fallocate(${1:fd}, ${2:mode}, ${3:off}, ${4:len})","Fchdir(${1:fd})","Fchmod(${1:fd}, ${2:mode})","Fchownat(${1:dirfd}, ${2:path}, ${3:uid}, ${4:gid}, ${5:flags})","Fdatasync(${1:fd})","Flock(${1:fd}, ${2:how})","Fsync(${1:fd})","Getdents(${1:fd}, ${2:buf})","Getpgid(${1:pid})","Getpid()","Getppid()","Getpriority(${1:which}, ${2:who})","Getrusage(${1:who}, ${2:rusage})","Gettid()","Getxattr(${1:path}, ${2:attr}, ${3:dest})","InotifyAddWatch(${1:fd}, ${2:pathname}, ${3:mask})","InotifyInit1(${1:flags})","InotifyRmWatch(${1:fd}, ${2:watchdesc})","Kill(${1:pid}, ${2:sig})","Klogctl(${1:typ}, ${2:buf})","Listxattr(${1:path}, ${2:dest})","Mkdirat(${1:dirfd}, ${2:path}, ${3:mode})","Mknodat(${1:dirfd}, ${2:path}, ${3:mode}, ${4:dev})","Nanosleep(${1:time}, ${2:leftover})","PivotRoot(${1:newroot}, ${2:putold})","Removexattr(${1:path}, ${2:attr})","Setdomainname(${1:p})","Sethostname(${1:p})","Setpgid(${1:pid}, ${2:pgid})","Setsid()","Settimeofday(${1:tv})","Setpriority(${1:which}, ${2:who}, ${3:prio})","Setxattr(${1:path}, ${2:attr}, ${3:data}, ${4:flags})","Sync()","Sysinfo(${1:info})","Tee(${1:rfd}, ${2:wfd}, ${3:len}, ${4:flags})","Tgkill(${1:tgid}, ${2:tid}, ${3:sig})","Times(${1:tms})","Umask(${1:mask})","Uname(${1:buf})","Unmount(${1:target}, ${2:flags})","Unshare(${1:flags})","Madvise(${1:b}, ${2:advice})","Mprotect(${1:b}, ${2:prot})","Mlock(${1:b})","Munlock(${1:b})","Mlockall(${1:flags})","Munlockall()","Dup2(${1:oldfd}, ${2:newfd})","Fchown(${1:fd}, ${2:uid}, ${3:gid})","Fstat(${1:fd}, ${2:stat})","Fstatfs(${1:fd}, ${2:buf})","Ftruncate(${1:fd}, ${2:length})","Getegid()","Geteuid()","Getgid()","Getrlimit(${1:resource}, ${2:rlim})","Getuid()","InotifyInit()","Ioperm(${1:from}, ${2:num}, ${3:on})","Iopl(${1:level})","Listen(${1:s}, ${2:n})","Pause()","Renameat(${1:olddirfd}, ${2:oldpath}, ${3:newdirfd}, ${4:newpath})","Seek(${1:fd}, ${2:offset}, ${3:whence})","Select(${1:nfd}, ${2:r}, ${3:w}, ${4:e}, ${5:timeout})","Setfsgid(${1:gid})","Setfsuid(${1:uid})","Shutdown(${1:fd}, ${2:how})","Splice(${1:rfd}, ${2:roff}, ${3:wfd}, ${4:woff}, ${5:len}, ${6:flags})","Statfs(${1:path}, ${2:buf})","SyncFileRange(${1:fd}, ${2:off}, ${3:n}, ${4:flags})","Truncate(${1:path}, ${2:length})","Ustat(${1:dev}, ${2:ubuf})","EpollWait(${1:epfd}, ${2:events}, ${3:msec})","Utime(${1:path}, ${2:buf})","SYS_READ","SYS_WRITE","SYS_OPEN","SYS_CLOSE","SYS_STAT","SYS_FSTAT","SYS_LSTAT","SYS_POLL","SYS_LSEEK","SYS_MMAP","SYS_MPROTECT","SYS_MUNMAP","SYS_BRK","SYS_RT_SIGACTION","SYS_RT_SIGPROCMASK","SYS_RT_SIGRETURN","SYS_IOCTL","SYS_PREAD64","SYS_PWRITE64","SYS_READV","SYS_WRITEV","SYS_ACCESS","SYS_PIPE","SYS_SELECT","SYS_SCHED_YIELD","SYS_MREMAP","SYS_MSYNC","SYS_MINCORE","SYS_MADVISE","SYS_SHMGET","SYS_SHMAT","SYS_SHMCTL","SYS_DUP","SYS_DUP2","SYS_PAUSE","SYS_NANOSLEEP","SYS_GETITIMER","SYS_ALARM","SYS_SETITIMER","SYS_GETPID","SYS_SENDFILE","SYS_SOCKET","SYS_CONNECT","SYS_ACCEPT","SYS_SENDTO","SYS_RECVFROM","SYS_SENDMSG","SYS_RECVMSG","SYS_SHUTDOWN","SYS_BIND","SYS_LISTEN","SYS_GETSOCKNAME","SYS_GETPEERNAME","SYS_SOCKETPAIR","SYS_SETSOCKOPT","SYS_GETSOCKOPT","SYS_CLONE","SYS_FORK","SYS_VFORK","SYS_EXECVE","SYS_EXIT","SYS_WAIT4","SYS_KILL","SYS_UNAME","SYS_SEMGET","SYS_SEMOP","SYS_SEMCTL","SYS_SHMDT","SYS_MSGGET","SYS_MSGSND","SYS_MSGRCV","SYS_MSGCTL","SYS_FCNTL","SYS_FLOCK","SYS_FSYNC","SYS_FDATASYNC","SYS_TRUNCATE","SYS_FTRUNCATE","SYS_GETDENTS","SYS_GETCWD","SYS_CHDIR","SYS_FCHDIR","SYS_RENAME","SYS_MKDIR","SYS_RMDIR","SYS_CREAT","SYS_LINK","SYS_UNLINK","SYS_SYMLINK","SYS_READLINK","SYS_CHMOD","SYS_FCHMOD","SYS_CHOWN","SYS_FCHOWN","SYS_LCHOWN","SYS_UMASK","SYS_GETTIMEOFDAY","SYS_GETRLIMIT","SYS_GETRUSAGE","SYS_SYSINFO","SYS_TIMES","SYS_PTRACE","SYS_GETUID","SYS_SYSLOG","SYS_GETGID","SYS_SETUID","SYS_SETGID","SYS_GETEUID","SYS_GETEGID","SYS_SETPGID","SYS_GETPPID","SYS_GETPGRP","SYS_SETSID","SYS_SETREUID","SYS_SETREGID","SYS_GETGROUPS","SYS_SETGROUPS","SYS_SETRESUID","SYS_GETRESUID","SYS_SETRESGID","SYS_GETRESGID","SYS_GETPGID","SYS_SETFSUID","SYS_SETFSGID","SYS_GETSID","SYS_CAPGET","SYS_CAPSET","SYS_RT_SIGPENDING","SYS_RT_SIGTIMEDWAIT","SYS_RT_SIGQUEUEINFO","SYS_RT_SIGSUSPEND","SYS_SIGALTSTACK","SYS_UTIME","SYS_MKNOD","SYS_USELIB","SYS_PERSONALITY","SYS_USTAT","SYS_STATFS","SYS_FSTATFS","SYS_SYSFS","SYS_GETPRIORITY","SYS_SETPRIORITY","SYS_SCHED_SETPARAM","SYS_SCHED_GETPARAM","SYS_SCHED_SETSCHEDULER","SYS_SCHED_GETSCHEDULER","SYS_SCHED_GET_PRIORITY_MAX","SYS_SCHED_GET_PRIORITY_MIN","SYS_SCHED_RR_GET_INTERVAL","SYS_MLOCK","SYS_MUNLOCK","SYS_MLOCKALL","SYS_MUNLOCKALL","SYS_VHANGUP","SYS_MODIFY_LDT","SYS_PIVOT_ROOT","SYS__SYSCTL","SYS_PRCTL","SYS_ARCH_PRCTL","SYS_ADJTIMEX","SYS_SETRLIMIT","SYS_CHROOT","SYS_SYNC","SYS_ACCT","SYS_SETTIMEOFDAY","SYS_MOUNT","SYS_UMOUNT2","SYS_SWAPON","SYS_SWAPOFF","SYS_REBOOT","SYS_SETHOSTNAME","SYS_SETDOMAINNAME","SYS_IOPL","SYS_IOPERM","SYS_CREATE_MODULE","SYS_INIT_MODULE","SYS_DELETE_MODULE","SYS_GET_KERNEL_SYMS","SYS_QUERY_MODULE","SYS_QUOTACTL","SYS_NFSSERVCTL","SYS_GETPMSG","SYS_PUTPMSG","SYS_AFS_SYSCALL","SYS_TUXCALL","SYS_SECURITY","SYS_GETTID","SYS_READAHEAD","SYS_SETXATTR","SYS_LSETXATTR","SYS_FSETXATTR","SYS_GETXATTR","SYS_LGETXATTR","SYS_FGETXATTR","SYS_LISTXATTR","SYS_LLISTXATTR","SYS_FLISTXATTR","SYS_REMOVEXATTR","SYS_LREMOVEXATTR","SYS_FREMOVEXATTR","SYS_TKILL","SYS_TIME","SYS_FUTEX","SYS_SCHED_SETAFFINITY","SYS_SCHED_GETAFFINITY","SYS_SET_THREAD_AREA","SYS_IO_SETUP","SYS_IO_DESTROY","SYS_IO_GETEVENTS","SYS_IO_SUBMIT","SYS_IO_CANCEL","SYS_GET_THREAD_AREA","SYS_LOOKUP_DCOOKIE","SYS_EPOLL_CREATE","SYS_EPOLL_CTL_OLD","SYS_EPOLL_WAIT_OLD","SYS_REMAP_FILE_PAGES","SYS_GETDENTS64","SYS_SET_TID_ADDRESS","SYS_RESTART_SYSCALL","SYS_SEMTIMEDOP","SYS_FADVISE64","SYS_TIMER_CREATE","SYS_TIMER_SETTIME","SYS_TIMER_GETTIME","SYS_TIMER_GETOVERRUN","SYS_TIMER_DELETE","SYS_CLOCK_SETTIME","SYS_CLOCK_GETTIME","SYS_CLOCK_GETRES","SYS_CLOCK_NANOSLEEP","SYS_EXIT_GROUP","SYS_EPOLL_WAIT","SYS_EPOLL_CTL","SYS_TGKILL","SYS_UTIMES","SYS_VSERVER","SYS_MBIND","SYS_SET_MEMPOLICY","SYS_GET_MEMPOLICY","SYS_MQ_OPEN","SYS_MQ_UNLINK","SYS_MQ_TIMEDSEND","SYS_MQ_TIMEDRECEIVE","SYS_MQ_NOTIFY","SYS_MQ_GETSETATTR","SYS_KEXEC_LOAD","SYS_WAITID","SYS_ADD_KEY","SYS_REQUEST_KEY","SYS_KEYCTL","SYS_IOPRIO_SET","SYS_IOPRIO_GET","SYS_INOTIFY_INIT","SYS_INOTIFY_ADD_WATCH","SYS_INOTIFY_RM_WATCH","SYS_MIGRATE_PAGES","SYS_OPENAT","SYS_MKDIRAT","SYS_MKNODAT","SYS_FCHOWNAT","SYS_FUTIMESAT","SYS_NEWFSTATAT","SYS_UNLINKAT","SYS_RENAMEAT","SYS_LINKAT","SYS_SYMLINKAT","SYS_READLINKAT","SYS_FCHMODAT","SYS_FACCESSAT","SYS_PSELECT6","SYS_PPOLL","SYS_UNSHARE","SYS_SET_ROBUST_LIST","SYS_GET_ROBUST_LIST","SYS_SPLICE","SYS_TEE","SYS_SYNC_FILE_RANGE","SYS_VMSPLICE","SYS_MOVE_PAGES","SYS_UTIMENSAT","SYS_EPOLL_PWAIT","SYS_SIGNALFD","SYS_TIMERFD_CREATE","SYS_EVENTFD","SYS_FALLOCATE","SYS_TIMERFD_SETTIME","SYS_TIMERFD_GETTIME","SYS_ACCEPT4","SYS_SIGNALFD4","SYS_EVENTFD2","SYS_EPOLL_CREATE1","SYS_DUP3","SYS_PIPE2","SYS_INOTIFY_INIT1","SYS_PREADV","SYS_PWRITEV","SYS_RT_TGSIGQUEUEINFO","SYS_PERF_EVENT_OPEN","SYS_RECVMMSG","SYS_FANOTIFY_INIT","SYS_FANOTIFY_MARK","SYS_PRLIMIT64","PathMax","Timespec{}","Timeval{}","Timex{}","Time_t","Tms{}","Utimbuf{}","Rusage{}","Rlimit{}","Stat_t{}","Statfs_t{}","Dirent{}","Fsid{}","Flock_t{}","RawSockaddrInet4{}","RawSockaddrInet6{}","RawSockaddrUnix{}","RawSockaddrLinklayer{}","RawSockaddrNetlink{}","RawSockaddr{}","RawSockaddrAny{}","Linger{}","Iovec{}","IPMreq{}","IPMreqn{}","IPv6Mreq{}","Msghdr{}","Cmsghdr{}","Inet4Pktinfo{}","Inet6Pktinfo{}","IPv6MTUInfo{}","ICMPv6Filter{}","Ucred{}","TCPInfo{}","SizeofSockaddrInet4","SizeofSockaddrInet6","SizeofSockaddrAny","SizeofSockaddrUnix","SizeofSockaddrLinklayer","SizeofSockaddrNetlink","SizeofLinger","SizeofIPMreq","SizeofIPMreqn","SizeofIPv6Mreq","SizeofMsghdr","SizeofCmsghdr","SizeofInet4Pktinfo","SizeofInet6Pktinfo","SizeofIPv6MTUInfo","SizeofICMPv6Filter","SizeofUcred","SizeofTCPInfo","IFA_UNSPEC","IFA_ADDRESS","IFA_LOCAL","IFA_LABEL","IFA_BROADCAST","IFA_ANYCAST","IFA_CACHEINFO","IFA_MULTICAST","IFLA_UNSPEC","IFLA_ADDRESS","IFLA_BROADCAST","IFLA_IFNAME","IFLA_MTU","IFLA_LINK","IFLA_QDISC","IFLA_STATS","IFLA_COST","IFLA_PRIORITY","IFLA_MASTER","IFLA_WIRELESS","IFLA_PROTINFO","IFLA_TXQLEN","IFLA_MAP","IFLA_WEIGHT","IFLA_OPERSTATE","IFLA_LINKMODE","IFLA_LINKINFO","IFLA_NET_NS_PID","IFLA_IFALIAS","IFLA_MAX","RT_SCOPE_UNIVERSE","RT_SCOPE_SITE","RT_SCOPE_LINK","RT_SCOPE_HOST","RT_SCOPE_NOWHERE","RT_TABLE_UNSPEC","RT_TABLE_COMPAT","RT_TABLE_DEFAULT","RT_TABLE_MAIN","RT_TABLE_LOCAL","RT_TABLE_MAX","RTA_UNSPEC","RTA_DST","RTA_SRC","RTA_IIF","RTA_OIF","RTA_GATEWAY","RTA_PRIORITY","RTA_PREFSRC","RTA_METRICS","RTA_MULTIPATH","RTA_FLOW","RTA_CACHEINFO","RTA_TABLE","RTN_UNSPEC","RTN_UNICAST","RTN_LOCAL","RTN_BROADCAST","RTN_ANYCAST","RTN_MULTICAST","RTN_BLACKHOLE","RTN_UNREACHABLE","RTN_PROHIBIT","RTN_THROW","RTN_NAT","RTN_XRESOLVE","RTNLGRP_NONE","RTNLGRP_LINK","RTNLGRP_NOTIFY","RTNLGRP_NEIGH","RTNLGRP_TC","RTNLGRP_IPV4_IFADDR","RTNLGRP_IPV4_MROUTE","RTNLGRP_IPV4_ROUTE","RTNLGRP_IPV4_RULE","RTNLGRP_IPV6_IFADDR","RTNLGRP_IPV6_MROUTE","RTNLGRP_IPV6_ROUTE","RTNLGRP_IPV6_IFINFO","RTNLGRP_IPV6_PREFIX","RTNLGRP_IPV6_RULE","RTNLGRP_ND_USEROPT","SizeofNlMsghdr","SizeofNlMsgerr","SizeofRtGenmsg","SizeofNlAttr","SizeofRtAttr","SizeofIfInfomsg","SizeofIfAddrmsg","SizeofRtMsg","SizeofRtNexthop","NlMsghdr{}","NlMsgerr{}","RtGenmsg{}","NlAttr{}","RtAttr{}","IfInfomsg{}","IfAddrmsg{}","RtMsg{}","RtNexthop{}","SizeofSockFilter","SizeofSockFprog","SockFilter{}","SockFprog{}","InotifyEvent{}","SizeofInotifyEvent","PtraceRegs{}","FdSet{}","Sysinfo_t{}","Utsname{}","Ustat_t{}","EpollEvent{}","Termios{}","VINTR","VQUIT","VERASE","VKILL","VEOF","VTIME","VMIN","VSWTC","VSTART","VSTOP","VSUSP","VEOL","VREPRINT","VDISCARD","VWERASE","VLNEXT","VEOL2","IGNBRK","BRKINT","IGNPAR","PARMRK","INPCK","ISTRIP","INLCR","IGNCR","ICRNL","IUCLC","IXON","IXANY","IXOFF","IMAXBEL","IUTF8","OPOST","OLCUC","ONLCR","OCRNL","ONOCR","ONLRET","OFILL","OFDEL","B0","B50","B75","B110","B134","B150","B200","B300","B600","B1200","B1800","B2400","B4800","B9600","B19200","B38400","CSIZE","CS5","CS6","CS7","CS8","CSTOPB","CREAD","PARENB","PARODD","HUPCL","CLOCAL","B57600","B115200","B230400","B460800","B500000","B576000","B921600","B1000000","B1152000","B1500000","B2000000","B2500000","B3000000","B3500000","B4000000","ISIG","ICANON","XCASE","ECHO","ECHOE","ECHOK","ECHONL","NOFLSH","TOSTOP","ECHOCTL","ECHOPRT","ECHOKE","FLUSHO","PENDIN","IEXTEN","TCGETS","TCSETS","AllocsPerRun(${1:runs}, ${2:f})","InternalBenchmark{}","B{}","BenchmarkResult{}","RunBenchmarks(${1:matchString}, ${2:benchmarks})","PB{}","Benchmark(${1:f})","CoverBlock{}","Cover{}","Coverage()","RegisterCover(${1:c})","InternalExample{}","RunExamples(${1:matchString}, ${2:examples})","InternalFuzzTarget{}","F{}","Init()","Short()","Testing()","CoverMode()","Verbose()","TB","T{}","InternalTest{}","Main(${1:matchString}, ${2:tests}, ${3:benchmarks}, ${4:examples})","M{}","MainStart(${1:deps}, ${2:tests}, ${3:benchmarks}, ${4:fuzzTargets}, ${5:examples})","RunTests(${1:matchString}, ${2:tests})","Layout","ANSIC","UnixDate","RubyDate","RFC822","RFC822Z","RFC850","RFC1123","RFC1123Z","RFC3339","RFC3339Nano","Kitchen","Stamp","StampMilli","StampMicro","StampNano","DateTime","DateOnly","TimeOnly","ParseError{}","Parse(${1:layout}, ${2:value})","ParseInLocation(${1:layout}, ${2:value}, ${3:loc})","ParseDuration(${1:s})","Sleep(${1:d})","Timer{}","NewTimer(${1:d})","After(${1:d})","AfterFunc(${1:d}, ${2:f})","Ticker{}","NewTicker(${1:d})","Tick(${1:d})","Time{}","Month","January","February","March","April","May","June","July","August","September","October","November","December","Weekday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Duration","Nanosecond","Microsecond","Millisecond","Second","Minute","Hour","Since(${1:t})","Until(${1:t})","Now()","Unix(${1:sec}, ${2:nsec})","UnixMilli(${1:msec})","UnixMicro(${1:usec})","Date(${1:year}, ${2:month}, ${3:day}, ${4:hour}, ${5:min}, ${6:sec}, ${7:nsec}, ${8:loc})","Location{}","UTC","Local","FixedZone(${1:name}, ${2:offset})","LoadLocation(${1:name})","LoadLocationFromTZData(${1:name}, ${2:data})","TurkishCase","AzeriCase","IsDigit(${1:r})","GraphicRanges","PrintRanges","IsGraphic(${1:r})","IsPrint(${1:r})","IsOneOf(${1:ranges}, ${2:r})","In(${1:r}, ${2:ranges})","IsControl(${1:r})","IsLetter(${1:r})","IsMark(${1:r})","IsNumber(${1:r})","IsPunct(${1:r})","IsSpace(${1:r})","IsSymbol(${1:r})","MaxRune","ReplacementChar","MaxASCII","MaxLatin1","RangeTable{}","Range16{}","Range32{}","CaseRange{}","SpecialCase","UpperCase","LowerCase","TitleCase","MaxCase","UpperLower","Is(${1:rangeTab}, ${2:r})","IsUpper(${1:r})","IsLower(${1:r})","IsTitle(${1:r})","To(${1:_case}, ${2:r})","ToUpper(${1:r})","ToLower(${1:r})","ToTitle(${1:r})","SimpleFold(${1:r})","Version","Categories","Cc","Cf","Co","Cs","Digit","Nd","Letter","L","Lm","Lo","Lower","Ll","Mark","M","Mc","Me","Mn","Nl","No","Number","N","Other","C","Pc","Pd","Pe","Pf","Pi","Po","Ps","Punct","P","Sc","Sk","Sm","So","Space","Z","Symbol","S","Title","Lt","Upper","Lu","Zl","Zp","Zs","Scripts","Adlam","Ahom","Anatolian_Hieroglyphs","Arabic","Armenian","Avestan","Balinese","Bamum","Bassa_Vah","Batak","Bengali","Bhaiksuki","Bopomofo","Brahmi","Braille","Buginese","Buhid","Canadian_Aboriginal","Carian","Caucasian_Albanian","Chakma","Cham","Cherokee","Chorasmian","Common","Coptic","Cuneiform","Cypriot","Cypro_Minoan","Cyrillic","Deseret","Devanagari","Dives_Akuru","Dogra","Duployan","Egyptian_Hieroglyphs","Elbasan","Elymaic","Ethiopic","Georgian","Glagolitic","Gothic","Grantha","Greek","Gujarati","Gunjala_Gondi","Gurmukhi","Han","Hangul","Hanifi_Rohingya","Hanunoo","Hatran","Hebrew","Hiragana","Imperial_Aramaic","Inherited","Inscriptional_Pahlavi","Inscriptional_Parthian","Javanese","Kaithi","Kannada","Katakana","Kawi","Kayah_Li","Kharoshthi","Khitan_Small_Script","Khmer","Khojki","Khudawadi","Lao","Latin","Lepcha","Limbu","Linear_A","Linear_B","Lisu","Lycian","Lydian","Mahajani","Makasar","Malayalam","Mandaic","Manichaean","Marchen","Masaram_Gondi","Medefaidrin","Meetei_Mayek","Mende_Kikakui","Meroitic_Cursive","Meroitic_Hieroglyphs","Miao","Modi","Mongolian","Mro","Multani","Myanmar","Nabataean","Nag_Mundari","Nandinagari","New_Tai_Lue","Newa","Nko","Nushu","Nyiakeng_Puachue_Hmong","Ogham","Ol_Chiki","Old_Hungarian","Old_Italic","Old_North_Arabian","Old_Permic","Old_Persian","Old_Sogdian","Old_South_Arabian","Old_Turkic","Old_Uyghur","Oriya","Osage","Osmanya","Pahawh_Hmong","Palmyrene","Pau_Cin_Hau","Phags_Pa","Phoenician","Psalter_Pahlavi","Rejang","Runic","Samaritan","Saurashtra","Sharada","Shavian","Siddham","SignWriting","Sinhala","Sogdian","Sora_Sompeng","Soyombo","Sundanese","Syloti_Nagri","Syriac","Tagalog","Tagbanwa","Tai_Le","Tai_Tham","Tai_Viet","Takri","Tamil","Tangsa","Tangut","Telugu","Thaana","Thai","Tibetan","Tifinagh","Tirhuta","Toto","Ugaritic","Vai","Vithkuqi","Wancho","Warang_Citi","Yezidi","Yi","Zanabazar_Square","Properties","ASCII_Hex_Digit","Bidi_Control","Dash","Deprecated","Diacritic","Extender","Hex_Digit","Hyphen","IDS_Binary_Operator","IDS_Trinary_Operator","Ideographic","Join_Control","Logical_Order_Exception","Noncharacter_Code_Point","Other_Alphabetic","Other_Default_Ignorable_Code_Point","Other_Grapheme_Extend","Other_ID_Continue","Other_ID_Start","Other_Lowercase","Other_Math","Other_Uppercase","Pattern_Syntax","Pattern_White_Space","Prepended_Concatenation_Mark","Quotation_Mark","Radical","Regional_Indicator","STerm","Sentence_Terminal","Soft_Dotted","Terminal_Punctuation","Unified_Ideograph","Variation_Selector","White_Space","CaseRanges","FoldCategory","FoldScript","Handle{}","Make[${1:T}](${2:value})","ArbitraryType","IntegerType","Pointer","Sizeof(${1:x})","Offsetof(${1:x})","Alignof(${1:x})","Add(${1:ptr}, ${2:len})","Slice(${1:ptr}, ${2:len})","SliceData(${1:slice})","String(${1:ptr}, ${2:len})","StringData(${1:str})","ErrHeader","ErrWriteTooLong","ErrFieldTooLong","ErrWriteAfterClose","ErrInsecurePath","TypeReg","TypeRegA","TypeLink","TypeSymlink","TypeChar","TypeBlock","TypeDir","TypeFifo","TypeCont","TypeXHeader","TypeXGlobalHeader","TypeGNUSparse","TypeGNULongName","TypeGNULongLink","Header{}","FileInfoHeader(${1:fi}, ${2:link})","FileInfoNames","Format","FormatUnknown","FormatUSTAR","FormatPAX","FormatGNU","Reader{}","NewReader(${1:r})","Writer{}","NewWriter(${1:w})","ErrFormat","ErrAlgorithm","ErrChecksum","ErrInsecurePath","Reader{}","ReadCloser{}","File{}","OpenReader(${1:name})","NewReader(${1:r}, ${2:size})","Compressor","Decompressor","RegisterDecompressor(${1:method}, ${2:dcomp})","RegisterCompressor(${1:method}, ${2:comp})","Store","Deflate","FileHeader{}","FileInfoHeader(${1:fi})","Writer{}","NewWriter(${1:w})","StructuralError","NewReader(${1:r})","NoCompression","BestSpeed","BestCompression","DefaultCompression","HuffmanOnly","NewWriter(${1:w}, ${2:level})","NewWriterDict(${1:w}, ${2:level}, ${3:dict})","Writer{}","CorruptInputError","InternalError","ReadError{}","WriteError{}","Resetter","Reader","NewReader(${1:r})","NewReaderDict(${1:r}, ${2:dict})","ErrChecksum","ErrHeader","Header{}","Reader{}","NewReader(${1:r})","NoCompression","BestSpeed","BestCompression","DefaultCompression","HuffmanOnly","Writer{}","NewWriter(${1:w})","NewWriterLevel(${1:w}, ${2:level})","Order","LSB","MSB","Reader{}","NewReader(${1:r}, ${2:order}, ${3:litWidth})","Writer{}","NewWriter(${1:w}, ${2:order}, ${3:litWidth})","ErrChecksum","ErrDictionary","ErrHeader","Resetter","NewReader(${1:r})","NewReaderDict(${1:r}, ${2:dict})","NoCompression","BestSpeed","BestCompression","DefaultCompression","HuffmanOnly","Writer{}","NewWriter(${1:w})","NewWriterLevel(${1:w}, ${2:level})","NewWriterLevelDict(${1:w}, ${2:level}, ${3:dict})","Interface","Init(${1:h})","Push(${1:h}, ${2:x})","Pop(${1:h})","Remove(${1:h}, ${2:i})","Fix(${1:h}, ${2:i})","Element{}","List{}","New()","Ring{}","New(${1:n})","BlockSize","KeySizeError","NewCipher(${1:key})","NewCBCEncrypter(${1:b}, ${2:iv})","NewCBCDecrypter(${1:b}, ${2:iv})","NewCFBEncrypter(${1:block}, ${2:iv})","NewCFBDecrypter(${1:block}, ${2:iv})","Block","Stream","BlockMode","NewCTR(${1:block}, ${2:iv})","AEAD","NewGCM(${1:cipher})","NewGCMWithNonceSize(${1:cipher}, ${2:size})","NewGCMWithTagSize(${1:cipher}, ${2:tagSize})","StreamReader{}","StreamWriter{}","NewOFB(${1:b}, ${2:iv})","BlockSize","KeySizeError","NewCipher(${1:key})","NewTripleDESCipher(${1:key})","Parameters{}","PublicKey{}","PrivateKey{}","ErrInvalidPublicKey","ParameterSizes","L1024N160","L2048N224","L2048N256","L3072N256","GenerateParameters(${1:params}, ${2:rand}, ${3:sizes})","GenerateKey(${1:priv}, ${2:rand})","Sign(${1:rand}, ${2:priv}, ${3:hash})","Verify(${1:pub}, ${2:hash}, ${3:r}, ${4:s})","Curve","PublicKey{}","PrivateKey{}","P256()","P384()","P521()","X25519()","PublicKey{}","PrivateKey{}","GenerateKey(${1:c}, ${2:rand})","SignASN1(${1:rand}, ${2:priv}, ${3:hash})","VerifyASN1(${1:pub}, ${2:hash}, ${3:sig})","Sign(${1:rand}, ${2:priv}, ${3:hash})","Verify(${1:pub}, ${2:hash}, ${3:r}, ${4:s})","PublicKeySize","PrivateKeySize","SignatureSize","SeedSize","PublicKey","PrivateKey","Options{}","GenerateKey(${1:rand})","NewKeyFromSeed(${1:seed})","Sign(${1:privateKey}, ${2:message})","Verify(${1:publicKey}, ${2:message}, ${3:sig})","VerifyWithOptions(${1:publicKey}, ${2:message}, ${3:sig}, ${4:opts})","Curve","GenerateKey(${1:curve}, ${2:rand})","Marshal(${1:curve}, ${2:x}, ${3:y})","MarshalCompressed(${1:curve}, ${2:x}, ${3:y})","Unmarshal(${1:curve}, ${2:data})","UnmarshalCompressed(${1:curve}, ${2:data})","P224()","P256()","P384()","P521()","CurveParams{}","New(${1:h}, ${2:key})","Equal(${1:mac1}, ${2:mac2})","Size","BlockSize","New()","Sum(${1:data})","Reader","Read(${1:b})","Prime(${1:rand}, ${2:bits})","Int(${1:rand}, ${2:max})","Cipher{}","KeySizeError","NewCipher(${1:key})","PKCS1v15DecryptOptions{}","EncryptPKCS1v15(${1:random}, ${2:pub}, ${3:msg})","DecryptPKCS1v15(${1:random}, ${2:priv}, ${3:ciphertext})","DecryptPKCS1v15SessionKey(${1:random}, ${2:priv}, ${3:ciphertext}, ${4:key})","SignPKCS1v15(${1:random}, ${2:priv}, ${3:hash}, ${4:hashed})","VerifyPKCS1v15(${1:pub}, ${2:hash}, ${3:hashed}, ${4:sig})","PSSSaltLengthAuto","PSSSaltLengthEqualsHash","PSSOptions{}","SignPSS(${1:rand}, ${2:priv}, ${3:hash}, ${4:digest}, ${5:opts})","VerifyPSS(${1:pub}, ${2:hash}, ${3:digest}, ${4:sig}, ${5:opts})","PublicKey{}","OAEPOptions{}","PrivateKey{}","PrecomputedValues{}","CRTValue{}","GenerateKey(${1:random}, ${2:bits})","GenerateMultiPrimeKey(${1:random}, ${2:nprimes}, ${3:bits})","ErrMessageTooLong","EncryptOAEP(${1:hash}, ${2:random}, ${3:pub}, ${4:msg}, ${5:label})","ErrDecryption","ErrVerification","DecryptOAEP(${1:hash}, ${2:random}, ${3:priv}, ${4:ciphertext}, ${5:label})","Size","BlockSize","New()","Sum(${1:data})","Size","Size224","BlockSize","New()","New224()","Sum256(${1:data})","Sum224(${1:data})","Size","Size224","Size256","Size384","BlockSize","New()","New512_224()","New512_256()","New384()","Sum512(${1:data})","Sum384(${1:data})","Sum512_224(${1:data})","Sum512_256(${1:data})","ConstantTimeCompare(${1:x}, ${2:y})","ConstantTimeSelect(${1:v}, ${2:x}, ${3:y})","ConstantTimeByteEq(${1:x}, ${2:y})","ConstantTimeEq(${1:x}, ${2:y})","ConstantTimeCopy(${1:v}, ${2:x}, ${3:y})","ConstantTimeLessOrEq(${1:x}, ${2:y})","XORBytes(${1:dst}, ${2:x}, ${3:y})","AlertError","CipherSuite{}","CipherSuites()","InsecureCipherSuites()","CipherSuiteName(${1:id})","TLS_RSA_WITH_RC4_128_SHA","TLS_RSA_WITH_3DES_EDE_CBC_SHA","TLS_RSA_WITH_AES_128_CBC_SHA","TLS_RSA_WITH_AES_256_CBC_SHA","TLS_RSA_WITH_AES_128_CBC_SHA256","TLS_RSA_WITH_AES_128_GCM_SHA256","TLS_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_RC4_128_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_RSA_WITH_RC4_128_SHA","TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256","TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256","TLS_AES_128_GCM_SHA256","TLS_AES_256_GCM_SHA384","TLS_CHACHA20_POLY1305_SHA256","TLS_FALLBACK_SCSV","TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305","TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305","VersionTLS10","VersionTLS11","VersionTLS12","VersionTLS13","VersionSSL30","VersionName(${1:version})","CurveID","CurveP256","CurveP384","CurveP521","X25519","ConnectionState{}","ClientAuthType","NoClientCert","RequestClientCert","RequireAnyClientCert","VerifyClientCertIfGiven","RequireAndVerifyClientCert","ClientSessionCache","SignatureScheme","PKCS1WithSHA256","PKCS1WithSHA384","PKCS1WithSHA512","PSSWithSHA256","PSSWithSHA384","PSSWithSHA512","ECDSAWithP256AndSHA256","ECDSAWithP384AndSHA384","ECDSAWithP521AndSHA512","Ed25519","PKCS1WithSHA1","ECDSAWithSHA1","ClientHelloInfo{}","CertificateRequestInfo{}","RenegotiationSupport","RenegotiateNever","RenegotiateOnceAsClient","RenegotiateFreelyAsClient","Config{}","Certificate{}","NewLRUClientSessionCache(${1:capacity})","CertificateVerificationError{}","Conn{}","RecordHeaderError{}","ECHRejectionError{}","QUICEncryptionLevel","QUICEncryptionLevelInitial","QUICEncryptionLevelEarly","QUICEncryptionLevelHandshake","QUICEncryptionLevelApplication","QUICConn{}","QUICConfig{}","QUICEventKind","QUICNoEvent","QUICSetReadSecret","QUICSetWriteSecret","QUICWriteData","QUICTransportParameters","QUICTransportParametersRequired","QUICRejectedEarlyData","QUICHandshakeDone","QUICResumeSession","QUICStoreSession","QUICEvent{}","QUICClient(${1:config})","QUICServer(${1:config})","QUICSessionTicketOptions{}","SessionState{}","ParseSessionState(${1:data})","ClientSessionState{}","NewResumptionState(${1:ticket}, ${2:state})","Server(${1:conn}, ${2:config})","Client(${1:conn}, ${2:config})","NewListener(${1:inner}, ${2:config})","Listen(${1:network}, ${2:laddr}, ${3:config})","DialWithDialer(${1:dialer}, ${2:network}, ${3:addr}, ${4:config})","Dial(${1:network}, ${2:addr}, ${3:config})","Dialer{}","LoadX509KeyPair(${1:certFile}, ${2:keyFile})","X509KeyPair(${1:certPEMBlock}, ${2:keyPEMBlock})","CertPool{}","NewCertPool()","SystemCertPool()","OID{}","ParseOID(${1:oid})","OIDFromInts(${1:oid})","ParseCertificate(${1:der})","ParseCertificates(${1:der})","ParseRevocationList(${1:der})","PEMCipher","PEMCipherDES","PEMCipher3DES","PEMCipherAES128","PEMCipherAES192","PEMCipherAES256","IsEncryptedPEMBlock(${1:b})","IncorrectPasswordError","DecryptPEMBlock(${1:b}, ${2:password})","EncryptPEMBlock(${1:rand}, ${2:blockType}, ${3:data}, ${4:password}, ${5:alg})","ParsePKCS1PrivateKey(${1:der})","MarshalPKCS1PrivateKey(${1:key})","ParsePKCS1PublicKey(${1:der})","MarshalPKCS1PublicKey(${1:key})","ParsePKCS8PrivateKey(${1:der})","MarshalPKCS8PrivateKey(${1:key})","SetFallbackRoots(${1:roots})","ParseECPrivateKey(${1:der})","MarshalECPrivateKey(${1:key})","InvalidReason","NotAuthorizedToSign","Expired","CANotAuthorizedForThisName","TooManyIntermediates","IncompatibleUsage","NameMismatch","NameConstraintsWithoutSANs","UnconstrainedName","TooManyConstraints","CANotAuthorizedForExtKeyUsage","CertificateInvalidError{}","HostnameError{}","UnknownAuthorityError{}","SystemRootsError{}","VerifyOptions{}","ParsePKIXPublicKey(${1:derBytes})","MarshalPKIXPublicKey(${1:pub})","SignatureAlgorithm","UnknownSignatureAlgorithm","MD2WithRSA","MD5WithRSA","SHA1WithRSA","SHA256WithRSA","SHA384WithRSA","SHA512WithRSA","DSAWithSHA1","DSAWithSHA256","ECDSAWithSHA1","ECDSAWithSHA256","ECDSAWithSHA384","ECDSAWithSHA512","SHA256WithRSAPSS","SHA384WithRSAPSS","SHA512WithRSAPSS","PureEd25519","PublicKeyAlgorithm","UnknownPublicKeyAlgorithm","RSA","DSA","ECDSA","Ed25519","KeyUsage","KeyUsageDigitalSignature","KeyUsageContentCommitment","KeyUsageKeyEncipherment","KeyUsageDataEncipherment","KeyUsageKeyAgreement","KeyUsageCertSign","KeyUsageCRLSign","KeyUsageEncipherOnly","KeyUsageDecipherOnly","ExtKeyUsage","ExtKeyUsageAny","ExtKeyUsageServerAuth","ExtKeyUsageClientAuth","ExtKeyUsageCodeSigning","ExtKeyUsageEmailProtection","ExtKeyUsageIPSECEndSystem","ExtKeyUsageIPSECTunnel","ExtKeyUsageIPSECUser","ExtKeyUsageTimeStamping","ExtKeyUsageOCSPSigning","ExtKeyUsageMicrosoftServerGatedCrypto","ExtKeyUsageNetscapeServerGatedCrypto","ExtKeyUsageMicrosoftCommercialCodeSigning","ExtKeyUsageMicrosoftKernelCodeSigning","Certificate{}","ErrUnsupportedAlgorithm","InsecureAlgorithmError","ConstraintViolationError{}","UnhandledCriticalExtension{}","CreateCertificate(${1:rand}, ${2:template}, ${3:parent}, ${4:pub}, ${5:priv})","ParseCRL(${1:crlBytes})","ParseDERCRL(${1:derBytes})","CertificateRequest{}","CreateCertificateRequest(${1:rand}, ${2:template}, ${3:priv})","ParseCertificateRequest(${1:asn1Data})","RevocationListEntry{}","RevocationList{}","CreateRevocationList(${1:rand}, ${2:template}, ${3:issuer}, ${4:priv})","Register(${1:name}, ${2:driver})","Drivers()","NamedArg{}","Named(${1:name}, ${2:value})","IsolationLevel","LevelDefault","LevelReadUncommitted","LevelReadCommitted","LevelWriteCommitted","LevelRepeatableRead","LevelSnapshot","LevelSerializable","LevelLinearizable","TxOptions{}","RawBytes","NullString{}","NullInt64{}","NullInt32{}","NullInt16{}","NullByte{}","NullFloat64{}","NullBool{}","NullTime{}","Null{}","Scanner","Out{}","ErrNoRows","DB{}","OpenDB(${1:c})","Open(${1:driverName}, ${2:dataSourceName})","DBStats{}","ErrConnDone","Conn{}","Tx{}","ErrTxDone","Stmt{}","Rows{}","ColumnType{}","Row{}","Result","BuildInfo","ReadFile(${1:name})","Read(${1:r})","DecodeError{}","Attr","AttrSibling","AttrLocation","AttrName","AttrOrdering","AttrByteSize","AttrBitOffset","AttrBitSize","AttrStmtList","AttrLowpc","AttrHighpc","AttrLanguage","AttrDiscr","AttrDiscrValue","AttrVisibility","AttrImport","AttrStringLength","AttrCommonRef","AttrCompDir","AttrConstValue","AttrContainingType","AttrDefaultValue","AttrInline","AttrIsOptional","AttrLowerBound","AttrProducer","AttrPrototyped","AttrReturnAddr","AttrStartScope","AttrStrideSize","AttrUpperBound","AttrAbstractOrigin","AttrAccessibility","AttrAddrClass","AttrArtificial","AttrBaseTypes","AttrCalling","AttrCount","AttrDataMemberLoc","AttrDeclColumn","AttrDeclFile","AttrDeclLine","AttrDeclaration","AttrDiscrList","AttrEncoding","AttrExternal","AttrFrameBase","AttrFriend","AttrIdentifierCase","AttrMacroInfo","AttrNamelistItem","AttrPriority","AttrSegment","AttrSpecification","AttrStaticLink","AttrType","AttrUseLocation","AttrVarParam","AttrVirtuality","AttrVtableElemLoc","AttrAllocated","AttrAssociated","AttrDataLocation","AttrStride","AttrEntrypc","AttrUseUTF8","AttrExtension","AttrRanges","AttrTrampoline","AttrCallColumn","AttrCallFile","AttrCallLine","AttrDescription","AttrBinaryScale","AttrDecimalScale","AttrSmall","AttrDecimalSign","AttrDigitCount","AttrPictureString","AttrMutable","AttrThreadsScaled","AttrExplicit","AttrObjectPointer","AttrEndianity","AttrElemental","AttrPure","AttrRecursive","AttrSignature","AttrMainSubprogram","AttrDataBitOffset","AttrConstExpr","AttrEnumClass","AttrLinkageName","AttrStringLengthBitSize","AttrStringLengthByteSize","AttrRank","AttrStrOffsetsBase","AttrAddrBase","AttrRnglistsBase","AttrDwoName","AttrReference","AttrRvalueReference","AttrMacros","AttrCallAllCalls","AttrCallAllSourceCalls","AttrCallAllTailCalls","AttrCallReturnPC","AttrCallValue","AttrCallOrigin","AttrCallParameter","AttrCallPC","AttrCallTailCall","AttrCallTarget","AttrCallTargetClobbered","AttrCallDataLocation","AttrCallDataValue","AttrNoreturn","AttrAlignment","AttrExportSymbols","AttrDeleted","AttrDefaulted","AttrLoclistsBase","Tag","TagArrayType","TagClassType","TagEntryPoint","TagEnumerationType","TagFormalParameter","TagImportedDeclaration","TagLabel","TagLexDwarfBlock","TagMember","TagPointerType","TagReferenceType","TagCompileUnit","TagStringType","TagStructType","TagSubroutineType","TagTypedef","TagUnionType","TagUnspecifiedParameters","TagVariant","TagCommonDwarfBlock","TagCommonInclusion","TagInheritance","TagInlinedSubroutine","TagModule","TagPtrToMemberType","TagSetType","TagSubrangeType","TagWithStmt","TagAccessDeclaration","TagBaseType","TagCatchDwarfBlock","TagConstType","TagConstant","TagEnumerator","TagFileType","TagFriend","TagNamelist","TagNamelistItem","TagPackedType","TagSubprogram","TagTemplateTypeParameter","TagTemplateValueParameter","TagThrownType","TagTryDwarfBlock","TagVariantPart","TagVariable","TagVolatileType","TagDwarfProcedure","TagRestrictType","TagInterfaceType","TagNamespace","TagImportedModule","TagUnspecifiedType","TagPartialUnit","TagImportedUnit","TagMutableType","TagCondition","TagSharedType","TagTypeUnit","TagRvalueReferenceType","TagTemplateAlias","TagCoarrayType","TagGenericSubrange","TagDynamicType","TagAtomicType","TagCallSite","TagCallSiteParameter","TagSkeletonUnit","TagImmutableType","Entry{}","Field{}","Class","ClassUnknown","ClassAddress","ClassBlock","ClassConstant","ClassExprLoc","ClassFlag","ClassLinePtr","ClassLocListPtr","ClassMacPtr","ClassRangeListPtr","ClassReference","ClassReferenceSig","ClassString","ClassReferenceAlt","ClassStringAlt","ClassAddrPtr","ClassLocList","ClassRngList","ClassRngListsPtr","ClassStrOffsetsPtr","Offset","Reader{}","LineReader{}","LineEntry{}","LineFile{}","LineReaderPos{}","ErrUnknownPC","Data{}","New(${1:abbrev}, ${2:aranges}, ${3:frame}, ${4:info}, ${5:line}, ${6:pubnames}, ${7:ranges}, ${8:str})","Type","CommonType{}","BasicType{}","CharType{}","UcharType{}","IntType{}","UintType{}","FloatType{}","ComplexType{}","BoolType{}","AddrType{}","UnspecifiedType{}","QualType{}","ArrayType{}","VoidType{}","PtrType{}","StructType{}","StructField{}","EnumType{}","EnumValue{}","FuncType{}","DotDotDotType{}","TypedefType{}","UnsupportedType{}","EI_CLASS","EI_DATA","EI_VERSION","EI_OSABI","EI_ABIVERSION","EI_PAD","EI_NIDENT","ELFMAG","Version","EV_NONE","EV_CURRENT","Class","ELFCLASSNONE","ELFCLASS32","ELFCLASS64","Data","ELFDATANONE","ELFDATA2LSB","ELFDATA2MSB","OSABI","ELFOSABI_NONE","ELFOSABI_HPUX","ELFOSABI_NETBSD","ELFOSABI_LINUX","ELFOSABI_HURD","ELFOSABI_86OPEN","ELFOSABI_SOLARIS","ELFOSABI_AIX","ELFOSABI_IRIX","ELFOSABI_FREEBSD","ELFOSABI_TRU64","ELFOSABI_MODESTO","ELFOSABI_OPENBSD","ELFOSABI_OPENVMS","ELFOSABI_NSK","ELFOSABI_AROS","ELFOSABI_FENIXOS","ELFOSABI_CLOUDABI","ELFOSABI_ARM","ELFOSABI_STANDALONE","Type","ET_NONE","ET_REL","ET_EXEC","ET_DYN","ET_CORE","ET_LOOS","ET_HIOS","ET_LOPROC","ET_HIPROC","Machine","EM_NONE","EM_M32","EM_SPARC","EM_386","EM_68K","EM_88K","EM_860","EM_MIPS","EM_S370","EM_MIPS_RS3_LE","EM_PARISC","EM_VPP500","EM_SPARC32PLUS","EM_960","EM_PPC","EM_PPC64","EM_S390","EM_V800","EM_FR20","EM_RH32","EM_RCE","EM_ARM","EM_SH","EM_SPARCV9","EM_TRICORE","EM_ARC","EM_H8_300","EM_H8_300H","EM_H8S","EM_H8_500","EM_IA_64","EM_MIPS_X","EM_COLDFIRE","EM_68HC12","EM_MMA","EM_PCP","EM_NCPU","EM_NDR1","EM_STARCORE","EM_ME16","EM_ST100","EM_TINYJ","EM_X86_64","EM_PDSP","EM_PDP10","EM_PDP11","EM_FX66","EM_ST9PLUS","EM_ST7","EM_68HC16","EM_68HC11","EM_68HC08","EM_68HC05","EM_SVX","EM_ST19","EM_VAX","EM_CRIS","EM_JAVELIN","EM_FIREPATH","EM_ZSP","EM_MMIX","EM_HUANY","EM_PRISM","EM_AVR","EM_FR30","EM_D10V","EM_D30V","EM_V850","EM_M32R","EM_MN10300","EM_MN10200","EM_PJ","EM_OPENRISC","EM_ARC_COMPACT","EM_XTENSA","EM_VIDEOCORE","EM_TMM_GPP","EM_NS32K","EM_TPC","EM_SNP1K","EM_ST200","EM_IP2K","EM_MAX","EM_CR","EM_F2MC16","EM_MSP430","EM_BLACKFIN","EM_SE_C33","EM_SEP","EM_ARCA","EM_UNICORE","EM_EXCESS","EM_DXP","EM_ALTERA_NIOS2","EM_CRX","EM_XGATE","EM_C166","EM_M16C","EM_DSPIC30F","EM_CE","EM_M32C","EM_TSK3000","EM_RS08","EM_SHARC","EM_ECOG2","EM_SCORE7","EM_DSP24","EM_VIDEOCORE3","EM_LATTICEMICO32","EM_SE_C17","EM_TI_C6000","EM_TI_C2000","EM_TI_C5500","EM_TI_ARP32","EM_TI_PRU","EM_MMDSP_PLUS","EM_CYPRESS_M8C","EM_R32C","EM_TRIMEDIA","EM_QDSP6","EM_8051","EM_STXP7X","EM_NDS32","EM_ECOG1","EM_ECOG1X","EM_MAXQ30","EM_XIMO16","EM_MANIK","EM_CRAYNV2","EM_RX","EM_METAG","EM_MCST_ELBRUS","EM_ECOG16","EM_CR16","EM_ETPU","EM_SLE9X","EM_L10M","EM_K10M","EM_AARCH64","EM_AVR32","EM_STM8","EM_TILE64","EM_TILEPRO","EM_MICROBLAZE","EM_CUDA","EM_TILEGX","EM_CLOUDSHIELD","EM_COREA_1ST","EM_COREA_2ND","EM_ARC_COMPACT2","EM_OPEN8","EM_RL78","EM_VIDEOCORE5","EM_78KOR","EM_56800EX","EM_BA1","EM_BA2","EM_XCORE","EM_MCHP_PIC","EM_INTEL205","EM_INTEL206","EM_INTEL207","EM_INTEL208","EM_INTEL209","EM_KM32","EM_KMX32","EM_KMX16","EM_KMX8","EM_KVARC","EM_CDP","EM_COGE","EM_COOL","EM_NORC","EM_CSR_KALIMBA","EM_Z80","EM_VISIUM","EM_FT32","EM_MOXIE","EM_AMDGPU","EM_RISCV","EM_LANAI","EM_BPF","EM_LOONGARCH","EM_486","EM_MIPS_RS4_BE","EM_ALPHA_STD","EM_ALPHA","SectionIndex","SHN_UNDEF","SHN_LORESERVE","SHN_LOPROC","SHN_HIPROC","SHN_LOOS","SHN_HIOS","SHN_ABS","SHN_COMMON","SHN_XINDEX","SHN_HIRESERVE","SectionType","SHT_NULL","SHT_PROGBITS","SHT_SYMTAB","SHT_STRTAB","SHT_RELA","SHT_HASH","SHT_DYNAMIC","SHT_NOTE","SHT_NOBITS","SHT_REL","SHT_SHLIB","SHT_DYNSYM","SHT_INIT_ARRAY","SHT_FINI_ARRAY","SHT_PREINIT_ARRAY","SHT_GROUP","SHT_SYMTAB_SHNDX","SHT_LOOS","SHT_GNU_ATTRIBUTES","SHT_GNU_HASH","SHT_GNU_LIBLIST","SHT_GNU_VERDEF","SHT_GNU_VERNEED","SHT_GNU_VERSYM","SHT_HIOS","SHT_LOPROC","SHT_MIPS_ABIFLAGS","SHT_HIPROC","SHT_LOUSER","SHT_HIUSER","SectionFlag","SHF_WRITE","SHF_ALLOC","SHF_EXECINSTR","SHF_MERGE","SHF_STRINGS","SHF_INFO_LINK","SHF_LINK_ORDER","SHF_OS_NONCONFORMING","SHF_GROUP","SHF_TLS","SHF_COMPRESSED","SHF_MASKOS","SHF_MASKPROC","CompressionType","COMPRESS_ZLIB","COMPRESS_ZSTD","COMPRESS_LOOS","COMPRESS_HIOS","COMPRESS_LOPROC","COMPRESS_HIPROC","ProgType","PT_NULL","PT_LOAD","PT_DYNAMIC","PT_INTERP","PT_NOTE","PT_SHLIB","PT_PHDR","PT_TLS","PT_LOOS","PT_GNU_EH_FRAME","PT_GNU_STACK","PT_GNU_RELRO","PT_GNU_PROPERTY","PT_GNU_MBIND_LO","PT_GNU_MBIND_HI","PT_PAX_FLAGS","PT_OPENBSD_RANDOMIZE","PT_OPENBSD_WXNEEDED","PT_OPENBSD_NOBTCFI","PT_OPENBSD_BOOTDATA","PT_SUNW_EH_FRAME","PT_SUNWSTACK","PT_HIOS","PT_LOPROC","PT_ARM_ARCHEXT","PT_ARM_EXIDX","PT_AARCH64_ARCHEXT","PT_AARCH64_UNWIND","PT_MIPS_REGINFO","PT_MIPS_RTPROC","PT_MIPS_OPTIONS","PT_MIPS_ABIFLAGS","PT_S390_PGSTE","PT_HIPROC","ProgFlag","PF_X","PF_W","PF_R","PF_MASKOS","PF_MASKPROC","DynTag","DT_NULL","DT_NEEDED","DT_PLTRELSZ","DT_PLTGOT","DT_HASH","DT_STRTAB","DT_SYMTAB","DT_RELA","DT_RELASZ","DT_RELAENT","DT_STRSZ","DT_SYMENT","DT_INIT","DT_FINI","DT_SONAME","DT_RPATH","DT_SYMBOLIC","DT_REL","DT_RELSZ","DT_RELENT","DT_PLTREL","DT_DEBUG","DT_TEXTREL","DT_JMPREL","DT_BIND_NOW","DT_INIT_ARRAY","DT_FINI_ARRAY","DT_INIT_ARRAYSZ","DT_FINI_ARRAYSZ","DT_RUNPATH","DT_FLAGS","DT_ENCODING","DT_PREINIT_ARRAY","DT_PREINIT_ARRAYSZ","DT_SYMTAB_SHNDX","DT_LOOS","DT_HIOS","DT_VALRNGLO","DT_GNU_PRELINKED","DT_GNU_CONFLICTSZ","DT_GNU_LIBLISTSZ","DT_CHECKSUM","DT_PLTPADSZ","DT_MOVEENT","DT_MOVESZ","DT_FEATURE","DT_POSFLAG_1","DT_SYMINSZ","DT_SYMINENT","DT_VALRNGHI","DT_ADDRRNGLO","DT_GNU_HASH","DT_TLSDESC_PLT","DT_TLSDESC_GOT","DT_GNU_CONFLICT","DT_GNU_LIBLIST","DT_CONFIG","DT_DEPAUDIT","DT_AUDIT","DT_PLTPAD","DT_MOVETAB","DT_SYMINFO","DT_ADDRRNGHI","DT_VERSYM","DT_RELACOUNT","DT_RELCOUNT","DT_FLAGS_1","DT_VERDEF","DT_VERDEFNUM","DT_VERNEED","DT_VERNEEDNUM","DT_LOPROC","DT_MIPS_RLD_VERSION","DT_MIPS_TIME_STAMP","DT_MIPS_ICHECKSUM","DT_MIPS_IVERSION","DT_MIPS_FLAGS","DT_MIPS_BASE_ADDRESS","DT_MIPS_MSYM","DT_MIPS_CONFLICT","DT_MIPS_LIBLIST","DT_MIPS_LOCAL_GOTNO","DT_MIPS_CONFLICTNO","DT_MIPS_LIBLISTNO","DT_MIPS_SYMTABNO","DT_MIPS_UNREFEXTNO","DT_MIPS_GOTSYM","DT_MIPS_HIPAGENO","DT_MIPS_RLD_MAP","DT_MIPS_DELTA_CLASS","DT_MIPS_DELTA_CLASS_NO","DT_MIPS_DELTA_INSTANCE","DT_MIPS_DELTA_INSTANCE_NO","DT_MIPS_DELTA_RELOC","DT_MIPS_DELTA_RELOC_NO","DT_MIPS_DELTA_SYM","DT_MIPS_DELTA_SYM_NO","DT_MIPS_DELTA_CLASSSYM","DT_MIPS_DELTA_CLASSSYM_NO","DT_MIPS_CXX_FLAGS","DT_MIPS_PIXIE_INIT","DT_MIPS_SYMBOL_LIB","DT_MIPS_LOCALPAGE_GOTIDX","DT_MIPS_LOCAL_GOTIDX","DT_MIPS_HIDDEN_GOTIDX","DT_MIPS_PROTECTED_GOTIDX","DT_MIPS_OPTIONS","DT_MIPS_INTERFACE","DT_MIPS_DYNSTR_ALIGN","DT_MIPS_INTERFACE_SIZE","DT_MIPS_RLD_TEXT_RESOLVE_ADDR","DT_MIPS_PERF_SUFFIX","DT_MIPS_COMPACT_SIZE","DT_MIPS_GP_VALUE","DT_MIPS_AUX_DYNAMIC","DT_MIPS_PLTGOT","DT_MIPS_RWPLT","DT_MIPS_RLD_MAP_REL","DT_PPC_GOT","DT_PPC_OPT","DT_PPC64_GLINK","DT_PPC64_OPD","DT_PPC64_OPDSZ","DT_PPC64_OPT","DT_SPARC_REGISTER","DT_AUXILIARY","DT_USED","DT_FILTER","DT_HIPROC","DynFlag","DF_ORIGIN","DF_SYMBOLIC","DF_TEXTREL","DF_BIND_NOW","DF_STATIC_TLS","DynFlag1","DF_1_NOW","DF_1_GLOBAL","DF_1_GROUP","DF_1_NODELETE","DF_1_LOADFLTR","DF_1_INITFIRST","DF_1_NOOPEN","DF_1_ORIGIN","DF_1_DIRECT","DF_1_TRANS","DF_1_INTERPOSE","DF_1_NODEFLIB","DF_1_NODUMP","DF_1_CONFALT","DF_1_ENDFILTEE","DF_1_DISPRELDNE","DF_1_DISPRELPND","DF_1_NODIRECT","DF_1_IGNMULDEF","DF_1_NOKSYMS","DF_1_NOHDR","DF_1_EDITED","DF_1_NORELOC","DF_1_SYMINTPOSE","DF_1_GLOBAUDIT","DF_1_SINGLETON","DF_1_STUB","DF_1_PIE","DF_1_KMOD","DF_1_WEAKFILTER","DF_1_NOCOMMON","NType","NT_PRSTATUS","NT_FPREGSET","NT_PRPSINFO","SymBind","STB_LOCAL","STB_GLOBAL","STB_WEAK","STB_LOOS","STB_HIOS","STB_LOPROC","STB_HIPROC","SymType","STT_NOTYPE","STT_OBJECT","STT_FUNC","STT_SECTION","STT_FILE","STT_COMMON","STT_TLS","STT_LOOS","STT_HIOS","STT_LOPROC","STT_HIPROC","STT_RELC","STT_SRELC","STT_GNU_IFUNC","SymVis","STV_DEFAULT","STV_INTERNAL","STV_HIDDEN","STV_PROTECTED","R_X86_64","R_X86_64_NONE","R_X86_64_64","R_X86_64_PC32","R_X86_64_GOT32","R_X86_64_PLT32","R_X86_64_COPY","R_X86_64_GLOB_DAT","R_X86_64_JMP_SLOT","R_X86_64_RELATIVE","R_X86_64_GOTPCREL","R_X86_64_32","R_X86_64_32S","R_X86_64_16","R_X86_64_PC16","R_X86_64_8","R_X86_64_PC8","R_X86_64_DTPMOD64","R_X86_64_DTPOFF64","R_X86_64_TPOFF64","R_X86_64_TLSGD","R_X86_64_TLSLD","R_X86_64_DTPOFF32","R_X86_64_GOTTPOFF","R_X86_64_TPOFF32","R_X86_64_PC64","R_X86_64_GOTOFF64","R_X86_64_GOTPC32","R_X86_64_GOT64","R_X86_64_GOTPCREL64","R_X86_64_GOTPC64","R_X86_64_GOTPLT64","R_X86_64_PLTOFF64","R_X86_64_SIZE32","R_X86_64_SIZE64","R_X86_64_GOTPC32_TLSDESC","R_X86_64_TLSDESC_CALL","R_X86_64_TLSDESC","R_X86_64_IRELATIVE","R_X86_64_RELATIVE64","R_X86_64_PC32_BND","R_X86_64_PLT32_BND","R_X86_64_GOTPCRELX","R_X86_64_REX_GOTPCRELX","R_AARCH64","R_AARCH64_NONE","R_AARCH64_P32_ABS32","R_AARCH64_P32_ABS16","R_AARCH64_P32_PREL32","R_AARCH64_P32_PREL16","R_AARCH64_P32_MOVW_UABS_G0","R_AARCH64_P32_MOVW_UABS_G0_NC","R_AARCH64_P32_MOVW_UABS_G1","R_AARCH64_P32_MOVW_SABS_G0","R_AARCH64_P32_LD_PREL_LO19","R_AARCH64_P32_ADR_PREL_LO21","R_AARCH64_P32_ADR_PREL_PG_HI21","R_AARCH64_P32_ADD_ABS_LO12_NC","R_AARCH64_P32_LDST8_ABS_LO12_NC","R_AARCH64_P32_LDST16_ABS_LO12_NC","R_AARCH64_P32_LDST32_ABS_LO12_NC","R_AARCH64_P32_LDST64_ABS_LO12_NC","R_AARCH64_P32_LDST128_ABS_LO12_NC","R_AARCH64_P32_TSTBR14","R_AARCH64_P32_CONDBR19","R_AARCH64_P32_JUMP26","R_AARCH64_P32_CALL26","R_AARCH64_P32_GOT_LD_PREL19","R_AARCH64_P32_ADR_GOT_PAGE","R_AARCH64_P32_LD32_GOT_LO12_NC","R_AARCH64_P32_TLSGD_ADR_PAGE21","R_AARCH64_P32_TLSGD_ADD_LO12_NC","R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21","R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC","R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19","R_AARCH64_P32_TLSLE_MOVW_TPREL_G1","R_AARCH64_P32_TLSLE_MOVW_TPREL_G0","R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC","R_AARCH64_P32_TLSLE_ADD_TPREL_HI12","R_AARCH64_P32_TLSLE_ADD_TPREL_LO12","R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC","R_AARCH64_P32_TLSDESC_LD_PREL19","R_AARCH64_P32_TLSDESC_ADR_PREL21","R_AARCH64_P32_TLSDESC_ADR_PAGE21","R_AARCH64_P32_TLSDESC_LD32_LO12_NC","R_AARCH64_P32_TLSDESC_ADD_LO12_NC","R_AARCH64_P32_TLSDESC_CALL","R_AARCH64_P32_COPY","R_AARCH64_P32_GLOB_DAT","R_AARCH64_P32_JUMP_SLOT","R_AARCH64_P32_RELATIVE","R_AARCH64_P32_TLS_DTPMOD","R_AARCH64_P32_TLS_DTPREL","R_AARCH64_P32_TLS_TPREL","R_AARCH64_P32_TLSDESC","R_AARCH64_P32_IRELATIVE","R_AARCH64_NULL","R_AARCH64_ABS64","R_AARCH64_ABS32","R_AARCH64_ABS16","R_AARCH64_PREL64","R_AARCH64_PREL32","R_AARCH64_PREL16","R_AARCH64_MOVW_UABS_G0","R_AARCH64_MOVW_UABS_G0_NC","R_AARCH64_MOVW_UABS_G1","R_AARCH64_MOVW_UABS_G1_NC","R_AARCH64_MOVW_UABS_G2","R_AARCH64_MOVW_UABS_G2_NC","R_AARCH64_MOVW_UABS_G3","R_AARCH64_MOVW_SABS_G0","R_AARCH64_MOVW_SABS_G1","R_AARCH64_MOVW_SABS_G2","R_AARCH64_LD_PREL_LO19","R_AARCH64_ADR_PREL_LO21","R_AARCH64_ADR_PREL_PG_HI21","R_AARCH64_ADR_PREL_PG_HI21_NC","R_AARCH64_ADD_ABS_LO12_NC","R_AARCH64_LDST8_ABS_LO12_NC","R_AARCH64_TSTBR14","R_AARCH64_CONDBR19","R_AARCH64_JUMP26","R_AARCH64_CALL26","R_AARCH64_LDST16_ABS_LO12_NC","R_AARCH64_LDST32_ABS_LO12_NC","R_AARCH64_LDST64_ABS_LO12_NC","R_AARCH64_LDST128_ABS_LO12_NC","R_AARCH64_GOT_LD_PREL19","R_AARCH64_LD64_GOTOFF_LO15","R_AARCH64_ADR_GOT_PAGE","R_AARCH64_LD64_GOT_LO12_NC","R_AARCH64_LD64_GOTPAGE_LO15","R_AARCH64_TLSGD_ADR_PREL21","R_AARCH64_TLSGD_ADR_PAGE21","R_AARCH64_TLSGD_ADD_LO12_NC","R_AARCH64_TLSGD_MOVW_G1","R_AARCH64_TLSGD_MOVW_G0_NC","R_AARCH64_TLSLD_ADR_PREL21","R_AARCH64_TLSLD_ADR_PAGE21","R_AARCH64_TLSIE_MOVW_GOTTPREL_G1","R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC","R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21","R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC","R_AARCH64_TLSIE_LD_GOTTPREL_PREL19","R_AARCH64_TLSLE_MOVW_TPREL_G2","R_AARCH64_TLSLE_MOVW_TPREL_G1","R_AARCH64_TLSLE_MOVW_TPREL_G1_NC","R_AARCH64_TLSLE_MOVW_TPREL_G0","R_AARCH64_TLSLE_MOVW_TPREL_G0_NC","R_AARCH64_TLSLE_ADD_TPREL_HI12","R_AARCH64_TLSLE_ADD_TPREL_LO12","R_AARCH64_TLSLE_ADD_TPREL_LO12_NC","R_AARCH64_TLSDESC_LD_PREL19","R_AARCH64_TLSDESC_ADR_PREL21","R_AARCH64_TLSDESC_ADR_PAGE21","R_AARCH64_TLSDESC_LD64_LO12_NC","R_AARCH64_TLSDESC_ADD_LO12_NC","R_AARCH64_TLSDESC_OFF_G1","R_AARCH64_TLSDESC_OFF_G0_NC","R_AARCH64_TLSDESC_LDR","R_AARCH64_TLSDESC_ADD","R_AARCH64_TLSDESC_CALL","R_AARCH64_TLSLE_LDST128_TPREL_LO12","R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC","R_AARCH64_TLSLD_LDST128_DTPREL_LO12","R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC","R_AARCH64_COPY","R_AARCH64_GLOB_DAT","R_AARCH64_JUMP_SLOT","R_AARCH64_RELATIVE","R_AARCH64_TLS_DTPMOD64","R_AARCH64_TLS_DTPREL64","R_AARCH64_TLS_TPREL64","R_AARCH64_TLSDESC","R_AARCH64_IRELATIVE","R_ALPHA","R_ALPHA_NONE","R_ALPHA_REFLONG","R_ALPHA_REFQUAD","R_ALPHA_GPREL32","R_ALPHA_LITERAL","R_ALPHA_LITUSE","R_ALPHA_GPDISP","R_ALPHA_BRADDR","R_ALPHA_HINT","R_ALPHA_SREL16","R_ALPHA_SREL32","R_ALPHA_SREL64","R_ALPHA_OP_PUSH","R_ALPHA_OP_STORE","R_ALPHA_OP_PSUB","R_ALPHA_OP_PRSHIFT","R_ALPHA_GPVALUE","R_ALPHA_GPRELHIGH","R_ALPHA_GPRELLOW","R_ALPHA_IMMED_GP_16","R_ALPHA_IMMED_GP_HI32","R_ALPHA_IMMED_SCN_HI32","R_ALPHA_IMMED_BR_HI32","R_ALPHA_IMMED_LO32","R_ALPHA_COPY","R_ALPHA_GLOB_DAT","R_ALPHA_JMP_SLOT","R_ALPHA_RELATIVE","R_ARM","R_ARM_NONE","R_ARM_PC24","R_ARM_ABS32","R_ARM_REL32","R_ARM_PC13","R_ARM_ABS16","R_ARM_ABS12","R_ARM_THM_ABS5","R_ARM_ABS8","R_ARM_SBREL32","R_ARM_THM_PC22","R_ARM_THM_PC8","R_ARM_AMP_VCALL9","R_ARM_SWI24","R_ARM_THM_SWI8","R_ARM_XPC25","R_ARM_THM_XPC22","R_ARM_TLS_DTPMOD32","R_ARM_TLS_DTPOFF32","R_ARM_TLS_TPOFF32","R_ARM_COPY","R_ARM_GLOB_DAT","R_ARM_JUMP_SLOT","R_ARM_RELATIVE","R_ARM_GOTOFF","R_ARM_GOTPC","R_ARM_GOT32","R_ARM_PLT32","R_ARM_CALL","R_ARM_JUMP24","R_ARM_THM_JUMP24","R_ARM_BASE_ABS","R_ARM_ALU_PCREL_7_0","R_ARM_ALU_PCREL_15_8","R_ARM_ALU_PCREL_23_15","R_ARM_LDR_SBREL_11_10_NC","R_ARM_ALU_SBREL_19_12_NC","R_ARM_ALU_SBREL_27_20_CK","R_ARM_TARGET1","R_ARM_SBREL31","R_ARM_V4BX","R_ARM_TARGET2","R_ARM_PREL31","R_ARM_MOVW_ABS_NC","R_ARM_MOVT_ABS","R_ARM_MOVW_PREL_NC","R_ARM_MOVT_PREL","R_ARM_THM_MOVW_ABS_NC","R_ARM_THM_MOVT_ABS","R_ARM_THM_MOVW_PREL_NC","R_ARM_THM_MOVT_PREL","R_ARM_THM_JUMP19","R_ARM_THM_JUMP6","R_ARM_THM_ALU_PREL_11_0","R_ARM_THM_PC12","R_ARM_ABS32_NOI","R_ARM_REL32_NOI","R_ARM_ALU_PC_G0_NC","R_ARM_ALU_PC_G0","R_ARM_ALU_PC_G1_NC","R_ARM_ALU_PC_G1","R_ARM_ALU_PC_G2","R_ARM_LDR_PC_G1","R_ARM_LDR_PC_G2","R_ARM_LDRS_PC_G0","R_ARM_LDRS_PC_G1","R_ARM_LDRS_PC_G2","R_ARM_LDC_PC_G0","R_ARM_LDC_PC_G1","R_ARM_LDC_PC_G2","R_ARM_ALU_SB_G0_NC","R_ARM_ALU_SB_G0","R_ARM_ALU_SB_G1_NC","R_ARM_ALU_SB_G1","R_ARM_ALU_SB_G2","R_ARM_LDR_SB_G0","R_ARM_LDR_SB_G1","R_ARM_LDR_SB_G2","R_ARM_LDRS_SB_G0","R_ARM_LDRS_SB_G1","R_ARM_LDRS_SB_G2","R_ARM_LDC_SB_G0","R_ARM_LDC_SB_G1","R_ARM_LDC_SB_G2","R_ARM_MOVW_BREL_NC","R_ARM_MOVT_BREL","R_ARM_MOVW_BREL","R_ARM_THM_MOVW_BREL_NC","R_ARM_THM_MOVT_BREL","R_ARM_THM_MOVW_BREL","R_ARM_TLS_GOTDESC","R_ARM_TLS_CALL","R_ARM_TLS_DESCSEQ","R_ARM_THM_TLS_CALL","R_ARM_PLT32_ABS","R_ARM_GOT_ABS","R_ARM_GOT_PREL","R_ARM_GOT_BREL12","R_ARM_GOTOFF12","R_ARM_GOTRELAX","R_ARM_GNU_VTENTRY","R_ARM_GNU_VTINHERIT","R_ARM_THM_JUMP11","R_ARM_THM_JUMP8","R_ARM_TLS_GD32","R_ARM_TLS_LDM32","R_ARM_TLS_LDO32","R_ARM_TLS_IE32","R_ARM_TLS_LE32","R_ARM_TLS_LDO12","R_ARM_TLS_LE12","R_ARM_TLS_IE12GP","R_ARM_PRIVATE_0","R_ARM_PRIVATE_1","R_ARM_PRIVATE_2","R_ARM_PRIVATE_3","R_ARM_PRIVATE_4","R_ARM_PRIVATE_5","R_ARM_PRIVATE_6","R_ARM_PRIVATE_7","R_ARM_PRIVATE_8","R_ARM_PRIVATE_9","R_ARM_PRIVATE_10","R_ARM_PRIVATE_11","R_ARM_PRIVATE_12","R_ARM_PRIVATE_13","R_ARM_PRIVATE_14","R_ARM_PRIVATE_15","R_ARM_ME_TOO","R_ARM_THM_TLS_DESCSEQ16","R_ARM_THM_TLS_DESCSEQ32","R_ARM_THM_GOT_BREL12","R_ARM_THM_ALU_ABS_G0_NC","R_ARM_THM_ALU_ABS_G1_NC","R_ARM_THM_ALU_ABS_G2_NC","R_ARM_THM_ALU_ABS_G3","R_ARM_IRELATIVE","R_ARM_RXPC25","R_ARM_RSBREL32","R_ARM_THM_RPC22","R_ARM_RREL32","R_ARM_RABS32","R_ARM_RPC24","R_ARM_RBASE","R_386","R_386_NONE","R_386_32","R_386_PC32","R_386_GOT32","R_386_PLT32","R_386_COPY","R_386_GLOB_DAT","R_386_JMP_SLOT","R_386_RELATIVE","R_386_GOTOFF","R_386_GOTPC","R_386_32PLT","R_386_TLS_TPOFF","R_386_TLS_IE","R_386_TLS_GOTIE","R_386_TLS_LE","R_386_TLS_GD","R_386_TLS_LDM","R_386_16","R_386_PC16","R_386_8","R_386_PC8","R_386_TLS_GD_32","R_386_TLS_GD_PUSH","R_386_TLS_GD_CALL","R_386_TLS_GD_POP","R_386_TLS_LDM_32","R_386_TLS_LDM_PUSH","R_386_TLS_LDM_CALL","R_386_TLS_LDM_POP","R_386_TLS_LDO_32","R_386_TLS_IE_32","R_386_TLS_LE_32","R_386_TLS_DTPMOD32","R_386_TLS_DTPOFF32","R_386_TLS_TPOFF32","R_386_SIZE32","R_386_TLS_GOTDESC","R_386_TLS_DESC_CALL","R_386_TLS_DESC","R_386_IRELATIVE","R_386_GOT32X","R_MIPS","R_MIPS_NONE","R_MIPS_16","R_MIPS_32","R_MIPS_REL32","R_MIPS_26","R_MIPS_HI16","R_MIPS_LO16","R_MIPS_GPREL16","R_MIPS_LITERAL","R_MIPS_GOT16","R_MIPS_PC16","R_MIPS_CALL16","R_MIPS_GPREL32","R_MIPS_SHIFT5","R_MIPS_SHIFT6","R_MIPS_64","R_MIPS_GOT_DISP","R_MIPS_GOT_PAGE","R_MIPS_GOT_OFST","R_MIPS_GOT_HI16","R_MIPS_GOT_LO16","R_MIPS_SUB","R_MIPS_INSERT_A","R_MIPS_INSERT_B","R_MIPS_DELETE","R_MIPS_HIGHER","R_MIPS_HIGHEST","R_MIPS_CALL_HI16","R_MIPS_CALL_LO16","R_MIPS_SCN_DISP","R_MIPS_REL16","R_MIPS_ADD_IMMEDIATE","R_MIPS_PJUMP","R_MIPS_RELGOT","R_MIPS_JALR","R_MIPS_TLS_DTPMOD32","R_MIPS_TLS_DTPREL32","R_MIPS_TLS_DTPMOD64","R_MIPS_TLS_DTPREL64","R_MIPS_TLS_GD","R_MIPS_TLS_LDM","R_MIPS_TLS_DTPREL_HI16","R_MIPS_TLS_DTPREL_LO16","R_MIPS_TLS_GOTTPREL","R_MIPS_TLS_TPREL32","R_MIPS_TLS_TPREL64","R_MIPS_TLS_TPREL_HI16","R_MIPS_TLS_TPREL_LO16","R_MIPS_PC32","R_LARCH","R_LARCH_NONE","R_LARCH_32","R_LARCH_64","R_LARCH_RELATIVE","R_LARCH_COPY","R_LARCH_JUMP_SLOT","R_LARCH_TLS_DTPMOD32","R_LARCH_TLS_DTPMOD64","R_LARCH_TLS_DTPREL32","R_LARCH_TLS_DTPREL64","R_LARCH_TLS_TPREL32","R_LARCH_TLS_TPREL64","R_LARCH_IRELATIVE","R_LARCH_MARK_LA","R_LARCH_MARK_PCREL","R_LARCH_SOP_PUSH_PCREL","R_LARCH_SOP_PUSH_ABSOLUTE","R_LARCH_SOP_PUSH_DUP","R_LARCH_SOP_PUSH_GPREL","R_LARCH_SOP_PUSH_TLS_TPREL","R_LARCH_SOP_PUSH_TLS_GOT","R_LARCH_SOP_PUSH_TLS_GD","R_LARCH_SOP_PUSH_PLT_PCREL","R_LARCH_SOP_ASSERT","R_LARCH_SOP_NOT","R_LARCH_SOP_SUB","R_LARCH_SOP_SL","R_LARCH_SOP_SR","R_LARCH_SOP_ADD","R_LARCH_SOP_AND","R_LARCH_SOP_IF_ELSE","R_LARCH_SOP_POP_32_S_10_5","R_LARCH_SOP_POP_32_U_10_12","R_LARCH_SOP_POP_32_S_10_12","R_LARCH_SOP_POP_32_S_10_16","R_LARCH_SOP_POP_32_S_10_16_S2","R_LARCH_SOP_POP_32_S_5_20","R_LARCH_SOP_POP_32_S_0_5_10_16_S2","R_LARCH_SOP_POP_32_S_0_10_10_16_S2","R_LARCH_SOP_POP_32_U","R_LARCH_ADD8","R_LARCH_ADD16","R_LARCH_ADD24","R_LARCH_ADD32","R_LARCH_ADD64","R_LARCH_SUB8","R_LARCH_SUB16","R_LARCH_SUB24","R_LARCH_SUB32","R_LARCH_SUB64","R_LARCH_GNU_VTINHERIT","R_LARCH_GNU_VTENTRY","R_LARCH_B16","R_LARCH_B21","R_LARCH_B26","R_LARCH_ABS_HI20","R_LARCH_ABS_LO12","R_LARCH_ABS64_LO20","R_LARCH_ABS64_HI12","R_LARCH_PCALA_HI20","R_LARCH_PCALA_LO12","R_LARCH_PCALA64_LO20","R_LARCH_PCALA64_HI12","R_LARCH_GOT_PC_HI20","R_LARCH_GOT_PC_LO12","R_LARCH_GOT64_PC_LO20","R_LARCH_GOT64_PC_HI12","R_LARCH_GOT_HI20","R_LARCH_GOT_LO12","R_LARCH_GOT64_LO20","R_LARCH_GOT64_HI12","R_LARCH_TLS_LE_HI20","R_LARCH_TLS_LE_LO12","R_LARCH_TLS_LE64_LO20","R_LARCH_TLS_LE64_HI12","R_LARCH_TLS_IE_PC_HI20","R_LARCH_TLS_IE_PC_LO12","R_LARCH_TLS_IE64_PC_LO20","R_LARCH_TLS_IE64_PC_HI12","R_LARCH_TLS_IE_HI20","R_LARCH_TLS_IE_LO12","R_LARCH_TLS_IE64_LO20","R_LARCH_TLS_IE64_HI12","R_LARCH_TLS_LD_PC_HI20","R_LARCH_TLS_LD_HI20","R_LARCH_TLS_GD_PC_HI20","R_LARCH_TLS_GD_HI20","R_LARCH_32_PCREL","R_LARCH_RELAX","R_LARCH_DELETE","R_LARCH_ALIGN","R_LARCH_PCREL20_S2","R_LARCH_CFA","R_LARCH_ADD6","R_LARCH_SUB6","R_LARCH_ADD_ULEB128","R_LARCH_SUB_ULEB128","R_LARCH_64_PCREL","R_PPC","R_PPC_NONE","R_PPC_ADDR32","R_PPC_ADDR24","R_PPC_ADDR16","R_PPC_ADDR16_LO","R_PPC_ADDR16_HI","R_PPC_ADDR16_HA","R_PPC_ADDR14","R_PPC_ADDR14_BRTAKEN","R_PPC_ADDR14_BRNTAKEN","R_PPC_REL24","R_PPC_REL14","R_PPC_REL14_BRTAKEN","R_PPC_REL14_BRNTAKEN","R_PPC_GOT16","R_PPC_GOT16_LO","R_PPC_GOT16_HI","R_PPC_GOT16_HA","R_PPC_PLTREL24","R_PPC_COPY","R_PPC_GLOB_DAT","R_PPC_JMP_SLOT","R_PPC_RELATIVE","R_PPC_LOCAL24PC","R_PPC_UADDR32","R_PPC_UADDR16","R_PPC_REL32","R_PPC_PLT32","R_PPC_PLTREL32","R_PPC_PLT16_LO","R_PPC_PLT16_HI","R_PPC_PLT16_HA","R_PPC_SDAREL16","R_PPC_SECTOFF","R_PPC_SECTOFF_LO","R_PPC_SECTOFF_HI","R_PPC_SECTOFF_HA","R_PPC_TLS","R_PPC_DTPMOD32","R_PPC_TPREL16","R_PPC_TPREL16_LO","R_PPC_TPREL16_HI","R_PPC_TPREL16_HA","R_PPC_TPREL32","R_PPC_DTPREL16","R_PPC_DTPREL16_LO","R_PPC_DTPREL16_HI","R_PPC_DTPREL16_HA","R_PPC_DTPREL32","R_PPC_GOT_TLSGD16","R_PPC_GOT_TLSGD16_LO","R_PPC_GOT_TLSGD16_HI","R_PPC_GOT_TLSGD16_HA","R_PPC_GOT_TLSLD16","R_PPC_GOT_TLSLD16_LO","R_PPC_GOT_TLSLD16_HI","R_PPC_GOT_TLSLD16_HA","R_PPC_GOT_TPREL16","R_PPC_GOT_TPREL16_LO","R_PPC_GOT_TPREL16_HI","R_PPC_GOT_TPREL16_HA","R_PPC_EMB_NADDR32","R_PPC_EMB_NADDR16","R_PPC_EMB_NADDR16_LO","R_PPC_EMB_NADDR16_HI","R_PPC_EMB_NADDR16_HA","R_PPC_EMB_SDAI16","R_PPC_EMB_SDA2I16","R_PPC_EMB_SDA2REL","R_PPC_EMB_SDA21","R_PPC_EMB_MRKREF","R_PPC_EMB_RELSEC16","R_PPC_EMB_RELST_LO","R_PPC_EMB_RELST_HI","R_PPC_EMB_RELST_HA","R_PPC_EMB_BIT_FLD","R_PPC_EMB_RELSDA","R_PPC64","R_PPC64_NONE","R_PPC64_ADDR32","R_PPC64_ADDR24","R_PPC64_ADDR16","R_PPC64_ADDR16_LO","R_PPC64_ADDR16_HI","R_PPC64_ADDR16_HA","R_PPC64_ADDR14","R_PPC64_ADDR14_BRTAKEN","R_PPC64_ADDR14_BRNTAKEN","R_PPC64_REL24","R_PPC64_REL14","R_PPC64_REL14_BRTAKEN","R_PPC64_REL14_BRNTAKEN","R_PPC64_GOT16","R_PPC64_GOT16_LO","R_PPC64_GOT16_HI","R_PPC64_GOT16_HA","R_PPC64_COPY","R_PPC64_GLOB_DAT","R_PPC64_JMP_SLOT","R_PPC64_RELATIVE","R_PPC64_UADDR32","R_PPC64_UADDR16","R_PPC64_REL32","R_PPC64_PLT32","R_PPC64_PLTREL32","R_PPC64_PLT16_LO","R_PPC64_PLT16_HI","R_PPC64_PLT16_HA","R_PPC64_SECTOFF","R_PPC64_SECTOFF_LO","R_PPC64_SECTOFF_HI","R_PPC64_SECTOFF_HA","R_PPC64_REL30","R_PPC64_ADDR64","R_PPC64_ADDR16_HIGHER","R_PPC64_ADDR16_HIGHERA","R_PPC64_ADDR16_HIGHEST","R_PPC64_ADDR16_HIGHESTA","R_PPC64_UADDR64","R_PPC64_REL64","R_PPC64_PLT64","R_PPC64_PLTREL64","R_PPC64_TOC16","R_PPC64_TOC16_LO","R_PPC64_TOC16_HI","R_PPC64_TOC16_HA","R_PPC64_TOC","R_PPC64_PLTGOT16","R_PPC64_PLTGOT16_LO","R_PPC64_PLTGOT16_HI","R_PPC64_PLTGOT16_HA","R_PPC64_ADDR16_DS","R_PPC64_ADDR16_LO_DS","R_PPC64_GOT16_DS","R_PPC64_GOT16_LO_DS","R_PPC64_PLT16_LO_DS","R_PPC64_SECTOFF_DS","R_PPC64_SECTOFF_LO_DS","R_PPC64_TOC16_DS","R_PPC64_TOC16_LO_DS","R_PPC64_PLTGOT16_DS","R_PPC64_PLTGOT_LO_DS","R_PPC64_TLS","R_PPC64_DTPMOD64","R_PPC64_TPREL16","R_PPC64_TPREL16_LO","R_PPC64_TPREL16_HI","R_PPC64_TPREL16_HA","R_PPC64_TPREL64","R_PPC64_DTPREL16","R_PPC64_DTPREL16_LO","R_PPC64_DTPREL16_HI","R_PPC64_DTPREL16_HA","R_PPC64_DTPREL64","R_PPC64_GOT_TLSGD16","R_PPC64_GOT_TLSGD16_LO","R_PPC64_GOT_TLSGD16_HI","R_PPC64_GOT_TLSGD16_HA","R_PPC64_GOT_TLSLD16","R_PPC64_GOT_TLSLD16_LO","R_PPC64_GOT_TLSLD16_HI","R_PPC64_GOT_TLSLD16_HA","R_PPC64_GOT_TPREL16_DS","R_PPC64_GOT_TPREL16_LO_DS","R_PPC64_GOT_TPREL16_HI","R_PPC64_GOT_TPREL16_HA","R_PPC64_GOT_DTPREL16_DS","R_PPC64_GOT_DTPREL16_LO_DS","R_PPC64_GOT_DTPREL16_HI","R_PPC64_GOT_DTPREL16_HA","R_PPC64_TPREL16_DS","R_PPC64_TPREL16_LO_DS","R_PPC64_TPREL16_HIGHER","R_PPC64_TPREL16_HIGHERA","R_PPC64_TPREL16_HIGHEST","R_PPC64_TPREL16_HIGHESTA","R_PPC64_DTPREL16_DS","R_PPC64_DTPREL16_LO_DS","R_PPC64_DTPREL16_HIGHER","R_PPC64_DTPREL16_HIGHERA","R_PPC64_DTPREL16_HIGHEST","R_PPC64_DTPREL16_HIGHESTA","R_PPC64_TLSGD","R_PPC64_TLSLD","R_PPC64_TOCSAVE","R_PPC64_ADDR16_HIGH","R_PPC64_ADDR16_HIGHA","R_PPC64_TPREL16_HIGH","R_PPC64_TPREL16_HIGHA","R_PPC64_DTPREL16_HIGH","R_PPC64_DTPREL16_HIGHA","R_PPC64_REL24_NOTOC","R_PPC64_ADDR64_LOCAL","R_PPC64_ENTRY","R_PPC64_PLTSEQ","R_PPC64_PLTCALL","R_PPC64_PLTSEQ_NOTOC","R_PPC64_PLTCALL_NOTOC","R_PPC64_PCREL_OPT","R_PPC64_REL24_P9NOTOC","R_PPC64_D34","R_PPC64_D34_LO","R_PPC64_D34_HI30","R_PPC64_D34_HA30","R_PPC64_PCREL34","R_PPC64_GOT_PCREL34","R_PPC64_PLT_PCREL34","R_PPC64_PLT_PCREL34_NOTOC","R_PPC64_ADDR16_HIGHER34","R_PPC64_ADDR16_HIGHERA34","R_PPC64_ADDR16_HIGHEST34","R_PPC64_ADDR16_HIGHESTA34","R_PPC64_REL16_HIGHER34","R_PPC64_REL16_HIGHERA34","R_PPC64_REL16_HIGHEST34","R_PPC64_REL16_HIGHESTA34","R_PPC64_D28","R_PPC64_PCREL28","R_PPC64_TPREL34","R_PPC64_DTPREL34","R_PPC64_GOT_TLSGD_PCREL34","R_PPC64_GOT_TLSLD_PCREL34","R_PPC64_GOT_TPREL_PCREL34","R_PPC64_GOT_DTPREL_PCREL34","R_PPC64_REL16_HIGH","R_PPC64_REL16_HIGHA","R_PPC64_REL16_HIGHER","R_PPC64_REL16_HIGHERA","R_PPC64_REL16_HIGHEST","R_PPC64_REL16_HIGHESTA","R_PPC64_REL16DX_HA","R_PPC64_JMP_IREL","R_PPC64_IRELATIVE","R_PPC64_REL16","R_PPC64_REL16_LO","R_PPC64_REL16_HI","R_PPC64_REL16_HA","R_PPC64_GNU_VTINHERIT","R_PPC64_GNU_VTENTRY","R_RISCV","R_RISCV_NONE","R_RISCV_32","R_RISCV_64","R_RISCV_RELATIVE","R_RISCV_COPY","R_RISCV_JUMP_SLOT","R_RISCV_TLS_DTPMOD32","R_RISCV_TLS_DTPMOD64","R_RISCV_TLS_DTPREL32","R_RISCV_TLS_DTPREL64","R_RISCV_TLS_TPREL32","R_RISCV_TLS_TPREL64","R_RISCV_BRANCH","R_RISCV_JAL","R_RISCV_CALL","R_RISCV_CALL_PLT","R_RISCV_GOT_HI20","R_RISCV_TLS_GOT_HI20","R_RISCV_TLS_GD_HI20","R_RISCV_PCREL_HI20","R_RISCV_PCREL_LO12_I","R_RISCV_PCREL_LO12_S","R_RISCV_HI20","R_RISCV_LO12_I","R_RISCV_LO12_S","R_RISCV_TPREL_HI20","R_RISCV_TPREL_LO12_I","R_RISCV_TPREL_LO12_S","R_RISCV_TPREL_ADD","R_RISCV_ADD8","R_RISCV_ADD16","R_RISCV_ADD32","R_RISCV_ADD64","R_RISCV_SUB8","R_RISCV_SUB16","R_RISCV_SUB32","R_RISCV_SUB64","R_RISCV_GNU_VTINHERIT","R_RISCV_GNU_VTENTRY","R_RISCV_ALIGN","R_RISCV_RVC_BRANCH","R_RISCV_RVC_JUMP","R_RISCV_RVC_LUI","R_RISCV_GPREL_I","R_RISCV_GPREL_S","R_RISCV_TPREL_I","R_RISCV_TPREL_S","R_RISCV_RELAX","R_RISCV_SUB6","R_RISCV_SET6","R_RISCV_SET8","R_RISCV_SET16","R_RISCV_SET32","R_RISCV_32_PCREL","R_390","R_390_NONE","R_390_8","R_390_12","R_390_16","R_390_32","R_390_PC32","R_390_GOT12","R_390_GOT32","R_390_PLT32","R_390_COPY","R_390_GLOB_DAT","R_390_JMP_SLOT","R_390_RELATIVE","R_390_GOTOFF","R_390_GOTPC","R_390_GOT16","R_390_PC16","R_390_PC16DBL","R_390_PLT16DBL","R_390_PC32DBL","R_390_PLT32DBL","R_390_GOTPCDBL","R_390_64","R_390_PC64","R_390_GOT64","R_390_PLT64","R_390_GOTENT","R_390_GOTOFF16","R_390_GOTOFF64","R_390_GOTPLT12","R_390_GOTPLT16","R_390_GOTPLT32","R_390_GOTPLT64","R_390_GOTPLTENT","R_390_GOTPLTOFF16","R_390_GOTPLTOFF32","R_390_GOTPLTOFF64","R_390_TLS_LOAD","R_390_TLS_GDCALL","R_390_TLS_LDCALL","R_390_TLS_GD32","R_390_TLS_GD64","R_390_TLS_GOTIE12","R_390_TLS_GOTIE32","R_390_TLS_GOTIE64","R_390_TLS_LDM32","R_390_TLS_LDM64","R_390_TLS_IE32","R_390_TLS_IE64","R_390_TLS_IEENT","R_390_TLS_LE32","R_390_TLS_LE64","R_390_TLS_LDO32","R_390_TLS_LDO64","R_390_TLS_DTPMOD","R_390_TLS_DTPOFF","R_390_TLS_TPOFF","R_390_20","R_390_GOT20","R_390_GOTPLT20","R_390_TLS_GOTIE20","R_SPARC","R_SPARC_NONE","R_SPARC_8","R_SPARC_16","R_SPARC_32","R_SPARC_DISP8","R_SPARC_DISP16","R_SPARC_DISP32","R_SPARC_WDISP30","R_SPARC_WDISP22","R_SPARC_HI22","R_SPARC_22","R_SPARC_13","R_SPARC_LO10","R_SPARC_GOT10","R_SPARC_GOT13","R_SPARC_GOT22","R_SPARC_PC10","R_SPARC_PC22","R_SPARC_WPLT30","R_SPARC_COPY","R_SPARC_GLOB_DAT","R_SPARC_JMP_SLOT","R_SPARC_RELATIVE","R_SPARC_UA32","R_SPARC_PLT32","R_SPARC_HIPLT22","R_SPARC_LOPLT10","R_SPARC_PCPLT32","R_SPARC_PCPLT22","R_SPARC_PCPLT10","R_SPARC_10","R_SPARC_11","R_SPARC_64","R_SPARC_OLO10","R_SPARC_HH22","R_SPARC_HM10","R_SPARC_LM22","R_SPARC_PC_HH22","R_SPARC_PC_HM10","R_SPARC_PC_LM22","R_SPARC_WDISP16","R_SPARC_WDISP19","R_SPARC_GLOB_JMP","R_SPARC_7","R_SPARC_5","R_SPARC_6","R_SPARC_DISP64","R_SPARC_PLT64","R_SPARC_HIX22","R_SPARC_LOX10","R_SPARC_H44","R_SPARC_M44","R_SPARC_L44","R_SPARC_REGISTER","R_SPARC_UA64","R_SPARC_UA16","ARM_MAGIC_TRAMP_NUMBER","Header32{}","Section32{}","Prog32{}","Dyn32{}","Chdr32{}","Rel32{}","Rela32{}","R_SYM32(${1:info})","R_TYPE32(${1:info})","R_INFO32(${1:sym}, ${2:typ})","Sym32{}","Sym32Size","ST_BIND(${1:info})","ST_TYPE(${1:info})","ST_INFO(${1:bind}, ${2:typ})","ST_VISIBILITY(${1:other})","Header64{}","Section64{}","Prog64{}","Dyn64{}","Chdr64{}","Rel64{}","Rela64{}","R_SYM64(${1:info})","R_TYPE64(${1:info})","R_INFO(${1:sym}, ${2:typ})","Sym64{}","Sym64Size","FileHeader{}","File{}","SectionHeader{}","Section{}","ProgHeader{}","Prog{}","Symbol{}","FormatError{}","Open(${1:name})","NewFile(${1:r})","ErrNoSymbols","ImportedSymbol{}","LineTable{}","NewLineTable(${1:data}, ${2:text})","Sym{}","Func{}","Obj{}","Table{}","NewTable(${1:symtab}, ${2:pcln})","UnknownFileError","UnknownLineError{}","DecodingError{}","FatFile{}","FatArchHeader{}","FatArch{}","ErrNotFat","NewFatFile(${1:r})","OpenFat(${1:name})","File{}","Load","LoadBytes","SegmentHeader{}","Segment{}","SectionHeader{}","Reloc{}","Section{}","Dylib{}","Symtab{}","Dysymtab{}","Rpath{}","Symbol{}","FormatError{}","Open(${1:name})","NewFile(${1:r})","FileHeader{}","Magic32","Magic64","MagicFat","Type","TypeObj","TypeExec","TypeDylib","TypeBundle","Cpu","Cpu386","CpuAmd64","CpuArm","CpuArm64","CpuPpc","CpuPpc64","LoadCmd","LoadCmdSegment","LoadCmdSymtab","LoadCmdThread","LoadCmdUnixThread","LoadCmdDysymtab","LoadCmdDylib","LoadCmdDylinker","LoadCmdSegment64","LoadCmdRpath","Segment32{}","Segment64{}","SymtabCmd{}","DysymtabCmd{}","DylibCmd{}","RpathCmd{}","Thread{}","FlagNoUndefs","FlagIncrLink","FlagDyldLink","FlagBindAtLoad","FlagPrebound","FlagSplitSegs","FlagLazyInit","FlagTwoLevel","FlagForceFlat","FlagNoMultiDefs","FlagNoFixPrebinding","FlagPrebindable","FlagAllModsBound","FlagSubsectionsViaSymbols","FlagCanonical","FlagWeakDefines","FlagBindsToWeak","FlagAllowStackExecution","FlagRootSafe","FlagSetuidSafe","FlagNoReexportedDylibs","FlagPIE","FlagDeadStrippableDylib","FlagHasTLVDescriptors","FlagNoHeapExecution","FlagAppExtensionSafe","Section32{}","Section64{}","Nlist32{}","Nlist64{}","Regs386{}","RegsAMD64{}","RelocTypeGeneric","GENERIC_RELOC_VANILLA","GENERIC_RELOC_PAIR","GENERIC_RELOC_SECTDIFF","GENERIC_RELOC_PB_LA_PTR","GENERIC_RELOC_LOCAL_SECTDIFF","GENERIC_RELOC_TLV","RelocTypeX86_64","X86_64_RELOC_UNSIGNED","X86_64_RELOC_SIGNED","X86_64_RELOC_BRANCH","X86_64_RELOC_GOT_LOAD","X86_64_RELOC_GOT","X86_64_RELOC_SUBTRACTOR","X86_64_RELOC_SIGNED_1","X86_64_RELOC_SIGNED_2","X86_64_RELOC_SIGNED_4","X86_64_RELOC_TLV","RelocTypeARM","ARM_RELOC_VANILLA","ARM_RELOC_PAIR","ARM_RELOC_SECTDIFF","ARM_RELOC_LOCAL_SECTDIFF","ARM_RELOC_PB_LA_PTR","ARM_RELOC_BR24","ARM_THUMB_RELOC_BR22","ARM_THUMB_32BIT_BRANCH","ARM_RELOC_HALF","ARM_RELOC_HALF_SECTDIFF","RelocTypeARM64","ARM64_RELOC_UNSIGNED","ARM64_RELOC_SUBTRACTOR","ARM64_RELOC_BRANCH26","ARM64_RELOC_PAGE21","ARM64_RELOC_PAGEOFF12","ARM64_RELOC_GOT_LOAD_PAGE21","ARM64_RELOC_GOT_LOAD_PAGEOFF12","ARM64_RELOC_POINTER_TO_GOT","ARM64_RELOC_TLVP_LOAD_PAGE21","ARM64_RELOC_TLVP_LOAD_PAGEOFF12","ARM64_RELOC_ADDEND","File{}","Open(${1:name})","NewFile(${1:r})","ImportDirectory{}","FormatError{}","FileHeader{}","DataDirectory{}","OptionalHeader32{}","OptionalHeader64{}","IMAGE_FILE_MACHINE_UNKNOWN","IMAGE_FILE_MACHINE_AM33","IMAGE_FILE_MACHINE_AMD64","IMAGE_FILE_MACHINE_ARM","IMAGE_FILE_MACHINE_ARMNT","IMAGE_FILE_MACHINE_ARM64","IMAGE_FILE_MACHINE_EBC","IMAGE_FILE_MACHINE_I386","IMAGE_FILE_MACHINE_IA64","IMAGE_FILE_MACHINE_LOONGARCH32","IMAGE_FILE_MACHINE_LOONGARCH64","IMAGE_FILE_MACHINE_M32R","IMAGE_FILE_MACHINE_MIPS16","IMAGE_FILE_MACHINE_MIPSFPU","IMAGE_FILE_MACHINE_MIPSFPU16","IMAGE_FILE_MACHINE_POWERPC","IMAGE_FILE_MACHINE_POWERPCFP","IMAGE_FILE_MACHINE_R4000","IMAGE_FILE_MACHINE_SH3","IMAGE_FILE_MACHINE_SH3DSP","IMAGE_FILE_MACHINE_SH4","IMAGE_FILE_MACHINE_SH5","IMAGE_FILE_MACHINE_THUMB","IMAGE_FILE_MACHINE_WCEMIPSV2","IMAGE_FILE_MACHINE_RISCV32","IMAGE_FILE_MACHINE_RISCV64","IMAGE_FILE_MACHINE_RISCV128","IMAGE_DIRECTORY_ENTRY_EXPORT","IMAGE_DIRECTORY_ENTRY_IMPORT","IMAGE_DIRECTORY_ENTRY_RESOURCE","IMAGE_DIRECTORY_ENTRY_EXCEPTION","IMAGE_DIRECTORY_ENTRY_SECURITY","IMAGE_DIRECTORY_ENTRY_BASERELOC","IMAGE_DIRECTORY_ENTRY_DEBUG","IMAGE_DIRECTORY_ENTRY_ARCHITECTURE","IMAGE_DIRECTORY_ENTRY_GLOBALPTR","IMAGE_DIRECTORY_ENTRY_TLS","IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG","IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT","IMAGE_DIRECTORY_ENTRY_IAT","IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT","IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR","IMAGE_FILE_RELOCS_STRIPPED","IMAGE_FILE_EXECUTABLE_IMAGE","IMAGE_FILE_LINE_NUMS_STRIPPED","IMAGE_FILE_LOCAL_SYMS_STRIPPED","IMAGE_FILE_AGGRESIVE_WS_TRIM","IMAGE_FILE_LARGE_ADDRESS_AWARE","IMAGE_FILE_BYTES_REVERSED_LO","IMAGE_FILE_32BIT_MACHINE","IMAGE_FILE_DEBUG_STRIPPED","IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP","IMAGE_FILE_NET_RUN_FROM_SWAP","IMAGE_FILE_SYSTEM","IMAGE_FILE_DLL","IMAGE_FILE_UP_SYSTEM_ONLY","IMAGE_FILE_BYTES_REVERSED_HI","IMAGE_SUBSYSTEM_UNKNOWN","IMAGE_SUBSYSTEM_NATIVE","IMAGE_SUBSYSTEM_WINDOWS_GUI","IMAGE_SUBSYSTEM_WINDOWS_CUI","IMAGE_SUBSYSTEM_OS2_CUI","IMAGE_SUBSYSTEM_POSIX_CUI","IMAGE_SUBSYSTEM_NATIVE_WINDOWS","IMAGE_SUBSYSTEM_WINDOWS_CE_GUI","IMAGE_SUBSYSTEM_EFI_APPLICATION","IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER","IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER","IMAGE_SUBSYSTEM_EFI_ROM","IMAGE_SUBSYSTEM_XBOX","IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION","IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA","IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE","IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY","IMAGE_DLLCHARACTERISTICS_NX_COMPAT","IMAGE_DLLCHARACTERISTICS_NO_ISOLATION","IMAGE_DLLCHARACTERISTICS_NO_SEH","IMAGE_DLLCHARACTERISTICS_NO_BIND","IMAGE_DLLCHARACTERISTICS_APPCONTAINER","IMAGE_DLLCHARACTERISTICS_WDM_DRIVER","IMAGE_DLLCHARACTERISTICS_GUARD_CF","IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE","SectionHeader32{}","Reloc{}","SectionHeader{}","Section{}","IMAGE_SCN_CNT_CODE","IMAGE_SCN_CNT_INITIALIZED_DATA","IMAGE_SCN_CNT_UNINITIALIZED_DATA","IMAGE_SCN_LNK_COMDAT","IMAGE_SCN_MEM_DISCARDABLE","IMAGE_SCN_MEM_EXECUTE","IMAGE_SCN_MEM_READ","IMAGE_SCN_MEM_WRITE","StringTable","COFFSymbolSize","COFFSymbol{}","Symbol{}","COFFSymbolAuxFormat5{}","IMAGE_COMDAT_SELECT_NODUPLICATES","IMAGE_COMDAT_SELECT_ANY","IMAGE_COMDAT_SELECT_SAME_SIZE","IMAGE_COMDAT_SELECT_EXACT_MATCH","IMAGE_COMDAT_SELECT_ASSOCIATIVE","IMAGE_COMDAT_SELECT_LARGEST","FileHeader{}","File{}","SectionHeader{}","Section{}","Sym{}","Open(${1:name})","NewFile(${1:r})","ErrNoSymbols","Magic64","Magic386","MagicAMD64","MagicARM","Encode(${1:dst}, ${2:src})","MaxEncodedLen(${1:n})","NewEncoder(${1:w})","CorruptInputError","Decode(${1:dst}, ${2:src}, ${3:flush})","NewDecoder(${1:r})","StructuralError{}","SyntaxError{}","BitString{}","NullRawValue","NullBytes","ObjectIdentifier","Enumerated","Flag","RawValue{}","RawContent","Unmarshal(${1:b}, ${2:val})","UnmarshalWithParams(${1:b}, ${2:val}, ${3:params})","TagBoolean","TagInteger","TagBitString","TagOctetString","TagNull","TagOID","TagEnum","TagUTF8String","TagSequence","TagSet","TagNumericString","TagPrintableString","TagT61String","TagIA5String","TagUTCTime","TagGeneralizedTime","TagGeneralString","TagBMPString","ClassUniversal","ClassApplication","ClassContextSpecific","ClassPrivate","Marshal(${1:val})","MarshalWithParams(${1:val}, ${2:params})","Encoding{}","StdPadding","NoPadding","NewEncoding(${1:encoder})","StdEncoding","HexEncoding","NewEncoder(${1:enc}, ${2:w})","CorruptInputError","NewDecoder(${1:enc}, ${2:r})","Encoding{}","StdPadding","NoPadding","NewEncoding(${1:encoder})","StdEncoding","URLEncoding","RawStdEncoding","RawURLEncoding","NewEncoder(${1:enc}, ${2:w})","CorruptInputError","NewDecoder(${1:enc}, ${2:r})","ByteOrder","AppendByteOrder","LittleEndian","BigEndian","Read(${1:r}, ${2:order}, ${3:data})","Decode(${1:buf}, ${2:order}, ${3:data})","Write(${1:w}, ${2:order}, ${3:data})","Encode(${1:buf}, ${2:order}, ${3:data})","Append(${1:buf}, ${2:order}, ${3:data})","Size(${1:v})","NativeEndian","MaxVarintLen16","MaxVarintLen32","MaxVarintLen64","AppendUvarint(${1:buf}, ${2:x})","PutUvarint(${1:buf}, ${2:x})","Uvarint(${1:buf})","AppendVarint(${1:buf}, ${2:x})","PutVarint(${1:buf}, ${2:x})","Varint(${1:buf})","ReadUvarint(${1:r})","ReadVarint(${1:r})","ParseError{}","ErrBareQuote","ErrQuote","ErrFieldCount","ErrTrailingComma","Reader{}","NewReader(${1:r})","Writer{}","NewWriter(${1:w})","Decoder{}","NewDecoder(${1:r})","Encoder{}","NewEncoder(${1:w})","CommonType{}","GobEncoder","GobDecoder","RegisterName(${1:name}, ${2:value})","Register(${1:value})","EncodedLen(${1:n})","Encode(${1:dst}, ${2:src})","AppendEncode(${1:dst}, ${2:src})","ErrLength","InvalidByteError","DecodedLen(${1:x})","Decode(${1:dst}, ${2:src})","AppendDecode(${1:dst}, ${2:src})","EncodeToString(${1:src})","DecodeString(${1:s})","Dump(${1:data})","NewEncoder(${1:w})","NewDecoder(${1:r})","Dumper(${1:w})","Unmarshal(${1:data}, ${2:v})","Unmarshaler","UnmarshalTypeError{}","UnmarshalFieldError{}","InvalidUnmarshalError{}","Number","Marshal(${1:v})","MarshalIndent(${1:v}, ${2:prefix}, ${3:indent})","Marshaler","UnsupportedTypeError{}","UnsupportedValueError{}","InvalidUTF8Error{}","MarshalerError{}","HTMLEscape(${1:dst}, ${2:src})","Compact(${1:dst}, ${2:src})","Indent(${1:dst}, ${2:src}, ${3:prefix}, ${4:indent})","Valid(${1:data})","SyntaxError{}","Decoder{}","NewDecoder(${1:r})","Encoder{}","NewEncoder(${1:w})","RawMessage","Token","Delim","Block{}","Decode(${1:data})","Encode(${1:out}, ${2:b})","EncodeToMemory(${1:b})","Header","Marshal(${1:v})","Marshaler","MarshalerAttr","MarshalIndent(${1:v}, ${2:prefix}, ${3:indent})","Encoder{}","NewEncoder(${1:w})","UnsupportedTypeError{}","Unmarshal(${1:data}, ${2:v})","UnmarshalError","Unmarshaler","UnmarshalerAttr","TagPathError{}","SyntaxError{}","Name{}","Attr{}","Token","StartElement{}","EndElement{}","CharData","Comment","ProcInst{}","Directive","CopyToken(${1:t})","TokenReader","Decoder{}","NewDecoder(${1:r})","NewTokenDecoder(${1:t})","HTMLEntity","HTMLAutoClose","EscapeText(${1:w}, ${2:s})","Escape(${1:w}, ${2:s})","Node","Expr","Stmt","Decl","Comment{}","CommentGroup{}","Field{}","FieldList{}","BadExpr{}","Ident{}","Ellipsis{}","BasicLit{}","FuncLit{}","CompositeLit{}","ParenExpr{}","SelectorExpr{}","IndexExpr{}","IndexListExpr{}","SliceExpr{}","TypeAssertExpr{}","CallExpr{}","StarExpr{}","UnaryExpr{}","BinaryExpr{}","KeyValueExpr{}","ChanDir","SEND","RECV","ArrayType{}","StructType{}","FuncType{}","InterfaceType{}","MapType{}","ChanType{}","NewIdent(${1:name})","IsExported(${1:name})","BadStmt{}","DeclStmt{}","EmptyStmt{}","LabeledStmt{}","ExprStmt{}","SendStmt{}","IncDecStmt{}","AssignStmt{}","GoStmt{}","DeferStmt{}","ReturnStmt{}","BranchStmt{}","BlockStmt{}","IfStmt{}","CaseClause{}","SwitchStmt{}","TypeSwitchStmt{}","CommClause{}","SelectStmt{}","ForStmt{}","RangeStmt{}","Spec","ImportSpec{}","ValueSpec{}","TypeSpec{}","BadDecl{}","GenDecl{}","FuncDecl{}","File{}","Package{}","IsGenerated(${1:file})","Unparen(${1:e})","CommentMap","NewCommentMap(${1:fset}, ${2:node}, ${3:comments})","FileExports(${1:src})","PackageExports(${1:pkg})","Filter","FilterDecl(${1:decl}, ${2:f})","FilterFile(${1:src}, ${2:f})","FilterPackage(${1:pkg}, ${2:f})","MergeMode","FilterFuncDuplicates","FilterUnassociatedComments","FilterImportDuplicates","MergePackageFiles(${1:pkg}, ${2:mode})","SortImports(${1:fset}, ${2:f})","FieldFilter","NotNilFilter(${1:_}, ${2:v})","Fprint(${1:w}, ${2:fset}, ${3:x}, ${4:f})","Print(${1:fset}, ${2:x})","Importer","NewPackage(${1:fset}, ${2:files}, ${3:importer}, ${4:universe})","Scope{}","NewScope(${1:outer})","Object{}","NewObj(${1:kind}, ${2:name})","ObjKind","Bad","Pkg","Con","Typ","Var","Fun","Lbl","Visitor","Walk(${1:v}, ${2:node})","Inspect(${1:node}, ${2:f})","Preorder(${1:root})","Context{}","Default","ImportMode","FindOnly","AllowBinary","ImportComment","IgnoreVendor","Package{}","Directive{}","NoGoError{}","MultiplePackageError{}","Import(${1:path}, ${2:srcDir}, ${3:mode})","ImportDir(${1:dir}, ${2:mode})","ToolDir","IsLocalImport(${1:path})","ArchChar(${1:goarch})","Kind","Unknown","Bool","String","Int","Float","Complex","Value","MakeUnknown()","MakeBool(${1:b})","MakeString(${1:s})","MakeInt64(${1:x})","MakeUint64(${1:x})","MakeFloat64(${1:x})","MakeFromLiteral(${1:lit}, ${2:tok}, ${3:zero})","BoolVal(${1:x})","StringVal(${1:x})","Int64Val(${1:x})","Uint64Val(${1:x})","Float32Val(${1:x})","Float64Val(${1:x})","Val(${1:x})","Make(${1:x})","BitLen(${1:x})","Sign(${1:x})","Bytes(${1:x})","MakeFromBytes(${1:bytes})","Num(${1:x})","Denom(${1:x})","MakeImag(${1:x})","Real(${1:x})","Imag(${1:x})","ToInt(${1:x})","ToFloat(${1:x})","ToComplex(${1:x})","UnaryOp(${1:op}, ${2:y}, ${3:prec})","BinaryOp(${1:x_}, ${2:op}, ${3:y_})","Shift(${1:x}, ${2:op}, ${3:s})","Compare(${1:x_}, ${2:op}, ${3:y_})","ToHTML(${1:w}, ${2:text}, ${3:words})","ToText(${1:w}, ${2:text}, ${3:prefix}, ${4:codePrefix}, ${5:width})","Package{}","Value{}","Type{}","Func{}","Note{}","Mode","AllDecls","AllMethods","PreserveAST","New(${1:pkg}, ${2:importPath}, ${3:mode})","NewFromFiles(${1:fset}, ${2:files}, ${3:importPath}, ${4:opts})","Example{}","Examples(${1:testFiles})","Filter","IsPredeclared(${1:s})","Synopsis(${1:text})","IllegalPrefixes","Node(${1:dst}, ${2:fset}, ${3:node})","Source(${1:src})","Lookup","ForCompiler(${1:fset}, ${2:compiler}, ${3:lookup})","For(${1:compiler}, ${2:lookup})","Default()","Mode","PackageClauseOnly","ImportsOnly","ParseComments","Trace","DeclarationErrors","SpuriousErrors","SkipObjectResolution","AllErrors","ParseFile(${1:fset}, ${2:filename}, ${3:src}, ${4:mode})","ParseDir(${1:fset}, ${2:path}, ${3:filter}, ${4:mode})","ParseExprFrom(${1:fset}, ${2:filename}, ${3:src}, ${4:mode})","ParseExpr(${1:x})","Mode","RawFormat","TabIndent","UseSpaces","SourcePos","Config{}","CommentedNode{}","Fprint(${1:output}, ${2:fset}, ${3:node})","Error{}","ErrorList","PrintError(${1:w}, ${2:err})","ErrorHandler","Scanner{}","Mode","ScanComments","Position{}","Pos","NoPos","File{}","FileSet{}","NewFileSet()","Token","ILLEGAL","EOF","COMMENT","IDENT","INT","FLOAT","IMAG","CHAR","STRING","ADD","SUB","MUL","QUO","REM","AND","OR","XOR","SHL","SHR","AND_NOT","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","QUO_ASSIGN","REM_ASSIGN","AND_ASSIGN","OR_ASSIGN","XOR_ASSIGN","SHL_ASSIGN","SHR_ASSIGN","AND_NOT_ASSIGN","LAND","LOR","ARROW","INC","DEC","EQL","LSS","GTR","ASSIGN","NOT","NEQ","LEQ","GEQ","DEFINE","ELLIPSIS","LPAREN","LBRACK","LBRACE","COMMA","PERIOD","RPAREN","RBRACK","RBRACE","SEMICOLON","COLON","BREAK","CASE","CHAN","CONST","CONTINUE","DEFAULT","DEFER","ELSE","FALLTHROUGH","FOR","FUNC","GO","GOTO","IF","IMPORT","INTERFACE","MAP","PACKAGE","RANGE","RETURN","SELECT","STRUCT","SWITCH","TYPE","VAR","TILDE","LowestPrec","UnaryPrec","HighestPrec","Lookup(${1:ident})","IsExported(${1:name})","IsKeyword(${1:name})","IsIdentifier(${1:name})","Alias{}","NewAlias(${1:obj}, ${2:rhs})","Unalias(${1:t})","Error{}","ArgumentError{}","Importer","ImportMode","ImporterFrom","Config{}","Info{}","TypeAndValue{}","Instance{}","Initializer{}","AssertableTo(${1:V}, ${2:T})","AssignableTo(${1:V}, ${2:T})","ConvertibleTo(${1:V}, ${2:T})","Implements(${1:V}, ${2:T})","Satisfies(${1:V}, ${2:T})","Identical(${1:x}, ${2:y})","IdenticalIgnoreTags(${1:x}, ${2:y})","Array{}","NewArray(${1:elem}, ${2:len})","BasicKind","Invalid","Bool","Int","Int8","Int16","Int32","Int64","Uint","Uint8","Uint16","Uint32","Uint64","Uintptr","Float32","Float64","Complex64","Complex128","String","UnsafePointer","UntypedBool","UntypedInt","UntypedRune","UntypedFloat","UntypedComplex","UntypedString","UntypedNil","Byte","Rune","BasicInfo","IsBoolean","IsInteger","IsUnsigned","IsFloat","IsComplex","IsString","IsUntyped","IsOrdered","IsNumeric","IsConstType","Basic{}","Chan{}","ChanDir","SendRecv","SendOnly","RecvOnly","NewChan(${1:dir}, ${2:elem})","Checker{}","NewChecker(${1:conf}, ${2:fset}, ${3:pkg}, ${4:info})","Context{}","NewContext()","Eval(${1:fset}, ${2:pkg}, ${3:pos}, ${4:expr})","CheckExpr(${1:fset}, ${2:pkg}, ${3:pos}, ${4:expr}, ${5:info})","ExprString(${1:x})","WriteExpr(${1:buf}, ${2:x})","Instantiate(${1:ctxt}, ${2:orig}, ${3:targs}, ${4:validate})","Interface{}","NewInterface(${1:methods}, ${2:embeddeds})","NewInterfaceType(${1:methods}, ${2:embeddeds})","LookupFieldOrMethod(${1:T}, ${2:addressable}, ${3:pkg}, ${4:name})","MissingMethod(${1:V}, ${2:T}, ${3:static})","Map{}","NewMap(${1:key}, ${2:elem})","MethodSet{}","NewMethodSet(${1:T})","Named{}","NewNamed(${1:obj}, ${2:underlying}, ${3:methods})","Object","Id(${1:pkg}, ${2:name})","PkgName{}","NewPkgName(${1:pos}, ${2:pkg}, ${3:name}, ${4:imported})","Const{}","NewConst(${1:pos}, ${2:pkg}, ${3:name}, ${4:typ}, ${5:val})","TypeName{}","NewTypeName(${1:pos}, ${2:pkg}, ${3:name}, ${4:typ})","Var{}","NewVar(${1:pos}, ${2:pkg}, ${3:name}, ${4:typ})","NewParam(${1:pos}, ${2:pkg}, ${3:name}, ${4:typ})","NewField(${1:pos}, ${2:pkg}, ${3:name}, ${4:typ}, ${5:embedded})","Func{}","NewFunc(${1:pos}, ${2:pkg}, ${3:name}, ${4:sig})","Label{}","NewLabel(${1:pos}, ${2:pkg}, ${3:name})","Builtin{}","Nil{}","ObjectString(${1:obj}, ${2:qf})","Package{}","NewPackage(${1:path}, ${2:name})","Pointer{}","NewPointer(${1:elem})","IsInterface(${1:t})","Comparable(${1:T})","Default(${1:t})","Scope{}","NewScope(${1:parent}, ${2:pos}, ${3:end}, ${4:comment})","SelectionKind","FieldVal","MethodVal","MethodExpr","Selection{}","SelectionString(${1:s}, ${2:qf})","Signature{}","NewSignature(${1:recv}, ${2:params}, ${3:results}, ${4:variadic})","NewSignatureType(${1:recv}, ${2:recvTypeParams}, ${3:typeParams}, ${4:params}, ${5:results}, ${6:variadic})","Sizes","StdSizes{}","SizesFor(${1:compiler}, ${2:arch})","Slice{}","NewSlice(${1:elem})","Struct{}","NewStruct(${1:fields}, ${2:tags})","Tuple{}","NewTuple(${1:x})","Type","TypeParamList{}","TypeList{}","TypeParam{}","NewTypeParam(${1:obj}, ${2:constraint})","Qualifier","RelativeTo(${1:pkg})","TypeString(${1:typ}, ${2:qf})","WriteType(${1:buf}, ${2:typ}, ${3:qf})","WriteSignature(${1:buf}, ${2:sig}, ${3:qf})","Union{}","NewUnion(${1:terms})","Term","NewTerm(${1:tilde}, ${2:typ})","Universe","Unsafe","Typ","DefPredeclaredTestFuncs()","Lang(${1:x})","Compare(${1:x}, ${2:y})","IsValid(${1:x})","Size","New()","Checksum(${1:data})","Size","IEEE","Castagnoli","Koopman","Table","IEEETable","MakeTable(${1:poly})","New(${1:tab})","NewIEEE()","Update(${1:crc}, ${2:tab}, ${3:p})","Checksum(${1:data}, ${2:tab})","ChecksumIEEE(${1:data})","Size","ISO","ECMA","Table","MakeTable(${1:poly})","New(${1:tab})","Update(${1:crc}, ${2:tab}, ${3:p})","Checksum(${1:data}, ${2:tab})","New32()","New32a()","New64()","New64a()","New128()","New128a()","Seed{}","Bytes(${1:seed}, ${2:b})","String(${1:seed}, ${2:s})","Hash{}","MakeSeed()","CSS","HTML","HTMLAttr","JS","JSStr","URL","Srcset","Error{}","ErrorCode","OK","ErrAmbigContext","ErrBadHTML","ErrBranchEnd","ErrEndContext","ErrNoSuchTemplate","ErrOutputContext","ErrPartialCharset","ErrPartialEscape","ErrRangeLoopReentry","ErrSlashAmbig","ErrPredefinedEscaper","ErrJSTemplate","HTMLEscape(${1:w}, ${2:b})","HTMLEscapeString(${1:s})","HTMLEscaper(${1:args})","JSEscape(${1:w}, ${2:b})","JSEscapeString(${1:s})","JSEscaper(${1:args})","URLQueryEscaper(${1:args})","Template{}","New(${1:name})","FuncMap","Must(${1:t}, ${2:err})","ParseFiles(${1:filenames})","ParseGlob(${1:pattern})","IsTrue(${1:val})","ParseFS(${1:fs}, ${2:patterns})","Color","RGBA{}","RGBA64{}","NRGBA{}","NRGBA64{}","Alpha{}","Alpha16{}","Gray{}","Gray16{}","Model","ModelFunc(${1:f})","RGBAModel","RGBA64Model","NRGBAModel","NRGBA64Model","AlphaModel","Alpha16Model","GrayModel","Gray16Model","Palette","Black","White","Transparent","Opaque","RGBToYCbCr(${1:r}, ${2:g}, ${3:b})","YCbCrToRGB(${1:y}, ${2:cb}, ${3:cr})","YCbCr{}","YCbCrModel","NYCbCrA{}","NYCbCrAModel","RGBToCMYK(${1:r}, ${2:g}, ${3:b})","CMYKToRGB(${1:c}, ${2:m}, ${3:y}, ${4:k})","CMYK{}","CMYKModel","Image","RGBA64Image","Quantizer","Op","Over","Src","Drawer","FloydSteinberg","Draw(${1:dst}, ${2:r}, ${3:src}, ${4:sp}, ${5:op})","DrawMask(${1:dst}, ${2:r}, ${3:src}, ${4:sp}, ${5:mask}, ${6:mp}, ${7:op})","DisposalNone","DisposalBackground","DisposalPrevious","Decode(${1:r})","GIF{}","DecodeAll(${1:r})","DecodeConfig(${1:r})","Options{}","EncodeAll(${1:w}, ${2:g})","Encode(${1:w}, ${2:m}, ${3:o})","FormatError","UnsupportedError","Reader","Decode(${1:r})","DecodeConfig(${1:r})","DefaultQuality","Options{}","Encode(${1:w}, ${2:m}, ${3:o})","FormatError","UnsupportedError","Decode(${1:r})","DecodeConfig(${1:r})","Encoder{}","EncoderBufferPool","EncoderBuffer","CompressionLevel","DefaultCompression","NoCompression","BestSpeed","BestCompression","Encode(${1:w}, ${2:m})","Index{}","New(${1:data})","FormatFileInfo(${1:info})","FormatDirEntry(${1:dir})","FS","ValidPath(${1:name})","File","DirEntry","ReadDirFile","ErrInvalid","ErrPermission","ErrExist","ErrNotExist","ErrClosed","FileInfo","FileMode","ModeDir","ModeAppend","ModeExclusive","ModeTemporary","ModeSymlink","ModeDevice","ModeNamedPipe","ModeSocket","ModeSetuid","ModeSetgid","ModeCharDevice","ModeSticky","ModeIrregular","ModeType","ModePerm","PathError{}","GlobFS","Glob(${1:fsys}, ${2:pattern})","ReadDirFS","ReadDir(${1:fsys}, ${2:name})","FileInfoToDirEntry(${1:info})","ReadFileFS","ReadFile(${1:fsys}, ${2:name})","StatFS","Stat(${1:fsys}, ${2:name})","SubFS","Sub(${1:fsys}, ${2:dir})","SkipDir","SkipAll","WalkDirFunc","WalkDir(${1:fsys}, ${2:root}, ${3:fn})","ReadAll(${1:r})","ReadFile(${1:filename})","WriteFile(${1:filename}, ${2:data}, ${3:perm})","ReadDir(${1:dirname})","NopCloser(${1:r})","Discard","TempFile(${1:dir}, ${2:pattern})","TempDir(${1:dir}, ${2:pattern})","Attr{}","String(${1:key}, ${2:value})","Int64(${1:key}, ${2:value})","Int(${1:key}, ${2:value})","Uint64(${1:key}, ${2:v})","Float64(${1:key}, ${2:v})","Bool(${1:key}, ${2:v})","Time(${1:key}, ${2:v})","Duration(${1:key}, ${2:v})","Group(${1:key}, ${2:args})","Any(${1:key}, ${2:value})","Handler","HandlerOptions{}","TimeKey","LevelKey","MessageKey","SourceKey","JSONHandler{}","NewJSONHandler(${1:w}, ${2:opts})","Level","LevelDebug","LevelInfo","LevelWarn","LevelError","LevelVar{}","Leveler","SetLogLoggerLevel(${1:level})","Default()","SetDefault(${1:l})","Logger{}","New(${1:h})","With(${1:args})","NewLogLogger(${1:h}, ${2:level})","Debug(${1:msg}, ${2:args})","DebugContext(${1:ctx}, ${2:msg}, ${3:args})","Info(${1:msg}, ${2:args})","InfoContext(${1:ctx}, ${2:msg}, ${3:args})","Warn(${1:msg}, ${2:args})","WarnContext(${1:ctx}, ${2:msg}, ${3:args})","Error(${1:msg}, ${2:args})","ErrorContext(${1:ctx}, ${2:msg}, ${3:args})","Log(${1:ctx}, ${2:level}, ${3:msg}, ${4:args})","LogAttrs(${1:ctx}, ${2:level}, ${3:msg}, ${4:attrs})","Record{}","NewRecord(${1:t}, ${2:level}, ${3:msg}, ${4:pc})","Source{}","TextHandler{}","NewTextHandler(${1:w}, ${2:opts})","Value{}","Kind","KindAny","KindBool","KindDuration","KindFloat64","KindInt64","KindString","KindTime","KindUint64","KindGroup","KindLogValuer","StringValue(${1:value})","IntValue(${1:v})","Int64Value(${1:v})","Uint64Value(${1:v})","Float64Value(${1:v})","BoolValue(${1:v})","TimeValue(${1:v})","DurationValue(${1:v})","GroupValue(${1:as})","AnyValue(${1:v})","LogValuer","Priority","LOG_EMERG","LOG_ALERT","LOG_CRIT","LOG_ERR","LOG_WARNING","LOG_NOTICE","LOG_INFO","LOG_DEBUG","LOG_KERN","LOG_USER","LOG_MAIL","LOG_DAEMON","LOG_AUTH","LOG_SYSLOG","LOG_LPR","LOG_NEWS","LOG_UUCP","LOG_CRON","LOG_AUTHPRIV","LOG_FTP","LOG_LOCAL0","LOG_LOCAL1","LOG_LOCAL2","LOG_LOCAL3","LOG_LOCAL4","LOG_LOCAL5","LOG_LOCAL6","LOG_LOCAL7","Writer{}","New(${1:priority}, ${2:tag})","Dial(${1:network}, ${2:raddr}, ${3:priority}, ${4:tag})","NewLogger(${1:p}, ${2:logFlag})","Word","Float{}","ErrNaN{}","NewFloat(${1:x})","MaxExp","MinExp","MaxPrec","RoundingMode","ToNearestEven","ToNearestAway","ToZero","AwayFromZero","ToNegativeInf","ToPositiveInf","Accuracy","Below","Exact","Above","ParseFloat(${1:s}, ${2:base}, ${3:prec}, ${4:mode})","Int{}","NewInt(${1:x})","Jacobi(${1:x}, ${2:y})","MaxBase","Rat{}","NewRat(${1:a}, ${2:b})","UintSize","LeadingZeros(${1:x})","LeadingZeros8(${1:x})","LeadingZeros16(${1:x})","LeadingZeros32(${1:x})","LeadingZeros64(${1:x})","TrailingZeros(${1:x})","TrailingZeros8(${1:x})","TrailingZeros16(${1:x})","TrailingZeros32(${1:x})","TrailingZeros64(${1:x})","OnesCount(${1:x})","OnesCount8(${1:x})","OnesCount16(${1:x})","OnesCount32(${1:x})","OnesCount64(${1:x})","RotateLeft(${1:x}, ${2:k})","RotateLeft8(${1:x}, ${2:k})","RotateLeft16(${1:x}, ${2:k})","RotateLeft32(${1:x}, ${2:k})","RotateLeft64(${1:x}, ${2:k})","Reverse(${1:x})","Reverse8(${1:x})","Reverse16(${1:x})","Reverse32(${1:x})","Reverse64(${1:x})","ReverseBytes(${1:x})","ReverseBytes16(${1:x})","ReverseBytes32(${1:x})","ReverseBytes64(${1:x})","Len(${1:x})","Len8(${1:x})","Len16(${1:x})","Len32(${1:x})","Len64(${1:x})","Add(${1:x}, ${2:y}, ${3:carry})","Add32(${1:x}, ${2:y}, ${3:carry})","Add64(${1:x}, ${2:y}, ${3:carry})","Sub(${1:x}, ${2:y}, ${3:borrow})","Sub32(${1:x}, ${2:y}, ${3:borrow})","Sub64(${1:x}, ${2:y}, ${3:borrow})","Mul(${1:x}, ${2:y})","Mul32(${1:x}, ${2:y})","Mul64(${1:x}, ${2:y})","Div(${1:hi}, ${2:lo}, ${3:y})","Div32(${1:hi}, ${2:lo}, ${3:y})","Div64(${1:hi}, ${2:lo}, ${3:y})","Rem(${1:hi}, ${2:lo}, ${3:y})","Rem32(${1:hi}, ${2:lo}, ${3:y})","Rem64(${1:hi}, ${2:lo}, ${3:y})","Abs(${1:x})","Asin(${1:x})","Asinh(${1:x})","Acos(${1:x})","Acosh(${1:x})","Atan(${1:x})","Atanh(${1:x})","Conj(${1:x})","Exp(${1:x})","IsInf(${1:x})","Inf()","IsNaN(${1:x})","NaN()","Log(${1:x})","Log10(${1:x})","Phase(${1:x})","Polar(${1:x})","Pow(${1:x}, ${2:y})","Rect(${1:r}, ${2:θ})","Sin(${1:x})","Sinh(${1:x})","Cos(${1:x})","Cosh(${1:x})","Sqrt(${1:x})","Tan(${1:x})","Tanh(${1:x})","Cot(${1:x})","Source","Source64","NewSource(${1:seed})","Rand{}","New(${1:src})","Seed(${1:seed})","Int63()","Uint32()","Uint64()","Int31()","Int()","Int63n(${1:n})","Int31n(${1:n})","Intn(${1:n})","Float64()","Float32()","Perm(${1:n})","Shuffle(${1:n}, ${2:swap})","Read(${1:p})","NormFloat64()","ExpFloat64()","Zipf{}","NewZipf(${1:r}, ${2:s}, ${3:v}, ${4:imax})","ErrMessageTooLarge","Form{}","FileHeader{}","File","Part{}","NewReader(${1:r}, ${2:boundary})","Reader{}","Writer{}","NewWriter(${1:w})","Reader{}","NewReader(${1:r})","Writer{}","NewWriter(${1:w})","Client{}","DefaultClient","RoundTripper","ErrSchemeMismatch","Get(${1:url})","ErrUseLastResponse","Post(${1:url}, ${2:contentType}, ${3:body})","PostForm(${1:url}, ${2:data})","Head(${1:url})","Cookie{}","SameSite","SameSiteDefaultMode","SameSiteLaxMode","SameSiteStrictMode","SameSiteNoneMode","ParseCookie(${1:line})","ParseSetCookie(${1:line})","SetCookie(${1:w}, ${2:cookie})","NewFileTransport(${1:fs})","NewFileTransportFS(${1:fsys})","Dir","FileSystem","File","ServeContent(${1:w}, ${2:req}, ${3:name}, ${4:modtime}, ${5:content})","ServeFile(${1:w}, ${2:r}, ${3:name})","ServeFileFS(${1:w}, ${2:r}, ${3:fsys}, ${4:name})","FS(${1:fsys})","FileServer(${1:root})","FileServerFS(${1:root})","Header","ParseTime(${1:text})","CanonicalHeaderKey(${1:s})","NoBody","PushOptions{}","Pusher","CookieJar","MethodGet","MethodHead","MethodPost","MethodPut","MethodPatch","MethodDelete","MethodConnect","MethodOptions","MethodTrace","ErrMissingFile","ProtocolError{}","ErrNotSupported","ErrUnexpectedTrailer","ErrMissingBoundary","ErrNotMultipart","ErrHeaderTooLong","ErrShortBody","ErrMissingContentLength","Request{}","ErrNoCookie","ParseHTTPVersion(${1:vers})","NewRequest(${1:method}, ${2:url}, ${3:body})","NewRequestWithContext(${1:ctx}, ${2:method}, ${3:url}, ${4:body})","ReadRequest(${1:b})","MaxBytesReader(${1:w}, ${2:r}, ${3:n})","MaxBytesError{}","Response{}","ErrNoLocation","ReadResponse(${1:r}, ${2:req})","ResponseController{}","NewResponseController(${1:rw})","ErrBodyNotAllowed","ErrHijacked","ErrContentLength","ErrWriteAfterFlush","Handler","ResponseWriter","Flusher","Hijacker","CloseNotifier","ServerContextKey","LocalAddrContextKey","TrailerPrefix","DefaultMaxHeaderBytes","TimeFormat","ErrAbortHandler","HandlerFunc","Error(${1:w}, ${2:error}, ${3:code})","NotFound(${1:w}, ${2:r})","NotFoundHandler()","StripPrefix(${1:prefix}, ${2:h})","Redirect(${1:w}, ${2:r}, ${3:url}, ${4:code})","RedirectHandler(${1:url}, ${2:code})","ServeMux{}","NewServeMux()","DefaultServeMux","Handle(${1:pattern}, ${2:handler})","HandleFunc(${1:pattern}, ${2:handler})","Serve(${1:l}, ${2:handler})","ServeTLS(${1:l}, ${2:handler}, ${3:certFile}, ${4:keyFile})","Server{}","ConnState","StateNew","StateActive","StateIdle","StateHijacked","StateClosed","AllowQuerySemicolons(${1:h})","ErrServerClosed","ListenAndServe(${1:addr}, ${2:handler})","ListenAndServeTLS(${1:addr}, ${2:certFile}, ${3:keyFile}, ${4:handler})","TimeoutHandler(${1:h}, ${2:dt}, ${3:msg})","ErrHandlerTimeout","MaxBytesHandler(${1:h}, ${2:n})","DetectContentType(${1:data})","StatusContinue","StatusSwitchingProtocols","StatusProcessing","StatusEarlyHints","StatusOK","StatusCreated","StatusAccepted","StatusNonAuthoritativeInfo","StatusNoContent","StatusResetContent","StatusPartialContent","StatusMultiStatus","StatusAlreadyReported","StatusIMUsed","StatusMultipleChoices","StatusMovedPermanently","StatusFound","StatusSeeOther","StatusNotModified","StatusUseProxy","StatusTemporaryRedirect","StatusPermanentRedirect","StatusBadRequest","StatusUnauthorized","StatusPaymentRequired","StatusForbidden","StatusNotFound","StatusMethodNotAllowed","StatusNotAcceptable","StatusProxyAuthRequired","StatusRequestTimeout","StatusConflict","StatusGone","StatusLengthRequired","StatusPreconditionFailed","StatusRequestEntityTooLarge","StatusRequestURITooLong","StatusUnsupportedMediaType","StatusRequestedRangeNotSatisfiable","StatusExpectationFailed","StatusTeapot","StatusMisdirectedRequest","StatusUnprocessableEntity","StatusLocked","StatusFailedDependency","StatusTooEarly","StatusUpgradeRequired","StatusPreconditionRequired","StatusTooManyRequests","StatusRequestHeaderFieldsTooLarge","StatusUnavailableForLegalReasons","StatusInternalServerError","StatusNotImplemented","StatusBadGateway","StatusServiceUnavailable","StatusGatewayTimeout","StatusHTTPVersionNotSupported","StatusVariantAlsoNegotiates","StatusInsufficientStorage","StatusLoopDetected","StatusNotExtended","StatusNetworkAuthenticationRequired","StatusText(${1:code})","ErrLineTooLong","ErrBodyReadAfterClose","DefaultTransport","DefaultMaxIdleConnsPerHost","Transport{}","ProxyFromEnvironment(${1:req})","ProxyURL(${1:fixedURL})","ErrSkipAltProtocol","Message{}","ReadMessage(${1:r})","ParseDate(${1:date})","Header","ErrHeaderNotPresent","Address{}","ParseAddress(${1:address})","ParseAddressList(${1:list})","AddressParser{}","Addr{}","IPv6LinkLocalAllNodes()","IPv6LinkLocalAllRouters()","IPv6Loopback()","IPv6Unspecified()","IPv4Unspecified()","AddrFrom4(${1:addr})","AddrFrom16(${1:addr})","ParseAddr(${1:s})","MustParseAddr(${1:s})","AddrFromSlice(${1:slice})","AddrPort{}","AddrPortFrom(${1:ip}, ${2:port})","ParseAddrPort(${1:s})","MustParseAddrPort(${1:s})","Prefix{}","PrefixFrom(${1:ip}, ${2:bits})","ParsePrefix(${1:s})","MustParsePrefix(${1:s})","ServerError","ErrShutdown","Call{}","Client{}","ClientCodec","NewClient(${1:conn})","NewClientWithCodec(${1:codec})","DialHTTP(${1:network}, ${2:address})","DialHTTPPath(${1:network}, ${2:address}, ${3:path})","Dial(${1:network}, ${2:address})","DefaultRPCPath","DefaultDebugPath","Request{}","Response{}","Server{}","NewServer()","DefaultServer","Register(${1:rcvr})","RegisterName(${1:name}, ${2:rcvr})","ServerCodec","ServeConn(${1:conn})","ServeCodec(${1:codec})","ServeRequest(${1:codec})","Accept(${1:lis})","HandleHTTP()","Auth","ServerInfo{}","PlainAuth(${1:identity}, ${2:username}, ${3:password}, ${4:host})","CRAMMD5Auth(${1:username}, ${2:secret})","Client{}","Dial(${1:addr})","NewClient(${1:conn}, ${2:host})","SendMail(${1:addr}, ${2:a}, ${3:from}, ${4:to}, ${5:msg})","MIMEHeader","Pipeline{}","Reader{}","NewReader(${1:r})","CanonicalMIMEHeaderKey(${1:s})","Error{}","ProtocolError","Conn{}","NewConn(${1:conn})","Dial(${1:network}, ${2:addr})","TrimString(${1:s})","TrimBytes(${1:b})","Writer{}","NewWriter(${1:w})","Error{}","EscapeError","InvalidHostError","QueryUnescape(${1:s})","PathUnescape(${1:s})","QueryEscape(${1:s})","PathEscape(${1:s})","URL{}","User(${1:username})","UserPassword(${1:username}, ${2:password})","Userinfo{}","Parse(${1:rawURL})","ParseRequestURI(${1:rawURL})","Values","ParseQuery(${1:query})","JoinPath(${1:base}, ${2:elem})","Error{}","ErrWaitDelay","Cmd{}","Command(${1:name}, ${2:arg})","CommandContext(${1:ctx}, ${2:name}, ${3:arg})","ExitError{}","ErrDot","ErrNotFound","LookPath(${1:file})","Ignore(${1:sig})","Ignored(${1:sig})","Notify(${1:c}, ${2:sig})","Reset(${1:sig})","Stop(${1:c})","NotifyContext(${1:parent}, ${2:signals})","Current()","Lookup(${1:username})","LookupId(${1:uid})","LookupGroup(${1:name})","LookupGroupId(${1:gid})","User{}","Group{}","UnknownUserIdError","UnknownUserError","UnknownGroupIdError","UnknownGroupError","ErrBadPattern","Match(${1:pattern}, ${2:name})","Glob(${1:pattern})","Separator","ListSeparator","Clean(${1:path})","IsLocal(${1:path})","Localize(${1:path})","ToSlash(${1:path})","FromSlash(${1:path})","SplitList(${1:path})","Split(${1:path})","Join(${1:elem})","Ext(${1:path})","EvalSymlinks(${1:path})","IsAbs(${1:path})","Abs(${1:path})","Rel(${1:basepath}, ${2:targpath})","SkipDir","SkipAll","WalkFunc","WalkDir(${1:root}, ${2:fn})","Walk(${1:root}, ${2:fn})","Base(${1:path})","Dir(${1:path})","VolumeName(${1:path})","HasPrefix(${1:p}, ${2:prefix})","Compile(${1:re})","Error{}","ErrorCode","ErrInternalError","ErrInvalidCharClass","ErrInvalidCharRange","ErrInvalidEscape","ErrInvalidNamedCapture","ErrInvalidPerlOp","ErrInvalidRepeatOp","ErrInvalidRepeatSize","ErrInvalidUTF8","ErrMissingBracket","ErrMissingParen","ErrMissingRepeatArgument","ErrTrailingBackslash","ErrUnexpectedParen","ErrNestingDepth","ErrLarge","Flags","FoldCase","Literal","ClassNL","DotNL","OneLine","NonGreedy","PerlX","UnicodeGroups","WasDollar","Simple","MatchNL","Perl","POSIX","Parse(${1:s}, ${2:flags})","Prog{}","InstOp","InstAlt","InstAltMatch","InstCapture","InstEmptyWidth","InstMatch","InstFail","InstNop","InstRune","InstRune1","InstRuneAny","InstRuneAnyNotNL","EmptyOp","EmptyBeginLine","EmptyEndLine","EmptyBeginText","EmptyEndText","EmptyWordBoundary","EmptyNoWordBoundary","EmptyOpContext(${1:r1}, ${2:r2})","IsWordChar(${1:r})","Inst{}","Regexp{}","Op","OpNoMatch","OpEmptyMatch","OpLiteral","OpCharClass","OpAnyCharNotNL","OpAnyChar","OpBeginLine","OpEndLine","OpBeginText","OpEndText","OpWordBoundary","OpNoWordBoundary","OpCapture","OpStar","OpPlus","OpQuest","OpRepeat","OpConcat","OpAlternate","Incomplete{}","Handle","NewHandle(${1:v})","WriteMetaDir(${1:dir})","WriteMeta(${1:w})","WriteCountersDir(${1:dir})","WriteCounters(${1:w})","ClearCounters()","GCStats{}","ReadGCStats(${1:stats})","SetGCPercent(${1:percent})","FreeOSMemory()","SetMaxStack(${1:bytes})","SetMaxThreads(${1:threads})","SetPanicOnFault(${1:enabled})","WriteHeapDump(${1:fd})","SetTraceback(${1:level})","SetMemoryLimit(${1:limit})","ReadBuildInfo()","BuildInfo{}","Module{}","BuildSetting{}","ParseBuildInfo(${1:data})","PrintStack()","Stack()","CrashOptions{}","SetCrashOutput(${1:f}, ${2:opts})","Description{}","All()","Float64Histogram{}","Sample{}","Read(${1:m})","ValueKind","KindBad","KindUint64","KindFloat64","KindFloat64Histogram","Value{}","LabelSet{}","WithLabels(${1:ctx}, ${2:labels})","Labels(${1:args})","Label(${1:ctx}, ${2:key})","ForLabels(${1:ctx}, ${2:f})","Profile{}","NewProfile(${1:name})","Lookup(${1:name})","Profiles()","WriteHeapProfile(${1:w})","StartCPUProfile(${1:w})","StopCPUProfile()","SetGoroutineLabels(${1:ctx})","Do(${1:ctx}, ${2:labels}, ${3:f})","NewTask(${1:pctx}, ${2:taskType})","Task{}","Log(${1:ctx}, ${2:category}, ${3:message})","Logf(${1:ctx}, ${2:category}, ${3:format}, ${4:args})","WithRegion(${1:ctx}, ${2:regionType}, ${3:fn})","StartRegion(${1:ctx}, ${2:regionType})","Region{}","IsEnabled()","Start(${1:w})","Stop()","SwapInt32(${1:addr}, ${2:new})","SwapInt64(${1:addr}, ${2:new})","SwapUint32(${1:addr}, ${2:new})","SwapUint64(${1:addr}, ${2:new})","SwapUintptr(${1:addr}, ${2:new})","SwapPointer(${1:addr}, ${2:new})","CompareAndSwapInt32(${1:addr}, ${2:old}, ${3:new})","CompareAndSwapInt64(${1:addr}, ${2:old}, ${3:new})","CompareAndSwapUint32(${1:addr}, ${2:old}, ${3:new})","CompareAndSwapUint64(${1:addr}, ${2:old}, ${3:new})","CompareAndSwapUintptr(${1:addr}, ${2:old}, ${3:new})","CompareAndSwapPointer(${1:addr}, ${2:old}, ${3:new})","AddInt32(${1:addr}, ${2:delta})","AddUint32(${1:addr}, ${2:delta})","AddInt64(${1:addr}, ${2:delta})","AddUint64(${1:addr}, ${2:delta})","AddUintptr(${1:addr}, ${2:delta})","AndInt32(${1:addr}, ${2:mask})","AndUint32(${1:addr}, ${2:mask})","AndInt64(${1:addr}, ${2:mask})","AndUint64(${1:addr}, ${2:mask})","AndUintptr(${1:addr}, ${2:mask})","OrInt32(${1:addr}, ${2:mask})","OrUint32(${1:addr}, ${2:mask})","OrInt64(${1:addr}, ${2:mask})","OrUint64(${1:addr}, ${2:mask})","OrUintptr(${1:addr}, ${2:mask})","LoadInt32(${1:addr})","LoadInt64(${1:addr})","LoadUint32(${1:addr})","LoadUint64(${1:addr})","LoadUintptr(${1:addr})","LoadPointer(${1:addr})","StoreInt32(${1:addr}, ${2:val})","StoreInt64(${1:addr}, ${2:val})","StoreUint32(${1:addr}, ${2:val})","StoreUint64(${1:addr}, ${2:val})","StoreUintptr(${1:addr}, ${2:val})","StorePointer(${1:addr}, ${2:val})","Bool{}","Pointer{}","Int32{}","Int64{}","Uint32{}","Uint64{}","Uintptr{}","Value{}","Func{}","FuncOf(${1:fn})","Value{}","Error{}","Undefined()","Null()","Global()","ValueOf(${1:x})","Type","TypeUndefined","TypeNull","TypeBoolean","TypeNumber","TypeString","TypeSymbol","TypeObject","TypeFunction","ValueError{}","CopyBytesToGo(${1:dst}, ${2:src})","CopyBytesToJS(${1:dst}, ${2:src})","MapFS","MapFile{}","TestFS(${1:fsys}, ${2:expected})","NewWriteLogger(${1:prefix}, ${2:w})","NewReadLogger(${1:prefix}, ${2:r})","OneByteReader(${1:r})","HalfReader(${1:r})","DataErrReader(${1:r})","ErrTimeout","TimeoutReader(${1:r})","ErrReader(${1:err})","TestReader(${1:r}, ${2:content})","TruncateWriter(${1:w}, ${2:n})","Generator","Value(${1:t}, ${2:rand})","Config{}","SetupError","CheckError{}","CheckEqualError{}","Check(${1:f}, ${2:config})","CheckEqual(${1:f}, ${2:g}, ${3:config})","TestHandler(${1:h}, ${2:results})","Run(${1:t}, ${2:newHandler}, ${3:result})","Position{}","ScanIdents","ScanInts","ScanFloats","ScanChars","ScanStrings","ScanRawStrings","ScanComments","SkipComments","GoTokens","EOF","Ident","Int","Float","Char","String","RawString","Comment","TokenString(${1:tok})","GoWhitespace","Scanner{}","Writer{}","FilterHTML","StripEscape","AlignRight","DiscardEmptyColumns","TabIndent","Debug","Escape","NewWriter(${1:output}, ${2:minwidth}, ${3:tabwidth}, ${4:padding}, ${5:padchar}, ${6:flags})","ExecError{}","IsTrue(${1:val})","FuncMap","HTMLEscape(${1:w}, ${2:b})","HTMLEscapeString(${1:s})","HTMLEscaper(${1:args})","JSEscape(${1:w}, ${2:b})","JSEscapeString(${1:s})","JSEscaper(${1:args})","URLQueryEscaper(${1:args})","Must(${1:t}, ${2:err})","ParseFiles(${1:filenames})","ParseGlob(${1:pattern})","ParseFS(${1:fsys}, ${2:patterns})","Template{}","New(${1:name})","IsSurrogate(${1:r})","DecodeRune(${1:r1}, ${2:r2})","EncodeRune(${1:r})","RuneLen(${1:r})","Encode(${1:s})","AppendRune(${1:a}, ${2:r})","Decode(${1:s})","RuneError","RuneSelf","MaxRune","UTFMax","FullRune(${1:p})","FullRuneInString(${1:s})","DecodeRune(${1:p})","DecodeRuneInString(${1:s})","DecodeLastRune(${1:p})","DecodeLastRuneInString(${1:s})","RuneLen(${1:r})","EncodeRune(${1:p}, ${2:r})","AppendRune(${1:p}, ${2:r})","RuneCount(${1:p})","RuneCountInString(${1:s})","RuneStart(${1:b})","Valid(${1:p})","ValidString(${1:s})","ValidRune(${1:r})","AlgorithmIdentifier{}","RDNSequence","RelativeDistinguishedNameSET","AttributeTypeAndValue{}","AttributeTypeAndValueSET{}","Extension{}","Name{}","CertificateList{}","TBSCertificateList{}","RevokedCertificate{}","Value","NamedValue{}","Driver","DriverContext","Connector","ErrSkip","ErrBadConn","Pinger","Execer","ExecerContext","Queryer","QueryerContext","Conn","ConnPrepareContext","IsolationLevel","TxOptions{}","ConnBeginTx","SessionResetter","Validator","Result","Stmt","StmtExecContext","StmtQueryContext","ErrRemoveArgument","NamedValueChecker","ColumnConverter","Rows","RowsNextResultSet","RowsColumnTypeScanType","RowsColumnTypeDatabaseTypeName","RowsColumnTypeLength","RowsColumnTypeNullable","RowsColumnTypePrecisionScale","Tx","RowsAffected","ResultNoRows","ValueConverter","Valuer","Bool","Int32","String","Null{}","NotNull{}","IsValue(${1:v})","IsScanValue(${1:v})","DefaultParameterConverter","Expr","TagExpr{}","NotExpr{}","AndExpr{}","OrExpr{}","SyntaxError{}","Parse(${1:line})","IsGoBuild(${1:line})","IsPlusBuild(${1:line})","PlusBuildLines(${1:x})","GoVersion(${1:x})","Doc{}","LinkDef{}","Block","Heading{}","List{}","ListItem{}","Paragraph{}","Code{}","Text","Plain","Italic","Link{}","DocLink{}","Parser{}","DefaultLookupPackage(${1:name})","Printer{}","Plan9","WebSafe","ChaCha8{}","NewChaCha8(${1:seed})","PCG{}","NewPCG(${1:seed1}, ${2:seed2})","Source","Rand{}","New(${1:src})","Int64()","Uint32()","Uint64N(${1:n})","Uint32N(${1:n})","Uint64()","Int32()","Int()","Uint()","Int64N(${1:n})","Int32N(${1:n})","IntN(${1:n})","UintN(${1:n})","N[${1:Int}](${2:n})","Float64()","Float32()","Perm(${1:n})","Shuffle(${1:n}, ${2:swap})","NormFloat64()","ExpFloat64()","Zipf{}","NewZipf(${1:r}, ${2:s}, ${3:v}, ${4:imax})","Request()","RequestFromMap(${1:params})","Serve(${1:handler})","Handler{}","PublicSuffixList","Options{}","Jar{}","New(${1:o})","ErrRequestAborted","ErrConnClosed","Serve(${1:l}, ${2:handler})","ProcessEnv(${1:r})","NewRequest(${1:method}, ${2:target}, ${3:body})","NewRequestWithContext(${1:ctx}, ${2:method}, ${3:target}, ${4:body})","ResponseRecorder{}","NewRecorder()","DefaultRemoteAddr","Server{}","NewServer(${1:handler})","NewUnstartedServer(${1:handler})","NewTLSServer(${1:handler})","ContextClientTrace(${1:ctx})","WithClientTrace(${1:ctx}, ${2:trace})","ClientTrace{}","WroteRequestInfo{}","DNSStartInfo{}","DNSDoneInfo{}","GotConnInfo{}","DumpRequestOut(${1:req}, ${2:body})","DumpRequest(${1:req}, ${2:body})","DumpResponse(${1:resp}, ${2:body})","NewChunkedReader(${1:r})","NewChunkedWriter(${1:w})","ErrLineTooLong","ErrPersistEOF","ErrClosed","ErrPipeline","ServerConn{}","NewServerConn(${1:c}, ${2:r})","ClientConn{}","NewClientConn(${1:c}, ${2:r})","NewProxyClientConn(${1:c}, ${2:r})","ProxyRequest{}","ReverseProxy{}","BufferPool","NewSingleHostReverseProxy(${1:target})","Cmdline(${1:w}, ${2:r})","Profile(${1:w}, ${2:r})","Trace(${1:w}, ${2:r})","Symbol(${1:w}, ${2:r})","Handler(${1:name})","Index(${1:w}, ${2:r})","NewClientCodec(${1:conn})","NewClient(${1:conn})","Dial(${1:network}, ${2:address})","NewServerCodec(${1:conn})","ServeConn(${1:conn})","Node","NodeType","Pos","NodeText","NodeAction","NodeBool","NodeChain","NodeCommand","NodeDot","NodeField","NodeIdentifier","NodeIf","NodeList","NodeNil","NodeNumber","NodePipe","NodeRange","NodeString","NodeTemplate","NodeVariable","NodeWith","NodeComment","NodeBreak","NodeContinue","ListNode{}","TextNode{}","CommentNode{}","PipeNode{}","ActionNode{}","CommandNode{}","IdentifierNode{}","NewIdentifier(${1:ident})","VariableNode{}","DotNode{}","NilNode{}","FieldNode{}","ChainNode{}","BoolNode{}","NumberNode{}","StringNode{}","BranchNode{}","IfNode{}","BreakNode{}","ContinueNode{}","RangeNode{}","WithNode{}","TemplateNode{}","Tree{}","Mode","ParseComments","SkipFuncCheck","Parse(${1:name}, ${2:text}, ${3:leftDelim}, ${4:rightDelim}, ${5:funcs})","New(${1:name}, ${2:funcs})","IsEmptyTree(${1:n})","KeySize","NonceSize","NonceSizeX","Cipher{}","NewUnauthenticatedCipher(${1:key}, ${2:nonce})","HChaCha20(${1:key}, ${2:nonce})","KeySize","NonceSize","NonceSizeX","Overhead","New(${1:key})","NewX(${1:key})","Builder{}","NewBuilder(${1:buffer})","NewFixedBuilder(${1:buffer})","BuilderContinuation","BuildError{}","MarshalingValue","String","Extract(${1:hash}, ${2:secret}, ${3:salt})","Expand(${1:hash}, ${2:pseudorandomKey}, ${3:info})","New(${1:hash}, ${2:secret}, ${3:salt}, ${4:info})","New224()","New256()","New384()","New512()","NewLegacyKeccak256()","NewLegacyKeccak512()","Sum224(${1:data})","Sum256(${1:data})","Sum384(${1:data})","Sum512(${1:data})","ShakeHash","NewShake128()","NewShake256()","NewCShake128(${1:N}, ${2:S})","NewCShake256(${1:N}, ${2:S})","ShakeSum128(${1:hash}, ${2:data})","ShakeSum256(${1:hash}, ${2:data})","ToASCII(${1:s})","ToUnicode(${1:s})","Option","Transitional(${1:transitional})","VerifyDNSLength(${1:verify})","RemoveLeadingDots(${1:remove})","ValidateLabels(${1:enable})","CheckHyphens(${1:enable})","CheckJoiners(${1:enable})","StrictDomainName(${1:use})","BidiRule()","ValidateForRegistration()","MapForLookup()","Profile{}","New(${1:o})","Punycode","Lookup","Display","Registration","UnicodeVersion","MakePipe","TestConn(${1:t}, ${2:mp})","SupportsIPv4()","SupportsIPv6()","SupportsRawSocket()","TestableNetwork(${1:network})","TestableAddress(${1:network}, ${2:address})","NewLocalListener(${1:network})","NewLocalPacketListener(${1:network})","LocalPath()","MulticastSource(${1:network}, ${2:ifi})","LoopbackInterface()","RoutedInterface(${1:network}, ${2:flags})","Initialized","CacheLinePad{}","X86","ARM64","ARM","MIPS64X","PPC64","S390X","IsBigEndian","ErrShortDst","ErrShortSrc","ErrEndOfSpan","Transformer","SpanningTransformer","NopResetter{}","Reader{}","NewReader(${1:r}, ${2:t})","Writer{}","NewWriter(${1:w}, ${2:t})","Discard","Nop","Chain(${1:t})","RemoveFunc(${1:f})","String(${1:t}, ${2:s})","Bytes(${1:t}, ${2:b})","Append(${1:t}, ${2:dst}, ${3:src})","Tag","BOOLEAN","INTEGER","BIT_STRING","OCTET_STRING","NULL","OBJECT_IDENTIFIER","ENUM","UTF8String","SEQUENCE","SET","PrintableString","T61String","IA5String","UTCTime","GeneralizedTime","GeneralString","Type","TypeA","TypeNS","TypeCNAME","TypeSOA","TypePTR","TypeMX","TypeTXT","TypeAAAA","TypeSRV","TypeOPT","TypeWKS","TypeHINFO","TypeMINFO","TypeAXFR","TypeALL","Class","ClassINET","ClassCSNET","ClassCHAOS","ClassHESIOD","ClassANY","OpCode","RCode","RCodeSuccess","RCodeFormatError","RCodeServerFailure","RCodeNameError","RCodeNotImplemented","RCodeRefused","ErrNotStarted","ErrSectionDone","Header{}","Message{}","Resource{}","ResourceBody","Parser{}","Builder{}","NewBuilder(${1:buf}, ${2:h})","ResourceHeader{}","Name{}","NewName(${1:name})","MustNewName(${1:name})","Question{}","CNAMEResource{}","MXResource{}","NSResource{}","PTRResource{}","SOAResource{}","TXTResource{}","SRVResource{}","AResource{}","AAAAResource{}","OPTResource{}","Option{}","UnknownResource{}","ValidTrailerHeader(${1:name})","IsTokenRune(${1:r})","HeaderValuesContainsToken(${1:values}, ${2:token})","ValidHeaderFieldName(${1:v})","ValidHostHeader(${1:h})","ValidHeaderFieldValue(${1:v})","PunycodeHostPort(${1:v})","Config{}","FromEnvironment()","Encoder{}","NewEncoder(${1:w})","DecodingError{}","InvalidIndexError","HeaderField{}","Decoder{}","NewDecoder(${1:maxDynamicTableSize}, ${2:emitFunc})","ErrStringLength","HuffmanDecode(${1:w}, ${2:v})","HuffmanDecodeToString(${1:v})","ErrInvalidHuffman","AppendHuffmanString(${1:dst}, ${2:s})","HuffmanEncodeLength(${1:s})","ErrInvalid","Direction(${1:b})","DirectionString(${1:s})","Valid(${1:b})","ValidString(${1:s})","New()","Transformer{}","Direction","LeftToRight","RightToLeft","Mixed","Neutral","Option","DefaultDirection(${1:d})","Paragraph{}","Ordering{}","Run{}","AppendReverse(${1:out}, ${2:in})","ReverseString(${1:s})","Properties{}","LookupRune(${1:r})","Lookup(${1:s})","LookupString(${1:s})","UnicodeVersion","Class","L","R","EN","ES","ET","AN","CS","B","S","WS","ON","BN","NSM","AL","Control","LRO","RLO","LRE","RLE","PDF","LRI","RLI","FSI","PDI","GraphemeJoiner","Properties{}","MaxSegmentSize","Iter{}","Form","NFC","NFD","NFKC","NFKD","Version","MaxTransformChunkSize"],"insertTextRules":[0,0,0,0,0,4,4,0,4,4,0,4,0,0,0,0,0,0,0,4,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,0,4,4,4,0,0,0,4,4,0,4,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,4,4,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,4,4,4,4,4,4,4,4,4,0,0,0,4,4,0,4,4,4,0,0,4,0,0,4,0,0,0,0,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,0,4,0,0,4,4,0,4,4,4,4,0,0,0,4,0,0,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,4,0,4,4,4,4,0,4,4,0,4,4,0,0,0,4,4,4,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,4,0,4,4,4,4,0,0,4,4,4,4,4,4,4,4,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,0,0,4,0,4,0,4,4,0,4,4,4,0,4,0,4,0,4,4,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,4,4,4,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,0,0,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,4,4,4,4,4,4,0,4,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,4,4,4,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,0,0,4,4,4,4,0,0,4,4,4,4,4,0,0,0,4,0,4,4,4,4,4,0,4,4,0,0,4,4,4,4,0,0,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,0,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,4,0,0,0,0,4,4,4,0,0,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,4,0,4,0,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,0,4,4,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,4,4,4,4,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,4,0,4,0,0,4,4,0,4,0,0,4,4,4,4,4,0,0,0,4,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,0,4,4,4,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,0,0,0,4,4,4,0,0,4,0,0,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,0,4,4,0,0,4,4,0,0,0,4,0,4,0,4,0,0,0,0,0,4,4,0,0,0,0,0,0,0,4,4,0,0,0,0,4,0,0,0,0,0,0,4,4,0,0,0,0,4,0,4,0,0,0,0,4,4,0,0,0,0,0,0,4,4,4,0,4,4,4,4,4,0,0,4,0,4,0,0,4,4,4,4,4,0,0,0,4,0,4,4,4,0,0,4,0,0,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,4,4,4,4,0,0,4,4,4,4,4,0,0,0,0,0,0,0,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,0,4,4,0,0,4,4,0,4,4,4,0,0,4,0,4,4,4,4,4,0,0,0,4,4,0,0,0,0,0,4,4,0,4,0,0,4,0,0,4,4,0,0,0,4,4,4,4,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,4,0,4,4,4,4,4,4,4,0,4,4,0,4,4,0,4,4,4,4,4,0,0,0,0,0,0,4,0,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,4,4,0,0,4,4,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,4,4,4,4,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,4,4,4,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,0,0,4,0,4,0,0,0,4,0,0,0,0,4,0,4,0,0,0,0,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,4,0,4,0,4,0,4,0,0,0,4,4,4,4,4,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,4,4,0,0,0,0,0,4,4,4,4,0,0,4,0,4,0,0,0,0,4,4,4,0,4,0,0,4,0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,4,4,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,4,4,4,0,4,4,4,0,0,0,0,4,4,0,4,4,4,0,4,0,4,0,4,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,4,4,0,4,4,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,4,4,0,4,0,4,4,0,4,4,0,4,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,4,0,0,4,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,0,4,4,4,4,4,4,0,4,4,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,4,4,0,4,0,4,0,0,4,0,4,0,4,4,4,4,0,4,0,0,0,0,0,4,0,4,4,0,0,4,0,4,0,4,0,4,0,0,0,0,4,0,4,4,4,4,0,4,0,4,0,0,0,4,4,4,4,0,4,4,0,0,0,0,0,0,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,4,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,0,4,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,0,4,4,0,4,4,0,0,0,4,4,0,0,4,0,0,4,4,0,0,0,0,0,0,0,0,4,0,4,4,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,0,4,0,4,0,4,0,0,0,4,4,4,4,4,4,0,4,4,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,4,0,0,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,0,0,0,0,0,4,0,0,4,0,4,0,4,0,0,0,0,4,0,4,4,4,0,0,0,0,0,0,4,4,4,4,4,0,0,0,4,4,4,4,4,4,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,0,0,0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,4,0,4,4,4,4,0,0,0,0,0,0,0,4,0,4,4,4,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,4,4,0,0,4,4,0,0,0,4,4,0,0,4,4,4,4,4,4,4,4,4,4,0,4,4,4,0,4,4,4,0,0,0,0,0,4,4,4,4,4,0,0,0,0,0,4,0,4,4,0,4,4,4,4,4,0,0,4,4,0,4,4,4,0,0,0,4,4,0,0,0,4,4,4,4,0,4,0,0,0,4,4,4,4,0,4,4,0,4,4,0,4,4,0,0,0,4,4,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,4,4,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,0,0,0,4,4,4,0,4,0,4,0,0,4,0,0,0,0,0,0,0,4,4,4,4,0,4,4,4,4,4,4,4,4,4,0,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,4,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,4,4,4,4,4,4,0,4,4,4,4,0,4,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,4,0,4,0,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,4,0,4,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,0,0,0,0,4,0,0,4,4,4,4,0,4,0,0,4,4,4,4,4,0,0,0,0,0,4,4,4,4,4,0,0,0,0,0,4,0,4,4,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,0,4,4,0,0,0,0,4,4,0,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,0,4,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,0,0,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,0,4,0,4,0,0,0,0,4,0,4,4,0,4,4,0,4,4,4,4,4,0,0,0,0,0,0,0,4,0,0,0,4,4,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"kinds":[4,4,4,4,6,1,1,6,1,1,6,1,6,5,4,4,4,4,14,1,4,1,1,1,1,5,14,14,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,14,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,6,4,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,7,1,1,1,7,4,4,1,1,5,1,5,1,1,1,1,1,1,1,1,1,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,5,5,7,7,7,5,6,7,7,7,7,1,4,1,1,1,1,7,6,6,6,6,6,5,1,1,1,1,1,1,1,1,4,7,7,5,14,14,14,6,6,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,1,1,7,7,1,1,1,1,1,1,1,1,1,7,7,7,1,1,4,1,1,1,6,4,1,6,4,1,6,7,7,7,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,4,4,4,4,6,1,5,14,14,14,14,14,14,6,1,6,1,14,14,14,4,4,4,4,4,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,6,1,6,6,1,1,4,1,1,1,1,4,6,6,1,5,5,1,1,14,14,14,14,14,14,14,14,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,14,14,6,1,4,1,1,1,1,6,1,1,6,1,1,6,6,6,1,1,1,6,5,14,14,14,14,14,14,1,1,1,1,14,14,5,5,6,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,6,1,6,1,1,1,1,4,6,1,1,1,1,1,1,1,1,1,5,1,7,7,7,7,7,4,6,6,6,5,5,6,6,4,5,1,6,1,1,6,6,1,6,1,6,1,1,6,1,1,1,6,1,6,1,6,1,1,5,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,5,6,1,1,1,1,1,4,6,6,7,1,1,1,1,4,4,6,1,4,4,4,14,14,14,14,14,14,14,14,14,14,14,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,14,1,1,1,1,1,1,1,14,14,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,6,5,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,4,1,1,1,1,1,1,1,1,6,1,5,1,1,1,7,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,6,6,5,1,1,1,1,1,1,1,1,1,1,6,6,6,6,6,1,1,1,5,14,14,14,6,1,1,1,1,1,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,1,14,1,1,1,1,1,1,7,6,1,1,1,1,14,14,1,1,1,1,1,6,4,6,1,6,1,1,1,1,1,6,1,1,6,6,1,1,1,1,6,6,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,1,1,1,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,4,4,6,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,1,6,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,6,1,6,6,7,6,1,1,1,6,6,6,1,1,1,1,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,4,1,1,1,1,6,6,1,1,1,1,1,1,1,1,1,1,7,7,6,1,6,1,6,1,1,1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,14,1,1,1,5,1,1,6,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,5,5,1,1,1,1,4,7,6,6,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,6,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,6,6,6,6,6,6,6,14,14,6,6,6,14,6,6,6,6,6,6,6,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,6,6,6,1,6,1,6,6,1,1,6,1,6,6,1,1,1,1,1,7,6,6,1,6,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,1,1,1,1,6,1,1,1,6,1,1,6,5,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,5,14,14,14,14,14,14,1,1,1,1,1,1,1,6,4,4,1,1,1,4,4,1,4,4,1,1,1,1,1,1,1,1,1,1,1,14,14,14,14,6,6,6,6,5,14,14,14,14,14,1,1,1,1,1,1,1,1,1,14,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,6,1,5,5,5,1,1,1,1,1,1,1,1,4,4,4,4,4,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,1,7,5,14,14,14,14,6,1,6,1,4,4,4,4,6,6,6,1,1,5,5,1,1,14,14,6,1,6,1,5,1,14,14,14,14,14,1,1,6,5,5,6,6,7,7,1,1,4,4,6,6,1,14,14,14,14,14,6,1,1,5,14,14,6,1,6,1,4,4,4,7,1,1,14,14,14,14,14,6,1,1,1,7,1,1,1,1,1,6,6,1,6,1,14,5,1,1,1,1,1,7,7,7,1,7,1,1,1,6,6,1,14,5,1,1,6,6,6,4,5,14,14,14,14,1,1,1,1,7,6,6,1,1,1,1,6,6,1,1,1,1,1,14,14,14,14,5,5,6,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,6,1,1,14,14,1,1,4,1,1,1,6,5,1,6,1,1,1,1,1,14,14,6,1,1,6,6,6,6,6,1,1,4,1,4,4,1,14,14,1,1,14,14,14,1,1,1,1,14,14,14,14,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,6,1,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,5,14,14,14,14,6,5,14,14,14,14,14,7,5,14,14,14,14,14,14,14,14,14,14,14,14,6,6,5,14,14,14,6,6,1,6,6,6,6,5,14,14,14,14,6,6,5,14,14,14,14,14,14,14,14,14,14,6,1,1,6,6,1,6,1,1,1,1,1,1,1,6,1,1,6,1,1,6,1,1,1,1,1,5,14,14,14,14,14,1,4,1,1,1,1,1,1,1,1,1,1,1,5,14,14,14,14,14,14,14,14,14,14,6,6,6,6,6,1,1,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,4,5,6,6,1,1,1,6,1,1,6,6,1,1,1,6,1,5,14,14,14,14,14,14,14,14,6,5,6,6,6,6,6,6,6,6,6,7,6,4,6,1,1,6,4,6,6,4,6,6,6,6,7,5,1,1,6,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,6,6,6,6,6,4,6,1,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,14,14,14,14,14,14,14,14,5,14,14,5,14,14,14,5,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,5,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,6,6,6,6,6,1,1,1,6,14,1,1,1,1,6,6,6,6,6,6,6,1,1,1,6,14,6,6,6,6,6,6,6,6,1,1,4,6,6,1,6,6,6,6,1,5,6,6,6,6,6,4,1,1,6,7,5,6,6,6,6,6,6,6,6,6,6,6,1,1,6,14,14,14,5,14,14,14,14,5,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,6,6,6,6,6,6,6,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,6,6,6,6,5,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,6,1,1,6,6,6,6,6,6,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,6,6,14,14,14,14,14,14,14,14,5,14,6,6,6,14,14,14,14,14,14,6,6,6,6,6,1,1,4,14,14,14,14,1,1,1,5,1,1,6,6,6,4,4,5,5,5,6,5,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,1,6,14,14,1,4,4,1,5,1,6,14,14,1,4,4,4,4,1,5,1,7,7,4,4,1,1,1,1,1,1,4,14,14,14,1,1,1,1,1,1,1,1,6,4,4,4,4,6,1,6,1,6,1,6,1,6,7,7,1,1,1,1,1,4,5,1,1,1,1,1,1,1,1,1,1,7,6,6,6,5,1,1,7,6,6,6,6,1,1,1,1,6,6,1,6,1,5,5,5,6,1,1,1,14,1,7,7,1,6,1,6,1,5,7,7,6,6,6,6,5,6,6,5,5,6,5,1,7,6,1,1,4,4,1,1,7,7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,14,14,6,6,6,6,6,6,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,6,6,6,6,6,6,6,6,1,1,5,1,1,1,5,1,1,1,5,14,14,14,1,1,5,1,1,1,5,1,6,1,6,1,5,14,14,14,14,14,14,14,7,1,1,1,6,4,5,14,14,14,14,6,6,6,6,1,1,4,1,1,5,14,14,14,14,14,14,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,6,6,6,6,5,14,14,14,1,1,6,1,5,1,1,4,1,1,5,1,1,1,5,14,14,14,14,14,14,14,14,1,1,1,1,5,14,14,14,14,6,6,1,6,5,1,5,6,5,14,6,5,14,6,6,1,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,1,1,1,6,1,1,6,6,7,5,7,6,6,6,6,6,1,1,1,1,1,1,1,6,1,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,6,6,5,14,14,14,1,6,1,6,1,1,1,1,1,1,6,1,1,1,1,6,1,6,1,6,1,7,1,6,1,6,1,6,1,6,1,1,1,6,1,6,1,6,6,1,6,1,6,1,1,1,1,6,1,5,14,14,14,6,1,6,1,1,7,6,1,6,1,6,1,6,1,7,6,6,6,1,5,1,1,1,1,6,1,5,1,4,4,4,1,1,1,1,14,1,1,14,14,14,14,5,4,1,1,1,1,1,1,14,14,14,5,1,1,1,1,1,1,1,1,1,1,6,1,1,6,1,5,5,5,5,5,5,5,6,5,14,14,14,14,14,14,14,14,14,14,14,14,14,1,1,1,1,1,1,1,6,1,5,1,1,1,1,1,7,6,6,6,6,6,6,6,6,7,1,4,4,4,4,4,4,4,4,5,4,4,4,4,1,1,6,4,6,4,1,1,6,4,7,7,7,5,14,14,7,4,1,1,14,14,14,1,6,1,1,6,1,1,5,5,7,1,1,14,6,1,5,5,1,1,6,7,5,5,14,14,14,14,1,6,1,1,1,7,1,7,7,7,4,4,4,4,4,7,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,7,1,7,1,1,7,1,7,1,7,1,4,4,5,1,1,1,1,1,1,4,1,1,6,1,1,1,1,1,1,1,1,1,1,7,6,14,14,14,14,6,1,5,14,14,14,14,6,7,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,6,6,1,6,5,14,14,14,14,14,14,14,14,14,14,1,1,1,1,1,1,1,1,1,1,7,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,1,1,1,5,6,6,1,14,14,14,5,14,14,14,14,14,14,5,14,14,14,1,6,1,1,14,6,1,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,7,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,4,6,6,7,6,1,6,6,1,6,1,6,1,6,4,7,4,1,4,1,1,1,6,5,14,14,14,14,1,1,1,1,1,5,7,7,1,1,1,1,1,1,5,1,1,4,6,7,7,14,14,14,14,14,14,14,14,14,4,6,4,4,4,4,4,4,4,6,4,1,1,1,1,1,6,6,4,1,6,1,4,4,4,4,7,7,7,7,7,4,4,14,14,14,4,5,1,1,1,1,1,1,6,1,4,1,1,1,1,6,5,14,14,14,14,14,1,4,1,1,1,4,1,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,4,4,4,14,6,1,1,4,6,1,1,5,4,6,1,1,6,6,1,1,1,1,1,1,1,1,1,1,6,1,1,1,6,1,1,1,5,4,6,6,7,1,1,1,1,1,14,14,6,6,6,1,4,1,1,7,1,1,1,1,1,7,6,1,1,6,1,1,1,5,6,6,1,1,6,5,6,1,1,1,1,6,1,6,5,5,1,1,1,1,6,1,1,6,1,1,5,1,1,6,4,6,1,1,6,4,4,1,1,1,1,1,1,1,1,1,1,1,1,6,6,5,5,5,5,4,1,1,14,14,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,5,1,1,1,1,1,1,1,6,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,1,6,5,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,1,1,6,6,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,5,1,1,1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,6,6,6,1,1,1,6,1,6,1,6,6,1,5,14,14,14,14,6,6,1,1,1,1,6,1,1,1,1,1,1,1,1,1,6,1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,6,6,6,6,6,6,6,6,1,6,6,1,1,1,1,5,14,14,14,14,14,14,14,14,6,1,1,5,6,1,1,1,1,1,1,4,1,1,1,1,7,1,6,5,6,6,1,1,1,1,6,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,1,14,6,6,14,14,14,14,14,14,14,1,6,1,5,1,1,1,1,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,1,14,14,14,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,5,5,6,6,6,6,6,6,6,5,6,7,7,7,4,4,7,7,7,7,7,7,7,5,6,7,7,7,7,7,7,7,4,7,7,7,7,7,7,7,7,7,7,5,4,7,7,4,4,4,6,6,1,1,4,7,6,6,6,6,6,1,1,1,1,1,6,6,7,6,6,6,6,6,7,5,5,6,6,6,1,6,4,4,6,1,6,1,7,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,1,1,1,6,7,6,6,1,4,4,1,1,1,1,6,1,14,6,1,1,1,1,1,6,6,6,6,6,1,1,1,1,1,4,4,4,4,6,1,6,1,1,6,6,7,1,1,1,1,1,1,1,1,1,1,1,1,7,5,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,6,6,6,6,6,6,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,14,14,1,1,1,14,14,14,6,1,1,14,14,14,14,1,1,6,1,1,5,6,7,5,1,1,1,1,1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,5,1,1,1,1,1,1,1,1,1,1,6,1,4,4,4,4,14,5,1,1,1,1,1,1,1,1,1,1,1,1,4,6,4,4,4,4,4,4,14,4,4,4,7,7,6,6,1,6,1,4,4,1,1,1,1,1,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,5,14,14,14,14,14,5,5,14,14,14,14,14,14,4,4,6,6,6,7,6,6,1,6,6,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1,6,1,6,1,6,5,6,6,1,4,1,1,4,1,1,4,1,1,1,1,1,6,5,14,14,14,14,5,1,6,6,6,1,1,6,1,1,1,14,5,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,6,14,6,5,14,14,14,14,14,14],"packages":[["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["bufio","bufio"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["builtin","builtin"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["bytes","bytes"],["cmp","cmp"],["cmp","cmp"],["cmp","cmp"],["cmp","cmp"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["context","context"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["crypto","crypto"],["embed","embed"],["encoding","encoding"],["encoding","encoding"],["encoding","encoding"],["encoding","encoding"],["errors","errors"],["errors","errors"],["errors","errors"],["errors","errors"],["errors","errors"],["errors","errors"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["expvar","expvar"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["flag","flag"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["fmt","fmt"],["hash","hash"],["hash","hash"],["hash","hash"],["html","html"],["html","html"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["image","image"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["io","io"],["iter","iter"],["iter","iter"],["iter","iter"],["iter","iter"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["log","log"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["maps","maps"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["math","math"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["mime","mime"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["net","net"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["os","os"],["path","path"],["path","path"],["path","path"],["path","path"],["path","path"],["path","path"],["path","path"],["path","path"],["path","path"],["plugin","plugin"],["plugin","plugin"],["plugin","plugin"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["reflect","reflect"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["regexp","regexp"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["runtime","runtime"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["slices","slices"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["sort","sort"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strconv","strconv"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["strings","strings"],["structs","structs"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["sync","sync"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["syscall","syscall"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["testing","testing"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["time","time"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unicode","unicode"],["unique","unique"],["unique","unique"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["unsafe","unsafe"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["tar","archive/tar"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["zip","archive/zip"],["bzip2","compress/bzip2"],["bzip2","compress/bzip2"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["flate","compress/flate"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["gzip","compress/gzip"],["lzw","compress/lzw"],["lzw","compress/lzw"],["lzw","compress/lzw"],["lzw","compress/lzw"],["lzw","compress/lzw"],["lzw","compress/lzw"],["lzw","compress/lzw"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["zlib","compress/zlib"],["heap","container/heap"],["heap","container/heap"],["heap","container/heap"],["heap","container/heap"],["heap","container/heap"],["heap","container/heap"],["list","container/list"],["list","container/list"],["list","container/list"],["ring","container/ring"],["ring","container/ring"],["aes","crypto/aes"],["aes","crypto/aes"],["aes","crypto/aes"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["cipher","crypto/cipher"],["des","crypto/des"],["des","crypto/des"],["des","crypto/des"],["des","crypto/des"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["dsa","crypto/dsa"],["ecdh","crypto/ecdh"],["ecdh","crypto/ecdh"],["ecdh","crypto/ecdh"],["ecdh","crypto/ecdh"],["ecdh","crypto/ecdh"],["ecdh","crypto/ecdh"],["ecdh","crypto/ecdh"],["ecdsa","crypto/ecdsa"],["ecdsa","crypto/ecdsa"],["ecdsa","crypto/ecdsa"],["ecdsa","crypto/ecdsa"],["ecdsa","crypto/ecdsa"],["ecdsa","crypto/ecdsa"],["ecdsa","crypto/ecdsa"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["ed25519","crypto/ed25519"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["elliptic","crypto/elliptic"],["hmac","crypto/hmac"],["hmac","crypto/hmac"],["md5","crypto/md5"],["md5","crypto/md5"],["md5","crypto/md5"],["md5","crypto/md5"],["rand","crypto/rand"],["rand","crypto/rand"],["rand","crypto/rand"],["rand","crypto/rand"],["rc4","crypto/rc4"],["rc4","crypto/rc4"],["rc4","crypto/rc4"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["rsa","crypto/rsa"],["sha1","crypto/sha1"],["sha1","crypto/sha1"],["sha1","crypto/sha1"],["sha1","crypto/sha1"],["sha256","crypto/sha256"],["sha256","crypto/sha256"],["sha256","crypto/sha256"],["sha256","crypto/sha256"],["sha256","crypto/sha256"],["sha256","crypto/sha256"],["sha256","crypto/sha256"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["sha512","crypto/sha512"],["subtle","crypto/subtle"],["subtle","crypto/subtle"],["subtle","crypto/subtle"],["subtle","crypto/subtle"],["subtle","crypto/subtle"],["subtle","crypto/subtle"],["subtle","crypto/subtle"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["tls","crypto/tls"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["x509","crypto/x509"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["sql","database/sql"],["buildinfo","debug/buildinfo"],["buildinfo","debug/buildinfo"],["buildinfo","debug/buildinfo"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["dwarf","debug/dwarf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["elf","debug/elf"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["gosym","debug/gosym"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["macho","debug/macho"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["pe","debug/pe"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["plan9obj","debug/plan9obj"],["ascii85","encoding/ascii85"],["ascii85","encoding/ascii85"],["ascii85","encoding/ascii85"],["ascii85","encoding/ascii85"],["ascii85","encoding/ascii85"],["ascii85","encoding/ascii85"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["asn1","encoding/asn1"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base32","encoding/base32"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["base64","encoding/base64"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["binary","encoding/binary"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["csv","encoding/csv"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["gob","encoding/gob"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["hex","encoding/hex"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["json","encoding/json"],["pem","encoding/pem"],["pem","encoding/pem"],["pem","encoding/pem"],["pem","encoding/pem"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["xml","encoding/xml"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["ast","go/ast"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["build","go/build"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["constant","go/constant"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["doc","go/doc"],["format","go/format"],["format","go/format"],["importer","go/importer"],["importer","go/importer"],["importer","go/importer"],["importer","go/importer"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["parser","go/parser"],["printer","go/printer"],["printer","go/printer"],["printer","go/printer"],["printer","go/printer"],["printer","go/printer"],["printer","go/printer"],["printer","go/printer"],["printer","go/printer"],["scanner","go/scanner"],["scanner","go/scanner"],["scanner","go/scanner"],["scanner","go/scanner"],["scanner","go/scanner"],["scanner","go/scanner"],["scanner","go/scanner"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["token","go/token"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["types","go/types"],["version","go/version"],["version","go/version"],["version","go/version"],["adler32","hash/adler32"],["adler32","hash/adler32"],["adler32","hash/adler32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc32","hash/crc32"],["crc64","hash/crc64"],["crc64","hash/crc64"],["crc64","hash/crc64"],["crc64","hash/crc64"],["crc64","hash/crc64"],["crc64","hash/crc64"],["crc64","hash/crc64"],["crc64","hash/crc64"],["fnv","hash/fnv"],["fnv","hash/fnv"],["fnv","hash/fnv"],["fnv","hash/fnv"],["fnv","hash/fnv"],["fnv","hash/fnv"],["maphash","hash/maphash"],["maphash","hash/maphash"],["maphash","hash/maphash"],["maphash","hash/maphash"],["maphash","hash/maphash"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["template","html/template"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["color","image/color"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["draw","image/draw"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["gif","image/gif"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["jpeg","image/jpeg"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["png","image/png"],["suffixarray","index/suffixarray"],["suffixarray","index/suffixarray"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["fs","io/fs"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["ioutil","io/ioutil"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["slog","log/slog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["syslog","log/syslog"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["big","math/big"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["bits","math/bits"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["cmplx","math/cmplx"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["rand","math/rand"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["multipart","mime/multipart"],["quotedprintable","mime/quotedprintable"],["quotedprintable","mime/quotedprintable"],["quotedprintable","mime/quotedprintable"],["quotedprintable","mime/quotedprintable"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["http","net/http"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["mail","net/mail"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["netip","net/netip"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["rpc","net/rpc"],["smtp","net/smtp"],["smtp","net/smtp"],["smtp","net/smtp"],["smtp","net/smtp"],["smtp","net/smtp"],["smtp","net/smtp"],["smtp","net/smtp"],["smtp","net/smtp"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["textproto","net/textproto"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["url","net/url"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["exec","os/exec"],["signal","os/signal"],["signal","os/signal"],["signal","os/signal"],["signal","os/signal"],["signal","os/signal"],["signal","os/signal"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["user","os/user"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["filepath","path/filepath"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["syntax","regexp/syntax"],["cgo","runtime/cgo"],["cgo","runtime/cgo"],["cgo","runtime/cgo"],["coverage","runtime/coverage"],["coverage","runtime/coverage"],["coverage","runtime/coverage"],["coverage","runtime/coverage"],["coverage","runtime/coverage"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["debug","runtime/debug"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["metrics","runtime/metrics"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["pprof","runtime/pprof"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["trace","runtime/trace"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["atomic","sync/atomic"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["js","syscall/js"],["fstest","testing/fstest"],["fstest","testing/fstest"],["fstest","testing/fstest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["iotest","testing/iotest"],["quick","testing/quick"],["quick","testing/quick"],["quick","testing/quick"],["quick","testing/quick"],["quick","testing/quick"],["quick","testing/quick"],["quick","testing/quick"],["quick","testing/quick"],["slogtest","testing/slogtest"],["slogtest","testing/slogtest"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["scanner","text/scanner"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["tabwriter","text/tabwriter"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["template","text/template"],["utf16","unicode/utf16"],["utf16","unicode/utf16"],["utf16","unicode/utf16"],["utf16","unicode/utf16"],["utf16","unicode/utf16"],["utf16","unicode/utf16"],["utf16","unicode/utf16"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["utf8","unicode/utf8"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["pkix","crypto/x509/pkix"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["driver","database/sql/driver"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["constraint","go/build/constraint"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["comment","go/doc/comment"],["palette","image/color/palette"],["palette","image/color/palette"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["rand","math/rand/v2"],["cgi","net/http/cgi"],["cgi","net/http/cgi"],["cgi","net/http/cgi"],["cgi","net/http/cgi"],["cookiejar","net/http/cookiejar"],["cookiejar","net/http/cookiejar"],["cookiejar","net/http/cookiejar"],["cookiejar","net/http/cookiejar"],["fcgi","net/http/fcgi"],["fcgi","net/http/fcgi"],["fcgi","net/http/fcgi"],["fcgi","net/http/fcgi"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptest","net/http/httptest"],["httptrace","net/http/httptrace"],["httptrace","net/http/httptrace"],["httptrace","net/http/httptrace"],["httptrace","net/http/httptrace"],["httptrace","net/http/httptrace"],["httptrace","net/http/httptrace"],["httptrace","net/http/httptrace"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["httputil","net/http/httputil"],["pprof","net/http/pprof"],["pprof","net/http/pprof"],["pprof","net/http/pprof"],["pprof","net/http/pprof"],["pprof","net/http/pprof"],["pprof","net/http/pprof"],["jsonrpc","net/rpc/jsonrpc"],["jsonrpc","net/rpc/jsonrpc"],["jsonrpc","net/rpc/jsonrpc"],["jsonrpc","net/rpc/jsonrpc"],["jsonrpc","net/rpc/jsonrpc"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["parse","text/template/parse"],["chacha20","golang.org/x/crypto/chacha20"],["chacha20","golang.org/x/crypto/chacha20"],["chacha20","golang.org/x/crypto/chacha20"],["chacha20","golang.org/x/crypto/chacha20"],["chacha20","golang.org/x/crypto/chacha20"],["chacha20","golang.org/x/crypto/chacha20"],["chacha20poly1305","golang.org/x/crypto/chacha20poly1305"],["chacha20poly1305","golang.org/x/crypto/chacha20poly1305"],["chacha20poly1305","golang.org/x/crypto/chacha20poly1305"],["chacha20poly1305","golang.org/x/crypto/chacha20poly1305"],["chacha20poly1305","golang.org/x/crypto/chacha20poly1305"],["chacha20poly1305","golang.org/x/crypto/chacha20poly1305"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["cryptobyte","golang.org/x/crypto/cryptobyte"],["hkdf","golang.org/x/crypto/hkdf"],["hkdf","golang.org/x/crypto/hkdf"],["hkdf","golang.org/x/crypto/hkdf"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["sha3","golang.org/x/crypto/sha3"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["idna","golang.org/x/net/idna"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["nettest","golang.org/x/net/nettest"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["cpu","golang.org/x/sys/cpu"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["transform","golang.org/x/text/transform"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["asn1","golang.org/x/crypto/cryptobyte/asn1"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["dnsmessage","golang.org/x/net/dns/dnsmessage"],["httpguts","golang.org/x/net/http/httpguts"],["httpguts","golang.org/x/net/http/httpguts"],["httpguts","golang.org/x/net/http/httpguts"],["httpguts","golang.org/x/net/http/httpguts"],["httpguts","golang.org/x/net/http/httpguts"],["httpguts","golang.org/x/net/http/httpguts"],["httpguts","golang.org/x/net/http/httpguts"],["httpproxy","golang.org/x/net/http/httpproxy"],["httpproxy","golang.org/x/net/http/httpproxy"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["hpack","golang.org/x/net/http2/hpack"],["bidirule","golang.org/x/text/secure/bidirule"],["bidirule","golang.org/x/text/secure/bidirule"],["bidirule","golang.org/x/text/secure/bidirule"],["bidirule","golang.org/x/text/secure/bidirule"],["bidirule","golang.org/x/text/secure/bidirule"],["bidirule","golang.org/x/text/secure/bidirule"],["bidirule","golang.org/x/text/secure/bidirule"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["bidi","golang.org/x/text/unicode/bidi"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"],["norm","golang.org/x/text/unicode/norm"]]}}
