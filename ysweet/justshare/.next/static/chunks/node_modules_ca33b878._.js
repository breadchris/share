(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/@y-sweet/sdk/dist/main.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/error.ts
__turbopack_context__.s({
    "DocConnection": (()=>DocConnection),
    "DocumentManager": (()=>DocumentManager),
    "YSweetError": (()=>YSweetError),
    "createDoc": (()=>createDoc),
    "decodeClientToken": (()=>decodeClientToken),
    "encodeClientToken": (()=>encodeClientToken),
    "getClientToken": (()=>getClientToken),
    "getOrCreateDocAndToken": (()=>getOrCreateDocAndToken)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var YSweetError = class _YSweetError extends Error {
    /**
   * Create a new {@link YSweetError}.
   *
   * @param cause An object representing metadata associated with the error.
   * @see {@link YSweetErrorPayload}
   */ constructor(cause){
        super(_YSweetError.getMessage(cause));
        this.cause = cause;
        this.name = "YSweetError";
    }
    /** Convert the message to an error string that can be displayed to the user.
   *
   * The error string can also be used with {@link YSweetError.fromMessage} to
   * reconstruct the payload object, which is useful in the context of Next.js,
   * which will only pass an error string from the server to the client.
   *
   * @param payload The payload object to convert to a string.
   * @returns A string representation of the error.
   */ static getMessage(payload) {
        let message;
        if (payload.code === "ServerRefused") {
            message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`;
        } else if (payload.code === "ServerError") {
            message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`;
        } else if (payload.code === "NoAuthProvided") {
            message = "No auth provided";
        } else if (payload.code === "InvalidAuthProvided") {
            message = "Invalid auth provided";
        } else {
            message = payload.message;
        }
        return `${payload.code}: ${message}`;
    }
    /**
   * In development, next.js passes error objects to the client but strips out everything but the
   * `message` field. This method allows us to reconstruct the original error object.
   *
   * @param messageString The error message string to reconstruct a payload from.
   * @returns A {@link YSweetError} object.
   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}
   */ static fromMessage(messageString) {
        let match = messageString.match(/^(.*?): (.*)$/);
        if (!match) {
            return new _YSweetError({
                code: "Unknown",
                message: messageString
            });
        }
        let [, code, message] = match;
        if (code === "ServerRefused") {
            match = message.match(/^Server at (.*?):(\d+) refused connection. URL: (.*)$/);
            if (!match) {
                return new _YSweetError({
                    code: "Unknown",
                    message: messageString
                });
            }
            let [, address, port, url] = match;
            return new _YSweetError({
                code,
                address,
                port: parseInt(port),
                url
            });
        }
        if (code === "ServerError") {
            match = message.match(/^Server responded with (\d+) (.*). URL: (.*)$/);
            if (!match) {
                return new _YSweetError({
                    code: "Unknown",
                    message: messageString
                });
            }
            let [, status, statusText, url] = match;
            return new _YSweetError({
                code,
                status: parseInt(status),
                message: statusText,
                url
            });
        }
        if (code === "NoAuthProvided") {
            return new _YSweetError({
                code
            });
        }
        if (code === "InvalidAuthProvided") {
            return new _YSweetError({
                code
            });
        }
        return new _YSweetError({
            code: "Unknown",
            message
        });
    }
};
// src/http.ts
var HttpClient = class {
    constructor(baseUrl, token){
        this.token = null;
        this.baseUrl = baseUrl;
        this.token = token;
    }
    async request(path, method, body) {
        const headers = new Headers();
        if (this.token) {
            headers.set("Authorization", `Bearer ${this.token}`);
        }
        let rawBody;
        if (body instanceof Uint8Array) {
            headers.set("Content-Type", "application/octet-stream");
            rawBody = body;
        } else if (body) {
            headers.set("Content-Type", "application/json");
            rawBody = JSON.stringify(body);
        }
        const cacheBust = generateRandomString();
        let url = `${this.baseUrl}/${path}?z=${cacheBust}`;
        let result;
        try {
            result = await fetch(url, {
                method,
                body: rawBody,
                headers
            });
        } catch (error) {
            if (error.cause?.code === "ECONNREFUSED") {
                let { address, port } = error.cause;
                throw new YSweetError({
                    code: "ServerRefused",
                    address,
                    port,
                    url
                });
            } else {
                throw new YSweetError({
                    code: "Unknown",
                    message: error.toString()
                });
            }
        }
        if (!result.ok) {
            if (result.status === 401) {
                if (this.token) {
                    throw new YSweetError({
                        code: "InvalidAuthProvided"
                    });
                } else {
                    throw new YSweetError({
                        code: "NoAuthProvided"
                    });
                }
            }
            throw new YSweetError({
                code: "ServerError",
                status: result.status,
                message: result.statusText,
                url
            });
        }
        return result;
    }
};
function generateRandomString() {
    return Math.random().toString(36).substring(2);
}
// src/connection.ts
var DocConnection = class {
    constructor(clientToken){
        let baseUrl = clientToken.baseUrl.replace(/\/$/, "");
        this.client = new HttpClient(baseUrl, clientToken.token ?? null);
        this.docId = clientToken.docId;
    }
    /**
   * Returns an entire document, represented as a Yjs update byte string.
   *
   * This can be turned back into a Yjs document as follows:
   *
   * ```typescript
   * import * as Y from 'yjs'
   *
   * let update = await manager.getDocAsUpdate(docId)
   * let doc = new Y.Doc()
   * doc.transact(() => {
   *  Y.applyUpdate(doc, update)
   * })
   * ```
   *
   * @returns
   */ async getAsUpdate() {
        const result = await this.client.request(`as-update`, "GET");
        if (!result.ok) {
            throw new Error(`Failed to get doc ${this.docId}: ${result.status} ${result.statusText}`);
        }
        let buffer = await result.arrayBuffer();
        return new Uint8Array(buffer);
    }
    /**
   * Updates a document with the given Yjs update byte string.
   *
   * This can be generated from a Yjs document as follows:
   *
   * ```typescript
   * import * as Y from 'yjs'
   *
   * let doc = new Y.Doc()
   * // Modify the document...
   * let update = Y.encodeStateAsUpdate(doc)
   * await manager.updateDoc(docId, update)
   * ```
   *
   * @param update
   */ async updateDoc(update) {
        const result = await this.client.request(`update`, "POST", update);
        if (!result.ok) {
            throw new Error(`Failed to update doc ${this.docId}: ${result.status} ${result.statusText}`);
        }
    }
};
// src/encoding.ts
function stringToBase64(input) {
    if (typeof window !== "undefined" && window.btoa) {
        return window.btoa(input);
    } else if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined") {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input).toString("base64");
    } else {
        throw new Error("Unable to encode to Base64");
    }
}
function base64ToString(input) {
    if (typeof window !== "undefined" && window.atob) {
        return window.atob(input);
    } else if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined") {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input, "base64").toString();
    } else {
        throw new Error("Unable to decode from Base64");
    }
}
function encodeClientToken(token) {
    const jsonString = JSON.stringify(token);
    let base64 = stringToBase64(jsonString);
    base64 = base64.replace("+", "-").replace("/", "_").replace(/=+$/, "");
    return base64;
}
function decodeClientToken(token) {
    let base64 = token.replace("-", "+").replace("_", "/");
    while(base64.length % 4){
        base64 += "=";
    }
    const jsonString = base64ToString(base64);
    return JSON.parse(jsonString);
}
// src/main.ts
var DocumentManager = class {
    /**
   * Create a new {@link DocumentManager}.
   *
   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
   */ constructor(connectionString){
        const parsedUrl = new URL(connectionString);
        let token = null;
        if (parsedUrl.username) {
            token = decodeURIComponent(parsedUrl.username);
        }
        let protocol = parsedUrl.protocol;
        if (protocol === "ys:") {
            protocol = "http:";
        } else if (protocol === "yss:") {
            protocol = "https:";
        }
        const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}`;
        let baseUrl = url.replace(/\/$/, "");
        this.client = new HttpClient(baseUrl, token);
    }
    async checkStore() {
        return await (await this.client.request("check_store", "POST", {})).json();
    }
    /**
   * Creates a new document on the y-sweet server given an optional docId. If a document with given
   * ID already exists, this is a no-op.
   *
   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.
   * @returns A {@link DocCreationResult} object containing the ID of the created document.
   */ async createDoc(docId) {
        const body = docId ? {
            docId
        } : {};
        const result = await this.client.request("doc/new", "POST", body);
        if (!result.ok) {
            throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`);
        }
        const responseBody = await result.json();
        return responseBody;
    }
    /**
   * Get a client token for the given document.
   *
   * If you are using authorization, this is expected to be called from your server
   * after a user has authenticated. The returned token should then be passed to the
   * client.
   *
   * @param docId The ID of the document to get a token for.
   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.
   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
   */ async getClientToken(docId, authDocRequest) {
        if (typeof docId !== "string") {
            docId = docId.docId;
        }
        const result = await this.client.request(`doc/${docId}/auth`, "POST", authDocRequest ?? {});
        if (!result.ok) {
            throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`);
        }
        const responseBody = await result.json();
        return responseBody;
    }
    /**
   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for
   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or
   * that one is created. If no docId is provided, a new document is created with a random ID.
   *
   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.
   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.
   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
   */ async getOrCreateDocAndToken(docId, authDocRequest) {
        const result = await this.createDoc(docId);
        return await this.getClientToken(result, authDocRequest);
    }
    /**
   * Returns an entire document, represented as a Yjs update byte string.
   *
   * @param docId The ID of the document to get.
   * @returns The document as a Yjs update byte string
   */ async getDocAsUpdate(docId) {
        const connection = await this.getDocConnection(docId);
        return await connection.getAsUpdate();
    }
    /**
   * Updates a document with the given Yjs update byte string.
   *
   * @param docId The ID of the document to update.
   * @param update The Yjs update byte string to apply to the document.
   */ async updateDoc(docId, update) {
        const connection = await this.getDocConnection(docId);
        return await connection.updateDoc(update);
    }
    async getDocConnection(docId, authDocRequest) {
        const clientToken = await this.getClientToken(docId, authDocRequest);
        return new DocConnection(clientToken);
    }
    /**
   * Creates a new document with initial content.
   *
   * @param update A Yjs update byte string representing the initial content.
   * @returns A {@link DocCreationResult} object containing the ID of the created document.
   */ async createDocWithContent(update) {
        const result = await this.createDoc();
        await this.updateDoc(result.docId, update);
        return result;
    }
};
async function getOrCreateDocAndToken(connectionString, docId, authDocRequest) {
    const manager = new DocumentManager(connectionString);
    return await manager.getOrCreateDocAndToken(docId, authDocRequest);
}
async function getClientToken(connectionString, docId, authDocRequest) {
    const manager = new DocumentManager(connectionString);
    return await manager.getClientToken(docId, authDocRequest);
}
async function createDoc(connectionString, docId) {
    const manager = new DocumentManager(connectionString);
    return await manager.createDoc(docId);
}
;
 //# sourceMappingURL=main.mjs.map
}}),
"[project]/node_modules/lib0/math.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Common Math expressions.
 *
 * @module math
 */ __turbopack_context__.s({
    "abs": (()=>abs),
    "add": (()=>add),
    "ceil": (()=>ceil),
    "exp10": (()=>exp10),
    "floor": (()=>floor),
    "imul": (()=>imul),
    "isNaN": (()=>isNaN),
    "isNegativeZero": (()=>isNegativeZero),
    "log": (()=>log),
    "log10": (()=>log10),
    "log2": (()=>log2),
    "max": (()=>max),
    "min": (()=>min),
    "pow": (()=>pow),
    "round": (()=>round),
    "sign": (()=>sign),
    "sqrt": (()=>sqrt)
});
const floor = Math.floor;
const ceil = Math.ceil;
const abs = Math.abs;
const imul = Math.imul;
const round = Math.round;
const log10 = Math.log10;
const log2 = Math.log2;
const log = Math.log;
const sqrt = Math.sqrt;
const add = (a, b)=>a + b;
const min = (a, b)=>a < b ? a : b;
const max = (a, b)=>a > b ? a : b;
const isNaN = Number.isNaN;
const pow = Math.pow;
const exp10 = (exp)=>Math.pow(10, exp);
const sign = Math.sign;
const isNegativeZero = (n)=>n !== 0 ? n < 0 : 1 / n < 0;
}}),
"[project]/node_modules/lib0/binary.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * Binary data constants.
 *
 * @module binary
 */ /**
 * n-th bit activated.
 *
 * @type {number}
 */ __turbopack_context__.s({
    "BIT1": (()=>BIT1),
    "BIT10": (()=>BIT10),
    "BIT11": (()=>BIT11),
    "BIT12": (()=>BIT12),
    "BIT13": (()=>BIT13),
    "BIT14": (()=>BIT14),
    "BIT15": (()=>BIT15),
    "BIT16": (()=>BIT16),
    "BIT17": (()=>BIT17),
    "BIT18": (()=>BIT18),
    "BIT19": (()=>BIT19),
    "BIT2": (()=>BIT2),
    "BIT20": (()=>BIT20),
    "BIT21": (()=>BIT21),
    "BIT22": (()=>BIT22),
    "BIT23": (()=>BIT23),
    "BIT24": (()=>BIT24),
    "BIT25": (()=>BIT25),
    "BIT26": (()=>BIT26),
    "BIT27": (()=>BIT27),
    "BIT28": (()=>BIT28),
    "BIT29": (()=>BIT29),
    "BIT3": (()=>BIT3),
    "BIT30": (()=>BIT30),
    "BIT31": (()=>BIT31),
    "BIT32": (()=>BIT32),
    "BIT4": (()=>BIT4),
    "BIT5": (()=>BIT5),
    "BIT6": (()=>BIT6),
    "BIT7": (()=>BIT7),
    "BIT8": (()=>BIT8),
    "BIT9": (()=>BIT9),
    "BITS0": (()=>BITS0),
    "BITS1": (()=>BITS1),
    "BITS10": (()=>BITS10),
    "BITS11": (()=>BITS11),
    "BITS12": (()=>BITS12),
    "BITS13": (()=>BITS13),
    "BITS14": (()=>BITS14),
    "BITS15": (()=>BITS15),
    "BITS16": (()=>BITS16),
    "BITS17": (()=>BITS17),
    "BITS18": (()=>BITS18),
    "BITS19": (()=>BITS19),
    "BITS2": (()=>BITS2),
    "BITS20": (()=>BITS20),
    "BITS21": (()=>BITS21),
    "BITS22": (()=>BITS22),
    "BITS23": (()=>BITS23),
    "BITS24": (()=>BITS24),
    "BITS25": (()=>BITS25),
    "BITS26": (()=>BITS26),
    "BITS27": (()=>BITS27),
    "BITS28": (()=>BITS28),
    "BITS29": (()=>BITS29),
    "BITS3": (()=>BITS3),
    "BITS30": (()=>BITS30),
    "BITS31": (()=>BITS31),
    "BITS32": (()=>BITS32),
    "BITS4": (()=>BITS4),
    "BITS5": (()=>BITS5),
    "BITS6": (()=>BITS6),
    "BITS7": (()=>BITS7),
    "BITS8": (()=>BITS8),
    "BITS9": (()=>BITS9)
});
const BIT1 = 1;
const BIT2 = 2;
const BIT3 = 4;
const BIT4 = 8;
const BIT5 = 16;
const BIT6 = 32;
const BIT7 = 64;
const BIT8 = 128;
const BIT9 = 256;
const BIT10 = 512;
const BIT11 = 1024;
const BIT12 = 2048;
const BIT13 = 4096;
const BIT14 = 8192;
const BIT15 = 16384;
const BIT16 = 32768;
const BIT17 = 65536;
const BIT18 = 1 << 17;
const BIT19 = 1 << 18;
const BIT20 = 1 << 19;
const BIT21 = 1 << 20;
const BIT22 = 1 << 21;
const BIT23 = 1 << 22;
const BIT24 = 1 << 23;
const BIT25 = 1 << 24;
const BIT26 = 1 << 25;
const BIT27 = 1 << 26;
const BIT28 = 1 << 27;
const BIT29 = 1 << 28;
const BIT30 = 1 << 29;
const BIT31 = 1 << 30;
const BIT32 = 1 << 31;
const BITS0 = 0;
const BITS1 = 1;
const BITS2 = 3;
const BITS3 = 7;
const BITS4 = 15;
const BITS5 = 31;
const BITS6 = 63;
const BITS7 = 127;
const BITS8 = 255;
const BITS9 = 511;
const BITS10 = 1023;
const BITS11 = 2047;
const BITS12 = 4095;
const BITS13 = 8191;
const BITS14 = 16383;
const BITS15 = 32767;
const BITS16 = 65535;
const BITS17 = BIT18 - 1;
const BITS18 = BIT19 - 1;
const BITS19 = BIT20 - 1;
const BITS20 = BIT21 - 1;
const BITS21 = BIT22 - 1;
const BITS22 = BIT23 - 1;
const BITS23 = BIT24 - 1;
const BITS24 = BIT25 - 1;
const BITS25 = BIT26 - 1;
const BITS26 = BIT27 - 1;
const BITS27 = BIT28 - 1;
const BITS28 = BIT29 - 1;
const BITS29 = BIT30 - 1;
const BITS30 = BIT31 - 1;
const BITS31 = 0x7FFFFFFF;
const BITS32 = 0xFFFFFFFF;
}}),
"[project]/node_modules/lib0/number.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility helpers for working with numbers.
 *
 * @module number
 */ __turbopack_context__.s({
    "HIGHEST_INT32": (()=>HIGHEST_INT32),
    "HIGHEST_UINT32": (()=>HIGHEST_UINT32),
    "LOWEST_INT32": (()=>LOWEST_INT32),
    "MAX_SAFE_INTEGER": (()=>MAX_SAFE_INTEGER),
    "MIN_SAFE_INTEGER": (()=>MIN_SAFE_INTEGER),
    "countBits": (()=>countBits),
    "isInteger": (()=>isInteger),
    "isNaN": (()=>isNaN),
    "parseInt": (()=>parseInt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/binary.js [app-client] (ecmascript)");
;
;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
const LOWEST_INT32 = 1 << 31;
const HIGHEST_INT32 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS31"];
const HIGHEST_UINT32 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS32"];
const isInteger = Number.isInteger || ((num)=>typeof num === 'number' && isFinite(num) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(num) === num);
const isNaN = Number.isNaN;
const parseInt = Number.parseInt;
const countBits = (n)=>{
    n &= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS32"];
    let count = 0;
    while(n){
        n &= n - 1;
        count++;
    }
    return count;
};
}}),
"[project]/node_modules/lib0/set.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to work with sets.
 *
 * @module set
 */ __turbopack_context__.s({
    "create": (()=>create),
    "first": (()=>first),
    "from": (()=>from),
    "toArray": (()=>toArray)
});
const create = ()=>new Set();
const toArray = (set)=>Array.from(set);
const first = (set)=>set.values().next().value ?? undefined;
const from = (entries)=>new Set(entries);
}}),
"[project]/node_modules/lib0/array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to work with Arrays.
 *
 * @module array
 */ __turbopack_context__.s({
    "appendTo": (()=>appendTo),
    "bubblesortItem": (()=>bubblesortItem),
    "copy": (()=>copy),
    "create": (()=>create),
    "equalFlat": (()=>equalFlat),
    "every": (()=>every),
    "flatten": (()=>flatten),
    "fold": (()=>fold),
    "from": (()=>from),
    "isArray": (()=>isArray),
    "last": (()=>last),
    "map": (()=>map),
    "some": (()=>some),
    "unfold": (()=>unfold),
    "unique": (()=>unique),
    "uniqueBy": (()=>uniqueBy)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/set.js [app-client] (ecmascript)");
;
const last = (arr)=>arr[arr.length - 1];
const create = ()=>[];
const copy = (a)=>a.slice();
const appendTo = (dest, src)=>{
    for(let i = 0; i < src.length; i++){
        dest.push(src[i]);
    }
};
const from = Array.from;
const every = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (!f(arr[i], i, arr)) {
            return false;
        }
    }
    return true;
};
const some = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (f(arr[i], i, arr)) {
            return true;
        }
    }
    return false;
};
const equalFlat = (a, b)=>a.length === b.length && every(a, (item, index)=>item === b[index]);
const flatten = (arr)=>fold(arr, [], (acc, val)=>acc.concat(val));
const unfold = (len, f)=>{
    const array = new Array(len);
    for(let i = 0; i < len; i++){
        array[i] = f(i, array);
    }
    return array;
};
const fold = (arr, seed, folder)=>arr.reduce(folder, seed);
const isArray = Array.isArray;
const unique = (arr)=>from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(arr));
const uniqueBy = (arr, mapper)=>{
    /**
   * @type {Set<M>}
   */ const happened = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    /**
   * @type {Array<T>}
   */ const result = [];
    for(let i = 0; i < arr.length; i++){
        const el = arr[i];
        const mapped = mapper(el);
        if (!happened.has(mapped)) {
            happened.add(mapped);
            result.push(el);
        }
    }
    return result;
};
const map = (arr, mapper)=>{
    /**
   * @type {Array<any>}
   */ const res = Array(arr.length);
    for(let i = 0; i < arr.length; i++){
        res[i] = mapper(arr[i], i, arr);
    }
    return res;
};
const bubblesortItem = (arr, i, compareFn)=>{
    const n = arr[i];
    let j = i;
    // try to sort to the right
    while(j + 1 < arr.length && compareFn(n, arr[j + 1]) > 0){
        arr[j] = arr[j + 1];
        arr[++j] = n;
    }
    if (i === j && j > 0) {
        // sort to the left
        while(j > 0 && compareFn(arr[j - 1], n) > 0){
            arr[j] = arr[j - 1];
            arr[--j] = n;
        }
    }
    return j;
};
}}),
"[project]/node_modules/lib0/string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MAX_UTF16_CHARACTER": (()=>MAX_UTF16_CHARACTER),
    "_decodeUtf8Native": (()=>_decodeUtf8Native),
    "_decodeUtf8Polyfill": (()=>_decodeUtf8Polyfill),
    "_encodeUtf8Native": (()=>_encodeUtf8Native),
    "_encodeUtf8Polyfill": (()=>_encodeUtf8Polyfill),
    "decodeUtf8": (()=>decodeUtf8),
    "encodeUtf8": (()=>encodeUtf8),
    "fromCamelCase": (()=>fromCamelCase),
    "fromCharCode": (()=>fromCharCode),
    "fromCodePoint": (()=>fromCodePoint),
    "repeat": (()=>repeat),
    "splice": (()=>splice),
    "trimLeft": (()=>trimLeft),
    "utf8ByteLength": (()=>utf8ByteLength),
    "utf8TextDecoder": (()=>utf8TextDecoder),
    "utf8TextEncoder": (()=>utf8TextEncoder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/array.js [app-client] (ecmascript)");
;
const fromCharCode = String.fromCharCode;
const fromCodePoint = String.fromCodePoint;
const MAX_UTF16_CHARACTER = fromCharCode(65535);
/**
 * @param {string} s
 * @return {string}
 */ const toLowerCase = (s)=>s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s)=>s.replace(trimLeftRegex, '');
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator)=>trimLeft(s.replace(fromCamelCaseRegex, (match)=>`${separator}${toLowerCase(match)}`));
const utf8ByteLength = (str)=>unescape(encodeURIComponent(str)).length;
const _encodeUtf8Polyfill = (str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        buf[i] = encodedString.codePointAt(i);
    }
    return buf;
};
const utf8TextEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
const _encodeUtf8Native = (str)=>utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
const _decodeUtf8Polyfill = (buf)=>{
    let remainingLen = buf.length;
    let encodedString = '';
    let bufPos = 0;
    while(remainingLen > 0){
        const nextLen = remainingLen < 10000 ? remainingLen : 10000;
        const bytes = buf.subarray(bufPos, bufPos + nextLen);
        bufPos += nextLen;
        // Starting with ES5.1 we can supply a generic array-like object as arguments
        encodedString += String.fromCodePoint.apply(null, bytes);
        remainingLen -= nextLen;
    }
    return decodeURIComponent(escape(encodedString));
};
let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', {
    fatal: true,
    ignoreBOM: true
});
/* c8 ignore start */ if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
    // Safari doesn't handle BOM correctly.
    // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.
    // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and
    // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call
    // Another issue is that from then on no BOM chars are recognized anymore
    /* c8 ignore next */ utf8TextDecoder = null;
}
const _decodeUtf8Native = (buf)=>/** @type {TextDecoder} */ utf8TextDecoder.decode(buf);
const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;
const splice = (str, index, remove, insert = '')=>str.slice(0, index) + insert + str.slice(index + remove);
const repeat = (source, n)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unfold"])(n, ()=>source).join('');
}}),
"[project]/node_modules/lib0/encoding.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Efficient schema-less binary encoding with support for variable length encoding.
 *
 * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module encoding
 */ __turbopack_context__.s({
    "Encoder": (()=>Encoder),
    "IncUintOptRleEncoder": (()=>IncUintOptRleEncoder),
    "IntDiffEncoder": (()=>IntDiffEncoder),
    "IntDiffOptRleEncoder": (()=>IntDiffOptRleEncoder),
    "RleEncoder": (()=>RleEncoder),
    "RleIntDiffEncoder": (()=>RleIntDiffEncoder),
    "StringEncoder": (()=>StringEncoder),
    "UintOptRleEncoder": (()=>UintOptRleEncoder),
    "_writeVarStringNative": (()=>_writeVarStringNative),
    "_writeVarStringPolyfill": (()=>_writeVarStringPolyfill),
    "createEncoder": (()=>createEncoder),
    "encode": (()=>encode),
    "hasContent": (()=>hasContent),
    "length": (()=>length),
    "set": (()=>set),
    "setUint16": (()=>setUint16),
    "setUint32": (()=>setUint32),
    "setUint8": (()=>setUint8),
    "toUint8Array": (()=>toUint8Array),
    "verifyLen": (()=>verifyLen),
    "write": (()=>write),
    "writeAny": (()=>writeAny),
    "writeBigInt64": (()=>writeBigInt64),
    "writeBigUint64": (()=>writeBigUint64),
    "writeBinaryEncoder": (()=>writeBinaryEncoder),
    "writeFloat32": (()=>writeFloat32),
    "writeFloat64": (()=>writeFloat64),
    "writeOnDataView": (()=>writeOnDataView),
    "writeTerminatedString": (()=>writeTerminatedString),
    "writeTerminatedUint8Array": (()=>writeTerminatedUint8Array),
    "writeUint16": (()=>writeUint16),
    "writeUint32": (()=>writeUint32),
    "writeUint32BigEndian": (()=>writeUint32BigEndian),
    "writeUint8": (()=>writeUint8),
    "writeUint8Array": (()=>writeUint8Array),
    "writeVarInt": (()=>writeVarInt),
    "writeVarString": (()=>writeVarString),
    "writeVarUint": (()=>writeVarUint),
    "writeVarUint8Array": (()=>writeVarUint8Array)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/binary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/array.js [app-client] (ecmascript)");
;
;
;
;
;
class Encoder {
    constructor(){
        this.cpos = 0;
        this.cbuf = new Uint8Array(100);
        /**
     * @type {Array<Uint8Array>}
     */ this.bufs = [];
    }
}
const createEncoder = ()=>new Encoder();
const encode = (f)=>{
    const encoder = createEncoder();
    f(encoder);
    return toUint8Array(encoder);
};
const length = (encoder)=>{
    let len = encoder.cpos;
    for(let i = 0; i < encoder.bufs.length; i++){
        len += encoder.bufs[i].length;
    }
    return len;
};
const hasContent = (encoder)=>encoder.cpos > 0 || encoder.bufs.length > 0;
const toUint8Array = (encoder)=>{
    const uint8arr = new Uint8Array(length(encoder));
    let curPos = 0;
    for(let i = 0; i < encoder.bufs.length; i++){
        const d = encoder.bufs[i];
        uint8arr.set(d, curPos);
        curPos += d.length;
    }
    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
};
const verifyLen = (encoder, len)=>{
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
        encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
        encoder.cbuf = new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(bufferLen, len) * 2);
        encoder.cpos = 0;
    }
};
const write = (encoder, num)=>{
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
        encoder.bufs.push(encoder.cbuf);
        encoder.cbuf = new Uint8Array(bufferLen * 2);
        encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
};
const set = (encoder, pos, num)=>{
    let buffer = null;
    // iterate all buffers and adjust position
    for(let i = 0; i < encoder.bufs.length && buffer === null; i++){
        const b = encoder.bufs[i];
        if (pos < b.length) {
            buffer = b // found buffer
            ;
        } else {
            pos -= b.length;
        }
    }
    if (buffer === null) {
        // use current buffer
        buffer = encoder.cbuf;
    }
    buffer[pos] = num;
};
const writeUint8 = write;
const setUint8 = set;
const writeUint16 = (encoder, num)=>{
    write(encoder, num & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
    write(encoder, num >>> 8 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
};
const setUint16 = (encoder, pos, num)=>{
    set(encoder, pos, num & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
    set(encoder, pos + 1, num >>> 8 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
};
const writeUint32 = (encoder, num)=>{
    for(let i = 0; i < 4; i++){
        write(encoder, num & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
        num >>>= 8;
    }
};
const writeUint32BigEndian = (encoder, num)=>{
    for(let i = 3; i >= 0; i--){
        write(encoder, num >>> 8 * i & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
    }
};
const setUint32 = (encoder, pos, num)=>{
    for(let i = 0; i < 4; i++){
        set(encoder, pos + i, num & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS8"]);
        num >>>= 8;
    }
};
const writeVarUint = (encoder, num)=>{
    while(num > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"]){
        write(encoder, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"] & num);
        num = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(num / 128) // shift >>> 7
        ;
    }
    write(encoder, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"] & num);
};
const writeVarInt = (encoder, num)=>{
    const isNegative = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNegativeZero"])(num);
    if (isNegative) {
        num = -num;
    }
    //             |- whether to continue reading         |- whether is negative     |- number
    write(encoder, (num > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS6"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"] : 0) | (isNegative ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"] : 0) | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS6"] & num);
    num = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(num / 64) // shift >>> 6
    ;
    // We don't need to consider the case of num === 0 so we can use a different
    // pattern here than above.
    while(num > 0){
        write(encoder, (num > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"] : 0) | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"] & num);
        num = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(num / 128) // shift >>> 7
        ;
    }
};
/**
 * A cache to store strings temporarily
 */ const _strBuffer = new Uint8Array(30000);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str)=>{
    if (str.length < _maxStrBSize) {
        // We can encode the string into the existing buffer
        /* c8 ignore next */ const written = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utf8TextEncoder"].encodeInto(str, _strBuffer).written || 0;
        writeVarUint(encoder, written);
        for(let i = 0; i < written; i++){
            write(encoder, _strBuffer[i]);
        }
    } else {
        writeVarUint8Array(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeUtf8"])(str));
    }
};
const _writeVarStringPolyfill = (encoder, str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for(let i = 0; i < len; i++){
        write(encoder, encodedString.codePointAt(i));
    }
};
const writeVarString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utf8TextEncoder"] && /** @type {any} */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utf8TextEncoder"].encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeTerminatedString = (encoder, str)=>writeTerminatedUint8Array(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeUtf8"])(str));
const writeTerminatedUint8Array = (encoder, buf)=>{
    for(let i = 0; i < buf.length; i++){
        const b = buf[i];
        if (b === 0 || b === 1) {
            write(encoder, 1);
        }
        write(encoder, buf[i]);
    }
    write(encoder, 0);
};
const writeBinaryEncoder = (encoder, append)=>writeUint8Array(encoder, toUint8Array(append));
const writeUint8Array = (encoder, uint8Array)=>{
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["min"])(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
        // Still something to write, write right half..
        // Append new buffer
        encoder.bufs.push(encoder.cbuf);
        // must have at least size of remaining buffer
        encoder.cbuf = new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(bufferLen * 2, rightCopyLen));
        // copy array
        encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
        encoder.cpos = rightCopyLen;
    }
};
const writeVarUint8Array = (encoder, uint8Array)=>{
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len)=>{
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
};
const writeFloat32 = (encoder, num)=>writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num)=>writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigInt64(0, num, false);
const writeBigUint64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigUint64(0, num, false);
const floatTestBed = new DataView(new ArrayBuffer(4));
/**
 * Check if a number can be encoded as a 32 bit float.
 *
 * @param {number} num
 * @return {boolean}
 */ const isFloat32 = (num)=>{
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data)=>{
    switch(typeof data){
        case 'string':
            // TYPE 119: STRING
            write(encoder, 119);
            writeVarString(encoder, data);
            break;
        case 'number':
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(data) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abs"])(data) <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS31"]) {
                // TYPE 125: INTEGER
                write(encoder, 125);
                writeVarInt(encoder, data);
            } else if (isFloat32(data)) {
                // TYPE 124: FLOAT32
                write(encoder, 124);
                writeFloat32(encoder, data);
            } else {
                // TYPE 123: FLOAT64
                write(encoder, 123);
                writeFloat64(encoder, data);
            }
            break;
        case 'bigint':
            // TYPE 122: BigInt
            write(encoder, 122);
            writeBigInt64(encoder, data);
            break;
        case 'object':
            if (data === null) {
                // TYPE 126: null
                write(encoder, 126);
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(data)) {
                // TYPE 117: Array
                write(encoder, 117);
                writeVarUint(encoder, data.length);
                for(let i = 0; i < data.length; i++){
                    writeAny(encoder, data[i]);
                }
            } else if (data instanceof Uint8Array) {
                // TYPE 116: ArrayBuffer
                write(encoder, 116);
                writeVarUint8Array(encoder, data);
            } else {
                // TYPE 118: Object
                write(encoder, 118);
                const keys = Object.keys(data);
                writeVarUint(encoder, keys.length);
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    writeVarString(encoder, key);
                    writeAny(encoder, data[key]);
                }
            }
            break;
        case 'boolean':
            // TYPE 120/121: boolean (true/false)
            write(encoder, data ? 120 : 121);
            break;
        default:
            // TYPE 127: undefined
            write(encoder, 127);
    }
};
class RleEncoder extends Encoder {
    /**
   * @param {function(Encoder, T):void} writer
   */ constructor(writer){
        super();
        /**
     * The writer
     */ this.w = writer;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    /**
   * @param {T} v
   */ write(v) {
        if (this.s === v) {
            this.count++;
        } else {
            if (this.count > 0) {
                // flush counter, unless this is the first value (count = 0)
                writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
                ;
            }
            this.count = 1;
            // write first value
            this.w(this, v);
            this.s = v;
        }
    }
}
class IntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @param {number} v
   */ write(v) {
        writeVarInt(this, v - this.s);
        this.s = v;
    }
}
class RleIntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v && this.count > 0) {
            this.count++;
        } else {
            if (this.count > 0) {
                // flush counter, unless this is the first value (count = 0)
                writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
                ;
            }
            this.count = 1;
            // write first value
            writeVarInt(this, v - this.s);
            this.s = v;
        }
    }
}
/**
 * @param {UintOptRleEncoder} encoder
 */ const flushUintOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set sign to positive
        // case 2: write several values. set sign to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
        if (encoder.count > 1) {
            writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
            ;
        }
    }
};
class UintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v) {
            this.count++;
        } else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class IncUintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s + this.count === v) {
            this.count++;
        } else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
/**
 * @param {IntDiffOptRleEncoder} encoder
 */ const flushIntDiffOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        //          31 bit making up the diff | wether to write the counter
        // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)
        const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set first bit to positive
        // case 2: write several values. set first bit to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encodedDiff);
        if (encoder.count > 1) {
            writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
            ;
        }
    }
};
class IntDiffOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.diff === v - this.s) {
            this.s = v;
            this.count++;
        } else {
            flushIntDiffOptRleEncoder(this);
            this.count = 1;
            this.diff = v - this.s;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushIntDiffOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class StringEncoder {
    constructor(){
        /**
     * @type {Array<string>}
     */ this.sarr = [];
        this.s = '';
        this.lensE = new UintOptRleEncoder();
    }
    /**
   * @param {string} string
   */ write(string) {
        this.s += string;
        if (this.s.length > 19) {
            this.sarr.push(this.s);
            this.s = '';
        }
        this.lensE.write(string.length);
    }
    toUint8Array() {
        const encoder = new Encoder();
        this.sarr.push(this.s);
        this.s = '';
        writeVarString(encoder, this.sarr.join(''));
        writeUint8Array(encoder, this.lensE.toUint8Array());
        return toUint8Array(encoder);
    }
}
}}),
"[project]/node_modules/lib0/error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Error helpers.
 *
 * @module error
 */ /**
 * @param {string} s
 * @return {Error}
 */ /* c8 ignore next */ __turbopack_context__.s({
    "create": (()=>create),
    "methodUnimplemented": (()=>methodUnimplemented),
    "unexpectedCase": (()=>unexpectedCase)
});
const create = (s)=>new Error(s);
const methodUnimplemented = ()=>{
    throw create('Method unimplemented');
};
const unexpectedCase = ()=>{
    throw create('Unexpected case');
};
}}),
"[project]/node_modules/lib0/decoding.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Efficient schema-less binary decoding with support for variable length encoding.
 *
 * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module decoding
 */ __turbopack_context__.s({
    "Decoder": (()=>Decoder),
    "IncUintOptRleDecoder": (()=>IncUintOptRleDecoder),
    "IntDiffDecoder": (()=>IntDiffDecoder),
    "IntDiffOptRleDecoder": (()=>IntDiffOptRleDecoder),
    "RleDecoder": (()=>RleDecoder),
    "RleIntDiffDecoder": (()=>RleIntDiffDecoder),
    "StringDecoder": (()=>StringDecoder),
    "UintOptRleDecoder": (()=>UintOptRleDecoder),
    "_readVarStringNative": (()=>_readVarStringNative),
    "_readVarStringPolyfill": (()=>_readVarStringPolyfill),
    "clone": (()=>clone),
    "createDecoder": (()=>createDecoder),
    "hasContent": (()=>hasContent),
    "peekUint16": (()=>peekUint16),
    "peekUint32": (()=>peekUint32),
    "peekUint8": (()=>peekUint8),
    "peekVarInt": (()=>peekVarInt),
    "peekVarString": (()=>peekVarString),
    "peekVarUint": (()=>peekVarUint),
    "readAny": (()=>readAny),
    "readBigInt64": (()=>readBigInt64),
    "readBigUint64": (()=>readBigUint64),
    "readFloat32": (()=>readFloat32),
    "readFloat64": (()=>readFloat64),
    "readFromDataView": (()=>readFromDataView),
    "readTailAsUint8Array": (()=>readTailAsUint8Array),
    "readTerminatedString": (()=>readTerminatedString),
    "readTerminatedUint8Array": (()=>readTerminatedUint8Array),
    "readUint16": (()=>readUint16),
    "readUint32": (()=>readUint32),
    "readUint32BigEndian": (()=>readUint32BigEndian),
    "readUint8": (()=>readUint8),
    "readUint8Array": (()=>readUint8Array),
    "readVarInt": (()=>readVarInt),
    "readVarString": (()=>readVarString),
    "readVarUint": (()=>readVarUint),
    "readVarUint8Array": (()=>readVarUint8Array),
    "skip8": (()=>skip8)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/binary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/encoding.js [app-client] (ecmascript)");
;
;
;
;
;
;
const errorUnexpectedEndOfArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('Unexpected end of array');
const errorIntegerOutOfRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('Integer out of Range');
class Decoder {
    /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */ constructor(uint8Array){
        /**
     * Decoding target.
     *
     * @type {Uint8Array}
     */ this.arr = uint8Array;
        /**
     * Current decoding position.
     *
     * @type {number}
     */ this.pos = 0;
    }
}
const createDecoder = (uint8Array)=>new Decoder(uint8Array);
const hasContent = (decoder)=>decoder.pos !== decoder.arr.length;
const clone = (decoder, newPos = decoder.pos)=>{
    const _decoder = createDecoder(decoder.arr);
    _decoder.pos = newPos;
    return _decoder;
};
const readUint8Array = (decoder, len)=>{
    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view;
};
const readVarUint8Array = (decoder)=>readUint8Array(decoder, readVarUint(decoder));
const readTailAsUint8Array = (decoder)=>readUint8Array(decoder, decoder.arr.length - decoder.pos);
const skip8 = (decoder)=>decoder.pos++;
const readUint8 = (decoder)=>decoder.arr[decoder.pos++];
const readUint16 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
    decoder.pos += 2;
    return uint;
};
const readUint32 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const readUint32BigEndian = (decoder)=>{
    const uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const peekUint8 = (decoder)=>decoder.arr[decoder.pos];
const peekUint16 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
const peekUint32 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
const readVarUint = (decoder)=>{
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        const r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"]) * mult // shift $r << (7*#iterations) and add it to num
        ;
        mult *= 128 // next iteration, shift 7 "more" to the left
        ;
        if (r < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"]) {
            return num;
        }
        /* c8 ignore start */ if (num > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_SAFE_INTEGER"]) {
            throw errorIntegerOutOfRange;
        }
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const readVarInt = (decoder)=>{
    let r = decoder.arr[decoder.pos++];
    let num = r & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS6"];
    let mult = 64;
    const sign = (r & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"]) > 0 ? -1 : 1;
    if ((r & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"]) === 0) {
        // don't continue reading
        return sign * num;
    }
    const len = decoder.arr.length;
    while(decoder.pos < len){
        r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS7"]) * mult;
        mult *= 128;
        if (r < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"]) {
            return sign * num;
        }
        /* c8 ignore start */ if (num > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_SAFE_INTEGER"]) {
            throw errorIntegerOutOfRange;
        }
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const peekVarUint = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarUint(decoder);
    decoder.pos = pos;
    return s;
};
const peekVarInt = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarInt(decoder);
    decoder.pos = pos;
    return s;
};
const _readVarStringPolyfill = (decoder)=>{
    let remainingLen = readVarUint(decoder);
    if (remainingLen === 0) {
        return '';
    } else {
        let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen
        ;
        if (--remainingLen < 100) {
            while(remainingLen--){
                encodedString += String.fromCodePoint(readUint8(decoder));
            }
        } else {
            while(remainingLen > 0){
                const nextLen = remainingLen < 10000 ? remainingLen : 10000;
                // this is dangerous, we create a fresh array view from the existing buffer
                const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
                decoder.pos += nextLen;
                // Starting with ES5.1 we can supply a generic array-like object as arguments
                encodedString += String.fromCodePoint.apply(null, bytes);
                remainingLen -= nextLen;
            }
        }
        return decodeURIComponent(escape(encodedString));
    }
};
const _readVarStringNative = (decoder)=>/** @type any */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utf8TextDecoder"].decode(readVarUint8Array(decoder));
const readVarString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utf8TextDecoder"] ? _readVarStringNative : _readVarStringPolyfill;
const readTerminatedUint8Array = (decoder)=>{
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
    let b;
    while(true){
        b = readUint8(decoder);
        if (b === 0) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(encoder);
        }
        if (b === 1) {
            b = readUint8(decoder);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["write"])(encoder, b);
    }
};
const readTerminatedString = (decoder)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeUtf8"])(readTerminatedUint8Array(decoder));
const peekVarString = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarString(decoder);
    decoder.pos = pos;
    return s;
};
const readFromDataView = (decoder, len)=>{
    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
    decoder.pos += len;
    return dv;
};
const readFloat32 = (decoder)=>readFromDataView(decoder, 4).getFloat32(0, false);
const readFloat64 = (decoder)=>readFromDataView(decoder, 8).getFloat64(0, false);
const readBigInt64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigInt64(0, false);
const readBigUint64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigUint64(0, false);
/**
 * @type {Array<function(Decoder):any>}
 */ const readAnyLookupTable = [
    (decoder)=>undefined,
    (decoder)=>null,
    readVarInt,
    readFloat32,
    readFloat64,
    readBigInt64,
    (decoder)=>false,
    (decoder)=>true,
    readVarString,
    (decoder)=>{
        const len = readVarUint(decoder);
        /**
     * @type {Object<string,any>}
     */ const obj = {};
        for(let i = 0; i < len; i++){
            const key = readVarString(decoder);
            obj[key] = readAny(decoder);
        }
        return obj;
    },
    (decoder)=>{
        const len = readVarUint(decoder);
        const arr = [];
        for(let i = 0; i < len; i++){
            arr.push(readAny(decoder));
        }
        return arr;
    },
    readVarUint8Array // CASE 116: Uint8Array
];
const readAny = (decoder)=>readAnyLookupTable[127 - readUint8(decoder)](decoder);
class RleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */ constructor(uint8Array, reader){
        super(uint8Array);
        /**
     * The reader
     */ this.reader = reader;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = this.reader(this);
            if (hasContent(this)) {
                this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
                ;
            } else {
                this.count = -1 // read the current value forever
                ;
            }
        }
        this.count--;
        return this.s;
    }
}
class IntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @return {number}
   */ read() {
        this.s += readVarInt(this);
        return this.s;
    }
}
class RleIntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            this.s += readVarInt(this);
            if (hasContent(this)) {
                this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
                ;
            } else {
                this.count = -1 // read the current value forever
                ;
            }
        }
        this.count--;
        return this.s;
    }
}
class UintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNegativeZero"])(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return this.s;
    }
}
class IncUintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNegativeZero"])(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return this.s++;
    }
}
class IntDiffOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            const diff = readVarInt(this);
            // if the first bit is set, we read more data
            const hasCount = diff & 1;
            this.diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(diff / 2) // shift >> 1
            ;
            this.count = 1;
            if (hasCount) {
                this.count = readVarUint(this) + 2;
            }
        }
        this.s += this.diff;
        this.count--;
        return this.s;
    }
}
class StringDecoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        this.decoder = new UintOptRleDecoder(uint8Array);
        this.str = readVarString(this.decoder);
        /**
     * @type {number}
     */ this.spos = 0;
    }
    /**
   * @return {string}
   */ read() {
        const end = this.spos + this.decoder.read();
        const res = this.str.slice(this.spos, end);
        this.spos = end;
        return res;
    }
}
}}),
"[project]/node_modules/lib0/metric.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to convert metric values.
 *
 * @module metric
 */ __turbopack_context__.s({
    "atto": (()=>atto),
    "centi": (()=>centi),
    "deca": (()=>deca),
    "deci": (()=>deci),
    "exa": (()=>exa),
    "femto": (()=>femto),
    "giga": (()=>giga),
    "hecto": (()=>hecto),
    "kilo": (()=>kilo),
    "mega": (()=>mega),
    "micro": (()=>micro),
    "milli": (()=>milli),
    "nano": (()=>nano),
    "peta": (()=>peta),
    "pico": (()=>pico),
    "prefix": (()=>prefix),
    "tera": (()=>tera),
    "yocto": (()=>yocto),
    "yotta": (()=>yotta),
    "zepto": (()=>zepto),
    "zetta": (()=>zetta)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
;
const yotta = 1e24;
const zetta = 1e21;
const exa = 1e18;
const peta = 1e15;
const tera = 1e12;
const giga = 1e9;
const mega = 1e6;
const kilo = 1e3;
const hecto = 1e2;
const deca = 10;
const deci = 0.1;
const centi = 0.01;
const milli = 1e-3;
const micro = 1e-6;
const nano = 1e-9;
const pico = 1e-12;
const femto = 1e-15;
const atto = 1e-18;
const zepto = 1e-21;
const yocto = 1e-24;
const prefixUp = [
    '',
    'k',
    'M',
    'G',
    'T',
    'P',
    'E',
    'Z',
    'Y'
];
const prefixDown = [
    '',
    'm',
    'μ',
    'n',
    'p',
    'f',
    'a',
    'z',
    'y'
];
const prefix = (n, baseMultiplier = 0)=>{
    const nPow = n === 0 ? 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log10"])(n);
    let mult = 0;
    while(nPow < mult * 3 && baseMultiplier > -8){
        baseMultiplier--;
        mult--;
    }
    while(nPow >= 3 + mult * 3 && baseMultiplier < 8){
        baseMultiplier++;
        mult++;
    }
    const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];
    return {
        n: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])((mult > 0 ? n / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exp10"])(mult * 3) : n * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exp10"])(mult * -3)) * 1e12) / 1e12,
        prefix
    };
};
}}),
"[project]/node_modules/lib0/time.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to work with time.
 *
 * @module time
 */ __turbopack_context__.s({
    "getDate": (()=>getDate),
    "getUnixTime": (()=>getUnixTime),
    "humanizeDuration": (()=>humanizeDuration)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$metric$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/metric.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
;
;
const getDate = ()=>new Date();
const getUnixTime = Date.now;
const humanizeDuration = (d)=>{
    if (d < 60000) {
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$metric$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"])(d, -1);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])(p.n * 100) / 100 + p.prefix + 's';
    }
    d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(d / 1000);
    const seconds = d % 60;
    const minutes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(d / 60) % 60;
    const hours = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(d / 3600) % 24;
    const days = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(d / 86400);
    if (days > 0) {
        return days + 'd' + (hours > 0 || minutes > 30 ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '');
    }
    if (hours > 0) {
        /* c8 ignore next */ return hours + 'h' + (minutes > 0 || seconds > 30 ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '');
    }
    return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '');
};
}}),
"[project]/node_modules/lib0/map.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to work with key-value stores.
 *
 * @module map
 */ /**
 * Creates a new Map instance.
 *
 * @function
 * @return {Map<any, any>}
 *
 * @function
 */ __turbopack_context__.s({
    "all": (()=>all),
    "any": (()=>any),
    "copy": (()=>copy),
    "create": (()=>create),
    "map": (()=>map),
    "setIfUndefined": (()=>setIfUndefined)
});
const create = ()=>new Map();
const copy = (m)=>{
    const r = create();
    m.forEach((v, k)=>{
        r.set(k, v);
    });
    return r;
};
const setIfUndefined = (map, key, createT)=>{
    let set = map.get(key);
    if (set === undefined) {
        map.set(key, set = createT());
    }
    return set;
};
const map = (m, f)=>{
    const res = [];
    for (const [key, value] of m){
        res.push(f(value, key));
    }
    return res;
};
const any = (m, f)=>{
    for (const [key, value] of m){
        if (f(value, key)) {
            return true;
        }
    }
    return false;
};
const all = (m, f)=>{
    for (const [key, value] of m){
        if (!f(value, key)) {
            return false;
        }
    }
    return true;
};
}}),
"[project]/node_modules/lib0/observable.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Observable class prototype.
 *
 * @module observable
 */ __turbopack_context__.s({
    "Observable": (()=>Observable),
    "ObservableV2": (()=>ObservableV2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/array.js [app-client] (ecmascript)");
;
;
;
class ObservableV2 {
    constructor(){
        /**
     * Some desc.
     * @type {Map<string, Set<any>>}
     */ this._observers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ on(name, f) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(this._observers, name, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"]).add(f);
        return f;
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, _f);
            f(...args);
        };
        this.on(name, _f);
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) {
                this._observers.delete(name);
            }
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])((this._observers.get(name) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    }
}
class Observable {
    constructor(){
        /**
     * Some desc.
     * @type {Map<N, any>}
     */ this._observers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    }
    /**
   * @param {N} name
   * @param {function} f
   */ on(name, f) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(this._observers, name, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"]).add(f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, _f);
            f(...args);
        };
        this.on(name, _f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) {
                this._observers.delete(name);
            }
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])((this._observers.get(name) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    }
} /* c8 ignore end */ 
}}),
"[project]/node_modules/lib0/object.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility functions for working with EcmaScript objects.
 *
 * @module object
 */ /**
 * @return {Object<string,any>} obj
 */ __turbopack_context__.s({
    "assign": (()=>assign),
    "create": (()=>create),
    "deepFreeze": (()=>deepFreeze),
    "equalFlat": (()=>equalFlat),
    "every": (()=>every),
    "forEach": (()=>forEach),
    "freeze": (()=>freeze),
    "hasProperty": (()=>hasProperty),
    "isEmpty": (()=>isEmpty),
    "keys": (()=>keys),
    "length": (()=>length),
    "map": (()=>map),
    "size": (()=>size),
    "some": (()=>some)
});
const create = ()=>Object.create(null);
const assign = Object.assign;
const keys = Object.keys;
const forEach = (obj, f)=>{
    for(const key in obj){
        f(obj[key], key);
    }
};
const map = (obj, f)=>{
    const results = [];
    for(const key in obj){
        results.push(f(obj[key], key));
    }
    return results;
};
const length = (obj)=>keys(obj).length;
const size = (obj)=>keys(obj).length;
const some = (obj, f)=>{
    for(const key in obj){
        if (f(obj[key], key)) {
            return true;
        }
    }
    return false;
};
const isEmpty = (obj)=>{
    // eslint-disable-next-line
    for(const _k in obj){
        return false;
    }
    return true;
};
const every = (obj, f)=>{
    for(const key in obj){
        if (!f(obj[key], key)) {
            return false;
        }
    }
    return true;
};
const hasProperty = (obj, key)=>Object.prototype.hasOwnProperty.call(obj, key);
const equalFlat = (a, b)=>a === b || size(a) === size(b) && every(a, (val, key)=>(val !== undefined || hasProperty(b, key)) && b[key] === val);
const freeze = Object.freeze;
const deepFreeze = (o)=>{
    for(const key in o){
        const c = o[key];
        if (typeof c === 'object' || typeof c === 'function') {
            deepFreeze(o[key]);
        }
    }
    return freeze(o);
};
}}),
"[project]/node_modules/lib0/function.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Common functions and function call helpers.
 *
 * @module function
 */ __turbopack_context__.s({
    "apply": (()=>apply),
    "callAll": (()=>callAll),
    "equalityDeep": (()=>equalityDeep),
    "equalityFlat": (()=>equalityFlat),
    "equalityStrict": (()=>equalityStrict),
    "id": (()=>id),
    "is": (()=>is),
    "isArray": (()=>isArray),
    "isNumber": (()=>isNumber),
    "isOneOf": (()=>isOneOf),
    "isString": (()=>isString),
    "isTemplate": (()=>isTemplate),
    "nop": (()=>nop)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/object.js [app-client] (ecmascript)");
;
;
const callAll = (fs, args, i = 0)=>{
    try {
        for(; i < fs.length; i++){
            fs[i](...args);
        }
    } finally{
        if (i < fs.length) {
            callAll(fs, args, i + 1);
        }
    }
};
const nop = ()=>{};
const apply = (f)=>f();
const id = (a)=>a;
const equalityStrict = (a, b)=>a === b;
const equalityFlat = (a, b)=>a === b || a != null && b != null && a.constructor === b.constructor && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(a) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equalFlat"])(a, b) || typeof a === 'object' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equalFlat"])(a, b));
const equalityDeep = (a, b)=>{
    if (a == null || b == null) {
        return equalityStrict(a, b);
    }
    if (a.constructor !== b.constructor) {
        return false;
    }
    if (a === b) {
        return true;
    }
    switch(a.constructor){
        case ArrayBuffer:
            a = new Uint8Array(a);
            b = new Uint8Array(b);
        // eslint-disable-next-line no-fallthrough
        case Uint8Array:
            {
                if (a.byteLength !== b.byteLength) {
                    return false;
                }
                for(let i = 0; i < a.length; i++){
                    if (a[i] !== b[i]) {
                        return false;
                    }
                }
                break;
            }
        case Set:
            {
                if (a.size !== b.size) {
                    return false;
                }
                for (const value of a){
                    if (!b.has(value)) {
                        return false;
                    }
                }
                break;
            }
        case Map:
            {
                if (a.size !== b.size) {
                    return false;
                }
                for (const key of a.keys()){
                    if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
                        return false;
                    }
                }
                break;
            }
        case Object:
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["length"])(a) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["length"])(b)) {
                return false;
            }
            for(const key in a){
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasProperty"])(a, key) || !equalityDeep(a[key], b[key])) {
                    return false;
                }
            }
            break;
        case Array:
            if (a.length !== b.length) {
                return false;
            }
            for(let i = 0; i < a.length; i++){
                if (!equalityDeep(a[i], b[i])) {
                    return false;
                }
            }
            break;
        default:
            return false;
    }
    return true;
};
const isOneOf = (value, options)=>options.includes(value);
const isArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"];
const isString = (s)=>s && s.constructor === String;
const isNumber = (n)=>n != null && n.constructor === Number;
const is = (n, T)=>n && n.constructor === T;
const isTemplate = (T)=>/**
   * @param {any} n
   * @return {n is InstanceType<TYPE>}
   **/ (n)=>n && n.constructor === T;
}}),
"[project]/node_modules/y-protocols/awareness.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @module awareness-protocol
 */ __turbopack_context__.s({
    "Awareness": (()=>Awareness),
    "applyAwarenessUpdate": (()=>applyAwarenessUpdate),
    "encodeAwarenessUpdate": (()=>encodeAwarenessUpdate),
    "modifyAwarenessUpdate": (()=>modifyAwarenessUpdate),
    "outdatedTimeout": (()=>outdatedTimeout),
    "removeAwarenessStates": (()=>removeAwarenessStates)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/decoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/observable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/function.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const outdatedTimeout = 30000;
class Awareness extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"] {
    /**
   * @param {Y.Doc} doc
   */ constructor(doc){
        super();
        this.doc = doc;
        /**
     * @type {number}
     */ this.clientID = doc.clientID;
        /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */ this.states = new Map();
        /**
     * @type {Map<number, MetaClientState>}
     */ this.meta = new Map();
        this._checkInterval = setInterval(()=>{
            const now = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
            if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ this.meta.get(this.clientID).lastUpdated) {
                // renew local clock
                this.setLocalState(this.getLocalState());
            }
            /**
       * @type {Array<number>}
       */ const remove = [];
            this.meta.forEach((meta, clientid)=>{
                if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
                    remove.push(clientid);
                }
            });
            if (remove.length > 0) {
                removeAwarenessStates(this, remove, 'timeout');
            }
        }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(outdatedTimeout / 10));
        doc.on('destroy', ()=>{
            this.destroy();
        });
        this.setLocalState({});
    }
    destroy() {
        this.emit('destroy', [
            this
        ]);
        this.setLocalState(null);
        super.destroy();
        clearInterval(this._checkInterval);
    }
    /**
   * @return {Object<string,any>|null}
   */ getLocalState() {
        return this.states.get(this.clientID) || null;
    }
    /**
   * @param {Object<string,any>|null} state
   */ setLocalState(state) {
        const clientID = this.clientID;
        const currLocalMeta = this.meta.get(clientID);
        const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;
        const prevState = this.states.get(clientID);
        if (state === null) {
            this.states.delete(clientID);
        } else {
            this.states.set(clientID, state);
        }
        this.meta.set(clientID, {
            clock,
            lastUpdated: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])()
        });
        const added = [];
        const updated = [];
        const filteredUpdated = [];
        const removed = [];
        if (state === null) {
            removed.push(clientID);
        } else if (prevState == null) {
            if (state != null) {
                added.push(clientID);
            }
        } else {
            updated.push(clientID);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equalityDeep"])(prevState, state)) {
                filteredUpdated.push(clientID);
            }
        }
        if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
            this.emit('change', [
                {
                    added,
                    updated: filteredUpdated,
                    removed
                },
                'local'
            ]);
        }
        this.emit('update', [
            {
                added,
                updated,
                removed
            },
            'local'
        ]);
    }
    /**
   * @param {string} field
   * @param {any} value
   */ setLocalStateField(field, value) {
        const state = this.getLocalState();
        if (state !== null) {
            this.setLocalState({
                ...state,
                [field]: value
            });
        }
    }
    /**
   * @return {Map<number,Object<string,any>>}
   */ getStates() {
        return this.states;
    }
}
const removeAwarenessStates = (awareness, clients, origin)=>{
    const removed = [];
    for(let i = 0; i < clients.length; i++){
        const clientID = clients[i];
        if (awareness.states.has(clientID)) {
            awareness.states.delete(clientID);
            if (clientID === awareness.clientID) {
                const curMeta = awareness.meta.get(clientID);
                awareness.meta.set(clientID, {
                    clock: curMeta.clock + 1,
                    lastUpdated: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])()
                });
            }
            removed.push(clientID);
        }
    }
    if (removed.length > 0) {
        awareness.emit('change', [
            {
                added: [],
                updated: [],
                removed
            },
            origin
        ]);
        awareness.emit('update', [
            {
                added: [],
                updated: [],
                removed
            },
            origin
        ]);
    }
};
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states)=>{
    const len = clients.length;
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, len);
    for(let i = 0; i < len; i++){
        const clientID = clients[i];
        const state = states.get(clientID) || null;
        const clock = /** @type {MetaClientState} */ awareness.meta.get(clientID).clock;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, clientID);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, clock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarString"])(encoder, JSON.stringify(state));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(encoder);
};
const modifyAwarenessUpdate = (update, modify)=>{
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update);
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
    const len = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, len);
    for(let i = 0; i < len; i++){
        const clientID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
        const clock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
        const state = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarString"])(decoder));
        const modifiedState = modify(state);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, clientID);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, clock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarString"])(encoder, JSON.stringify(modifiedState));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(encoder);
};
const applyAwarenessUpdate = (awareness, update, origin)=>{
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update);
    const timestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    const len = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
    for(let i = 0; i < len; i++){
        const clientID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
        let clock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
        const state = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarString"])(decoder));
        const clientMeta = awareness.meta.get(clientID);
        const prevState = awareness.states.get(clientID);
        const currClock = clientMeta === undefined ? 0 : clientMeta.clock;
        if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
            if (state === null) {
                // never let a remote client remove this local state
                if (clientID === awareness.clientID && awareness.getLocalState() != null) {
                    // remote client removed the local state. Do not remote state. Broadcast a message indicating
                    // that this client still exists by increasing the clock
                    clock++;
                } else {
                    awareness.states.delete(clientID);
                }
            } else {
                awareness.states.set(clientID, state);
            }
            awareness.meta.set(clientID, {
                clock,
                lastUpdated: timestamp
            });
            if (clientMeta === undefined && state !== null) {
                added.push(clientID);
            } else if (clientMeta !== undefined && state === null) {
                removed.push(clientID);
            } else if (state !== null) {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equalityDeep"])(state, prevState)) {
                    filteredUpdated.push(clientID);
                }
                updated.push(clientID);
            }
        }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
        awareness.emit('change', [
            {
                added,
                updated: filteredUpdated,
                removed
            },
            origin
        ]);
    }
    if (added.length > 0 || updated.length > 0 || removed.length > 0) {
        awareness.emit('update', [
            {
                added,
                updated,
                removed
            },
            origin
        ]);
    }
};
}}),
"[project]/node_modules/lib0/webcrypto.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-env browser */ __turbopack_context__.s({
    "getRandomValues": (()=>getRandomValues),
    "subtle": (()=>subtle)
});
const subtle = crypto.subtle;
const getRandomValues = crypto.getRandomValues.bind(crypto);
}}),
"[project]/node_modules/lib0/random.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Isomorphic module for true random numbers / buffers / uuids.
 *
 * Attention: falls back to Math.random if the browser does not support crypto.
 *
 * @module random
 */ __turbopack_context__.s({
    "oneOf": (()=>oneOf),
    "rand": (()=>rand),
    "uint32": (()=>uint32),
    "uint53": (()=>uint53),
    "uuidv4": (()=>uuidv4)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/binary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$webcrypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/webcrypto.js [app-client] (ecmascript)");
;
;
;
const rand = Math.random;
const uint32 = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$webcrypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRandomValues"])(new Uint32Array(1))[0];
const uint53 = ()=>{
    const arr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$webcrypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRandomValues"])(new Uint32Array(8));
    return (arr[0] & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS21"]) * (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS32"] + 1) + (arr[1] >>> 0);
};
const oneOf = (arr)=>arr[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(rand() * arr.length)];
// @ts-ignore
const uuidv4Template = [
    1e7
] + -1e3 + -4e3 + -8e3 + -1e11;
const uuidv4 = ()=>uuidv4Template.replace(/[018]/g, /** @param {number} c */ (c)=>(c ^ uint32() & 15 >> c / 4).toString(16));
}}),
"[project]/node_modules/lib0/promise.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility helpers to work with promises.
 *
 * @module promise
 */ __turbopack_context__.s({
    "all": (()=>all),
    "create": (()=>create),
    "createEmpty": (()=>createEmpty),
    "isPromise": (()=>isPromise),
    "reject": (()=>reject),
    "resolve": (()=>resolve),
    "resolveWith": (()=>resolveWith),
    "until": (()=>until),
    "untilAsync": (()=>untilAsync),
    "wait": (()=>wait)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/time.js [app-client] (ecmascript)");
;
const create = (f)=>new Promise(f);
const createEmpty = (f)=>new Promise(f);
const all = Promise.all.bind(Promise);
const reject = (reason)=>Promise.reject(reason);
const resolve = (res)=>Promise.resolve(res);
const resolveWith = (res)=>Promise.resolve(res);
const until = (timeout, check, intervalResolution = 10)=>create((resolve, reject)=>{
        const startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
        const hasTimeout = timeout > 0;
        const untilInterval = ()=>{
            if (check()) {
                clearInterval(intervalHandle);
                resolve();
            } else if (hasTimeout) {
                /* c8 ignore else */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])() - startTime > timeout) {
                    clearInterval(intervalHandle);
                    reject(new Error('Timeout'));
                }
            }
        };
        const intervalHandle = setInterval(untilInterval, intervalResolution);
    });
const untilAsync = async (check, timeout = 0, intervalResolution = 10)=>{
    const startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
    const noTimeout = timeout <= 0;
    // eslint-disable-next-line no-unmodified-loop-condition
    while(noTimeout || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])() - startTime <= timeout){
        if (await check()) return;
        await wait(intervalResolution);
    }
    throw new Error('Timeout');
};
const wait = (timeout)=>create((resolve, _reject)=>setTimeout(resolve, timeout));
const isPromise = (p)=>p instanceof Promise || p && p.then && p.catch && p.finally;
}}),
"[project]/node_modules/lib0/conditions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Often used conditions.
 *
 * @module conditions
 */ /**
 * @template T
 * @param {T|null|undefined} v
 * @return {T|null}
 */ /* c8 ignore next */ __turbopack_context__.s({
    "undefinedToNull": (()=>undefinedToNull)
});
const undefinedToNull = (v)=>v === undefined ? null : v;
}}),
"[project]/node_modules/lib0/storage.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * Isomorphic variable storage.
 *
 * Uses LocalStorage in the browser and falls back to in-memory storage.
 *
 * @module storage
 */ /* c8 ignore start */ __turbopack_context__.s({
    "offChange": (()=>offChange),
    "onChange": (()=>onChange),
    "varStorage": (()=>varStorage)
});
class VarStoragePolyfill {
    constructor(){
        this.map = new Map();
    }
    /**
   * @param {string} key
   * @param {any} newValue
   */ setItem(key, newValue) {
        this.map.set(key, newValue);
    }
    /**
   * @param {string} key
   */ getItem(key) {
        return this.map.get(key);
    }
}
/* c8 ignore stop */ /**
 * @type {any}
 */ let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
/* c8 ignore start */ try {
    // if the same-origin rule is violated, accessing localStorage might thrown an error
    if (typeof localStorage !== 'undefined' && localStorage) {
        _localStorage = localStorage;
        usePolyfill = false;
    }
} catch (e) {}
const varStorage = _localStorage;
const onChange = (eventHandler)=>usePolyfill || addEventListener('storage', eventHandler);
const offChange = (eventHandler)=>usePolyfill || removeEventListener('storage', eventHandler);
}}),
"[project]/node_modules/lib0/environment.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Isomorphic module to work access the environment (query params, env variables).
 *
 * @module environment
 */ __turbopack_context__.s({
    "ensureConf": (()=>ensureConf),
    "getConf": (()=>getConf),
    "getParam": (()=>getParam),
    "getVariable": (()=>getVariable),
    "hasConf": (()=>hasConf),
    "hasParam": (()=>hasParam),
    "isBrowser": (()=>isBrowser),
    "isMac": (()=>isMac),
    "isNode": (()=>isNode),
    "production": (()=>production),
    "supportsColor": (()=>supportsColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$conditions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/conditions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$storage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/storage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/function.js [app-client] (ecmascript)");
;
;
;
;
;
const isNode = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].release && /node|io\.js/.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].release.name) && Object.prototype.toString.call(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : 0) === '[object process]';
const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode;
const isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
/**
 * @type {Map<string,string>}
 */ let params;
const args = [];
/* c8 ignore start */ const computeParams = ()=>{
    if (params === undefined) {
        if (isNode) {
            params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
            const pargs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].argv;
            let currParamName = null;
            for(let i = 0; i < pargs.length; i++){
                const parg = pargs[i];
                if (parg[0] === '-') {
                    if (currParamName !== null) {
                        params.set(currParamName, '');
                    }
                    currParamName = parg;
                } else {
                    if (currParamName !== null) {
                        params.set(currParamName, parg);
                        currParamName = null;
                    } else {
                        args.push(parg);
                    }
                }
            }
            if (currParamName !== null) {
                params.set(currParamName, '');
            }
        // in ReactNative for example this would not be true (unless connected to the Remote Debugger)
        } else if (typeof location === 'object') {
            params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(); // eslint-disable-next-line no-undef
            (location.search || '?').slice(1).split('&').forEach((kv)=>{
                if (kv.length !== 0) {
                    const [key, value] = kv.split('=');
                    params.set(`--${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCamelCase"])(key, '-')}`, value);
                    params.set(`-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCamelCase"])(key, '-')}`, value);
                }
            });
        } else {
            params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
        }
    }
    return params;
};
const hasParam = (name)=>computeParams().has(name);
const getParam = (name, defaultVal)=>computeParams().get(name) || defaultVal;
const getVariable = (name)=>isNode ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$conditions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undefinedToNull"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env[name.toUpperCase().replaceAll('-', '_')]) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$conditions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undefinedToNull"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$storage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varStorage"].getItem(name));
const getConf = (name)=>computeParams().get('--' + name) || getVariable(name);
const ensureConf = (name)=>{
    const c = getConf(name);
    if (c == null) throw new Error(`Expected configuration "${name.toUpperCase().replaceAll('-', '_')}"`);
    return c;
};
const hasConf = (name)=>hasParam('--' + name) || getVariable(name) !== null;
const production = hasConf('production');
/* c8 ignore next 2 */ const forceColor = isNode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOneOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FORCE_COLOR, [
    'true',
    '1',
    '2'
]);
const supportsColor = forceColor || !hasParam('--no-colors') && // @todo deprecate --no-colors
!hasConf('no-color') && (!isNode || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout.isTTY) && (!isNode || hasParam('--color') || getVariable('COLORTERM') !== null || (getVariable('TERM') || '').includes('color')) /* c8 ignore stop */ ;
}}),
"[project]/node_modules/lib0/buffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility functions to work with buffers (Uint8Array).
 *
 * @module buffer
 */ __turbopack_context__.s({
    "copyUint8Array": (()=>copyUint8Array),
    "createUint8ArrayFromArrayBuffer": (()=>createUint8ArrayFromArrayBuffer),
    "createUint8ArrayFromLen": (()=>createUint8ArrayFromLen),
    "createUint8ArrayViewFromArrayBuffer": (()=>createUint8ArrayViewFromArrayBuffer),
    "decodeAny": (()=>decodeAny),
    "encodeAny": (()=>encodeAny),
    "fromBase64": (()=>fromBase64),
    "fromBase64UrlEncoded": (()=>fromBase64UrlEncoded),
    "fromHexString": (()=>fromHexString),
    "shiftNBitsLeft": (()=>shiftNBitsLeft),
    "toBase64": (()=>toBase64),
    "toBase64UrlEncoded": (()=>toBase64UrlEncoded),
    "toHexString": (()=>toHexString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/decoding.js [app-client] (ecmascript)");
;
;
;
;
;
;
const createUint8ArrayFromLen = (len)=>new Uint8Array(len);
const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length)=>new Uint8Array(buffer, byteOffset, length);
const createUint8ArrayFromArrayBuffer = (buffer)=>new Uint8Array(buffer);
/* c8 ignore start */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Browser = (bytes)=>{
    let s = '';
    for(let i = 0; i < bytes.byteLength; i++){
        s += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCharCode"])(bytes[i]);
    }
    // eslint-disable-next-line no-undef
    return btoa(s);
};
/* c8 ignore stop */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Node = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64');
/* c8 ignore start */ /**
 * @param {string} s
 * @return {Uint8Array}
 */ const fromBase64Browser = (s)=>{
    // eslint-disable-next-line no-undef
    const a = atob(s);
    const bytes = createUint8ArrayFromLen(a.length);
    for(let i = 0; i < a.length; i++){
        bytes[i] = a.charCodeAt(i);
    }
    return bytes;
};
/* c8 ignore stop */ /**
 * @param {string} s
 */ const fromBase64Node = (s)=>{
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, 'base64');
    return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
const toBase64 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBrowser"] ? toBase64Browser : toBase64Node;
const fromBase64 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBrowser"] ? fromBase64Browser : fromBase64Node;
const toBase64UrlEncoded = (buf)=>toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
const fromBase64UrlEncoded = (base64)=>fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'));
const toHexString = (buf)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(buf, (b)=>b.toString(16).padStart(2, '0')).join('');
const fromHexString = (hex)=>{
    const hlen = hex.length;
    const buf = new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ceil"])(hlen / 2));
    for(let i = 0; i < hlen; i += 2){
        buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16);
    }
    return buf;
};
const copyUint8Array = (uint8Array)=>{
    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
    newBuf.set(uint8Array);
    return newBuf;
};
const encodeAny = (data)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])((encoder)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeAny"])(encoder, data));
const decodeAny = (buf)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readAny"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(buf));
const shiftNBitsLeft = (bs, N)=>{
    if (N === 0) return bs;
    bs = new Uint8Array(bs);
    bs[0] <<= N;
    for(let i = 1; i < bs.length; i++){
        bs[i - 1] |= bs[i] >>> 8 - N;
        bs[i] <<= N;
    }
    return bs;
};
}}),
"[project]/node_modules/lib0/pair.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Working with value pairs.
 *
 * @module pair
 */ /**
 * @template L,R
 */ __turbopack_context__.s({
    "Pair": (()=>Pair),
    "create": (()=>create),
    "createReversed": (()=>createReversed),
    "forEach": (()=>forEach),
    "map": (()=>map)
});
class Pair {
    /**
   * @param {L} left
   * @param {R} right
   */ constructor(left, right){
        this.left = left;
        this.right = right;
    }
}
const create = (left, right)=>new Pair(left, right);
const createReversed = (right, left)=>new Pair(left, right);
const forEach = (arr, f)=>arr.forEach((p)=>f(p.left, p.right));
const map = (arr, f)=>arr.map((p)=>f(p.left, p.right));
}}),
"[project]/node_modules/lib0/dom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * Utility module to work with the DOM.
 *
 * @module dom
 */ __turbopack_context__.s({
    "CDATA_SECTION_NODE": (()=>CDATA_SECTION_NODE),
    "COMMENT_NODE": (()=>COMMENT_NODE),
    "DOCUMENT_FRAGMENT_NODE": (()=>DOCUMENT_FRAGMENT_NODE),
    "DOCUMENT_NODE": (()=>DOCUMENT_NODE),
    "DOCUMENT_TYPE_NODE": (()=>DOCUMENT_TYPE_NODE),
    "ELEMENT_NODE": (()=>ELEMENT_NODE),
    "TEXT_NODE": (()=>TEXT_NODE),
    "addEventListener": (()=>addEventListener),
    "addEventListeners": (()=>addEventListeners),
    "append": (()=>append),
    "appendChild": (()=>appendChild),
    "canvas": (()=>canvas),
    "checkNodeType": (()=>checkNodeType),
    "createDocumentFragment": (()=>createDocumentFragment),
    "createElement": (()=>createElement),
    "createTextNode": (()=>createTextNode),
    "doc": (()=>doc),
    "domParser": (()=>domParser),
    "element": (()=>element),
    "emitCustomEvent": (()=>emitCustomEvent),
    "fragment": (()=>fragment),
    "getElementById": (()=>getElementById),
    "insertBefore": (()=>insertBefore),
    "isParentOf": (()=>isParentOf),
    "mapToStyleString": (()=>mapToStyleString),
    "pairToStyleString": (()=>pairToStyleString),
    "pairsToStyleString": (()=>pairsToStyleString),
    "parseElement": (()=>parseElement),
    "parseFragment": (()=>parseFragment),
    "querySelector": (()=>querySelector),
    "querySelectorAll": (()=>querySelectorAll),
    "remove": (()=>remove),
    "removeEventListener": (()=>removeEventListener),
    "removeEventListeners": (()=>removeEventListeners),
    "replaceWith": (()=>replaceWith),
    "setAttributes": (()=>setAttributes),
    "setAttributesMap": (()=>setAttributesMap),
    "text": (()=>text)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/pair.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/map.js [app-client] (ecmascript)");
;
;
const doc = typeof document !== 'undefined' ? document : {};
const createElement = (name)=>doc.createElement(name);
const createDocumentFragment = ()=>doc.createDocumentFragment();
const createTextNode = (text)=>doc.createTextNode(text);
const domParser = typeof DOMParser !== 'undefined' ? new DOMParser() : null;
const emitCustomEvent = (el, name, opts)=>el.dispatchEvent(new CustomEvent(name, opts));
const setAttributes = (el, attrs)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forEach"])(attrs, (key, value)=>{
        if (value === false) {
            el.removeAttribute(key);
        } else if (value === true) {
            el.setAttribute(key, '');
        } else {
            // @ts-ignore
            el.setAttribute(key, value);
        }
    });
    return el;
};
const setAttributesMap = (el, attrs)=>{
    attrs.forEach((value, key)=>{
        el.setAttribute(key, value);
    });
    return el;
};
const fragment = (children)=>{
    const fragment = createDocumentFragment();
    for(let i = 0; i < children.length; i++){
        appendChild(fragment, children[i]);
    }
    return fragment;
};
const append = (parent, nodes)=>{
    appendChild(parent, fragment(nodes));
    return parent;
};
const remove = (el)=>el.remove();
const addEventListener = (el, name, f)=>el.addEventListener(name, f);
const removeEventListener = (el, name, f)=>el.removeEventListener(name, f);
const addEventListeners = (node, listeners)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forEach"])(listeners, (name, f)=>addEventListener(node, name, f));
    return node;
};
const removeEventListeners = (node, listeners)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forEach"])(listeners, (name, f)=>removeEventListener(node, name, f));
    return node;
};
const element = (name, attrs = [], children = [])=>append(setAttributes(createElement(name), attrs), children);
const canvas = (width, height)=>{
    const c = createElement('canvas');
    c.height = height;
    c.width = width;
    return c;
};
const text = createTextNode;
const pairToStyleString = (pair)=>`${pair.left}:${pair.right};`;
const pairsToStyleString = (pairs)=>pairs.map(pairToStyleString).join('');
const mapToStyleString = (m)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(m, (value, key)=>`${key}:${value};`).join('');
const querySelector = (el, query)=>el.querySelector(query);
const querySelectorAll = (el, query)=>el.querySelectorAll(query);
const getElementById = (id)=>doc.getElementById(id);
/**
 * @param {string} html
 * @return {HTMLElement}
 */ const _parse = (html)=>domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body;
const parseFragment = (html)=>fragment(_parse(html).childNodes);
const parseElement = (html)=>_parse(html).firstElementChild;
const replaceWith = (oldEl, newEl)=>oldEl.replaceWith(newEl);
const insertBefore = (parent, el, ref)=>parent.insertBefore(el, ref);
const appendChild = (parent, child)=>parent.appendChild(child);
const ELEMENT_NODE = doc.ELEMENT_NODE;
const TEXT_NODE = doc.TEXT_NODE;
const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
const COMMENT_NODE = doc.COMMENT_NODE;
const DOCUMENT_NODE = doc.DOCUMENT_NODE;
const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;
const checkNodeType = (node, type)=>node.nodeType === type;
const isParentOf = (parent, child)=>{
    let p = child.parentNode;
    while(p && p !== parent){
        p = p.parentNode;
    }
    return p === parent;
} /* c8 ignore stop */ ;
}}),
"[project]/node_modules/lib0/json.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * JSON utility functions.
 *
 * @module json
 */ /**
 * Transform JavaScript object to JSON.
 *
 * @param {any} object
 * @return {string}
 */ __turbopack_context__.s({
    "parse": (()=>parse),
    "stringify": (()=>stringify)
});
const stringify = JSON.stringify;
const parse = JSON.parse;
}}),
"[project]/node_modules/lib0/eventloop.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */ __turbopack_context__.s({
    "Animation": (()=>Animation),
    "animationFrame": (()=>animationFrame),
    "createDebouncer": (()=>createDebouncer),
    "enqueue": (()=>enqueue),
    "idleCallback": (()=>idleCallback),
    "interval": (()=>interval),
    "timeout": (()=>timeout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/time.js [app-client] (ecmascript)");
;
/**
 * Utility module to work with EcmaScript's event loop.
 *
 * @module eventloop
 */ /**
 * @type {Array<function>}
 */ let queue = [];
const _runQueue = ()=>{
    for(let i = 0; i < queue.length; i++){
        queue[i]();
    }
    queue = [];
};
const enqueue = (f)=>{
    queue.push(f);
    if (queue.length === 1) {
        setTimeout(_runQueue, 0);
    }
};
/**
 * @typedef {Object} TimeoutObject
 * @property {function} TimeoutObject.destroy
 */ /**
 * @param {function(number):void} clearFunction
 */ const createTimeoutClass = (clearFunction)=>class TT {
        /**
   * @param {number} timeoutId
   */ constructor(timeoutId){
            this._ = timeoutId;
        }
        destroy() {
            clearFunction(this._);
        }
    };
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout, callback)=>new Timeout(setTimeout(callback, timeout));
const Interval = createTimeoutClass(clearInterval);
const interval = (timeout, callback)=>new Interval(setInterval(callback, timeout));
const Animation = createTimeoutClass((arg)=>typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg));
const animationFrame = (cb)=>typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));
/* c8 ignore next */ // @ts-ignore
const Idle = createTimeoutClass((arg)=>typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg));
const idleCallback = (cb)=>typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);
const createDebouncer = (timeout, triggerAfter = -1)=>{
    let timer = -1;
    /**
   * @type {number?}
    */ let lastCall = null;
    /**
   * @param {((...args: any)=>void)?} cb function to trigger after debounce. If null, it will reset the
   *                         debounce.
   */ return (cb)=>{
        clearTimeout(timer);
        if (cb) {
            if (triggerAfter >= 0) {
                const now = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
                if (lastCall === null) lastCall = now;
                if (now - lastCall > triggerAfter) {
                    lastCall = null;
                    timer = setTimeout(cb, 0);
                    return;
                }
            }
            timer = setTimeout(()=>{
                lastCall = null;
                cb();
            }, timeout);
        } else {
            lastCall = null;
        }
    };
};
}}),
"[project]/node_modules/lib0/symbol.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to work with EcmaScript Symbols.
 *
 * @module symbol
 */ /**
 * Return fresh symbol.
 *
 * @return {Symbol}
 */ __turbopack_context__.s({
    "create": (()=>create),
    "isSymbol": (()=>isSymbol)
});
const create = Symbol;
const isSymbol = (s)=>typeof s === 'symbol';
}}),
"[project]/node_modules/lib0/logging.common.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BLUE": (()=>BLUE),
    "BOLD": (()=>BOLD),
    "GREEN": (()=>GREEN),
    "GREY": (()=>GREY),
    "ORANGE": (()=>ORANGE),
    "PURPLE": (()=>PURPLE),
    "RED": (()=>RED),
    "UNBOLD": (()=>UNBOLD),
    "UNCOLOR": (()=>UNCOLOR),
    "computeNoColorLoggingArgs": (()=>computeNoColorLoggingArgs),
    "createModuleLogger": (()=>createModuleLogger)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/symbol.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/function.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/json.js [app-client] (ecmascript)");
;
;
;
;
;
const BOLD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const UNBOLD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const BLUE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const GREY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const GREEN = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const RED = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const PURPLE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const ORANGE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const UNCOLOR = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$symbol$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
const computeNoColorLoggingArgs = (args)=>{
    if (args.length === 1 && args[0]?.constructor === Function) {
        args = /** @type {[function]} */ args[0]();
    }
    const strBuilder = [];
    const logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        if (arg === undefined) {
            break;
        } else if (arg.constructor === String || arg.constructor === Number) {
            strBuilder.push(arg);
        } else if (arg.constructor === Object) {
            break;
        }
    }
    if (i > 0) {
        // create logArgs with what we have so far
        logArgs.push(strBuilder.join(''));
    }
    // append the rest
    for(; i < args.length; i++){
        const arg = args[i];
        if (!(arg instanceof Symbol)) {
            logArgs.push(arg);
        }
    }
    return logArgs;
};
/* c8 ignore stop */ const loggingColors = [
    GREEN,
    PURPLE,
    ORANGE,
    BLUE
];
let nextColor = 0;
let lastLoggingTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
const createModuleLogger = (_print, moduleName)=>{
    const color = loggingColors[nextColor];
    const debugRegexVar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVariable"])('log');
    const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName));
    nextColor = (nextColor + 1) % loggingColors.length;
    moduleName += ': ';
    return !doLogging ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nop"] : (...args)=>{
        if (args.length === 1 && args[0]?.constructor === Function) {
            args = args[0]();
        }
        const timeNow = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
        const timeDiff = timeNow - lastLoggingTime;
        lastLoggingTime = timeNow;
        _print(color, moduleName, UNCOLOR, ...args.map((arg)=>{
            if (arg != null && arg.constructor === Uint8Array) {
                arg = Array.from(arg);
            }
            const t = typeof arg;
            switch(t){
                case 'string':
                case 'symbol':
                    return arg;
                default:
                    {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(arg);
                    }
            }
        }), color, ' +' + timeDiff + 'ms');
    };
} /* c8 ignore stop */ ;
}}),
"[project]/node_modules/lib0/logging.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Isomorphic logging module with support for colors!
 *
 * @module logging
 */ __turbopack_context__.s({
    "VConsole": (()=>VConsole),
    "createModuleLogger": (()=>createModuleLogger),
    "createVConsole": (()=>createVConsole),
    "group": (()=>group),
    "groupCollapsed": (()=>groupCollapsed),
    "groupEnd": (()=>groupEnd),
    "print": (()=>print),
    "printCanvas": (()=>printCanvas),
    "printDom": (()=>printDom),
    "printError": (()=>printError),
    "printImg": (()=>printImg),
    "printImgBase64": (()=>printImgBase64),
    "vconsoles": (()=>vconsoles),
    "warn": (()=>warn)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/pair.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/dom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/json.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/eventloop.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/logging.common.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * @type {Object<Symbol,pair.Pair<string,string>>}
 */ const _browserStyleMap = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BOLD"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('font-weight', 'bold'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNBOLD"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('font-weight', 'normal'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BLUE"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'blue'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GREEN"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'green'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GREY"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'grey'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RED"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'red'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PURPLE"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'purple'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ORANGE"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'orange'),
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNCOLOR"]]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('color', 'black')
};
/**
 * @param {Array<string|Symbol|Object|number|function():any>} args
 * @return {Array<string|object|number>}
 */ /* c8 ignore start */ const computeBrowserLoggingArgs = (args)=>{
    if (args.length === 1 && args[0]?.constructor === Function) {
        args = /** @type {[function]} */ args[0]();
    }
    const strBuilder = [];
    const styles = [];
    const currentStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    /**
   * @type {Array<string|Object|number>}
   */ let logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) {
            currentStyle.set(style.left, style.right);
        } else {
            if (arg === undefined) {
                break;
            }
            if (arg.constructor === String || arg.constructor === Number) {
                const style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapToStyleString"])(currentStyle);
                if (i > 0 || style.length > 0) {
                    strBuilder.push('%c' + arg);
                    styles.push(style);
                } else {
                    strBuilder.push(arg);
                }
            } else {
                break;
            }
        }
    }
    if (i > 0) {
        // create logArgs with what we have so far
        logArgs = styles;
        logArgs.unshift(strBuilder.join(''));
    }
    // append the rest
    for(; i < args.length; i++){
        const arg = args[i];
        if (!(arg instanceof Symbol)) {
            logArgs.push(arg);
        }
    }
    return logArgs;
};
/* c8 ignore stop */ /* c8 ignore start */ const computeLoggingArgs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["supportsColor"] ? computeBrowserLoggingArgs : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeNoColorLoggingArgs"];
const print = (...args)=>{
    console.log(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.print(args));
};
const warn = (...args)=>{
    console.warn(...computeLoggingArgs(args));
    args.unshift(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ORANGE"]);
    vconsoles.forEach((vc)=>vc.print(args));
};
const printError = (err)=>{
    console.error(err);
    vconsoles.forEach((vc)=>vc.printError(err));
};
const printImg = (url, height)=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBrowser"]) {
        console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`);
    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)
    }
    vconsoles.forEach((vc)=>vc.printImg(url, height));
};
const printImgBase64 = (base64, height)=>printImg(`data:image/gif;base64,${base64}`, height);
const group = (...args)=>{
    console.group(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.group(args));
};
const groupCollapsed = (...args)=>{
    console.groupCollapsed(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupCollapsed(args));
};
const groupEnd = ()=>{
    console.groupEnd();
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupEnd());
};
const printDom = (createNode)=>vconsoles.forEach((vc)=>vc.printDom(createNode()));
const printCanvas = (canvas, height)=>printImg(canvas.toDataURL(), height);
const vconsoles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
/**
 * @param {Array<string|Symbol|Object|number>} args
 * @return {Array<Element>}
 */ /* c8 ignore start */ const _computeLineSpans = (args)=>{
    const spans = [];
    const currentStyle = new Map();
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        let arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) {
            currentStyle.set(style.left, style.right);
        } else {
            if (arg === undefined) {
                arg = 'undefined ';
            }
            if (arg.constructor === String || arg.constructor === Number) {
                // @ts-ignore
                const span = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('span', [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('style', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapToStyleString"])(currentStyle))
                ], [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"])(arg.toString())
                ]);
                if (span.innerHTML === '') {
                    span.innerHTML = '&nbsp;';
                }
                spans.push(span);
            } else {
                break;
            }
        }
    }
    // append the rest
    for(; i < args.length; i++){
        let content = args[i];
        if (!(content instanceof Symbol)) {
            if (content.constructor !== String && content.constructor !== Number) {
                content = ' ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(content) + ' ';
            }
            spans.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('span', [], [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"])(content)
            ]));
        }
    }
    return spans;
};
/* c8 ignore stop */ const lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;';
class VConsole {
    /**
   * @param {Element} dom
   */ constructor(dom){
        this.dom = dom;
        /**
     * @type {Element}
     */ this.ccontainer = this.dom;
        this.depth = 0;
        vconsoles.add(this);
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   * @param {boolean} collapsed
   */ group(args, collapsed = false) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enqueue"])(()=>{
            const triangleDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('span', [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('hidden', collapsed),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('style', 'color:grey;font-size:120%;')
            ], [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"])('▼')
            ]);
            const triangleRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('span', [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('hidden', !collapsed),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('style', 'color:grey;font-size:125%;')
            ], [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"])('▶')
            ]);
            const content = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('div', [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('style', `${lineStyle};padding-left:${this.depth * 10}px`)
            ], [
                triangleDown,
                triangleRight,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["text"])(' ')
            ].concat(_computeLineSpans(args)));
            const nextContainer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('div', [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('hidden', collapsed)
            ]);
            const nextLine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('div', [], [
                content,
                nextContainer
            ]);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["append"])(this.ccontainer, [
                nextLine
            ]);
            this.ccontainer = nextContainer;
            this.depth++;
            // when header is clicked, collapse/uncollapse container
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addEventListener"])(content, 'click', (_event)=>{
                nextContainer.toggleAttribute('hidden');
                triangleDown.toggleAttribute('hidden');
                triangleRight.toggleAttribute('hidden');
            });
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ groupCollapsed(args) {
        this.group(args, true);
    }
    groupEnd() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enqueue"])(()=>{
            if (this.depth > 0) {
                this.depth--;
                // @ts-ignore
                this.ccontainer = this.ccontainer.parentElement.parentElement;
            }
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ print(args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enqueue"])(()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["append"])(this.ccontainer, [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('div', [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('style', `${lineStyle};padding-left:${this.depth * 10}px`)
                ], _computeLineSpans(args))
            ]);
        });
    }
    /**
   * @param {Error} err
   */ printError(err) {
        this.print([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RED"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BOLD"],
            err.toString()
        ]);
    }
    /**
   * @param {string} url
   * @param {number} height
   */ printImg(url, height) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enqueue"])(()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["append"])(this.ccontainer, [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["element"])('img', [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('src', url),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$pair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('height', `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])(height * 1.5)}px`)
                ])
            ]);
        });
    }
    /**
   * @param {Node} node
   */ printDom(node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enqueue"])(()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["append"])(this.ccontainer, [
                node
            ]);
        });
    }
    destroy() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$eventloop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enqueue"])(()=>{
            vconsoles.delete(this);
        });
    }
}
const createVConsole = (dom)=>new VConsole(dom);
const createModuleLogger = (moduleName)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createModuleLogger"])(print, moduleName);
}}),
"[project]/node_modules/lib0/iterator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Utility module to create and manipulate Iterators.
 *
 * @module iterator
 */ /**
 * @template T,R
 * @param {Iterator<T>} iterator
 * @param {function(T):R} f
 * @return {IterableIterator<R>}
 */ __turbopack_context__.s({
    "createIterator": (()=>createIterator),
    "iteratorFilter": (()=>iteratorFilter),
    "iteratorMap": (()=>iteratorMap),
    "mapIterator": (()=>mapIterator)
});
const mapIterator = (iterator, f)=>({
        [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next () {
            const r = iterator.next();
            return {
                value: r.done ? undefined : f(r.value),
                done: r.done
            };
        }
    });
const createIterator = (next)=>({
        /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next
    });
const iteratorFilter = (iterator, filter)=>createIterator(()=>{
        let res;
        do {
            res = iterator.next();
        }while (!res.done && !filter(res.value))
        return res;
    });
const iteratorMap = (iterator, fmap)=>createIterator(()=>{
        const { done, value } = iterator.next();
        return {
            done,
            value: done ? undefined : fmap(value)
        };
    });
}}),
"[project]/node_modules/yjs/dist/yjs.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbsolutePosition": (()=>AbsolutePosition),
    "AbstractConnector": (()=>AbstractConnector),
    "AbstractStruct": (()=>AbstractStruct),
    "AbstractType": (()=>AbstractType),
    "Array": (()=>YArray),
    "ContentAny": (()=>ContentAny),
    "ContentBinary": (()=>ContentBinary),
    "ContentDeleted": (()=>ContentDeleted),
    "ContentDoc": (()=>ContentDoc),
    "ContentEmbed": (()=>ContentEmbed),
    "ContentFormat": (()=>ContentFormat),
    "ContentJSON": (()=>ContentJSON),
    "ContentString": (()=>ContentString),
    "ContentType": (()=>ContentType),
    "Doc": (()=>Doc),
    "GC": (()=>GC),
    "ID": (()=>ID),
    "Item": (()=>Item),
    "Map": (()=>YMap),
    "PermanentUserData": (()=>PermanentUserData),
    "RelativePosition": (()=>RelativePosition),
    "Skip": (()=>Skip),
    "Snapshot": (()=>Snapshot),
    "Text": (()=>YText),
    "Transaction": (()=>Transaction),
    "UndoManager": (()=>UndoManager),
    "UpdateDecoderV1": (()=>UpdateDecoderV1),
    "UpdateDecoderV2": (()=>UpdateDecoderV2),
    "UpdateEncoderV1": (()=>UpdateEncoderV1),
    "UpdateEncoderV2": (()=>UpdateEncoderV2),
    "XmlElement": (()=>YXmlElement),
    "XmlFragment": (()=>YXmlFragment),
    "XmlHook": (()=>YXmlHook),
    "XmlText": (()=>YXmlText),
    "YArrayEvent": (()=>YArrayEvent),
    "YEvent": (()=>YEvent),
    "YMapEvent": (()=>YMapEvent),
    "YTextEvent": (()=>YTextEvent),
    "YXmlEvent": (()=>YXmlEvent),
    "applyUpdate": (()=>applyUpdate),
    "applyUpdateV2": (()=>applyUpdateV2),
    "cleanupYTextFormatting": (()=>cleanupYTextFormatting),
    "compareIDs": (()=>compareIDs),
    "compareRelativePositions": (()=>compareRelativePositions),
    "convertUpdateFormatV1ToV2": (()=>convertUpdateFormatV1ToV2),
    "convertUpdateFormatV2ToV1": (()=>convertUpdateFormatV2ToV1),
    "createAbsolutePositionFromRelativePosition": (()=>createAbsolutePositionFromRelativePosition),
    "createDeleteSet": (()=>createDeleteSet),
    "createDeleteSetFromStructStore": (()=>createDeleteSetFromStructStore),
    "createDocFromSnapshot": (()=>createDocFromSnapshot),
    "createID": (()=>createID),
    "createRelativePositionFromJSON": (()=>createRelativePositionFromJSON),
    "createRelativePositionFromTypeIndex": (()=>createRelativePositionFromTypeIndex),
    "createSnapshot": (()=>createSnapshot),
    "decodeRelativePosition": (()=>decodeRelativePosition),
    "decodeSnapshot": (()=>decodeSnapshot),
    "decodeSnapshotV2": (()=>decodeSnapshotV2),
    "decodeStateVector": (()=>decodeStateVector),
    "decodeUpdate": (()=>decodeUpdate),
    "decodeUpdateV2": (()=>decodeUpdateV2),
    "diffUpdate": (()=>diffUpdate),
    "diffUpdateV2": (()=>diffUpdateV2),
    "emptySnapshot": (()=>emptySnapshot),
    "encodeRelativePosition": (()=>encodeRelativePosition),
    "encodeSnapshot": (()=>encodeSnapshot),
    "encodeSnapshotV2": (()=>encodeSnapshotV2),
    "encodeStateAsUpdate": (()=>encodeStateAsUpdate),
    "encodeStateAsUpdateV2": (()=>encodeStateAsUpdateV2),
    "encodeStateVector": (()=>encodeStateVector),
    "encodeStateVectorFromUpdate": (()=>encodeStateVectorFromUpdate),
    "encodeStateVectorFromUpdateV2": (()=>encodeStateVectorFromUpdateV2),
    "equalDeleteSets": (()=>equalDeleteSets),
    "equalSnapshots": (()=>equalSnapshots),
    "findIndexSS": (()=>findIndexSS),
    "findRootTypeKey": (()=>findRootTypeKey),
    "getItem": (()=>getItem),
    "getItemCleanEnd": (()=>getItemCleanEnd),
    "getItemCleanStart": (()=>getItemCleanStart),
    "getState": (()=>getState),
    "getTypeChildren": (()=>getTypeChildren),
    "isDeleted": (()=>isDeleted),
    "isParentOf": (()=>isParentOf),
    "iterateDeletedStructs": (()=>iterateDeletedStructs),
    "logType": (()=>logType),
    "logUpdate": (()=>logUpdate),
    "logUpdateV2": (()=>logUpdateV2),
    "mergeDeleteSets": (()=>mergeDeleteSets),
    "mergeUpdates": (()=>mergeUpdates),
    "mergeUpdatesV2": (()=>mergeUpdatesV2),
    "obfuscateUpdate": (()=>obfuscateUpdate),
    "obfuscateUpdateV2": (()=>obfuscateUpdateV2),
    "parseUpdateMeta": (()=>parseUpdateMeta),
    "parseUpdateMetaV2": (()=>parseUpdateMetaV2),
    "readUpdate": (()=>readUpdate),
    "readUpdateV2": (()=>readUpdateV2),
    "relativePositionToJSON": (()=>relativePositionToJSON),
    "snapshot": (()=>snapshot),
    "snapshotContainsUpdate": (()=>snapshotContainsUpdate),
    "transact": (()=>transact),
    "tryGc": (()=>tryGc),
    "typeListToArraySnapshot": (()=>typeListToArraySnapshot),
    "typeMapGetAllSnapshot": (()=>typeMapGetAllSnapshot),
    "typeMapGetSnapshot": (()=>typeMapGetSnapshot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/observable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/decoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$random$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/random.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$promise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/promise.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/binary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/function.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/lib0/logging.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/logging.common.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/iterator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/environment.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * This is an abstract interface that all Connectors should implement to keep them interchangeable.
 *
 * @note This interface is experimental and it is not advised to actually inherit this class.
 *       It just serves as typing information.
 *
 * @extends {ObservableV2<any>}
 */ class AbstractConnector extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableV2"] {
    /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */ constructor(ydoc, awareness){
        super();
        this.doc = ydoc;
        this.awareness = awareness;
    }
}
class DeleteItem {
    /**
   * @param {number} clock
   * @param {number} len
   */ constructor(clock, len){
        /**
     * @type {number}
     */ this.clock = clock;
        /**
     * @type {number}
     */ this.len = len;
    }
}
/**
 * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.
 * - When created in a transaction, it must only be accessed after sorting, and merging
 *   - This DeleteSet is send to other clients
 * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore
 * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.
 */ class DeleteSet {
    constructor(){
        /**
     * @type {Map<number,Array<DeleteItem>>}
     */ this.clients = new Map();
    }
}
/**
 * Iterate over all structs that the DeleteSet gc's.
 *
 * @param {Transaction} transaction
 * @param {DeleteSet} ds
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateDeletedStructs = (transaction, ds, f)=>ds.clients.forEach((deletes, clientid)=>{
        const structs = transaction.doc.store.clients.get(clientid);
        if (structs != null) {
            const lastStruct = structs[structs.length - 1];
            const clockState = lastStruct.id.clock + lastStruct.length;
            for(let i = 0, del = deletes[i]; i < deletes.length && del.clock < clockState; del = deletes[++i]){
                iterateStructs(transaction, structs, del.clock, del.len, f);
            }
        }
    });
/**
 * @param {Array<DeleteItem>} dis
 * @param {number} clock
 * @return {number|null}
 *
 * @private
 * @function
 */ const findIndexDS = (dis, clock)=>{
    let left = 0;
    let right = dis.length - 1;
    while(left <= right){
        const midindex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])((left + right) / 2);
        const mid = dis[midindex];
        const midclock = mid.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.len) {
                return midindex;
            }
            left = midindex + 1;
        } else {
            right = midindex - 1;
        }
    }
    return null;
};
/**
 * @param {DeleteSet} ds
 * @param {ID} id
 * @return {boolean}
 *
 * @private
 * @function
 */ const isDeleted = (ds, id)=>{
    const dis = ds.clients.get(id.client);
    return dis !== undefined && findIndexDS(dis, id.clock) !== null;
};
/**
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const sortAndMergeDeleteSet = (ds)=>{
    ds.clients.forEach((dels)=>{
        dels.sort((a, b)=>a.clock - b.clock);
        // merge items without filtering or splicing the array
        // i is the current pointer
        // j refers to the current insert position for the pointed item
        // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
        let i, j;
        for(i = 1, j = 1; i < dels.length; i++){
            const left = dels[j - 1];
            const right = dels[i];
            if (left.clock + left.len >= right.clock) {
                left.len = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(left.len, right.clock + right.len - left.clock);
            } else {
                if (j < i) {
                    dels[j] = right;
                }
                j++;
            }
        }
        dels.length = j;
    });
};
/**
 * @param {Array<DeleteSet>} dss
 * @return {DeleteSet} A fresh DeleteSet
 */ const mergeDeleteSets = (dss)=>{
    const merged = new DeleteSet();
    for(let dssI = 0; dssI < dss.length; dssI++){
        dss[dssI].clients.forEach((delsLeft, client)=>{
            if (!merged.clients.has(client)) {
                // Write all missing keys from current ds and all following.
                // If merged already contains `client` current ds has already been added.
                /**
         * @type {Array<DeleteItem>}
         */ const dels = delsLeft.slice();
                for(let i = dssI + 1; i < dss.length; i++){
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["appendTo"])(dels, dss[i].clients.get(client) || []);
                }
                merged.clients.set(client, dels);
            }
        });
    }
    sortAndMergeDeleteSet(merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {number} client
 * @param {number} clock
 * @param {number} length
 *
 * @private
 * @function
 */ const addToDeleteSet = (ds, client, clock, length)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(ds.clients, client, ()=>[]).push(new DeleteItem(clock, length));
};
const createDeleteSet = ()=>new DeleteSet();
/**
 * @param {StructStore} ss
 * @return {DeleteSet} Merged and sorted DeleteSet
 *
 * @private
 * @function
 */ const createDeleteSetFromStructStore = (ss)=>{
    const ds = createDeleteSet();
    ss.clients.forEach((structs, client)=>{
        /**
     * @type {Array<DeleteItem>}
     */ const dsitems = [];
        for(let i = 0; i < structs.length; i++){
            const struct = structs[i];
            if (struct.deleted) {
                const clock = struct.id.clock;
                let len = struct.length;
                if (i + 1 < structs.length) {
                    for(let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]){
                        len += next.length;
                    }
                }
                dsitems.push(new DeleteItem(clock, len));
            }
        }
        if (dsitems.length > 0) {
            ds.clients.set(client, dsitems);
        }
    });
    return ds;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const writeDeleteSet = (encoder, ds)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, ds.clients.size);
    // Ensure that the delete set is written in a deterministic order
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(ds.clients.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, dsitems])=>{
        encoder.resetDsCurVal();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, client);
        const len = dsitems.length;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, len);
        for(let i = 0; i < len; i++){
            const item = dsitems[i];
            encoder.writeDsClock(item.clock);
            encoder.writeDsLen(item.len);
        }
    });
};
/**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {DeleteSet}
 *
 * @private
 * @function
 */ const readDeleteSet = (decoder)=>{
    const ds = new DeleteSet();
    const numClients = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        const numberOfDeletes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        if (numberOfDeletes > 0) {
            const dsField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(ds.clients, client, ()=>[]);
            for(let i = 0; i < numberOfDeletes; i++){
                dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
            }
        }
    }
    return ds;
};
/**
 * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..
 */ /**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.
 *
 * @private
 * @function
 */ const readAndApplyDeleteSet = (decoder, transaction, store)=>{
    const unappliedDS = new DeleteSet();
    const numClients = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        const numberOfDeletes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        const structs = store.clients.get(client) || [];
        const state = getState(store, client);
        for(let i = 0; i < numberOfDeletes; i++){
            const clock = decoder.readDsClock();
            const clockEnd = clock + decoder.readDsLen();
            if (clock < state) {
                if (state < clockEnd) {
                    addToDeleteSet(unappliedDS, client, state, clockEnd - state);
                }
                let index = findIndexSS(structs, clock);
                /**
         * We can ignore the case of GC and Delete structs, because we are going to skip them
         * @type {Item}
         */ // @ts-ignore
                let struct = structs[index];
                // split the first item if necessary
                if (!struct.deleted && struct.id.clock < clock) {
                    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
                    index++; // increase we now want to use the next struct
                }
                while(index < structs.length){
                    // @ts-ignore
                    struct = structs[index++];
                    if (struct.id.clock < clockEnd) {
                        if (!struct.deleted) {
                            if (clockEnd < struct.id.clock + struct.length) {
                                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                            }
                            struct.delete(transaction);
                        }
                    } else {
                        break;
                    }
                }
            } else {
                addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
            }
        }
    }
    if (unappliedDS.clients.size > 0) {
        const ds = new UpdateEncoderV2();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(ds.restEncoder, 0); // encode 0 structs
        writeDeleteSet(ds, unappliedDS);
        return ds.toUint8Array();
    }
    return null;
};
/**
 * @param {DeleteSet} ds1
 * @param {DeleteSet} ds2
 */ const equalDeleteSets = (ds1, ds2)=>{
    if (ds1.clients.size !== ds2.clients.size) return false;
    for (const [client, deleteItems1] of ds1.clients.entries()){
        const deleteItems2 = ds2.clients.get(client);
        if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;
        for(let i = 0; i < deleteItems1.length; i++){
            const di1 = deleteItems1[i];
            const di2 = deleteItems2[i];
            if (di1.clock !== di2.clock || di1.len !== di2.len) {
                return false;
            }
        }
    }
    return true;
};
/**
 * @module Y
 */ const generateNewClientId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$random$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint32"];
/**
 * @typedef {Object} DocOpts
 * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)
 * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.
 * @property {string} [DocOpts.guid] Define a globally unique identifier for this document
 * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.
 * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
 * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
 * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
 */ /**
 * @typedef {Object} DocEvents
 * @property {function(Doc):void} DocEvents.destroy
 * @property {function(Doc):void} DocEvents.load
 * @property {function(boolean, Doc):void} DocEvents.sync
 * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.update
 * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.updateV2
 * @property {function(Doc):void} DocEvents.beforeAllTransactions
 * @property {function(Transaction, Doc):void} DocEvents.beforeTransaction
 * @property {function(Transaction, Doc):void} DocEvents.beforeObserverCalls
 * @property {function(Transaction, Doc):void} DocEvents.afterTransaction
 * @property {function(Transaction, Doc):void} DocEvents.afterTransactionCleanup
 * @property {function(Doc, Array<Transaction>):void} DocEvents.afterAllTransactions
 * @property {function({ loaded: Set<Doc>, added: Set<Doc>, removed: Set<Doc> }, Doc, Transaction):void} DocEvents.subdocs
 */ /**
 * A Yjs instance handles the state of shared data.
 * @extends ObservableV2<DocEvents>
 */ class Doc extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableV2"] {
    /**
   * @param {DocOpts} opts configuration
   */ constructor({ guid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$random$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uuidv4"])(), collectionid = null, gc = true, gcFilter = ()=>true, meta = null, autoLoad = false, shouldLoad = true } = {}){
        super();
        this.gc = gc;
        this.gcFilter = gcFilter;
        this.clientID = generateNewClientId();
        this.guid = guid;
        this.collectionid = collectionid;
        /**
     * @type {Map<string, AbstractType<YEvent<any>>>}
     */ this.share = new Map();
        this.store = new StructStore();
        /**
     * @type {Transaction | null}
     */ this._transaction = null;
        /**
     * @type {Array<Transaction>}
     */ this._transactionCleanups = [];
        /**
     * @type {Set<Doc>}
     */ this.subdocs = new Set();
        /**
     * If this document is a subdocument - a document integrated into another document - then _item is defined.
     * @type {Item?}
     */ this._item = null;
        this.shouldLoad = shouldLoad;
        this.autoLoad = autoLoad;
        this.meta = meta;
        /**
     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
     *
     * @type {boolean}
     */ this.isLoaded = false;
        /**
     * This is set to true when the connection provider has successfully synced with a backend.
     * Note that when using peer-to-peer providers this event may not provide very useful.
     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
     * lost (with false as a parameter).
     */ this.isSynced = false;
        this.isDestroyed = false;
        /**
     * Promise that resolves once the document has been loaded from a persistence provider.
     */ this.whenLoaded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$promise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])((resolve)=>{
            this.on('load', ()=>{
                this.isLoaded = true;
                resolve(this);
            });
        });
        const provideSyncedPromise = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$promise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])((resolve)=>{
                /**
       * @param {boolean} isSynced
       */ const eventHandler = (isSynced)=>{
                    if (isSynced === undefined || isSynced === true) {
                        this.off('sync', eventHandler);
                        resolve();
                    }
                };
                this.on('sync', eventHandler);
            });
        this.on('sync', (isSynced)=>{
            if (isSynced === false && this.isSynced) {
                this.whenSynced = provideSyncedPromise();
            }
            this.isSynced = isSynced === undefined || isSynced === true;
            if (this.isSynced && !this.isLoaded) {
                this.emit('load', [
                    this
                ]);
            }
        });
        /**
     * Promise that resolves once the document has been synced with a backend.
     * This promise is recreated when the connection is lost.
     * Note the documentation about the `isSynced` property.
     */ this.whenSynced = provideSyncedPromise();
    }
    /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */ load() {
        const item = this._item;
        if (item !== null && !this.shouldLoad) {
            transact(/** @type {any} */ item.parent.doc, (transaction)=>{
                transaction.subdocsLoaded.add(this);
            }, null, true);
        }
        this.shouldLoad = true;
    }
    getSubdocs() {
        return this.subdocs;
    }
    getSubdocGuids() {
        return new Set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(this.subdocs).map((doc)=>doc.guid));
    }
    /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */ transact(f, origin = null) {
        return transact(this, f, origin);
    }
    /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */ get(name, TypeConstructor = AbstractType) {
        const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(this.share, name, ()=>{
            // @ts-ignore
            const t = new TypeConstructor();
            t._integrate(this, null);
            return t;
        });
        const Constr = type.constructor;
        if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
            if (Constr === AbstractType) {
                // @ts-ignore
                const t = new TypeConstructor();
                t._map = type._map;
                type._map.forEach(/** @param {Item?} n */ (n)=>{
                    for(; n !== null; n = n.left){
                        // @ts-ignore
                        n.parent = t;
                    }
                });
                t._start = type._start;
                for(let n = t._start; n !== null; n = n.right){
                    n.parent = t;
                }
                t._length = type._length;
                this.share.set(name, t);
                t._integrate(this, null);
                return t;
            } else {
                throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
            }
        }
        return type;
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */ getArray(name = '') {
        return this.get(name, YArray);
    }
    /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */ getText(name = '') {
        return this.get(name, YText);
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */ getMap(name = '') {
        return this.get(name, YMap);
    }
    /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */ getXmlElement(name = '') {
        return this.get(name, YXmlElement);
    }
    /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */ getXmlFragment(name = '') {
        return this.get(name, YXmlFragment);
    }
    /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */ toJSON() {
        /**
     * @type {Object<string, any>}
     */ const doc = {};
        this.share.forEach((value, key)=>{
            doc[key] = value.toJSON();
        });
        return doc;
    }
    /**
   * Emit `destroy` event and unregister all event handlers.
   */ destroy() {
        this.isDestroyed = true;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(this.subdocs).forEach((subdoc)=>subdoc.destroy());
        const item = this._item;
        if (item !== null) {
            this._item = null;
            const content = item.content;
            content.doc = new Doc({
                guid: this.guid,
                ...content.opts,
                shouldLoad: false
            });
            content.doc._item = item;
            transact(/** @type {any} */ item.parent.doc, (transaction)=>{
                const doc = content.doc;
                if (!item.deleted) {
                    transaction.subdocsAdded.add(doc);
                }
                transaction.subdocsRemoved.add(this);
            }, null, true);
        }
        // @ts-ignore
        this.emit('destroyed', [
            true
        ]); // DEPRECATED!
        this.emit('destroy', [
            this
        ]);
        super.destroy();
    }
}
class DSDecoderV1 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @return {number}
   */ readDsClock() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder);
    }
    /**
   * @return {number}
   */ readDsLen() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder);
    }
}
class UpdateDecoderV1 extends DSDecoderV1 {
    /**
   * @return {ID}
   */ readLeftID() {
        return createID((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder));
    }
    /**
   * @return {ID}
   */ readRightID() {
        return createID((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder));
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder);
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8"])(this.restDecoder);
    }
    /**
   * @return {string}
   */ readString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarString"])(this.restDecoder);
    }
    /**
   * @return {boolean} isKey
   */ readParentInfo() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder) === 1;
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readTypeRef() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */ readLen() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder);
    }
    /**
   * @return {any}
   */ readAny() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readAny"])(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyUint8Array"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(this.restDecoder));
    }
    /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */ readJSON() {
        return JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarString"])(this.restDecoder));
    }
    /**
   * @return {string}
   */ readKey() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarString"])(this.restDecoder);
    }
}
class DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        /**
     * @private
     */ this.dsCurrVal = 0;
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @return {number}
   */ readDsClock() {
        this.dsCurrVal += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder);
        return this.dsCurrVal;
    }
    /**
   * @return {number}
   */ readDsLen() {
        const diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(this.restDecoder) + 1;
        this.dsCurrVal += diff;
        return diff;
    }
}
class UpdateDecoderV2 extends DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        super(decoder);
        /**
     * List of cached keys. If the keys[id] does not exist, we read a new key
     * from stringEncoder and push it to keys.
     *
     * @type {Array<string>}
     */ this.keys = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder); // read feature flag - currently unused
        this.keyClockDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntDiffOptRleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
        this.clientDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UintOptRleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
        this.leftClockDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntDiffOptRleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
        this.rightClockDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntDiffOptRleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
        this.infoDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8"]);
        this.stringDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StringDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
        this.parentInfoDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8"]);
        this.typeRefDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UintOptRleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
        this.lenDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UintOptRleDecoder"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
    }
    /**
   * @return {ID}
   */ readLeftID() {
        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
    }
    /**
   * @return {ID}
   */ readRightID() {
        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return this.clientDecoder.read();
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return this.infoDecoder.read();
    }
    /**
   * @return {string}
   */ readString() {
        return this.stringDecoder.read();
    }
    /**
   * @return {boolean}
   */ readParentInfo() {
        return this.parentInfoDecoder.read() === 1;
    }
    /**
   * @return {number} An unsigned 8-bit integer
   */ readTypeRef() {
        return this.typeRefDecoder.read();
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */ readLen() {
        return this.lenDecoder.read();
    }
    /**
   * @return {any}
   */ readAny() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readAny"])(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(this.restDecoder);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */ readJSON() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readAny"])(this.restDecoder);
    }
    /**
   * @return {string}
   */ readKey() {
        const keyClock = this.keyClockDecoder.read();
        if (keyClock < this.keys.length) {
            return this.keys[keyClock];
        } else {
            const key = this.stringDecoder.read();
            this.keys.push(key);
            return key;
        }
    }
}
class DSEncoderV1 {
    constructor(){
        this.restEncoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
    }
    toUint8Array() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(this.restEncoder);
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, clock);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, len);
    }
}
class UpdateEncoderV1 extends DSEncoderV1 {
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, id.client);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, id.client);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, id.clock);
    }
    /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */ writeClient(client) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8"])(this.restEncoder, info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarString"])(this.restEncoder, s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeAny"])(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(this.restEncoder, buf);
    }
    /**
   * @param {any} embed
   */ writeJSON(embed) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarString"])(this.restEncoder, JSON.stringify(embed));
    }
    /**
   * @param {string} key
   */ writeKey(key) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarString"])(this.restEncoder, key);
    }
}
class DSEncoderV2 {
    constructor(){
        this.restEncoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])(); // encodes all the rest / non-optimized
        this.dsCurrVal = 0;
    }
    toUint8Array() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(this.restEncoder);
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        const diff = clock - this.dsCurrVal;
        this.dsCurrVal = clock;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, diff);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        if (len === 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(this.restEncoder, len - 1);
        this.dsCurrVal += len;
    }
}
class UpdateEncoderV2 extends DSEncoderV2 {
    constructor(){
        super();
        /**
     * @type {Map<string,number>}
     */ this.keyMap = new Map();
        /**
     * Refers to the next unique key-identifier to me used.
     * See writeKey method for more information.
     *
     * @type {number}
     */ this.keyClock = 0;
        this.keyClockEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntDiffOptRleEncoder"]();
        this.clientEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UintOptRleEncoder"]();
        this.leftClockEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntDiffOptRleEncoder"]();
        this.rightClockEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntDiffOptRleEncoder"]();
        this.infoEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RleEncoder"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8"]);
        this.stringEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StringEncoder"]();
        this.parentInfoEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RleEncoder"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8"]);
        this.typeRefEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UintOptRleEncoder"]();
        this.lenEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UintOptRleEncoder"]();
    }
    toUint8Array() {
        const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, 0); // this is a feature flag that we might use in the future
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.keyClockEncoder.toUint8Array());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.clientEncoder.toUint8Array());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.leftClockEncoder.toUint8Array());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.rightClockEncoder.toUint8Array());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(this.infoEncoder));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.stringEncoder.toUint8Array());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(this.parentInfoEncoder));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.typeRefEncoder.toUint8Array());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, this.lenEncoder.toUint8Array());
        // @note The rest encoder is appended! (note the missing var)
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8Array"])(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(this.restEncoder));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(encoder);
    }
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        this.clientEncoder.write(id.client);
        this.leftClockEncoder.write(id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        this.clientEncoder.write(id.client);
        this.rightClockEncoder.write(id.clock);
    }
    /**
   * @param {number} client
   */ writeClient(client) {
        this.clientEncoder.write(client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        this.infoEncoder.write(info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        this.stringEncoder.write(s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        this.typeRefEncoder.write(info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        this.lenEncoder.write(len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeAny"])(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(this.restEncoder, buf);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */ writeJSON(embed) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeAny"])(this.restEncoder, embed);
    }
    /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */ writeKey(key) {
        const clock = this.keyMap.get(key);
        if (clock === undefined) {
            /**
       * @todo uncomment to introduce this feature finally
       *
       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
       * Furthermore, I forgot to set the keyclock. So everything was working fine.
       *
       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
       *
       * I don't know yet how to reintroduce this feature..
       *
       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
       *
       */ // this.keyMap.set(key, this.keyClock)
            this.keyClockEncoder.write(this.keyClock++);
            this.stringEncoder.write(key);
        } else {
            this.keyClockEncoder.write(clock);
        }
    }
}
/**
 * @module encoding
 */ /*
 * We use the first five bits in the info flag for determining the type of the struct.
 *
 * 0: GC
 * 1: Item with Deleted content
 * 2: Item with JSON content
 * 3: Item with Binary content
 * 4: Item with String content
 * 5: Item with Embed content (for richtext content)
 * 6: Item with Format content (a formatting marker for richtext content)
 * 7: Item with Type
 */ /**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Array<GC|Item>} structs All structs by `client`
 * @param {number} client
 * @param {number} clock write structs starting with `ID(client,clock)`
 *
 * @function
 */ const writeStructs = (encoder, structs, client, clock)=>{
    // write first id
    clock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(clock, structs[0].id.clock); // make sure the first id exists
    const startNewStructs = findIndexSS(structs, clock);
    // write # encoded structs
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, clock);
    const firstStruct = structs[startNewStructs];
    // write first struct with an offset
    firstStruct.write(encoder, clock - firstStruct.id.clock);
    for(let i = startNewStructs + 1; i < structs.length; i++){
        structs[i].write(encoder, 0);
    }
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {StructStore} store
 * @param {Map<number,number>} _sm
 *
 * @private
 * @function
 */ const writeClientsStructs = (encoder, store, _sm)=>{
    // we filter all valid _sm entries into sm
    const sm = new Map();
    _sm.forEach((clock, client)=>{
        // only write if new structs are available
        if (getState(store, client) > clock) {
            sm.set(client, clock);
        }
    });
    getStateVector(store).forEach((_clock, client)=>{
        if (!_sm.has(client)) {
            sm.set(client, 0);
        }
    });
    // write # states that were updated
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, sm.size);
    // Write items with higher client ids first
    // This heavily improves the conflict algorithm.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(sm.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        writeStructs(encoder, store.clients.get(client), client, clock);
    });
};
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.
 * @param {Doc} doc
 * @return {Map<number, { i: number, refs: Array<Item | GC> }>}
 *
 * @private
 * @function
 */ const readClientsStructRefs = (decoder, doc)=>{
    /**
   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}
   */ const clientRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    const numOfStateUpdates = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        /**
     * @type {Array<GC|Item>}
     */ const refs = new Array(numberOfStructs);
        const client = decoder.readClient();
        let clock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        // const start = performance.now()
        clientRefs.set(client, {
            i: 0,
            refs
        });
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            switch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS5"] & info){
                case 0:
                    {
                        const len = decoder.readLen();
                        refs[i] = new GC(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                case 10:
                    {
                        // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.
                        const len = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
                        refs[i] = new Skip(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                default:
                    {
                        /**
           * The optimized implementation doesn't use any variables because inlining variables is faster.
           * Below a non-optimized version is shown that implements the basic algorithm with
           * a few comments
           */ const cantCopyParentInfo = (info & (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"])) === 0;
                        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                        // and we read the next string as parentYKey.
                        // It indicates how we store/retrieve parent from `y.share`
                        // @type {string|null}
                        const struct = new Item(createID(client, clock), null, (info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"] ? decoder.readLeftID() : null, null, (info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"] ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT6"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT6"] ? decoder.readString() : null, readItemContent(decoder, info) // item content
                        );
                        /* A non-optimized implementation of the above algorithm:

          // The item that was originally to the left of this item.
          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null
          // The item that was originally to the right of this item.
          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null
          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0
          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false
          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
          // and we read the next string as parentYKey.
          // It indicates how we store/retrieve parent from `y.share`
          // @type {string|null}
          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null

          const struct = new Item(
            createID(client, clock),
            null, // left
            origin, // origin
            null, // right
            rightOrigin, // right origin
            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent
            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
            readItemContent(decoder, info) // item content
          )
          */ refs[i] = struct;
                        clock += struct.length;
                    }
            }
        }
    // console.log('time to read: ', performance.now() - start) // @todo remove
    }
    return clientRefs;
};
/**
 * Resume computing structs generated by struct readers.
 *
 * While there is something to do, we integrate structs in this order
 * 1. top element on stack, if stack is not empty
 * 2. next element from current struct reader (if empty, use next struct reader)
 *
 * If struct causally depends on another struct (ref.missing), we put next reader of
 * `ref.id.client` on top of stack.
 *
 * At some point we find a struct that has no causal dependencies,
 * then we start emptying the stack.
 *
 * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
 * depends on struct3 (from client1). Therefore the max stack size is equal to `structReaders.length`.
 *
 * This method is implemented in a way so that we can resume computation if this update
 * causally depends on another update.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs
 * @return { null | { update: Uint8Array, missing: Map<number,number> } }
 *
 * @private
 * @function
 */ const integrateStructs = (transaction, store, clientsStructRefs)=>{
    /**
   * @type {Array<Item | GC>}
   */ const stack = [];
    // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.
    let clientsStructRefsIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(clientsStructRefs.keys()).sort((a, b)=>a - b);
    if (clientsStructRefsIds.length === 0) {
        return null;
    }
    const getNextStructTarget = ()=>{
        if (clientsStructRefsIds.length === 0) {
            return null;
        }
        let nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
        while(nextStructsTarget.refs.length === nextStructsTarget.i){
            clientsStructRefsIds.pop();
            if (clientsStructRefsIds.length > 0) {
                nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
            } else {
                return null;
            }
        }
        return nextStructsTarget;
    };
    let curStructsTarget = getNextStructTarget();
    if (curStructsTarget === null) {
        return null;
    }
    /**
   * @type {StructStore}
   */ const restStructs = new StructStore();
    const missingSV = new Map();
    /**
   * @param {number} client
   * @param {number} clock
   */ const updateMissingSv = (client, clock)=>{
        const mclock = missingSV.get(client);
        if (mclock == null || mclock > clock) {
            missingSV.set(client, clock);
        }
    };
    /**
   * @type {GC|Item}
   */ let stackHead = /** @type {any} */ curStructsTarget.refs[/** @type {any} */ curStructsTarget.i++];
    // caching the state because it is used very often
    const state = new Map();
    const addStackToRestSS = ()=>{
        for (const item of stack){
            const client = item.id.client;
            const inapplicableItems = clientsStructRefs.get(client);
            if (inapplicableItems) {
                // decrement because we weren't able to apply previous operation
                inapplicableItems.i--;
                restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
                clientsStructRefs.delete(client);
                inapplicableItems.i = 0;
                inapplicableItems.refs = [];
            } else {
                // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue
                restStructs.clients.set(client, [
                    item
                ]);
            }
            // remove client from clientsStructRefsIds to prevent users from applying the same update again
            clientsStructRefsIds = clientsStructRefsIds.filter((c)=>c !== client);
        }
        stack.length = 0;
    };
    // iterate over all struct readers until we are done
    while(true){
        if (stackHead.constructor !== Skip) {
            const localClock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(state, stackHead.id.client, ()=>getState(store, stackHead.id.client));
            const offset = localClock - stackHead.id.clock;
            if (offset < 0) {
                // update from the same client is missing
                stack.push(stackHead);
                updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
                // hid a dead wall, add all items from stack to restSS
                addStackToRestSS();
            } else {
                const missing = stackHead.getMissing(transaction, store);
                if (missing !== null) {
                    stack.push(stackHead);
                    // get the struct reader that has the missing struct
                    /**
           * @type {{ refs: Array<GC|Item>, i: number }}
           */ const structRefs = clientsStructRefs.get(missing) || {
                        refs: [],
                        i: 0
                    };
                    if (structRefs.refs.length === structRefs.i) {
                        // This update message causally depends on another update message that doesn't exist yet
                        updateMissingSv(missing, getState(store, missing));
                        addStackToRestSS();
                    } else {
                        stackHead = structRefs.refs[structRefs.i++];
                        continue;
                    }
                } else if (offset === 0 || offset < stackHead.length) {
                    // all fine, apply the stackhead
                    stackHead.integrate(transaction, offset);
                    state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
                }
            }
        }
        // iterate to next stackHead
        if (stack.length > 0) {
            stackHead = stack.pop();
        } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
            stackHead = curStructsTarget.refs[curStructsTarget.i++];
        } else {
            curStructsTarget = getNextStructTarget();
            if (curStructsTarget === null) {
                break;
            } else {
                stackHead = curStructsTarget.refs[curStructsTarget.i++];
            }
        }
    }
    if (restStructs.clients.size > 0) {
        const encoder = new UpdateEncoderV2();
        writeClientsStructs(encoder, restStructs, new Map());
        // write empty deleteset
        // writeDeleteSet(encoder, new DeleteSet())
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes
        return {
            missing: missingSV,
            update: encoder.toUint8Array()
        };
    }
    return null;
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 *
 * @private
 * @function
 */ const writeStructsFromTransaction = (encoder, transaction)=>writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts a decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]
 *
 * @function
 */ const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder))=>transact(ydoc, (transaction)=>{
        // force that transaction.local is set to non-local
        transaction.local = false;
        let retry = false;
        const doc = transaction.doc;
        const store = doc.store;
        // let start = performance.now()
        const ss = readClientsStructRefs(structDecoder, doc);
        // console.log('time to read structs: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to merge: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const restStructs = integrateStructs(transaction, store, ss);
        const pending = store.pendingStructs;
        if (pending) {
            // check if we can apply something
            for (const [client, clock] of pending.missing){
                if (clock < getState(store, client)) {
                    retry = true;
                    break;
                }
            }
            if (restStructs) {
                // merge restStructs into store.pending
                for (const [client, clock] of restStructs.missing){
                    const mclock = pending.missing.get(client);
                    if (mclock == null || mclock > clock) {
                        pending.missing.set(client, clock);
                    }
                }
                pending.update = mergeUpdatesV2([
                    pending.update,
                    restStructs.update
                ]);
            }
        } else {
            store.pendingStructs = restStructs;
        }
        // console.log('time to integrate: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
        if (store.pendingDs) {
            // @todo we could make a lower-bound state-vector check as we do above
            const pendingDSUpdate = new UpdateDecoderV2((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(store.pendingDs));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate
            const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
            if (dsRest && dsRest2) {
                // case 1: ds1 != null && ds2 != null
                store.pendingDs = mergeUpdatesV2([
                    dsRest,
                    dsRest2
                ]);
            } else {
                // case 2: ds1 != null
                // case 3: ds2 != null
                // case 4: ds1 == null && ds2 == null
                store.pendingDs = dsRest || dsRest2;
            }
        } else {
            // Either dsRest == null && pendingDs == null OR dsRest != null
            store.pendingDs = dsRest;
        }
        // console.log('time to cleanup: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove
        // start = performance.now()
        if (retry) {
            const update = /** @type {{update: Uint8Array}} */ store.pendingStructs.update;
            store.pendingStructs = null;
            applyUpdateV2(transaction.doc, update);
        }
    }, transactionOrigin, false);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts a decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const readUpdate = (decoder, ydoc, transactionOrigin)=>readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 *
 * @function
 */ const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2)=>{
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update);
    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const applyUpdate = (ydoc, update, transactionOrigin)=>applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
/**
 * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will
 * only write the operations that are missing.
 *
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Doc} doc
 * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 *
 * @function
 */ const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map())=>{
    writeClientsStructs(encoder, doc.store, targetStateVector);
    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([
    0
]), encoder = new UpdateEncoderV2())=>{
    const targetStateVector = decodeStateVector(encodedTargetStateVector);
    writeStateAsUpdate(encoder, doc, targetStateVector);
    const updates = [
        encoder.toUint8Array()
    ];
    // also add the pending updates (if there are any)
    if (doc.store.pendingDs) {
        updates.push(doc.store.pendingDs);
    }
    if (doc.store.pendingStructs) {
        updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));
    }
    if (updates.length > 1) {
        if (encoder.constructor === UpdateEncoderV1) {
            return mergeUpdates(updates.map((update, i)=>i === 0 ? update : convertUpdateFormatV2ToV1(update)));
        } else if (encoder.constructor === UpdateEncoderV2) {
            return mergeUpdatesV2(updates);
        }
    }
    return updates[0];
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdate = (doc, encodedTargetStateVector)=>encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());
/**
 * Read state vector from Decoder and return as Map
 *
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const readStateVector = (decoder)=>{
    const ss = new Map();
    const ssLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
    for(let i = 0; i < ssLength; i++){
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        const clock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        ss.set(client, clock);
    }
    return ss;
};
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const decodeStateVector = (decodedState)=>readStateVector(new DSDecoderV1((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(decodedState)));
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Map<number,number>} sv
 * @function
 */ const writeStateVector = (encoder, sv)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, sv.size);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(sv.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, clock);
    });
    return encoder;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Doc} doc
 *
 * @function
 */ const writeDocumentStateVector = (encoder, doc)=>writeStateVector(encoder, getStateVector(doc.store));
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2())=>{
    if (doc instanceof Map) {
        writeStateVector(encoder, doc);
    } else {
        writeDocumentStateVector(encoder, doc);
    }
    return encoder.toUint8Array();
};
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVector = (doc)=>encodeStateVectorV2(doc, new DSEncoderV1());
/**
 * General event handler implementation.
 *
 * @template ARG0, ARG1
 *
 * @private
 */ class EventHandler {
    constructor(){
        /**
     * @type {Array<function(ARG0, ARG1):void>}
     */ this.l = [];
    }
}
/**
 * @template ARG0,ARG1
 * @returns {EventHandler<ARG0,ARG1>}
 *
 * @private
 * @function
 */ const createEventHandler = ()=>new EventHandler();
/**
 * Adds an event listener that is called when
 * {@link EventHandler#callEventListeners} is called.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler.
 *
 * @private
 * @function
 */ const addEventHandlerListener = (eventHandler, f)=>eventHandler.l.push(f);
/**
 * Removes an event listener.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler that was added with
 *                     {@link EventHandler#addEventListener}
 *
 * @private
 * @function
 */ const removeEventHandlerListener = (eventHandler, f)=>{
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g)=>f !== g);
    if (len === eventHandler.l.length) {
        console.error('[yjs] Tried to remove event handler that doesn\'t exist.');
    }
};
/**
 * Call all event listeners that were added via
 * {@link EventHandler#addEventListener}.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {ARG0} arg0
 * @param {ARG1} arg1
 *
 * @private
 * @function
 */ const callEventHandlerListeners = (eventHandler, arg0, arg1)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callAll"])(eventHandler.l, [
        arg0,
        arg1
    ]);
class ID {
    /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */ constructor(client, clock){
        /**
     * Client id
     * @type {number}
     */ this.client = client;
        /**
     * unique per client id, continuous number
     * @type {number}
     */ this.clock = clock;
    }
}
/**
 * @param {ID | null} a
 * @param {ID | null} b
 * @return {boolean}
 *
 * @function
 */ const compareIDs = (a, b)=>a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
/**
 * @param {number} client
 * @param {number} clock
 *
 * @private
 * @function
 */ const createID = (client, clock)=>new ID(client, clock);
/**
 * @param {encoding.Encoder} encoder
 * @param {ID} id
 *
 * @private
 * @function
 */ const writeID = (encoder, id)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, id.client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, id.clock);
};
/**
 * Read ID.
 * * If first varUint read is 0xFFFFFF a RootID is returned.
 * * Otherwise an ID is returned
 *
 * @param {decoding.Decoder} decoder
 * @return {ID}
 *
 * @private
 * @function
 */ const readID = (decoder)=>createID((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder));
/**
 * The top types are mapped from y.share.get(keyname) => type.
 * `type` does not store any information about the `keyname`.
 * This function finds the correct `keyname` for `type` and throws otherwise.
 *
 * @param {AbstractType<any>} type
 * @return {string}
 *
 * @private
 * @function
 */ const findRootTypeKey = (type)=>{
    // @ts-ignore _y must be defined, otherwise unexpected case
    for (const [key, value] of type.doc.share.entries()){
        if (value === type) {
            return key;
        }
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
};
/**
 * Check if `parent` is a parent of `child`.
 *
 * @param {AbstractType<any>} parent
 * @param {Item|null} child
 * @return {Boolean} Whether `parent` is a parent of `child`.
 *
 * @private
 * @function
 */ const isParentOf = (parent, child)=>{
    while(child !== null){
        if (child.parent === parent) {
            return true;
        }
        child = /** @type {AbstractType<any>} */ child.parent._item;
    }
    return false;
};
/**
 * Convenient helper to log type information.
 *
 * Do not use in productive systems as the output can be immense!
 *
 * @param {AbstractType<any>} type
 */ const logType = (type)=>{
    const res = [];
    let n = type._start;
    while(n){
        res.push(n);
        n = n.right;
    }
    console.log('Children: ', res);
    console.log('Children content: ', res.filter((m)=>!m.deleted).map((m)=>m.content));
};
class PermanentUserData {
    /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */ constructor(doc, storeType = doc.getMap('users')){
        /**
     * @type {Map<string,DeleteSet>}
     */ const dss = new Map();
        this.yusers = storeType;
        this.doc = doc;
        /**
     * Maps from clientid to userDescription
     *
     * @type {Map<number,string>}
     */ this.clients = new Map();
        this.dss = dss;
        /**
     * @param {YMap<any>} user
     * @param {string} userDescription
     */ const initUser = (user, userDescription)=>{
            /**
       * @type {YArray<Uint8Array>}
       */ const ds = user.get('ds');
            const ids = user.get('ids');
            const addClientId = /** @param {number} clientid */ (clientid)=>this.clients.set(clientid, userDescription);
            ds.observe(/** @param {YArrayEvent<any>} event */ (event)=>{
                event.changes.added.forEach((item)=>{
                    item.content.getContent().forEach((encodedDs)=>{
                        if (encodedDs instanceof Uint8Array) {
                            this.dss.set(userDescription, mergeDeleteSets([
                                this.dss.get(userDescription) || createDeleteSet(),
                                readDeleteSet(new DSDecoderV1((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(encodedDs)))
                            ]));
                        }
                    });
                });
            });
            this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs)=>readDeleteSet(new DSDecoderV1((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(encodedDs))))));
            ids.observe(/** @param {YArrayEvent<any>} event */ (event)=>event.changes.added.forEach((item)=>item.content.getContent().forEach(addClientId)));
            ids.forEach(addClientId);
        };
        // observe users
        storeType.observe((event)=>{
            event.keysChanged.forEach((userDescription)=>initUser(storeType.get(userDescription), userDescription));
        });
        // add initial data
        storeType.forEach(initUser);
    }
    /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */ setUserMapping(doc, clientid, userDescription, { filter = ()=>true } = {}) {
        const users = this.yusers;
        let user = users.get(userDescription);
        if (!user) {
            user = new YMap();
            user.set('ids', new YArray());
            user.set('ds', new YArray());
            users.set(userDescription, user);
        }
        user.get('ids').push([
            clientid
        ]);
        users.observe((_event)=>{
            setTimeout(()=>{
                const userOverwrite = users.get(userDescription);
                if (userOverwrite !== user) {
                    // user was overwritten, port all data over to the next user object
                    // @todo Experiment with Y.Sets here
                    user = userOverwrite;
                    // @todo iterate over old type
                    this.clients.forEach((_userDescription, clientid)=>{
                        if (userDescription === _userDescription) {
                            user.get('ids').push([
                                clientid
                            ]);
                        }
                    });
                    const encoder = new DSEncoderV1();
                    const ds = this.dss.get(userDescription);
                    if (ds) {
                        writeDeleteSet(encoder, ds);
                        user.get('ds').push([
                            encoder.toUint8Array()
                        ]);
                    }
                }
            }, 0);
        });
        doc.on('afterTransaction', /** @param {Transaction} transaction */ (transaction)=>{
            setTimeout(()=>{
                const yds = user.get('ds');
                const ds = transaction.deleteSet;
                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
                    const encoder = new DSEncoderV1();
                    writeDeleteSet(encoder, ds);
                    yds.push([
                        encoder.toUint8Array()
                    ]);
                }
            });
        });
    }
    /**
   * @param {number} clientid
   * @return {any}
   */ getUserByClientId(clientid) {
        return this.clients.get(clientid) || null;
    }
    /**
   * @param {ID} id
   * @return {string | null}
   */ getUserByDeletedId(id) {
        for (const [userDescription, ds] of this.dss.entries()){
            if (isDeleted(ds, id)) {
                return userDescription;
            }
        }
        return null;
    }
}
/**
 * A relative position is based on the Yjs model and is not affected by document changes.
 * E.g. If you place a relative position before a certain character, it will always point to this character.
 * If you place a relative position at the end of a type, it will always point to the end of the type.
 *
 * A numeric position is often unsuited for user selections, because it does not change when content is inserted
 * before or after.
 *
 * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
 *
 * One of the properties must be defined.
 *
 * @example
 *   // Current cursor position is at position 10
 *   const relativePosition = createRelativePositionFromIndex(yText, 10)
 *   // modify yText
 *   yText.insert(0, 'abc')
 *   yText.delete(3, 10)
 *   // Compute the cursor position
 *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
 *   absolutePosition.type === yText // => true
 *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
 *
 */ class RelativePosition {
    /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */ constructor(type, tname, item, assoc = 0){
        /**
     * @type {ID|null}
     */ this.type = type;
        /**
     * @type {string|null}
     */ this.tname = tname;
        /**
     * @type {ID | null}
     */ this.item = item;
        /**
     * A relative position is associated to a specific character. By default
     * assoc >= 0, the relative position is associated to the character
     * after the meant position.
     * I.e. position 1 in 'ab' is associated to character 'b'.
     *
     * If assoc < 0, then the relative position is associated to the character
     * before the meant position.
     *
     * @type {number}
     */ this.assoc = assoc;
    }
}
/**
 * @param {RelativePosition} rpos
 * @return {any}
 */ const relativePositionToJSON = (rpos)=>{
    const json = {};
    if (rpos.type) {
        json.type = rpos.type;
    }
    if (rpos.tname) {
        json.tname = rpos.tname;
    }
    if (rpos.item) {
        json.item = rpos.item;
    }
    if (rpos.assoc != null) {
        json.assoc = rpos.assoc;
    }
    return json;
};
/**
 * @param {any} json
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromJSON = (json)=>new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
class AbsolutePosition {
    /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */ constructor(type, index, assoc = 0){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
        /**
     * @type {number}
     */ this.index = index;
        this.assoc = assoc;
    }
}
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @param {number} [assoc]
 *
 * @function
 */ const createAbsolutePosition = (type, index, assoc = 0)=>new AbsolutePosition(type, index, assoc);
/**
 * @param {AbstractType<any>} type
 * @param {ID|null} item
 * @param {number} [assoc]
 *
 * @function
 */ const createRelativePosition = (type, item, assoc)=>{
    let typeid = null;
    let tname = null;
    if (type._item === null) {
        tname = findRootTypeKey(type);
    } else {
        typeid = createID(type._item.id.client, type._item.id.clock);
    }
    return new RelativePosition(typeid, tname, item, assoc);
};
/**
 * Create a relativePosition based on a absolute position.
 *
 * @param {AbstractType<any>} type The base type (e.g. YText or YArray).
 * @param {number} index The absolute position.
 * @param {number} [assoc]
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromTypeIndex = (type, index, assoc = 0)=>{
    let t = type._start;
    if (assoc < 0) {
        // associated to the left character or the beginning of a type, increment index if possible.
        if (index === 0) {
            return createRelativePosition(type, null, assoc);
        }
        index--;
    }
    while(t !== null){
        if (!t.deleted && t.countable) {
            if (t.length > index) {
                // case 1: found position somewhere in the linked list
                return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);
            }
            index -= t.length;
        }
        if (t.right === null && assoc < 0) {
            // left-associated position, return last available id
            return createRelativePosition(type, t.lastId, assoc);
        }
        t = t.right;
    }
    return createRelativePosition(type, null, assoc);
};
/**
 * @param {encoding.Encoder} encoder
 * @param {RelativePosition} rpos
 *
 * @function
 */ const writeRelativePosition = (encoder, rpos)=>{
    const { type, tname, item, assoc } = rpos;
    if (item !== null) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, 0);
        writeID(encoder, item);
    } else if (tname !== null) {
        // case 2: found position at the end of the list and type is stored in y.share
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8"])(encoder, 1);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarString"])(encoder, tname);
    } else if (type !== null) {
        // case 3: found position at the end of the list and type is attached to an item
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8"])(encoder, 2);
        writeID(encoder, type);
    } else {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarInt"])(encoder, assoc);
    return encoder;
};
/**
 * @param {RelativePosition} rpos
 * @return {Uint8Array}
 */ const encodeRelativePosition = (rpos)=>{
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
    writeRelativePosition(encoder, rpos);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(encoder);
};
/**
 * @param {decoding.Decoder} decoder
 * @return {RelativePosition}
 *
 * @function
 */ const readRelativePosition = (decoder)=>{
    let type = null;
    let tname = null;
    let itemID = null;
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder)){
        case 0:
            // case 1: found position somewhere in the linked list
            itemID = readID(decoder);
            break;
        case 1:
            // case 2: found position at the end of the list and type is stored in y.share
            tname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarString"])(decoder);
            break;
        case 2:
            {
                // case 3: found position at the end of the list and type is attached to an item
                type = readID(decoder);
            }
    }
    const assoc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasContent"])(decoder) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarInt"])(decoder) : 0;
    return new RelativePosition(type, tname, itemID, assoc);
};
/**
 * @param {Uint8Array} uint8Array
 * @return {RelativePosition}
 */ const decodeRelativePosition = (uint8Array)=>readRelativePosition((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(uint8Array));
/**
 * @param {StructStore} store
 * @param {ID} id
 */ const getItemWithOffset = (store, id)=>{
    const item = getItem(store, id);
    const diff = id.clock - item.id.clock;
    return {
        item,
        diff
    };
};
/**
 * Transform a relative position to an absolute position.
 *
 * If you want to share the relative position with other users, you should set
 * `followUndoneDeletions` to false to get consistent results across all clients.
 *
 * When calculating the absolute position, we try to follow the "undone deletions". This yields
 * better results for the user who performed undo. However, only the user who performed the undo
 * will get the better results, the other users don't know which operations recreated a deleted
 * range of content. There is more information in this ticket: https://github.com/yjs/yjs/issues/638
 *
 * @param {RelativePosition} rpos
 * @param {Doc} doc
 * @param {boolean} followUndoneDeletions - whether to follow undone deletions - see https://github.com/yjs/yjs/issues/638
 * @return {AbsolutePosition|null}
 *
 * @function
 */ const createAbsolutePositionFromRelativePosition = (rpos, doc, followUndoneDeletions = true)=>{
    const store = doc.store;
    const rightID = rpos.item;
    const typeID = rpos.type;
    const tname = rpos.tname;
    const assoc = rpos.assoc;
    let type = null;
    let index = 0;
    if (rightID !== null) {
        if (getState(store, rightID.client) <= rightID.clock) {
            return null;
        }
        const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
        const right = res.item;
        if (!(right instanceof Item)) {
            return null;
        }
        type = right.parent;
        if (type._item === null || !type._item.deleted) {
            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary
            let n = right.left;
            while(n !== null){
                if (!n.deleted && n.countable) {
                    index += n.length;
                }
                n = n.left;
            }
        }
    } else {
        if (tname !== null) {
            type = doc.get(tname);
        } else if (typeID !== null) {
            if (getState(store, typeID.client) <= typeID.clock) {
                // type does not exist yet
                return null;
            }
            const { item } = followUndoneDeletions ? followRedone(store, typeID) : {
                item: getItem(store, typeID)
            };
            if (item instanceof Item && item.content instanceof ContentType) {
                type = item.content.type;
            } else {
                // struct is garbage collected
                return null;
            }
        } else {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
        }
        if (assoc >= 0) {
            index = type._length;
        } else {
            index = 0;
        }
    }
    return createAbsolutePosition(type, index, rpos.assoc);
};
/**
 * @param {RelativePosition|null} a
 * @param {RelativePosition|null} b
 * @return {boolean}
 *
 * @function
 */ const compareRelativePositions = (a, b)=>a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
class Snapshot {
    /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */ constructor(ds, sv){
        /**
     * @type {DeleteSet}
     */ this.ds = ds;
        /**
     * State Map
     * @type {Map<number,number>}
     */ this.sv = sv;
    }
}
/**
 * @param {Snapshot} snap1
 * @param {Snapshot} snap2
 * @return {boolean}
 */ const equalSnapshots = (snap1, snap2)=>{
    const ds1 = snap1.ds.clients;
    const ds2 = snap2.ds.clients;
    const sv1 = snap1.sv;
    const sv2 = snap2.sv;
    if (sv1.size !== sv2.size || ds1.size !== ds2.size) {
        return false;
    }
    for (const [key, value] of sv1.entries()){
        if (sv2.get(key) !== value) {
            return false;
        }
    }
    for (const [client, dsitems1] of ds1.entries()){
        const dsitems2 = ds2.get(client) || [];
        if (dsitems1.length !== dsitems2.length) {
            return false;
        }
        for(let i = 0; i < dsitems1.length; i++){
            const dsitem1 = dsitems1[i];
            const dsitem2 = dsitems2[i];
            if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {
                return false;
            }
        }
    }
    return true;
};
/**
 * @param {Snapshot} snapshot
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 */ const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2())=>{
    writeDeleteSet(encoder, snapshot.ds);
    writeStateVector(encoder, snapshot.sv);
    return encoder.toUint8Array();
};
/**
 * @param {Snapshot} snapshot
 * @return {Uint8Array}
 */ const encodeSnapshot = (snapshot)=>encodeSnapshotV2(snapshot, new DSEncoderV1());
/**
 * @param {Uint8Array} buf
 * @param {DSDecoderV1 | DSDecoderV2} [decoder]
 * @return {Snapshot}
 */ const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(buf)))=>{
    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
};
/**
 * @param {Uint8Array} buf
 * @return {Snapshot}
 */ const decodeSnapshot = (buf)=>decodeSnapshotV2(buf, new DSDecoderV1((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(buf)));
/**
 * @param {DeleteSet} ds
 * @param {Map<number,number>} sm
 * @return {Snapshot}
 */ const createSnapshot = (ds, sm)=>new Snapshot(ds, sm);
const emptySnapshot = createSnapshot(createDeleteSet(), new Map());
/**
 * @param {Doc} doc
 * @return {Snapshot}
 */ const snapshot = (doc)=>createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
/**
 * @param {Item} item
 * @param {Snapshot|undefined} snapshot
 *
 * @protected
 * @function
 */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
/**
 * @param {Transaction} transaction
 * @param {Snapshot} snapshot
 */ const splitSnapshotAffectedStructs = (transaction, snapshot)=>{
    const meta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(transaction.meta, splitSnapshotAffectedStructs, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"]);
    const store = transaction.doc.store;
    // check if we already split for this snapshot
    if (!meta.has(snapshot)) {
        snapshot.sv.forEach((clock, client)=>{
            if (clock < getState(store, client)) {
                getItemCleanStart(transaction, createID(client, clock));
            }
        });
        iterateDeletedStructs(transaction, snapshot.ds, (_item)=>{});
        meta.add(snapshot);
    }
};
/**
 * @example
 *  const ydoc = new Y.Doc({ gc: false })
 *  ydoc.getText().insert(0, 'world!')
 *  const snapshot = Y.snapshot(ydoc)
 *  ydoc.getText().insert(0, 'hello ')
 *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)
 *  assert(restored.getText().toString() === 'world!')
 *
 * @param {Doc} originDoc
 * @param {Snapshot} snapshot
 * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc
 * @return {Doc}
 */ const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc())=>{
    if (originDoc.gc) {
        // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted
        throw new Error('Garbage-collection must be disabled in `originDoc`!');
    }
    const { sv, ds } = snapshot;
    const encoder = new UpdateEncoderV2();
    originDoc.transact((transaction)=>{
        let size = 0;
        sv.forEach((clock)=>{
            if (clock > 0) {
                size++;
            }
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, size);
        // splitting the structs before writing them to the encoder
        for (const [client, clock] of sv){
            if (clock === 0) {
                continue;
            }
            if (clock < getState(originDoc.store, client)) {
                getItemCleanStart(transaction, createID(client, clock));
            }
            const structs = originDoc.store.clients.get(client) || [];
            const lastStructIndex = findIndexSS(structs, clock - 1);
            // write # encoded structs
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, lastStructIndex + 1);
            encoder.writeClient(client);
            // first clock written is 0
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, 0);
            for(let i = 0; i <= lastStructIndex; i++){
                structs[i].write(encoder, 0);
            }
        }
        writeDeleteSet(encoder, ds);
    });
    applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');
    return newDoc;
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 */ const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2)=>{
    const updateDecoder = new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
            return false;
        }
    }
    const mergedDS = mergeDeleteSets([
        snapshot.ds,
        readDeleteSet(updateDecoder)
    ]);
    return equalDeleteSets(snapshot.ds, mergedDS);
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 */ const snapshotContainsUpdate = (snapshot, update)=>snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);
class StructStore {
    constructor(){
        /**
     * @type {Map<number,Array<GC|Item>>}
     */ this.clients = new Map();
        /**
     * @type {null | { missing: Map<number, number>, update: Uint8Array }}
     */ this.pendingStructs = null;
        /**
     * @type {null | Uint8Array}
     */ this.pendingDs = null;
    }
}
/**
 * Return the states as a Map<client,clock>.
 * Note that clock refers to the next expected clock id.
 *
 * @param {StructStore} store
 * @return {Map<number,number>}
 *
 * @public
 * @function
 */ const getStateVector = (store)=>{
    const sm = new Map();
    store.clients.forEach((structs, client)=>{
        const struct = structs[structs.length - 1];
        sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
};
/**
 * @param {StructStore} store
 * @param {number} client
 * @return {number}
 *
 * @public
 * @function
 */ const getState = (store, client)=>{
    const structs = store.clients.get(client);
    if (structs === undefined) {
        return 0;
    }
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
};
/**
 * @param {StructStore} store
 * @param {GC|Item} struct
 *
 * @private
 * @function
 */ const addStruct = (store, struct)=>{
    let structs = store.clients.get(struct.id.client);
    if (structs === undefined) {
        structs = [];
        store.clients.set(struct.id.client, structs);
    } else {
        const lastStruct = structs[structs.length - 1];
        if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
        }
    }
    structs.push(struct);
};
/**
 * Perform a binary search on a sorted array
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 * @return {number}
 *
 * @private
 * @function
 */ const findIndexSS = (structs, clock)=>{
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock) {
        return right;
    }
    // @todo does it even make sense to pivot the search?
    // If a good split misses, it might actually increase the time to find the correct item.
    // Currently, the only advantage is that search with pivoting might find the item on the first try.
    let midindex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(clock / (midclock + mid.length - 1) * right); // pivoting the search
    while(left <= right){
        mid = structs[midindex];
        midclock = mid.id.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.length) {
                return midindex;
            }
            left = midindex + 1;
        } else {
            right = midindex - 1;
        }
        midindex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])((left + right) / 2);
    }
    // Always check state before looking for a struct in StructStore
    // Therefore the case of not finding a struct is unexpected
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {GC|Item}
 *
 * @private
 * @function
 */ const find = (store, id)=>{
    /**
   * @type {Array<GC|Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    return structs[findIndexSS(structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 * @private
 * @function
 */ const getItem = find;
/**
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 */ const findIndexCleanStart = (transaction, structs, clock)=>{
    const index = findIndexSS(structs, clock);
    const struct = structs[index];
    if (struct.id.clock < clock && struct instanceof Item) {
        structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
        return index + 1;
    }
    return index;
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanStart = (transaction, id)=>{
    const structs = transaction.doc.store.clients.get(id.client);
    return structs[findIndexCleanStart(transaction, structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanEnd = (transaction, store, id)=>{
    /**
   * @type {Array<Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    const index = findIndexSS(structs, id.clock);
    const struct = structs[index];
    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
        structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
    }
    return struct;
};
/**
 * Replace `item` with `newitem` in store
 * @param {StructStore} store
 * @param {GC|Item} struct
 * @param {GC|Item} newStruct
 *
 * @private
 * @function
 */ const replaceStruct = (store, struct, newStruct)=>{
    const structs = store.clients.get(struct.id.client);
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
/**
 * Iterate over a range of structs
 *
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clockStart Inclusive start
 * @param {number} len
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateStructs = (transaction, structs, clockStart, len, f)=>{
    if (len === 0) {
        return;
    }
    const clockEnd = clockStart + len;
    let index = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
        struct = structs[index++];
        if (clockEnd < struct.id.clock + struct.length) {
            findIndexCleanStart(transaction, structs, clockEnd);
        }
        f(struct);
    }while (index < structs.length && structs[index].id.clock < clockEnd)
};
/**
 * A transaction is created for every change on the Yjs model. It is possible
 * to bundle changes on the Yjs model in a single transaction to
 * minimize the number on messages sent and the number of observer calls.
 * If possible the user of this library should bundle as many changes as
 * possible. Here is an example to illustrate the advantages of bundling:
 *
 * @example
 * const ydoc = new Y.Doc()
 * const map = ydoc.getMap('map')
 * // Log content when change is triggered
 * map.observe(() => {
 *   console.log('change triggered')
 * })
 * // Each change on the map type triggers a log message:
 * map.set('a', 0) // => "change triggered"
 * map.set('b', 0) // => "change triggered"
 * // When put in a transaction, it will trigger the log after the transaction:
 * ydoc.transact(() => {
 *   map.set('a', 1)
 *   map.set('b', 1)
 * }) // => "change triggered"
 *
 * @public
 */ class Transaction {
    /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */ constructor(doc, origin, local){
        /**
     * The Yjs instance.
     * @type {Doc}
     */ this.doc = doc;
        /**
     * Describes the set of deleted items by ids
     * @type {DeleteSet}
     */ this.deleteSet = new DeleteSet();
        /**
     * Holds the state before the transaction started.
     * @type {Map<Number,Number>}
     */ this.beforeState = getStateVector(doc.store);
        /**
     * Holds the state after the transaction.
     * @type {Map<Number,Number>}
     */ this.afterState = new Map();
        /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}
     */ this.changed = new Map();
        /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}
     */ this.changedParentTypes = new Map();
        /**
     * @type {Array<AbstractStruct>}
     */ this._mergeStructs = [];
        /**
     * @type {any}
     */ this.origin = origin;
        /**
     * Stores meta information on the transaction
     * @type {Map<any,any>}
     */ this.meta = new Map();
        /**
     * Whether this change originates from this doc.
     * @type {boolean}
     */ this.local = local;
        /**
     * @type {Set<Doc>}
     */ this.subdocsAdded = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsRemoved = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsLoaded = new Set();
        /**
     * @type {boolean}
     */ this._needFormattingCleanup = false;
    }
}
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 * @return {boolean} Whether data was written.
 */ const writeUpdateMessageFromTransaction = (encoder, transaction)=>{
    if (transaction.deleteSet.clients.size === 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["any"])(transaction.afterState, (clock, client)=>transaction.beforeState.get(client) !== clock)) {
        return false;
    }
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
};
/**
 * If `type.parent` was added in current transaction, `type` technically
 * did not change, it was just added and we should not fire events for `type`.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<YEvent<any>>} type
 * @param {string|null} parentSub
 */ const addChangedTypeToTransaction = (transaction, type, parentSub)=>{
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(transaction.changed, type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"]).add(parentSub);
    }
};
/**
 * @param {Array<AbstractStruct>} structs
 * @param {number} pos
 * @return {number} # of merged structs
 */ const tryToMergeWithLefts = (structs, pos)=>{
    let right = structs[pos];
    let left = structs[pos - 1];
    let i = pos;
    for(; i > 0; right = left, left = structs[--i - 1]){
        if (left.deleted === right.deleted && left.constructor === right.constructor) {
            if (left.mergeWith(right)) {
                if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ right.parent._map.get(right.parentSub) === right) {
                    /** @type {AbstractType<any>} */ right.parent._map.set(right.parentSub, left);
                }
                continue;
            }
        }
        break;
    }
    const merged = pos - i;
    if (merged) {
        // remove all merged structs from the array
        structs.splice(pos + 1 - merged, merged);
    }
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGcDeleteSet = (ds, store, gcFilter)=>{
    for (const [client, deleteItems] of ds.clients.entries()){
        const structs = store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            const endDeleteItemClock = deleteItem.clock + deleteItem.len;
            for(let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]){
                const struct = structs[si];
                if (deleteItem.clock + deleteItem.len <= struct.id.clock) {
                    break;
                }
                if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {
                    struct.gc(store, false);
                }
            }
        }
    }
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 */ const tryMergeDeleteSet = (ds, store)=>{
    // try to merge deleted / gc'd items
    // merge from right to left for better efficiency and so we don't miss any merge targets
    ds.clients.forEach((deleteItems, client)=>{
        const structs = store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            // start with merging the item next to the last deleted item
            const mostRightIndexToCheck = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["min"])(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
            for(let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]){
                si -= 1 + tryToMergeWithLefts(structs, si);
            }
        }
    });
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGc = (ds, store, gcFilter)=>{
    tryGcDeleteSet(ds, store, gcFilter);
    tryMergeDeleteSet(ds, store);
};
/**
 * @param {Array<Transaction>} transactionCleanups
 * @param {number} i
 */ const cleanupTransactions = (transactionCleanups, i)=>{
    if (i < transactionCleanups.length) {
        const transaction = transactionCleanups[i];
        const doc = transaction.doc;
        const store = doc.store;
        const ds = transaction.deleteSet;
        const mergeStructs = transaction._mergeStructs;
        try {
            sortAndMergeDeleteSet(ds);
            transaction.afterState = getStateVector(transaction.doc.store);
            doc.emit('beforeObserverCalls', [
                transaction,
                doc
            ]);
            /**
       * An array of event callbacks.
       *
       * Each callback is called even if the other ones throw errors.
       *
       * @type {Array<function():void>}
       */ const fs = [];
            // observe events on changed types
            transaction.changed.forEach((subs, itemtype)=>fs.push(()=>{
                    if (itemtype._item === null || !itemtype._item.deleted) {
                        itemtype._callObserver(transaction, subs);
                    }
                }));
            fs.push(()=>{
                // deep observe events
                transaction.changedParentTypes.forEach((events, type)=>{
                    // We need to think about the possibility that the user transforms the
                    // Y.Doc in the event.
                    if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
                        events = events.filter((event)=>event.target._item === null || !event.target._item.deleted);
                        events.forEach((event)=>{
                            event.currentTarget = type;
                            // path is relative to the current target
                            event._path = null;
                        });
                        // sort events by path length so that top-level events are fired first.
                        events.sort((event1, event2)=>event1.path.length - event2.path.length);
                        // We don't need to check for events.length
                        // because we know it has at least one element
                        callEventHandlerListeners(type._dEH, events, transaction);
                    }
                });
            });
            fs.push(()=>doc.emit('afterTransaction', [
                    transaction,
                    doc
                ]));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callAll"])(fs, []);
            if (transaction._needFormattingCleanup) {
                cleanupYTextAfterTransaction(transaction);
            }
        } finally{
            // Replace deleted items with ItemDeleted / GC.
            // This is where content is actually remove from the Yjs Doc.
            if (doc.gc) {
                tryGcDeleteSet(ds, store, doc.gcFilter);
            }
            tryMergeDeleteSet(ds, store);
            // on all affected store.clients props, try to merge
            transaction.afterState.forEach((clock, client)=>{
                const beforeClock = transaction.beforeState.get(client) || 0;
                if (beforeClock !== clock) {
                    const structs = store.clients.get(client);
                    // we iterate from right to left so we can safely remove entries
                    const firstChangePos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(findIndexSS(structs, beforeClock), 1);
                    for(let i = structs.length - 1; i >= firstChangePos;){
                        i -= 1 + tryToMergeWithLefts(structs, i);
                    }
                }
            });
            // try to merge mergeStructs
            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left
            //        but at the moment DS does not handle duplicates
            for(let i = mergeStructs.length - 1; i >= 0; i--){
                const { client, clock } = mergeStructs[i].id;
                const structs = store.clients.get(client);
                const replacedStructPos = findIndexSS(structs, clock);
                if (replacedStructPos + 1 < structs.length) {
                    if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
                        continue; // no need to perform next check, both are already merged
                    }
                }
                if (replacedStructPos > 0) {
                    tryToMergeWithLefts(structs, replacedStructPos);
                }
            }
            if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["print"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ORANGE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BOLD"], '[yjs] ', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNBOLD"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RED"], 'Changed the client-id because another client seems to be using it.');
                doc.clientID = generateNewClientId();
            }
            // @todo Merge all the transactions into one and provide send the data as a single update message
            doc.emit('afterTransactionCleanup', [
                transaction,
                doc
            ]);
            if (doc._observers.has('update')) {
                const encoder = new UpdateEncoderV1();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) {
                    doc.emit('update', [
                        encoder.toUint8Array(),
                        transaction.origin,
                        doc,
                        transaction
                    ]);
                }
            }
            if (doc._observers.has('updateV2')) {
                const encoder = new UpdateEncoderV2();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) {
                    doc.emit('updateV2', [
                        encoder.toUint8Array(),
                        transaction.origin,
                        doc,
                        transaction
                    ]);
                }
            }
            const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
                subdocsAdded.forEach((subdoc)=>{
                    subdoc.clientID = doc.clientID;
                    if (subdoc.collectionid == null) {
                        subdoc.collectionid = doc.collectionid;
                    }
                    doc.subdocs.add(subdoc);
                });
                subdocsRemoved.forEach((subdoc)=>doc.subdocs.delete(subdoc));
                doc.emit('subdocs', [
                    {
                        loaded: subdocsLoaded,
                        added: subdocsAdded,
                        removed: subdocsRemoved
                    },
                    doc,
                    transaction
                ]);
                subdocsRemoved.forEach((subdoc)=>subdoc.destroy());
            }
            if (transactionCleanups.length <= i + 1) {
                doc._transactionCleanups = [];
                doc.emit('afterAllTransactions', [
                    doc,
                    transactionCleanups
                ]);
            } else {
                cleanupTransactions(transactionCleanups, i + 1);
            }
        }
    }
};
/**
 * Implements the functionality of `y.transact(()=>{..})`
 *
 * @template T
 * @param {Doc} doc
 * @param {function(Transaction):T} f
 * @param {any} [origin=true]
 * @return {T}
 *
 * @function
 */ const transact = (doc, f, origin = null, local = true)=>{
    const transactionCleanups = doc._transactionCleanups;
    let initialCall = false;
    /**
   * @type {any}
   */ let result = null;
    if (doc._transaction === null) {
        initialCall = true;
        doc._transaction = new Transaction(doc, origin, local);
        transactionCleanups.push(doc._transaction);
        if (transactionCleanups.length === 1) {
            doc.emit('beforeAllTransactions', [
                doc
            ]);
        }
        doc.emit('beforeTransaction', [
            doc._transaction,
            doc
        ]);
    }
    try {
        result = f(doc._transaction);
    } finally{
        if (initialCall) {
            const finishCleanup = doc._transaction === transactionCleanups[0];
            doc._transaction = null;
            if (finishCleanup) {
                // The first transaction ended, now process observer calls.
                // Observer call may create new transactions for which we need to call the observers and do cleanup.
                // We don't want to nest these calls, so we execute these calls one after
                // another.
                // Also we need to ensure that all cleanups are called, even if the
                // observes throw errors.
                // This file is full of hacky try {} finally {} blocks to ensure that an
                // event can throw errors and also that the cleanup is called.
                cleanupTransactions(transactionCleanups, 0);
            }
        }
    }
    return result;
};
class StackItem {
    /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */ constructor(deletions, insertions){
        this.insertions = insertions;
        this.deletions = deletions;
        /**
     * Use this to save and restore metadata like selection range
     */ this.meta = new Map();
    }
}
/**
 * @param {Transaction} tr
 * @param {UndoManager} um
 * @param {StackItem} stackItem
 */ const clearUndoManagerStackItem = (tr, um, stackItem)=>{
    iterateDeletedStructs(tr, stackItem.deletions, (item)=>{
        if (item instanceof Item && um.scope.some((type)=>type === tr.doc || isParentOf(type, item))) {
            keepItem(item, false);
        }
    });
};
/**
 * @param {UndoManager} undoManager
 * @param {Array<StackItem>} stack
 * @param {'undo'|'redo'} eventType
 * @return {StackItem?}
 */ const popStackItem = (undoManager, stack, eventType)=>{
    /**
   * Keep a reference to the transaction so we can fire the event with the changedParentTypes
   * @type {any}
   */ let _tr = null;
    const doc = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc, (transaction)=>{
        while(stack.length > 0 && undoManager.currStackItem === null){
            const store = doc.store;
            const stackItem = stack.pop();
            /**
       * @type {Set<Item>}
       */ const itemsToRedo = new Set();
            /**
       * @type {Array<Item>}
       */ const itemsToDelete = [];
            let performedChange = false;
            iterateDeletedStructs(transaction, stackItem.insertions, (struct)=>{
                if (struct instanceof Item) {
                    if (struct.redone !== null) {
                        let { item, diff } = followRedone(store, struct.id);
                        if (diff > 0) {
                            item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
                        }
                        struct = item;
                    }
                    if (!struct.deleted && scope.some((type)=>type === transaction.doc || isParentOf(type, struct))) {
                        itemsToDelete.push(struct);
                    }
                }
            });
            iterateDeletedStructs(transaction, stackItem.deletions, (struct)=>{
                if (struct instanceof Item && scope.some((type)=>type === transaction.doc || isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
                !isDeleted(stackItem.insertions, struct.id)) {
                    itemsToRedo.add(struct);
                }
            });
            itemsToRedo.forEach((struct)=>{
                performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
            });
            // We want to delete in reverse order so that children are deleted before
            // parents, so we have more information available when items are filtered.
            for(let i = itemsToDelete.length - 1; i >= 0; i--){
                const item = itemsToDelete[i];
                if (undoManager.deleteFilter(item)) {
                    item.delete(transaction);
                    performedChange = true;
                }
            }
            undoManager.currStackItem = performedChange ? stackItem : null;
        }
        transaction.changed.forEach((subProps, type)=>{
            // destroy search marker if necessary
            if (subProps.has(null) && type._searchMarker) {
                type._searchMarker.length = 0;
            }
        });
        _tr = transaction;
    }, undoManager);
    const res = undoManager.currStackItem;
    if (res != null) {
        const changedParentTypes = _tr.changedParentTypes;
        undoManager.emit('stack-item-popped', [
            {
                stackItem: res,
                type: eventType,
                changedParentTypes,
                origin: undoManager
            },
            undoManager
        ]);
        undoManager.currStackItem = null;
    }
    return res;
};
/**
 * @typedef {Object} UndoManagerOptions
 * @property {number} [UndoManagerOptions.captureTimeout=500]
 * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.
 * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes
 * it is necessary to filter what an Undo/Redo operation can delete. If this
 * filter returns false, the type/item won't be deleted even it is in the
 * undo/redo scope.
 * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]
 * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
 * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.
 */ /**
 * @typedef {Object} StackItemEvent
 * @property {StackItem} StackItemEvent.stackItem
 * @property {any} StackItemEvent.origin
 * @property {'undo'|'redo'} StackItemEvent.type
 * @property {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>} StackItemEvent.changedParentTypes
 */ /**
 * Fires 'stack-item-added' event when a stack item was added to either the undo- or
 * the redo-stack. You may store additional stack information via the
 * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
 * Fires 'stack-item-popped' event when a stack item was popped from either the
 * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
 *
 * @extends {ObservableV2<{'stack-item-added':function(StackItemEvent, UndoManager):void, 'stack-item-popped': function(StackItemEvent, UndoManager):void, 'stack-cleared': function({ undoStackCleared: boolean, redoStackCleared: boolean }):void, 'stack-item-updated': function(StackItemEvent, UndoManager):void }>}
 */ class UndoManager extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservableV2"] {
    /**
   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
   * @param {UndoManagerOptions} options
   */ constructor(typeScope, { captureTimeout = 500, captureTransaction = (_tr)=>true, deleteFilter = ()=>true, trackedOrigins = new Set([
        null
    ]), ignoreRemoteMapChanges = false, doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc } = {}){
        super();
        /**
     * @type {Array<AbstractType<any> | Doc>}
     */ this.scope = [];
        this.doc = doc;
        this.addToScope(typeScope);
        this.deleteFilter = deleteFilter;
        trackedOrigins.add(this);
        this.trackedOrigins = trackedOrigins;
        this.captureTransaction = captureTransaction;
        /**
     * @type {Array<StackItem>}
     */ this.undoStack = [];
        /**
     * @type {Array<StackItem>}
     */ this.redoStack = [];
        /**
     * Whether the client is currently undoing (calling UndoManager.undo)
     *
     * @type {boolean}
     */ this.undoing = false;
        this.redoing = false;
        /**
     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing
     *
     * @type {StackItem|null}
     */ this.currStackItem = null;
        this.lastChange = 0;
        this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
        this.captureTimeout = captureTimeout;
        /**
     * @param {Transaction} transaction
     */ this.afterTransactionHandler = (transaction)=>{
            // Only track certain transactions
            if (!this.captureTransaction(transaction) || !this.scope.some((type)=>transaction.changedParentTypes.has(type) || type === this.doc) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
                return;
            }
            const undoing = this.undoing;
            const redoing = this.redoing;
            const stack = undoing ? this.redoStack : this.undoStack;
            if (undoing) {
                this.stopCapturing(); // next undo should not be appended to last stack item
            } else if (!redoing) {
                // neither undoing nor redoing: delete redoStack
                this.clear(false, true);
            }
            const insertions = new DeleteSet();
            transaction.afterState.forEach((endClock, client)=>{
                const startClock = transaction.beforeState.get(client) || 0;
                const len = endClock - startClock;
                if (len > 0) {
                    addToDeleteSet(insertions, client, startClock, len);
                }
            });
            const now = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUnixTime"])();
            let didAdd = false;
            if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
                // append change to last stack op
                const lastOp = stack[stack.length - 1];
                lastOp.deletions = mergeDeleteSets([
                    lastOp.deletions,
                    transaction.deleteSet
                ]);
                lastOp.insertions = mergeDeleteSets([
                    lastOp.insertions,
                    insertions
                ]);
            } else {
                // create a new stack op
                stack.push(new StackItem(transaction.deleteSet, insertions));
                didAdd = true;
            }
            if (!undoing && !redoing) {
                this.lastChange = now;
            }
            // make sure that deleted structs are not gc'd
            iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ (item)=>{
                if (item instanceof Item && this.scope.some((type)=>type === transaction.doc || isParentOf(type, item))) {
                    keepItem(item, true);
                }
            });
            /**
       * @type {[StackItemEvent, UndoManager]}
       */ const changeEvent = [
                {
                    stackItem: stack[stack.length - 1],
                    origin: transaction.origin,
                    type: undoing ? 'redo' : 'undo',
                    changedParentTypes: transaction.changedParentTypes
                },
                this
            ];
            if (didAdd) {
                this.emit('stack-item-added', changeEvent);
            } else {
                this.emit('stack-item-updated', changeEvent);
            }
        };
        this.doc.on('afterTransaction', this.afterTransactionHandler);
        this.doc.on('destroy', ()=>{
            this.destroy();
        });
    }
    /**
   * Extend the scope.
   *
   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes
   */ addToScope(ytypes) {
        const tmpSet = new Set(this.scope);
        ytypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(ytypes) ? ytypes : [
            ytypes
        ];
        ytypes.forEach((ytype)=>{
            if (!tmpSet.has(ytype)) {
                tmpSet.add(ytype);
                if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["warn"])('[yjs#509] Not same Y.Doc'); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
                this.scope.push(ytype);
            }
        });
    }
    /**
   * @param {any} origin
   */ addTrackedOrigin(origin) {
        this.trackedOrigins.add(origin);
    }
    /**
   * @param {any} origin
   */ removeTrackedOrigin(origin) {
        this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
        if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
            this.doc.transact((tr)=>{
                if (clearUndoStack) {
                    this.undoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                    this.undoStack = [];
                }
                if (clearRedoStack) {
                    this.redoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                    this.redoStack = [];
                }
                this.emit('stack-cleared', [
                    {
                        undoStackCleared: clearUndoStack,
                        redoStackCleared: clearRedoStack
                    }
                ]);
            });
        }
    }
    /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */ stopCapturing() {
        this.lastChange = 0;
    }
    /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ undo() {
        this.undoing = true;
        let res;
        try {
            res = popStackItem(this, this.undoStack, 'undo');
        } finally{
            this.undoing = false;
        }
        return res;
    }
    /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ redo() {
        this.redoing = true;
        let res;
        try {
            res = popStackItem(this, this.redoStack, 'redo');
        } finally{
            this.redoing = false;
        }
        return res;
    }
    /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */ canUndo() {
        return this.undoStack.length > 0;
    }
    /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */ canRedo() {
        return this.redoStack.length > 0;
    }
    destroy() {
        this.trackedOrigins.delete(this);
        this.doc.off('afterTransaction', this.afterTransactionHandler);
        super.destroy();
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 */ function* lazyStructReaderGenerator(decoder) {
    const numOfStateUpdates = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        const client = decoder.readClient();
        let clock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            // @todo use switch instead of ifs
            if (info === 10) {
                const len = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder.restDecoder);
                yield new Skip(createID(client, clock), len);
                clock += len;
            } else if ((__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS5"] & info) !== 0) {
                const cantCopyParentInfo = (info & (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"])) === 0;
                // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                // and we read the next string as parentYKey.
                // It indicates how we store/retrieve parent from `y.share`
                // @type {string|null}
                const struct = new Item(createID(client, clock), null, (info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"] ? decoder.readLeftID() : null, null, (info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"] ? decoder.readRightID() : null, // @ts-ignore Force writing a string here.
                cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT6"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT6"] ? decoder.readString() : null, readItemContent(decoder, info) // item content
                );
                yield struct;
                clock += struct.length;
            } else {
                const len = decoder.readLen();
                yield new GC(createID(client, clock), len);
                clock += len;
            }
        }
    }
}
class LazyStructReader {
    /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */ constructor(decoder, filterSkips){
        this.gen = lazyStructReaderGenerator(decoder);
        /**
     * @type {null | Item | Skip | GC}
     */ this.curr = null;
        this.done = false;
        this.filterSkips = filterSkips;
        this.next();
    }
    /**
   * @return {Item | GC | Skip |null}
   */ next() {
        // ignore "Skip" structs
        do {
            this.curr = this.gen.next().value || null;
        }while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)
        return this.curr;
    }
}
/**
 * @param {Uint8Array} update
 *
 */ const logUpdate = (update)=>logUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const logUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        structs.push(curr);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["print"])('Structs: ', structs);
    const ds = readDeleteSet(updateDecoder);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["print"])('DeleteSet: ', ds);
};
/**
 * @param {Uint8Array} update
 *
 */ const decodeUpdate = (update)=>decodeUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        structs.push(curr);
    }
    return {
        structs,
        ds: readDeleteSet(updateDecoder)
    };
};
class LazyStructWriter {
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ constructor(encoder){
        this.currClient = 0;
        this.startClock = 0;
        this.written = 0;
        this.encoder = encoder;
        /**
     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
     *
     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
     *
     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
     *
     * @type {Array<{ written: number, restEncoder: Uint8Array }>}
     */ this.clientStructs = [];
    }
}
/**
 * @param {Array<Uint8Array>} updates
 * @return {Uint8Array}
 */ const mergeUpdates = (updates)=>mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2)=>{
    const encoder = new YEncoder();
    const updateDecoder = new LazyStructReader(new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let size = 0;
        let currClient = curr.id.client;
        let stopCounting = curr.id.clock !== 0; // must start at 0
        let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                if (currClock !== 0) {
                    size++;
                    // We found a new client
                    // write what we have to the encoder
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, currClient);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, currClock);
                }
                currClient = curr.id.client;
                currClock = 0;
                stopCounting = curr.id.clock !== 0;
            }
            // we ignore skips
            if (curr.constructor === Skip) {
                stopCounting = true;
            }
            if (!stopCounting) {
                currClock = curr.id.clock + curr.length;
            }
        }
        // write what we have
        if (currClock !== 0) {
            size++;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, currClient);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, currClock);
        }
        // prepend the size of the state vector
        const enc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(enc, size);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeBinaryEncoder"])(enc, encoder.restEncoder);
        encoder.restEncoder = enc;
        return encoder.toUint8Array();
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, 0);
        return encoder.toUint8Array();
    }
};
/**
 * @param {Uint8Array} update
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdate = (update)=>encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2)=>{
    /**
   * @type {Map<number, number>}
   */ const from = new Map();
    /**
   * @type {Map<number, number>}
   */ const to = new Map();
    const updateDecoder = new LazyStructReader(new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let currClient = curr.id.client;
        let currClock = curr.id.clock;
        // write the beginning to `from`
        from.set(currClient, currClock);
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                // We found a new client
                // write the end to `to`
                to.set(currClient, currClock);
                // write the beginning to `from`
                from.set(curr.id.client, curr.id.clock);
                // update currClient
                currClient = curr.id.client;
            }
            currClock = curr.id.clock + curr.length;
        }
        // write the end to `to`
        to.set(currClient, currClock);
    }
    return {
        from,
        to
    };
};
/**
 * @param {Uint8Array} update
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMeta = (update)=>parseUpdateMetaV2(update, UpdateDecoderV1);
/**
 * This method is intended to slice any kind of struct and retrieve the right part.
 * It does not handle side-effects, so it should only be used by the lazy-encoder.
 *
 * @param {Item | GC | Skip} left
 * @param {number} diff
 * @return {Item | GC}
 */ const sliceStruct = (left, diff)=>{
    if (left.constructor === GC) {
        const { client, clock } = left.id;
        return new GC(createID(client, clock + diff), left.length - diff);
    } else if (left.constructor === Skip) {
        const { client, clock } = left.id;
        return new Skip(createID(client, clock + diff), left.length - diff);
    } else {
        const leftItem = left;
        const { client, clock } = leftItem.id;
        return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    }
};
/**
 *
 * This function works similarly to `readUpdateV2`.
 *
 * @param {Array<Uint8Array>} updates
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 * @return {Uint8Array}
 */ const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    if (updates.length === 1) {
        return updates[0];
    }
    const updateDecoders = updates.map((update)=>new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update)));
    let lazyStructDecoders = updateDecoders.map((decoder)=>new LazyStructReader(decoder, true));
    /**
   * @todo we don't need offset because we always slice before
   * @type {null | { struct: Item | GC | Skip, offset: number }}
   */ let currWrite = null;
    const updateEncoder = new YEncoder();
    // write structs lazily
    const lazyStructEncoder = new LazyStructWriter(updateEncoder);
    // Note: We need to ensure that all lazyStructDecoders are fully consumed
    // Note: Should merge document updates whenever possible - even from different updates
    // Note: Should handle that some operations cannot be applied yet ()
    while(true){
        // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content
        lazyStructDecoders = lazyStructDecoders.filter((dec)=>dec.curr !== null);
        lazyStructDecoders.sort(/** @type {function(any,any):number} */ (dec1, dec2)=>{
            if (dec1.curr.id.client === dec2.curr.id.client) {
                const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
                if (clockDiff === 0) {
                    // @todo remove references to skip since the structDecoders must filter Skips.
                    return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.
                    ;
                } else {
                    return clockDiff;
                }
            } else {
                return dec2.curr.id.client - dec1.curr.id.client;
            }
        });
        if (lazyStructDecoders.length === 0) {
            break;
        }
        const currDecoder = lazyStructDecoders[0];
        // write from currDecoder until the next operation is from another client or if filler-struct
        // then we need to reorder the decoders and find the next operation to write
        const firstClient = /** @type {Item | GC} */ currDecoder.curr.id.client;
        if (currWrite !== null) {
            let curr = currDecoder.curr;
            let iterated = false;
            // iterate until we find something that we haven't written already
            // remember: first the high client-ids are written
            while(curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client){
                curr = currDecoder.next();
                iterated = true;
            }
            if (curr === null || // current decoder is empty
            curr.id.client !== firstClient || iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates
            ) {
                continue;
            }
            if (firstClient !== currWrite.struct.id.client) {
                writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                currWrite = {
                    struct: curr,
                    offset: 0
                };
                currDecoder.next();
            } else {
                if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
                    // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)
                    if (currWrite.struct.constructor === Skip) {
                        // extend existing skip
                        currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
                    } else {
                        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                        const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
                        /**
             * @type {Skip}
             */ const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
                        currWrite = {
                            struct,
                            offset: 0
                        };
                    }
                } else {
                    const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
                    if (diff > 0) {
                        if (currWrite.struct.constructor === Skip) {
                            // prefer to slice Skip because the other struct might contain more information
                            currWrite.struct.length -= diff;
                        } else {
                            curr = sliceStruct(curr, diff);
                        }
                    }
                    if (!currWrite.struct.mergeWith(curr)) {
                        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                        currWrite = {
                            struct: curr,
                            offset: 0
                        };
                        currDecoder.next();
                    }
                }
            }
        } else {
            currWrite = {
                struct: currDecoder.curr,
                offset: 0
            };
            currDecoder.next();
        }
        for(let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()){
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = {
                struct: next,
                offset: 0
            };
        }
    }
    if (currWrite !== null) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = null;
    }
    finishLazyStructWriting(lazyStructEncoder);
    const dss = updateDecoders.map((decoder)=>readDeleteSet(decoder));
    const ds = mergeDeleteSets(dss);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 */ const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    const state = decodeStateVector(sv);
    const encoder = new YEncoder();
    const lazyStructWriter = new LazyStructWriter(encoder);
    const decoder = new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update));
    const reader = new LazyStructReader(decoder, false);
    while(reader.curr){
        const curr = reader.curr;
        const currClient = curr.id.client;
        const svClock = state.get(currClient) || 0;
        if (reader.curr.constructor === Skip) {
            // the first written struct shouldn't be a skip
            reader.next();
            continue;
        }
        if (curr.id.clock + curr.length > svClock) {
            writeStructToLazyStructWriter(lazyStructWriter, curr, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(svClock - curr.id.clock, 0));
            reader.next();
            while(reader.curr && reader.curr.id.client === currClient){
                writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
                reader.next();
            }
        } else {
            // read until something new comes up
            while(reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock){
                reader.next();
            }
        }
    }
    finishLazyStructWriting(lazyStructWriter);
    // write ds
    const ds = readDeleteSet(decoder);
    writeDeleteSet(encoder, ds);
    return encoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 */ const diffUpdate = (update, sv)=>diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {LazyStructWriter} lazyWriter
 */ const flushLazyStructWriter = (lazyWriter)=>{
    if (lazyWriter.written > 0) {
        lazyWriter.clientStructs.push({
            written: lazyWriter.written,
            restEncoder: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUint8Array"])(lazyWriter.encoder.restEncoder)
        });
        lazyWriter.encoder.restEncoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])();
        lazyWriter.written = 0;
    }
};
/**
 * @param {LazyStructWriter} lazyWriter
 * @param {Item | GC} struct
 * @param {number} offset
 */ const writeStructToLazyStructWriter = (lazyWriter, struct, offset)=>{
    // flush curr if we start another client
    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
        flushLazyStructWriter(lazyWriter);
    }
    if (lazyWriter.written === 0) {
        lazyWriter.currClient = struct.id.client;
        // write next client
        lazyWriter.encoder.writeClient(struct.id.client);
        // write startClock
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
    }
    struct.write(lazyWriter.encoder, offset);
    lazyWriter.written++;
};
/**
 * Call this function when we collected all parts and want to
 * put all the parts together. After calling this method,
 * you can continue using the UpdateEncoder.
 *
 * @param {LazyStructWriter} lazyWriter
 */ const finishLazyStructWriting = (lazyWriter)=>{
    flushLazyStructWriter(lazyWriter);
    // this is a fresh encoder because we called flushCurr
    const restEncoder = lazyWriter.encoder.restEncoder;
    /**
   * Now we put all the fragments together.
   * This works similarly to `writeClientsStructs`
   */ // write # states that were updated - i.e. the clients
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(restEncoder, lazyWriter.clientStructs.length);
    for(let i = 0; i < lazyWriter.clientStructs.length; i++){
        const partStructs = lazyWriter.clientStructs[i];
        /**
     * Works similarly to `writeStructs`
     */ // write # encoded structs
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(restEncoder, partStructs.written);
        // write the rest of the fragment
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUint8Array"])(restEncoder, partStructs.restEncoder);
    }
};
/**
 * @param {Uint8Array} update
 * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder
 * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder
 */ const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder)=>{
    const updateDecoder = new YDecoder((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    const updateEncoder = new YEncoder();
    const lazyWriter = new LazyStructWriter(updateEncoder);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
    }
    finishLazyStructWriting(lazyWriter);
    const ds = readDeleteSet(updateDecoder);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @typedef {Object} ObfuscatorOptions
 * @property {boolean} [ObfuscatorOptions.formatting=true]
 * @property {boolean} [ObfuscatorOptions.subdocs=true]
 * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName
 */ /**
 * @param {ObfuscatorOptions} obfuscator
 */ const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {})=>{
    let i = 0;
    const mapKeyCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    const nodeNameCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    const formattingKeyCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    const formattingValueCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range
    /**
   * @param {Item|GC|Skip} block
   * @return {Item|GC|Skip}
   */ return (block)=>{
        switch(block.constructor){
            case GC:
            case Skip:
                return block;
            case Item:
                {
                    const item = block;
                    const content = item.content;
                    switch(content.constructor){
                        case ContentDeleted:
                            break;
                        case ContentType:
                            {
                                if (yxml) {
                                    const type = /** @type {ContentType} */ content.type;
                                    if (type instanceof YXmlElement) {
                                        type.nodeName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(nodeNameCache, type.nodeName, ()=>'node-' + i);
                                    }
                                    if (type instanceof YXmlHook) {
                                        type.hookName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(nodeNameCache, type.hookName, ()=>'hook-' + i);
                                    }
                                }
                                break;
                            }
                        case ContentAny:
                            {
                                const c = content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentBinary:
                            {
                                const c = content;
                                c.content = new Uint8Array([
                                    i
                                ]);
                                break;
                            }
                        case ContentDoc:
                            {
                                const c = content;
                                if (subdocs) {
                                    c.opts = {};
                                    c.doc.guid = i + '';
                                }
                                break;
                            }
                        case ContentEmbed:
                            {
                                const c = content;
                                c.embed = {};
                                break;
                            }
                        case ContentFormat:
                            {
                                const c = content;
                                if (formatting) {
                                    c.key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(formattingKeyCache, c.key, ()=>i + '');
                                    c.value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(formattingValueCache, c.value, ()=>({
                                            i
                                        }));
                                }
                                break;
                            }
                        case ContentJSON:
                            {
                                const c = content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentString:
                            {
                                const c = content;
                                c.str = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["repeat"])(i % 10 + '', c.str.length);
                                break;
                            }
                        default:
                            // unknown content type
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
                    }
                    if (item.parentSub) {
                        item.parentSub = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(mapKeyCache, item.parentSub, ()=>i + '');
                    }
                    i++;
                    return block;
                }
            default:
                // unknown block-type
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
        }
    };
};
/**
 * This function obfuscates the content of a Yjs update. This is useful to share
 * buggy Yjs documents while significantly limiting the possibility that a
 * developer can on the user. Note that it might still be possible to deduce
 * some information by analyzing the "structure" of the document or by analyzing
 * the typing behavior using the CRDT-related metadata that is still kept fully
 * intact.
 *
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdate = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdateV2 = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV1ToV2 = (update)=>convertUpdateFormat(update, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["id"], UpdateDecoderV1, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV2ToV1 = (update)=>convertUpdateFormat(update, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["id"], UpdateDecoderV2, UpdateEncoderV1);
const errorComputeChanges = 'You must not compute changes after the event-handler fired.';
/**
 * @template {AbstractType<any>} T
 * YEvent describes the changes on a YType.
 */ class YEvent {
    /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */ constructor(target, transaction){
        /**
     * The type on which this event was created on.
     * @type {T}
     */ this.target = target;
        /**
     * The current target on which the observe callback is called.
     * @type {AbstractType<any>}
     */ this.currentTarget = target;
        /**
     * The transaction that triggered this event.
     * @type {Transaction}
     */ this.transaction = transaction;
        /**
     * @type {Object|null}
     */ this._changes = null;
        /**
     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
     */ this._keys = null;
        /**
     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}
     */ this._delta = null;
        /**
     * @type {Array<string|number>|null}
     */ this._path = null;
    }
    /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */ get path() {
        return this._path || (this._path = getPathTo(this.currentTarget, this.target));
    }
    /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ deletes(struct) {
        return isDeleted(this.transaction.deleteSet, struct.id);
    }
    /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */ get keys() {
        if (this._keys === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(errorComputeChanges);
            }
            const keys = new Map();
            const target = this.target;
            const changed = this.transaction.changed.get(target);
            changed.forEach((key)=>{
                if (key !== null) {
                    const item = target._map.get(key);
                    /**
           * @type {'delete' | 'add' | 'update'}
           */ let action;
                    let oldValue;
                    if (this.adds(item)) {
                        let prev = item.left;
                        while(prev !== null && this.adds(prev)){
                            prev = prev.left;
                        }
                        if (this.deletes(item)) {
                            if (prev !== null && this.deletes(prev)) {
                                action = 'delete';
                                oldValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["last"])(prev.content.getContent());
                            } else {
                                return;
                            }
                        } else {
                            if (prev !== null && this.deletes(prev)) {
                                action = 'update';
                                oldValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["last"])(prev.content.getContent());
                            } else {
                                action = 'add';
                                oldValue = undefined;
                            }
                        }
                    } else {
                        if (this.deletes(item)) {
                            action = 'delete';
                            oldValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["last"])(/** @type {Item} */ item.content.getContent());
                        } else {
                            return; // nop
                        }
                    }
                    keys.set(key, {
                        action,
                        oldValue
                    });
                }
            });
            this._keys = keys;
        }
        return this._keys;
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */ get delta() {
        return this.changes.delta;
    }
    /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ adds(struct) {
        return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        let changes = this._changes;
        if (changes === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(errorComputeChanges);
            }
            const target = this.target;
            const added = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
            const deleted = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
            /**
       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}
       */ const delta = [];
            changes = {
                added,
                deleted,
                delta,
                keys: this.keys
            };
            const changed = this.transaction.changed.get(target);
            if (changed.has(null)) {
                /**
         * @type {any}
         */ let lastOp = null;
                const packOp = ()=>{
                    if (lastOp) {
                        delta.push(lastOp);
                    }
                };
                for(let item = target._start; item !== null; item = item.right){
                    if (item.deleted) {
                        if (this.deletes(item) && !this.adds(item)) {
                            if (lastOp === null || lastOp.delete === undefined) {
                                packOp();
                                lastOp = {
                                    delete: 0
                                };
                            }
                            lastOp.delete += item.length;
                            deleted.add(item);
                        } // else nop
                    } else {
                        if (this.adds(item)) {
                            if (lastOp === null || lastOp.insert === undefined) {
                                packOp();
                                lastOp = {
                                    insert: []
                                };
                            }
                            lastOp.insert = lastOp.insert.concat(item.content.getContent());
                            added.add(item);
                        } else {
                            if (lastOp === null || lastOp.retain === undefined) {
                                packOp();
                                lastOp = {
                                    retain: 0
                                };
                            }
                            lastOp.retain += item.length;
                        }
                    }
                }
                if (lastOp !== null && lastOp.retain === undefined) {
                    packOp();
                }
            }
            this._changes = changes;
        }
        return changes;
    }
}
/**
 * Compute the path from this type to the specified target.
 *
 * @example
 *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`
 *   const path = type.getPathTo(child)
 *   // assuming `type instanceof YArray`
 *   console.log(path) // might look like => [2, 'key1']
 *   child === type.get(path[0]).get(path[1])
 *
 * @param {AbstractType<any>} parent
 * @param {AbstractType<any>} child target
 * @return {Array<string|number>} Path to the target
 *
 * @private
 * @function
 */ const getPathTo = (parent, child)=>{
    const path = [];
    while(child._item !== null && child !== parent){
        if (child._item.parentSub !== null) {
            // parent is map-ish
            path.unshift(child._item.parentSub);
        } else {
            // parent is array-ish
            let i = 0;
            let c = /** @type {AbstractType<any>} */ child._item.parent._start;
            while(c !== child._item && c !== null){
                if (!c.deleted && c.countable) {
                    i += c.length;
                }
                c = c.right;
            }
            path.unshift(i);
        }
        child = child._item.parent;
    }
    return path;
};
/**
 * https://docs.yjs.dev/getting-started/working-with-shared-types#caveats
 */ const warnPrematureAccess = ()=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$logging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["warn"])('Invalid access: Add Yjs type to a document before reading data.');
};
const maxSearchMarker = 80;
/**
 * A unique timestamp that identifies each marker.
 *
 * Time is relative,.. this is more like an ever-increasing clock.
 *
 * @type {number}
 */ let globalSearchMarkerTimestamp = 0;
class ArraySearchMarker {
    /**
   * @param {Item} p
   * @param {number} index
   */ constructor(p, index){
        p.marker = true;
        this.p = p;
        this.index = index;
        this.timestamp = globalSearchMarkerTimestamp++;
    }
}
/**
 * @param {ArraySearchMarker} marker
 */ const refreshMarkerTimestamp = (marker)=>{
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * This is rather complex so this function is the only thing that should overwrite a marker
 *
 * @param {ArraySearchMarker} marker
 * @param {Item} p
 * @param {number} index
 */ const overwriteMarker = (marker, p, index)=>{
    marker.p.marker = false;
    marker.p = p;
    p.marker = true;
    marker.index = index;
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {Item} p
 * @param {number} index
 */ const markPosition = (searchMarker, p, index)=>{
    if (searchMarker.length >= maxSearchMarker) {
        // override oldest marker (we don't want to create more objects)
        const marker = searchMarker.reduce((a, b)=>a.timestamp < b.timestamp ? a : b);
        overwriteMarker(marker, p, index);
        return marker;
    } else {
        // create new marker
        const pm = new ArraySearchMarker(p, index);
        searchMarker.push(pm);
        return pm;
    }
};
/**
 * Search marker help us to find positions in the associative array faster.
 *
 * They speed up the process of finding a position without much bookkeeping.
 *
 * A maximum of `maxSearchMarker` objects are created.
 *
 * This function always returns a refreshed marker (updated timestamp)
 *
 * @param {AbstractType<any>} yarray
 * @param {number} index
 */ const findMarker = (yarray, index)=>{
    if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
        return null;
    }
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abs"])(index - a.index) < (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abs"])(index - b.index) ? a : b);
    let p = yarray._start;
    let pindex = 0;
    if (marker !== null) {
        p = marker.p;
        pindex = marker.index;
        refreshMarkerTimestamp(marker); // we used it, we might need to use it again
    }
    // iterate to right if possible
    while(p.right !== null && pindex < index){
        if (!p.deleted && p.countable) {
            if (index < pindex + p.length) {
                break;
            }
            pindex += p.length;
        }
        p = p.right;
    }
    // iterate to left if necessary (might be that pindex > index)
    while(p.left !== null && pindex > index){
        p = p.left;
        if (!p.deleted && p.countable) {
            pindex -= p.length;
        }
    }
    // we want to make sure that p can't be merged with left, because that would screw up everything
    // in that cas just return what we have (it is most likely the best marker anyway)
    // iterate to left until p can't be merged with left
    while(p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock){
        p = p.left;
        if (!p.deleted && p.countable) {
            pindex -= p.length;
        }
    }
    // @todo remove!
    // assure position
    // {
    //   let start = yarray._start
    //   let pos = 0
    //   while (start !== p) {
    //     if (!start.deleted && start.countable) {
    //       pos += start.length
    //     }
    //     start = /** @type {Item} */ (start.right)
    //   }
    //   if (pos !== pindex) {
    //     debugger
    //     throw new Error('Gotcha position fail!')
    //   }
    // }
    // if (marker) {
    //   if (window.lengths == null) {
    //     window.lengths = []
    //     window.getLengths = () => window.lengths.sort((a, b) => a - b)
    //   }
    //   window.lengths.push(marker.index - pindex)
    //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)
    // }
    if (marker !== null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abs"])(marker.index - pindex) < /** @type {YText|YArray<any>} */ p.parent.length / maxSearchMarker) {
        // adjust existing marker
        overwriteMarker(marker, p, pindex);
        return marker;
    } else {
        // create new marker
        return markPosition(yarray._searchMarker, p, pindex);
    }
};
/**
 * Update markers when a change happened.
 *
 * This should be called before doing a deletion!
 *
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {number} index
 * @param {number} len If insertion, len is positive. If deletion, len is negative.
 */ const updateMarkerChanges = (searchMarker, index, len)=>{
    for(let i = searchMarker.length - 1; i >= 0; i--){
        const m = searchMarker[i];
        if (len > 0) {
            /**
       * @type {Item|null}
       */ let p = m.p;
            p.marker = false;
            // Ideally we just want to do a simple position comparison, but this will only work if
            // search markers don't point to deleted items for formats.
            // Iterate marker to prev undeleted countable position so we know what to do when updating a position
            while(p && (p.deleted || !p.countable)){
                p = p.left;
                if (p && !p.deleted && p.countable) {
                    // adjust position. the loop should break now
                    m.index -= p.length;
                }
            }
            if (p === null || p.marker === true) {
                // remove search marker if updated position is null or if position is already marked
                searchMarker.splice(i, 1);
                continue;
            }
            m.p = p;
            p.marker = true;
        }
        if (index < m.index || len > 0 && index === m.index) {
            m.index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(index, m.index + len);
        }
    }
};
/**
 * Accumulate all (list) children of a type and return them as an Array.
 *
 * @param {AbstractType<any>} t
 * @return {Array<Item>}
 */ const getTypeChildren = (t)=>{
    t.doc ?? warnPrematureAccess();
    let s = t._start;
    const arr = [];
    while(s){
        arr.push(s);
        s = s.right;
    }
    return arr;
};
/**
 * Call event listeners with an event. This will also add an event to all
 * parents (for `.observeDeep` handlers).
 *
 * @template EventType
 * @param {AbstractType<EventType>} type
 * @param {Transaction} transaction
 * @param {EventType} event
 */ const callTypeObservers = (type, transaction, event)=>{
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while(true){
        // @ts-ignore
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfUndefined"])(changedParentTypes, type, ()=>[]).push(event);
        if (type._item === null) {
            break;
        }
        type = type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
};
/**
 * @template EventType
 * Abstract Yjs Type class
 */ class AbstractType {
    constructor(){
        /**
     * @type {Item|null}
     */ this._item = null;
        /**
     * @type {Map<string,Item>}
     */ this._map = new Map();
        /**
     * @type {Item|null}
     */ this._start = null;
        /**
     * @type {Doc|null}
     */ this.doc = null;
        this._length = 0;
        /**
     * Event handlers
     * @type {EventHandler<EventType,Transaction>}
     */ this._eH = createEventHandler();
        /**
     * Deep event handlers
     * @type {EventHandler<Array<YEvent<any>>,Transaction>}
     */ this._dEH = createEventHandler();
        /**
     * @type {null | Array<ArraySearchMarker>}
     */ this._searchMarker = null;
    }
    /**
   * @return {AbstractType<any>|null}
   */ get parent() {
        return this._item ? this._item.parent : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */ _integrate(y, item) {
        this.doc = y;
        this._item = item;
    }
    /**
   * @return {AbstractType<EventType>}
   */ _copy() {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */ clone() {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */ _write(_encoder) {}
    /**
   * The first non-deleted item
   */ get _first() {
        let n = this._start;
        while(n !== null && n.deleted){
            n = n.right;
        }
        return n;
    }
    /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, _parentSubs) {
        if (!transaction.local && this._searchMarker) {
            this._searchMarker.length = 0;
        }
    }
    /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */ observe(f) {
        addEventHandlerListener(this._eH, f);
    }
    /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ observeDeep(f) {
        addEventHandlerListener(this._dEH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */ unobserve(f) {
        removeEventHandlerListener(this._eH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ unobserveDeep(f) {
        removeEventHandlerListener(this._dEH, f);
    }
    /**
   * @abstract
   * @return {any}
   */ toJSON() {}
}
/**
 * @param {AbstractType<any>} type
 * @param {number} start
 * @param {number} end
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListSlice = (type, start, end)=>{
    type.doc ?? warnPrematureAccess();
    if (start < 0) {
        start = type._length + start;
    }
    if (end < 0) {
        end = type._length + end;
    }
    let len = end - start;
    const cs = [];
    let n = type._start;
    while(n !== null && len > 0){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            if (c.length <= start) {
                start -= c.length;
            } else {
                for(let i = start; i < c.length && len > 0; i++){
                    cs.push(c[i]);
                    len--;
                }
                start = 0;
            }
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArray = (type)=>{
    type.doc ?? warnPrematureAccess();
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++){
                cs.push(c[i]);
            }
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @param {Snapshot} snapshot
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArraySnapshot = (type, snapshot)=>{
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && isVisible(n, snapshot)) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++){
                cs.push(c[i]);
            }
        }
        n = n.right;
    }
    return cs;
};
/**
 * Executes a provided function on once on every element of this YArray.
 *
 * @param {AbstractType<any>} type
 * @param {function(any,number,any):void} f A function to execute on every element of this YArray.
 *
 * @private
 * @function
 */ const typeListForEach = (type, f)=>{
    let index = 0;
    let n = type._start;
    type.doc ?? warnPrematureAccess();
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++){
                f(c[i], index++, type);
            }
        }
        n = n.right;
    }
};
/**
 * @template C,R
 * @param {AbstractType<any>} type
 * @param {function(C,number,AbstractType<any>):R} f
 * @return {Array<R>}
 *
 * @private
 * @function
 */ const typeListMap = (type, f)=>{
    /**
   * @type {Array<any>}
   */ const result = [];
    typeListForEach(type, (c, i)=>{
        result.push(f(c, i, type));
    });
    return result;
};
/**
 * @param {AbstractType<any>} type
 * @return {IterableIterator<any>}
 *
 * @private
 * @function
 */ const typeListCreateIterator = (type)=>{
    let n = type._start;
    /**
   * @type {Array<any>|null}
   */ let currentContent = null;
    let currentContentIndex = 0;
    return {
        [Symbol.iterator] () {
            return this;
        },
        next: ()=>{
            // find some content
            if (currentContent === null) {
                while(n !== null && n.deleted){
                    n = n.right;
                }
                // check if we reached the end, no need to check currentContent, because it does not exist
                if (n === null) {
                    return {
                        done: true,
                        value: undefined
                    };
                }
                // we found n, so we can set currentContent
                currentContent = n.content.getContent();
                currentContentIndex = 0;
                n = n.right; // we used the content of n, now iterate to next
            }
            const value = currentContent[currentContentIndex++];
            // check if we need to empty currentContent
            if (currentContent.length <= currentContentIndex) {
                currentContent = null;
            }
            return {
                done: false,
                value
            };
        }
    };
};
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @return {any}
 *
 * @private
 * @function
 */ const typeListGet = (type, index)=>{
    type.doc ?? warnPrematureAccess();
    const marker = findMarker(type, index);
    let n = type._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    for(; n !== null; n = n.right){
        if (!n.deleted && n.countable) {
            if (index < n.length) {
                return n.content.getContent()[index];
            }
            index -= n.length;
        }
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Item?} referenceItem
 * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content)=>{
    let left = referenceItem;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const store = doc.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    /**
   * @type {Array<Object|Array<any>|number|null>}
   */ let jsonContent = [];
    const packJsonContent = ()=>{
        if (jsonContent.length > 0) {
            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
            left.integrate(transaction, 0);
            jsonContent = [];
        }
    };
    content.forEach((c)=>{
        if (c === null) {
            jsonContent.push(c);
        } else {
            switch(c.constructor){
                case Number:
                case Object:
                case Boolean:
                case Array:
                case String:
                    jsonContent.push(c);
                    break;
                default:
                    packJsonContent();
                    switch(c.constructor){
                        case Uint8Array:
                        case ArrayBuffer:
                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(c)));
                            left.integrate(transaction, 0);
                            break;
                        case Doc:
                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(c));
                            left.integrate(transaction, 0);
                            break;
                        default:
                            if (c instanceof AbstractType) {
                                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                                left.integrate(transaction, 0);
                            } else {
                                throw new Error('Unexpected content type in insert operation');
                            }
                    }
            }
        }
    });
    packJsonContent();
};
const lengthExceeded = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('Length exceeded!');
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenerics = (transaction, parent, index, content)=>{
    if (index > parent._length) {
        throw lengthExceeded();
    }
    if (index === 0) {
        if (parent._searchMarker) {
            updateMarkerChanges(parent._searchMarker, index, content.length);
        }
        return typeListInsertGenericsAfter(transaction, parent, null, content);
    }
    const startIndex = index;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
        // we need to iterate one to the left so that the algorithm works
        if (index === 0) {
            // @todo refactor this as it actually doesn't consider formats
            n = n.prev; // important! get the left undeleted item so that we can actually decrease index
            index += n && n.countable && !n.deleted ? n.length : 0;
        }
    }
    for(; n !== null; n = n.right){
        if (!n.deleted && n.countable) {
            if (index <= n.length) {
                if (index < n.length) {
                    // insert in-between
                    getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
                }
                break;
            }
            index -= n.length;
        }
    }
    if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, startIndex, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * Pushing content is special as we generally want to push after the last item. So we don't have to update
 * the search marker.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListPushGenerics = (transaction, parent, content)=>{
    // Use the marker with the highest index and iterate to the right.
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker)=>currMarker.index > maxMarker.index ? currMarker : maxMarker, {
        index: 0,
        p: parent._start
    });
    let n = marker.p;
    if (n) {
        while(n.right){
            n = n.right;
        }
    }
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {number} length
 *
 * @private
 * @function
 */ const typeListDelete = (transaction, parent, index, length)=>{
    if (length === 0) {
        return;
    }
    const startIndex = index;
    const startLength = length;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    // compute the first item to be deleted
    for(; n !== null && index > 0; n = n.right){
        if (!n.deleted && n.countable) {
            if (index < n.length) {
                getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
            }
            index -= n.length;
        }
    }
    // delete all items until done
    while(length > 0 && n !== null){
        if (!n.deleted) {
            if (length < n.length) {
                getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));
            }
            n.delete(transaction);
            length -= n.length;
        }
        n = n.right;
    }
    if (length > 0) {
        throw lengthExceeded();
    }
    if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */ );
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 *
 * @private
 * @function
 */ const typeMapDelete = (transaction, parent, key)=>{
    const c = parent._map.get(key);
    if (c !== undefined) {
        c.delete(transaction);
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value
 *
 * @private
 * @function
 */ const typeMapSet = (transaction, parent, key, value)=>{
    const left = parent._map.get(key) || null;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    let content;
    if (value == null) {
        content = new ContentAny([
            value
        ]);
    } else {
        switch(value.constructor){
            case Number:
            case Object:
            case Boolean:
            case Array:
            case String:
                content = new ContentAny([
                    value
                ]);
                break;
            case Uint8Array:
                content = new ContentBinary(value);
                break;
            case Doc:
                content = new ContentDoc(value);
                break;
            default:
                if (value instanceof AbstractType) {
                    content = new ContentType(value);
                } else {
                    throw new Error('Unexpected content type');
                }
        }
    }
    new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGet = (parent, key)=>{
    parent.doc ?? warnPrematureAccess();
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAll = (parent)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent.doc ?? warnPrematureAccess();
    parent._map.forEach((value, key)=>{
        if (!value.deleted) {
            res[key] = value.content.getContent()[value.length - 1];
        }
    });
    return res;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {boolean}
 *
 * @private
 * @function
 */ const typeMapHas = (parent, key)=>{
    parent.doc ?? warnPrematureAccess();
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Snapshot} snapshot
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGetSnapshot = (parent, key, snapshot)=>{
    let v = parent._map.get(key) || null;
    while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))){
        v = v.left;
    }
    return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @param {Snapshot} snapshot
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAllSnapshot = (parent, snapshot)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent._map.forEach((value, key)=>{
        /**
     * @type {Item|null}
     */ let v = value;
        while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))){
            v = v.left;
        }
        if (v !== null && isVisible(v, snapshot)) {
            res[key] = v.content.getContent()[v.length - 1];
        }
    });
    return res;
};
/**
 * @param {AbstractType<any> & { _map: Map<string, Item> }} type
 * @return {IterableIterator<Array<any>>}
 *
 * @private
 * @function
 */ const createMapIterator = (type)=>{
    type.doc ?? warnPrematureAccess();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iteratorFilter"])(type._map.entries(), /** @param {any} entry */ (entry)=>!entry[1].deleted);
};
/**
 * @module YArray
 */ /**
 * Event that describes the changes on a YArray
 * @template T
 * @extends YEvent<YArray<T>>
 */ class YArrayEvent extends YEvent {
}
/**
 * A shared Array implementation.
 * @template T
 * @extends AbstractType<YArrayEvent<T>>
 * @implements {Iterable<T>}
 */ class YArray extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>?}
     * @private
     */ this._prelimContent = [];
        /**
     * @type {Array<ArraySearchMarker>}
     */ this._searchMarker = [];
    }
    /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */ static from(items) {
        /**
     * @type {YArray<T>}
     */ const a = new YArray();
        a.push(items);
        return a;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, this._prelimContent);
        this._prelimContent = null;
    }
    /**
   * @return {YArray<T>}
   */ _copy() {
        return new YArray();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */ clone() {
        /**
     * @type {YArray<T>}
     */ const arr = new YArray();
        arr.insert(0, this.toArray().map((el)=>el instanceof AbstractType ? el.clone() : el));
        return arr;
    }
    get length() {
        this.doc ?? warnPrematureAccess();
        return this._length;
    }
    /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeListInsertGenerics(transaction, this, index, content);
            });
        } else {
            /** @type {Array<any>} */ this._prelimContent.splice(index, 0, ...content);
        }
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */ push(content) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeListPushGenerics(transaction, this, content);
            });
        } else {
            /** @type {Array<any>} */ this._prelimContent.push(...content);
        }
    }
    /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeListDelete(transaction, this, index, length);
            });
        } else {
            /** @type {Array<any>} */ this._prelimContent.splice(index, length);
        }
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */ toJSON() {
        return this.map((c)=>c instanceof AbstractType ? c.toJSON() : c);
    }
    /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */ map(f) {
        return typeListMap(this, f);
    }
    /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator]() {
        return typeListCreateIterator(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YArrayRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYArray = (_decoder)=>new YArray();
/**
 * @module YMap
 */ /**
 * @template T
 * @extends YEvent<YMap<T>>
 * Event that describes the changes on a YMap.
 */ class YMapEvent extends YEvent {
    /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */ constructor(ymap, transaction, subs){
        super(ymap, transaction);
        this.keysChanged = subs;
    }
}
/**
 * @template MapType
 * A shared Map implementation.
 *
 * @extends AbstractType<YMapEvent<MapType>>
 * @implements {Iterable<[string, MapType]>}
 */ class YMap extends AbstractType {
    /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */ constructor(entries){
        super();
        /**
     * @type {Map<string,any>?}
     * @private
     */ this._prelimContent = null;
        if (entries === undefined) {
            this._prelimContent = new Map();
        } else {
            this._prelimContent = new Map(entries);
        }
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item); /** @type {Map<string, any>} */ 
        this._prelimContent.forEach((value, key)=>{
            this.set(key, value);
        });
        this._prelimContent = null;
    }
    /**
   * @return {YMap<MapType>}
   */ _copy() {
        return new YMap();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */ clone() {
        /**
     * @type {YMap<MapType>}
     */ const map = new YMap();
        this.forEach((value, key)=>{
            map.set(key, value instanceof AbstractType ? value.clone() : value);
        });
        return map;
    }
    /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */ toJSON() {
        this.doc ?? warnPrematureAccess();
        /**
     * @type {Object<string,MapType>}
     */ const map = {};
        this._map.forEach((item, key)=>{
            if (!item.deleted) {
                const v = item.content.getContent()[item.length - 1];
                map[key] = v instanceof AbstractType ? v.toJSON() : v;
            }
        });
        return map;
    }
    /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */ get size() {
        return [
            ...createMapIterator(this)
        ].length;
    }
    /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */ keys() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iteratorMap"])(createMapIterator(this), /** @param {any} v */ (v)=>v[0]);
    }
    /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */ values() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iteratorMap"])(createMapIterator(this), /** @param {any} v */ (v)=>v[1].content.getContent()[v[1].length - 1]);
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */ entries() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iteratorMap"])(createMapIterator(this), /** @param {any} v */ (v)=>[
                v[0],
                v[1].content.getContent()[v[1].length - 1]
            ]);
    }
    /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        this.doc ?? warnPrematureAccess();
        this._map.forEach((item, key)=>{
            if (!item.deleted) {
                f(item.content.getContent()[item.length - 1], key, this);
            }
        });
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */ delete(key) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeMapDelete(transaction, this, key);
            });
        } else {
            /** @type {Map<string, any>} */ this._prelimContent.delete(key);
        }
    }
    /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */ set(key, value) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeMapSet(transaction, this, key, value);
            });
        } else {
            /** @type {Map<string, any>} */ this._prelimContent.set(key, value);
        }
        return value;
    }
    /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */ get(key) {
        return typeMapGet(this, key);
    }
    /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */ has(key) {
        return typeMapHas(this, key);
    }
    /**
   * Removes all elements from this YMap.
   */ clear() {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                this.forEach(function(_value, key, map) {
                    typeMapDelete(transaction, map, key);
                });
            });
        } else {
            /** @type {Map<string, any>} */ this._prelimContent.clear();
        }
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YMapRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYMap = (_decoder)=>new YMap();
/**
 * @module YText
 */ /**
 * @param {any} a
 * @param {any} b
 * @return {boolean}
 */ const equalAttrs = (a, b)=>a === b || typeof a === 'object' && typeof b === 'object' && a && b && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equalFlat"])(a, b);
class ItemTextListPosition {
    /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */ constructor(left, right, index, currentAttributes){
        this.left = left;
        this.right = right;
        this.index = index;
        this.currentAttributes = currentAttributes;
    }
    /**
   * Only call this if you know that this.right is defined
   */ forward() {
        if (this.right === null) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
        }
        switch(this.right.content.constructor){
            case ContentFormat:
                if (!this.right.deleted) {
                    updateCurrentAttributes(this.currentAttributes, this.right.content);
                }
                break;
            default:
                if (!this.right.deleted) {
                    this.index += this.right.length;
                }
                break;
        }
        this.left = this.right;
        this.right = this.right.right;
    }
}
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} pos
 * @param {number} count steps to move forward
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findNextPosition = (transaction, pos, count)=>{
    while(pos.right !== null && count > 0){
        switch(pos.right.content.constructor){
            case ContentFormat:
                if (!pos.right.deleted) {
                    updateCurrentAttributes(pos.currentAttributes, pos.right.content);
                }
                break;
            default:
                if (!pos.right.deleted) {
                    if (count < pos.right.length) {
                        // split right
                        getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
                    }
                    pos.index += pos.right.length;
                    count -= pos.right.length;
                }
                break;
        }
        pos.left = pos.right;
        pos.right = pos.right.right;
    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above
    }
    return pos;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {boolean} useSearchMarker
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findPosition = (transaction, parent, index, useSearchMarker)=>{
    const currentAttributes = new Map();
    const marker = useSearchMarker ? findMarker(parent, index) : null;
    if (marker) {
        const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
        return findNextPosition(transaction, pos, index - marker.index);
    } else {
        const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
        return findNextPosition(transaction, pos, index);
    }
};
/**
 * Negate applied formats
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Map<string,any>} negatedAttributes
 *
 * @private
 * @function
 */ const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes)=>{
    // check if we really need to remove attributes
    while(currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ currPos.right.content.key), /** @type {ContentFormat} */ currPos.right.content.value))){
        if (!currPos.right.deleted) {
            negatedAttributes.delete(/** @type {ContentFormat} */ currPos.right.content.key);
        }
        currPos.forward();
    }
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    negatedAttributes.forEach((val, key)=>{
        const left = currPos.left;
        const right = currPos.right;
        const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
        nextFormat.integrate(transaction, 0);
        currPos.right = nextFormat;
        currPos.forward();
    });
};
/**
 * @param {Map<string,any>} currentAttributes
 * @param {ContentFormat} format
 *
 * @private
 * @function
 */ const updateCurrentAttributes = (currentAttributes, format)=>{
    const { key, value } = format;
    if (value === null) {
        currentAttributes.delete(key);
    } else {
        currentAttributes.set(key, value);
    }
};
/**
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const minimizeAttributeChanges = (currPos, attributes)=>{
    // go right while attributes[right.key] === right.value (or right is deleted)
    while(true){
        if (currPos.right === null) {
            break;
        } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[currPos.right.content.key] ?? null, /** @type {ContentFormat} */ currPos.right.content.value)) ;
        else {
            break;
        }
        currPos.forward();
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 * @return {Map<string,any>}
 *
 * @private
 * @function
 **/ const insertAttributes = (transaction, parent, currPos, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const negatedAttributes = new Map();
    // insert format-start items
    for(const key in attributes){
        const val = attributes[key];
        const currentVal = currPos.currentAttributes.get(key) ?? null;
        if (!equalAttrs(currentVal, val)) {
            // save negated attribute (set null if currentVal undefined)
            negatedAttributes.set(key, currentVal);
            const { left, right } = currPos;
            currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
            currPos.right.integrate(transaction, 0);
            currPos.forward();
        }
    }
    return negatedAttributes;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {string|object|AbstractType<any>} text
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 **/ const insertText = (transaction, parent, currPos, text, attributes)=>{
    currPos.currentAttributes.forEach((_val, key)=>{
        if (attributes[key] === undefined) {
            attributes[key] = null;
        }
    });
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // insert content
    const content = text.constructor === String ? new ContentString(text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);
    let { left, right, index } = currPos;
    if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
    }
    right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const formatText = (transaction, parent, currPos, length, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
    // eslint-disable-next-line no-labels
    iterationLoop: while(currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))){
        if (!currPos.right.deleted) {
            switch(currPos.right.content.constructor){
                case ContentFormat:
                    {
                        const { key, value } = currPos.right.content;
                        const attr = attributes[key];
                        if (attr !== undefined) {
                            if (equalAttrs(attr, value)) {
                                negatedAttributes.delete(key);
                            } else {
                                if (length === 0) {
                                    break iterationLoop;
                                }
                                negatedAttributes.set(key, value);
                            }
                            currPos.right.delete(transaction);
                        } else {
                            currPos.currentAttributes.set(key, value);
                        }
                        break;
                    }
                default:
                    if (length < currPos.right.length) {
                        getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                    }
                    length -= currPos.right.length;
                    break;
            }
        }
        currPos.forward();
    }
    // Quill just assumes that the editor starts with a newline and that it always
    // ends with a newline. We only insert that newline when a new newline is
    // inserted - i.e when length is bigger than type.length
    if (length > 0) {
        let newlines = '';
        for(; length > 0; length--){
            newlines += '\n';
        }
        currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * Call this function after string content has been deleted in order to
 * clean up formatting Items.
 *
 * @param {Transaction} transaction
 * @param {Item} start
 * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item
 * @param {Map<string,any>} startAttributes
 * @param {Map<string,any>} currAttributes
 * @return {number} The amount of formatting Items deleted.
 *
 * @function
 */ const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes)=>{
    /**
   * @type {Item|null}
   */ let end = start;
    /**
   * @type {Map<string,ContentFormat>}
   */ const endFormats = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    while(end && (!end.countable || end.deleted)){
        if (!end.deleted && end.content.constructor === ContentFormat) {
            const cf = end.content;
            endFormats.set(cf.key, cf);
        }
        end = end.right;
    }
    let cleanups = 0;
    let reachedCurr = false;
    while(start !== end){
        if (curr === start) {
            reachedCurr = true;
        }
        if (!start.deleted) {
            const content = start.content;
            switch(content.constructor){
                case ContentFormat:
                    {
                        const { key, value } = content;
                        const startAttrValue = startAttributes.get(key) ?? null;
                        if (endFormats.get(key) !== content || startAttrValue === value) {
                            // Either this format is overwritten or it is not necessary because the attribute already existed.
                            start.delete(transaction);
                            cleanups++;
                            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {
                                if (startAttrValue === null) {
                                    currAttributes.delete(key);
                                } else {
                                    currAttributes.set(key, startAttrValue);
                                }
                            }
                        }
                        if (!reachedCurr && !start.deleted) {
                            updateCurrentAttributes(currAttributes, content);
                        }
                        break;
                    }
            }
        }
        start = start.right;
    }
    return cleanups;
};
/**
 * @param {Transaction} transaction
 * @param {Item | null} item
 */ const cleanupContextlessFormattingGap = (transaction, item)=>{
    // iterate until item.right is null or content
    while(item && item.right && (item.right.deleted || !item.right.countable)){
        item = item.right;
    }
    const attrs = new Set();
    // iterate back until a content item is found
    while(item && (item.deleted || !item.countable)){
        if (!item.deleted && item.content.constructor === ContentFormat) {
            const key = /** @type {ContentFormat} */ item.content.key;
            if (attrs.has(key)) {
                item.delete(transaction);
            } else {
                attrs.add(key);
            }
        }
        item = item.left;
    }
};
/**
 * This function is experimental and subject to change / be removed.
 *
 * Ideally, we don't need this function at all. Formatting attributes should be cleaned up
 * automatically after each change. This function iterates twice over the complete YText type
 * and removes unnecessary formatting attributes. This is also helpful for testing.
 *
 * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.
 *
 * @param {YText} type
 * @return {number} How many formatting attributes have been cleaned up.
 */ const cleanupYTextFormatting = (type)=>{
    let res = 0;
    transact(type.doc, (transaction)=>{
        let start = type._start;
        let end = type._start;
        let startAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
        const currentAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copy"])(startAttributes);
        while(end){
            if (end.deleted === false) {
                switch(end.content.constructor){
                    case ContentFormat:
                        updateCurrentAttributes(currentAttributes, end.content);
                        break;
                    default:
                        res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                        startAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copy"])(currentAttributes);
                        start = end;
                        break;
                }
            }
            end = end.right;
        }
    });
    return res;
};
/**
 * This will be called by the transaction once the event handlers are called to potentially cleanup
 * formatting attributes.
 *
 * @param {Transaction} transaction
 */ const cleanupYTextAfterTransaction = (transaction)=>{
    /**
   * @type {Set<YText>}
   */ const needFullCleanup = new Set();
    // check if another formatting item was inserted
    const doc = transaction.doc;
    for (const [client, afterClock] of transaction.afterState.entries()){
        const clock = transaction.beforeState.get(client) || 0;
        if (afterClock === clock) {
            continue;
        }
        iterateStructs(transaction, doc.store.clients.get(client), clock, afterClock, (item)=>{
            if (!item.deleted && /** @type {Item} */ item.content.constructor === ContentFormat && item.constructor !== GC) {
                needFullCleanup.add(/** @type {any} */ item.parent);
            }
        });
    }
    // cleanup in a new transaction
    transact(doc, (t)=>{
        iterateDeletedStructs(transaction, transaction.deleteSet, (item)=>{
            if (item instanceof GC || !/** @type {YText} */ item.parent._hasFormatting || needFullCleanup.has(item.parent)) {
                return;
            }
            const parent = item.parent;
            if (item.content.constructor === ContentFormat) {
                needFullCleanup.add(parent);
            } else {
                // If no formatting attribute was inserted or deleted, we can make due with contextless
                // formatting cleanups.
                // Contextless: it is not necessary to compute currentAttributes for the affected position.
                cleanupContextlessFormattingGap(t, item);
            }
        });
        // If a formatting item was inserted, we simply clean the whole type.
        // We need to compute currentAttributes for the current position anyway.
        for (const yText of needFullCleanup){
            cleanupYTextFormatting(yText);
        }
    });
};
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const deleteText = (transaction, currPos, length)=>{
    const startLength = length;
    const startAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copy"])(currPos.currentAttributes);
    const start = currPos.right;
    while(length > 0 && currPos.right !== null){
        if (currPos.right.deleted === false) {
            switch(currPos.right.content.constructor){
                case ContentType:
                case ContentEmbed:
                case ContentString:
                    if (length < currPos.right.length) {
                        getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                    }
                    length -= currPos.right.length;
                    currPos.right.delete(transaction);
                    break;
            }
        }
        currPos.forward();
    }
    if (start) {
        cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    }
    const parent = /** @type {Item} */ (currPos.left || currPos.right).parent;
    if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);
    }
    return currPos;
};
/**
 * The Quill Delta format represents changes on a text document with
 * formatting information. For more information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
 *
 * @example
 *   {
 *     ops: [
 *       { insert: 'Gandalf', attributes: { bold: true } },
 *       { insert: ' the ' },
 *       { insert: 'Grey', attributes: { color: '#cccccc' } }
 *     ]
 *   }
 *
 */ /**
  * Attributes that can be assigned to a selection of text.
  *
  * @example
  *   {
  *     bold: true,
  *     font-size: '40px'
  *   }
  *
  * @typedef {Object} TextAttributes
  */ /**
 * @extends YEvent<YText>
 * Event that describes the changes on a YText type.
 */ class YTextEvent extends YEvent {
    /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */ constructor(ytext, transaction, subs){
        super(ytext, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.keysChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) {
                this.childListChanged = true;
            } else {
                this.keysChanged.add(sub);
            }
        });
    }
    /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        if (this._changes === null) {
            /**
       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}
       */ const changes = {
                keys: this.keys,
                delta: this.delta,
                added: new Set(),
                deleted: new Set()
            };
            this._changes = changes;
        }
        return this._changes;
    }
    /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */ get delta() {
        if (this._delta === null) {
            const y = this.target.doc;
            /**
       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
       */ const delta = [];
            transact(y, (transaction)=>{
                const currentAttributes = new Map(); // saves all current attributes for insert
                const oldAttributes = new Map();
                let item = this.target._start;
                /**
         * @type {string?}
         */ let action = null;
                /**
         * @type {Object<string,any>}
         */ const attributes = {}; // counts added or removed new attributes for retain
                /**
         * @type {string|object}
         */ let insert = '';
                let retain = 0;
                let deleteLen = 0;
                const addOp = ()=>{
                    if (action !== null) {
                        /**
             * @type {any}
             */ let op = null;
                        switch(action){
                            case 'delete':
                                if (deleteLen > 0) {
                                    op = {
                                        delete: deleteLen
                                    };
                                }
                                deleteLen = 0;
                                break;
                            case 'insert':
                                if (typeof insert === 'object' || insert.length > 0) {
                                    op = {
                                        insert
                                    };
                                    if (currentAttributes.size > 0) {
                                        op.attributes = {};
                                        currentAttributes.forEach((value, key)=>{
                                            if (value !== null) {
                                                op.attributes[key] = value;
                                            }
                                        });
                                    }
                                }
                                insert = '';
                                break;
                            case 'retain':
                                if (retain > 0) {
                                    op = {
                                        retain
                                    };
                                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmpty"])(attributes)) {
                                        op.attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, attributes);
                                    }
                                }
                                retain = 0;
                                break;
                        }
                        if (op) delta.push(op);
                        action = null;
                    }
                };
                while(item !== null){
                    switch(item.content.constructor){
                        case ContentType:
                        case ContentEmbed:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    addOp();
                                    action = 'insert';
                                    insert = item.content.getContent()[0];
                                    addOp();
                                }
                            } else if (this.deletes(item)) {
                                if (action !== 'delete') {
                                    addOp();
                                    action = 'delete';
                                }
                                deleteLen += 1;
                            } else if (!item.deleted) {
                                if (action !== 'retain') {
                                    addOp();
                                    action = 'retain';
                                }
                                retain += 1;
                            }
                            break;
                        case ContentString:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    if (action !== 'insert') {
                                        addOp();
                                        action = 'insert';
                                    }
                                    insert += /** @type {ContentString} */ item.content.str;
                                }
                            } else if (this.deletes(item)) {
                                if (action !== 'delete') {
                                    addOp();
                                    action = 'delete';
                                }
                                deleteLen += item.length;
                            } else if (!item.deleted) {
                                if (action !== 'retain') {
                                    addOp();
                                    action = 'retain';
                                }
                                retain += item.length;
                            }
                            break;
                        case ContentFormat:
                            {
                                const { key, value } = item.content;
                                if (this.adds(item)) {
                                    if (!this.deletes(item)) {
                                        const curVal = currentAttributes.get(key) ?? null;
                                        if (!equalAttrs(curVal, value)) {
                                            if (action === 'retain') {
                                                addOp();
                                            }
                                            if (equalAttrs(value, oldAttributes.get(key) ?? null)) {
                                                delete attributes[key];
                                            } else {
                                                attributes[key] = value;
                                            }
                                        } else if (value !== null) {
                                            item.delete(transaction);
                                        }
                                    }
                                } else if (this.deletes(item)) {
                                    oldAttributes.set(key, value);
                                    const curVal = currentAttributes.get(key) ?? null;
                                    if (!equalAttrs(curVal, value)) {
                                        if (action === 'retain') {
                                            addOp();
                                        }
                                        attributes[key] = curVal;
                                    }
                                } else if (!item.deleted) {
                                    oldAttributes.set(key, value);
                                    const attr = attributes[key];
                                    if (attr !== undefined) {
                                        if (!equalAttrs(attr, value)) {
                                            if (action === 'retain') {
                                                addOp();
                                            }
                                            if (value === null) {
                                                delete attributes[key];
                                            } else {
                                                attributes[key] = value;
                                            }
                                        } else if (attr !== null) {
                                            item.delete(transaction);
                                        }
                                    }
                                }
                                if (!item.deleted) {
                                    if (action === 'insert') {
                                        addOp();
                                    }
                                    updateCurrentAttributes(currentAttributes, item.content);
                                }
                                break;
                            }
                    }
                    item = item.right;
                }
                addOp();
                while(delta.length > 0){
                    const lastOp = delta[delta.length - 1];
                    if (lastOp.retain !== undefined && lastOp.attributes === undefined) {
                        // retain delta's if they don't assign attributes
                        delta.pop();
                    } else {
                        break;
                    }
                }
            });
            this._delta = delta;
        }
        return this._delta;
    }
}
/**
 * Type that represents text with formatting information.
 *
 * This type replaces y-richtext as this implementation is able to handle
 * block formats (format information on a paragraph), embeds (complex elements
 * like pictures and videos), and text formats (**bold**, *italic*).
 *
 * @extends AbstractType<YTextEvent>
 */ class YText extends AbstractType {
    /**
   * @param {String} [string] The initial value of the YText.
   */ constructor(string){
        super();
        /**
     * Array of pending operations on this type
     * @type {Array<function():void>?}
     */ this._pending = string !== undefined ? [
            ()=>this.insert(0, string)
        ] : [];
        /**
     * @type {Array<ArraySearchMarker>|null}
     */ this._searchMarker = [];
        /**
     * Whether this YText contains formatting attributes.
     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
     */ this._hasFormatting = false;
    }
    /**
   * Number of characters of this text type.
   *
   * @type {number}
   */ get length() {
        this.doc ?? warnPrematureAccess();
        return this._length;
    }
    /**
   * @param {Doc} y
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        try {
            /** @type {Array<function>} */ this._pending.forEach((f)=>f());
        } catch (e) {
            console.error(e);
        }
        this._pending = null;
    }
    _copy() {
        return new YText();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */ clone() {
        const text = new YText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        const event = new YTextEvent(this, transaction, parentSubs);
        callTypeObservers(this, transaction, event);
        // If a remote change happened, we try to cleanup potential formatting duplicates.
        if (!transaction.local && this._hasFormatting) {
            transaction._needFormattingCleanup = true;
        }
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */ toString() {
        this.doc ?? warnPrematureAccess();
        let str = '';
        /**
     * @type {Item|null}
     */ let n = this._start;
        while(n !== null){
            if (!n.deleted && n.countable && n.content.constructor === ContentString) {
                str += /** @type {ContentString} */ n.content.str;
            }
            n = n.right;
        }
        return str;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */ toJSON() {
        return this.toString();
    }
    /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */ applyDelta(delta, { sanitize = true } = {}) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                const currPos = new ItemTextListPosition(null, this._start, 0, new Map());
                for(let i = 0; i < delta.length; i++){
                    const op = delta[i];
                    if (op.insert !== undefined) {
                        // Quill assumes that the content starts with an empty paragraph.
                        // Yjs/Y.Text assumes that it starts empty. We always hide that
                        // there is a newline at the end of the content.
                        // If we omit this step, clients will see a different number of
                        // paragraphs, but nothing bad will happen.
                        const ins = !sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\n' ? op.insert.slice(0, -1) : op.insert;
                        if (typeof ins !== 'string' || ins.length > 0) {
                            insertText(transaction, this, currPos, ins, op.attributes || {});
                        }
                    } else if (op.retain !== undefined) {
                        formatText(transaction, this, currPos, op.retain, op.attributes || {});
                    } else if (op.delete !== undefined) {
                        deleteText(transaction, currPos, op.delete);
                    }
                }
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.applyDelta(delta));
        }
    }
    /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */ toDelta(snapshot, prevSnapshot, computeYChange) {
        this.doc ?? warnPrematureAccess();
        /**
     * @type{Array<any>}
     */ const ops = [];
        const currentAttributes = new Map();
        const doc = this.doc;
        let str = '';
        let n = this._start;
        function packStr() {
            if (str.length > 0) {
                // pack str with attributes to ops
                /**
         * @type {Object<string,any>}
         */ const attributes = {};
                let addAttributes = false;
                currentAttributes.forEach((value, key)=>{
                    addAttributes = true;
                    attributes[key] = value;
                });
                /**
         * @type {Object<string,any>}
         */ const op = {
                    insert: str
                };
                if (addAttributes) {
                    op.attributes = attributes;
                }
                ops.push(op);
                str = '';
            }
        }
        const computeDelta = ()=>{
            while(n !== null){
                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) {
                    switch(n.content.constructor){
                        case ContentString:
                            {
                                const cur = currentAttributes.get('ychange');
                                if (snapshot !== undefined && !isVisible(n, snapshot)) {
                                    if (cur === undefined || cur.user !== n.id.client || cur.type !== 'removed') {
                                        packStr();
                                        currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : {
                                            type: 'removed'
                                        });
                                    }
                                } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {
                                    if (cur === undefined || cur.user !== n.id.client || cur.type !== 'added') {
                                        packStr();
                                        currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : {
                                            type: 'added'
                                        });
                                    }
                                } else if (cur !== undefined) {
                                    packStr();
                                    currentAttributes.delete('ychange');
                                }
                                str += /** @type {ContentString} */ n.content.str;
                                break;
                            }
                        case ContentType:
                        case ContentEmbed:
                            {
                                packStr();
                                /**
               * @type {Object<string,any>}
               */ const op = {
                                    insert: n.content.getContent()[0]
                                };
                                if (currentAttributes.size > 0) {
                                    const attrs = {};
                                    op.attributes = attrs;
                                    currentAttributes.forEach((value, key)=>{
                                        attrs[key] = value;
                                    });
                                }
                                ops.push(op);
                                break;
                            }
                        case ContentFormat:
                            if (isVisible(n, snapshot)) {
                                packStr();
                                updateCurrentAttributes(currentAttributes, n.content);
                            }
                            break;
                    }
                }
                n = n.right;
            }
            packStr();
        };
        if (snapshot || prevSnapshot) {
            // snapshots are merged again after the transaction, so we need to keep the
            // transaction alive until we are done
            transact(doc, (transaction)=>{
                if (snapshot) {
                    splitSnapshotAffectedStructs(transaction, snapshot);
                }
                if (prevSnapshot) {
                    splitSnapshotAffectedStructs(transaction, prevSnapshot);
                }
                computeDelta();
            }, 'cleanup');
        } else {
            computeDelta();
        }
        return ops;
    }
    /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */ insert(index, text, attributes) {
        if (text.length <= 0) {
            return;
        }
        const y = this.doc;
        if (y !== null) {
            transact(y, (transaction)=>{
                const pos = findPosition(transaction, this, index, !attributes);
                if (!attributes) {
                    attributes = {};
                    // @ts-ignore
                    pos.currentAttributes.forEach((v, k)=>{
                        attributes[k] = v;
                    });
                }
                insertText(transaction, this, pos, text, attributes);
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.insert(index, text, attributes));
        }
    }
    /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */ insertEmbed(index, embed, attributes) {
        const y = this.doc;
        if (y !== null) {
            transact(y, (transaction)=>{
                const pos = findPosition(transaction, this, index, !attributes);
                insertText(transaction, this, pos, embed, attributes || {});
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.insertEmbed(index, embed, attributes || {}));
        }
    }
    /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */ delete(index, length) {
        if (length === 0) {
            return;
        }
        const y = this.doc;
        if (y !== null) {
            transact(y, (transaction)=>{
                deleteText(transaction, findPosition(transaction, this, index, true), length);
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.delete(index, length));
        }
    }
    /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */ format(index, length, attributes) {
        if (length === 0) {
            return;
        }
        const y = this.doc;
        if (y !== null) {
            transact(y, (transaction)=>{
                const pos = findPosition(transaction, this, index, false);
                if (pos.right === null) {
                    return;
                }
                formatText(transaction, this, pos, length, attributes);
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.format(index, length, attributes));
        }
    }
    /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeMapDelete(transaction, this, attributeName);
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.removeAttribute(attributeName));
        }
    }
    /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeMapSet(transaction, this, attributeName, attributeValue);
            });
        } else {
            /** @type {Array<function>} */ this._pending.push(()=>this.setAttribute(attributeName, attributeValue));
        }
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return typeMapGet(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes() {
        return typeMapGetAll(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YText}
 *
 * @private
 * @function
 */ const readYText = (_decoder)=>new YText();
/**
 * @module YXml
 */ /**
 * Define the elements to which a set of CSS queries apply.
 * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
 *
 * @example
 *   query = '.classSelector'
 *   query = 'nodeSelector'
 *   query = '#idSelector'
 *
 * @typedef {string} CSS_Selector
 */ /**
 * Dom filter function.
 *
 * @callback domFilter
 * @param {string} nodeName The nodeName of the element
 * @param {Map} attributes The map of attributes.
 * @return {boolean} Whether to include the Dom node in the YXmlElement.
 */ /**
 * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
 * position within them.
 *
 * Can be created with {@link YXmlFragment#createTreeWalker}
 *
 * @public
 * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}
 */ class YXmlTreeWalker {
    /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */ constructor(root, f = ()=>true){
        this._filter = f;
        this._root = root;
        /**
     * @type {Item}
     */ this._currentNode = root._start;
        this._firstCall = true;
        root.doc ?? warnPrematureAccess();
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */ next() {
        /**
     * @type {Item|null}
     */ let n = this._currentNode;
        let type = n && n.content && /** @type {any} */ n.content.type;
        if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
            do {
                type = /** @type {any} */ n.content.type;
                if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
                    // walk down in the tree
                    n = type._start;
                } else {
                    // walk right or up in the tree
                    while(n !== null){
                        /**
             * @type {Item | null}
             */ const nxt = n.next;
                        if (nxt !== null) {
                            n = nxt;
                            break;
                        } else if (n.parent === this._root) {
                            n = null;
                        } else {
                            n = /** @type {AbstractType<any>} */ n.parent._item;
                        }
                    }
                }
            }while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ n.content.type)))
        }
        this._firstCall = false;
        if (n === null) {
            // @ts-ignore
            return {
                value: undefined,
                done: true
            };
        }
        this._currentNode = n;
        return {
            value: /** @type {any} */ n.content.type,
            done: false
        };
    }
}
/**
 * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
 * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
 * nodeName and it does not have attributes. Though it can be bound to a DOM
 * element - in this case the attributes and the nodeName are not shared.
 *
 * @public
 * @extends AbstractType<YXmlEvent>
 */ class YXmlFragment extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>|null}
     */ this._prelimContent = [];
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get firstChild() {
        const first = this._first;
        return first ? first.content.getContent()[0] : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, this._prelimContent);
        this._prelimContent = null;
    }
    _copy() {
        return new YXmlFragment();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */ clone() {
        const el = new YXmlFragment();
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    get length() {
        this.doc ?? warnPrematureAccess();
        return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */ createTreeWalker(filter) {
        return new YXmlTreeWalker(this, filter);
    }
    /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */ querySelector(query) {
        query = query.toUpperCase();
        // @ts-ignore
        const iterator = new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query);
        const next = iterator.next();
        if (next.done) {
            return null;
        } else {
            return next.value;
        }
    }
    /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */ querySelectorAll(query) {
        query = query.toUpperCase();
        // @ts-ignore
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query));
    }
    /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */ toString() {
        return typeListMap(this, (xml)=>xml.toString()).join('');
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const fragment = _document.createDocumentFragment();
        if (binding !== undefined) {
            binding._createAssociation(fragment, this);
        }
        typeListForEach(this, (xmlType)=>{
            fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
        });
        return fragment;
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeListInsertGenerics(transaction, this, index, content);
            });
        } else {
            // @ts-ignore _prelimContent is defined because this is not yet integrated
            this._prelimContent.splice(index, 0, ...content);
        }
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insertAfter(ref, content) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
                typeListInsertGenericsAfter(transaction, this, refItem, content);
            });
        } else {
            const pc = this._prelimContent;
            const index = ref === null ? 0 : pc.findIndex((el)=>el === ref) + 1;
            if (index === 0 && ref !== null) {
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])('Reference item not found');
            }
            pc.splice(index, 0, ...content);
        }
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeListDelete(transaction, this, index, length);
            });
        } else {
            // @ts-ignore _prelimContent is defined because this is not yet integrated
            this._prelimContent.splice(index, length);
        }
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */ push(content) {
        this.insert(this.length, content);
    }
    /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlFragmentRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YXmlFragment}
 *
 * @private
 * @function
 */ const readYXmlFragment = (_decoder)=>new YXmlFragment();
/**
 * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes
 */ /**
 * An YXmlElement imitates the behavior of a
 * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element
 *
 * * An YXmlElement has attributes (key value pairs)
 * * An YXmlElement has childElements that must inherit from YXmlElement
 *
 * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]
 */ class YXmlElement extends YXmlFragment {
    constructor(nodeName = 'UNDEFINED'){
        super();
        this.nodeName = nodeName;
        /**
     * @type {Map<string, any>|null}
     */ this._prelimAttrs = new Map();
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this._prelimAttrs.forEach((value, key)=>{
            this.setAttribute(key, value);
        });
        this._prelimAttrs = null;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */ _copy() {
        return new YXmlElement(this.nodeName);
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */ clone() {
        /**
     * @type {YXmlElement<KV>}
     */ const el = new YXmlElement(this.nodeName);
        const attrs = this.getAttributes();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forEach"])(attrs, (value, key)=>{
            if (typeof value === 'string') {
                el.setAttribute(key, value);
            }
        });
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */ toString() {
        const attrs = this.getAttributes();
        const stringBuilder = [];
        const keys = [];
        for(const key in attrs){
            keys.push(key);
        }
        keys.sort();
        const keysLen = keys.length;
        for(let i = 0; i < keysLen; i++){
            const key = keys[i];
            stringBuilder.push(key + '="' + attrs[key] + '"');
        }
        const nodeName = this.nodeName.toLocaleLowerCase();
        const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';
        return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeMapDelete(transaction, this, attributeName);
            });
        } else {
            /** @type {Map<string,any>} */ this._prelimAttrs.delete(attributeName);
        }
    }
    /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) {
            transact(this.doc, (transaction)=>{
                typeMapSet(transaction, this, attributeName, attributeValue);
            });
        } else {
            /** @type {Map<string, any>} */ this._prelimAttrs.set(attributeName, attributeValue);
        }
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return typeMapGet(this, attributeName);
    }
    /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */ hasAttribute(attributeName) {
        return typeMapHas(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes(snapshot) {
        return snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this);
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const dom = _document.createElement(this.nodeName);
        const attrs = this.getAttributes();
        for(const key in attrs){
            const value = attrs[key];
            if (typeof value === 'string') {
                dom.setAttribute(key, value);
            }
        }
        typeListForEach(this, (yxml)=>{
            dom.appendChild(yxml.toDOM(_document, hooks, binding));
        });
        if (binding !== undefined) {
            binding._createAssociation(dom, this);
        }
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlElementRefID);
        encoder.writeKey(this.nodeName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlElement}
 *
 * @function
 */ const readYXmlElement = (decoder)=>new YXmlElement(decoder.readKey());
/**
 * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>
 * An Event that describes changes on a YXml Element or Yxml Fragment
 */ class YXmlEvent extends YEvent {
    /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */ constructor(target, subs, transaction){
        super(target, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.attributesChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) {
                this.childListChanged = true;
            } else {
                this.attributesChanged.add(sub);
            }
        });
    }
}
/**
 * You can manage binding to a custom type with YXmlHook.
 *
 * @extends {YMap<any>}
 */ class YXmlHook extends YMap {
    /**
   * @param {string} hookName nodeName of the Dom Node.
   */ constructor(hookName){
        super();
        /**
     * @type {string}
     */ this.hookName = hookName;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   */ _copy() {
        return new YXmlHook(this.hookName);
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */ clone() {
        const el = new YXmlHook(this.hookName);
        this.forEach((value, key)=>{
            el.set(key, value);
        });
        return el;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const hook = hooks[this.hookName];
        let dom;
        if (hook !== undefined) {
            dom = hook.createDom(this);
        } else {
            dom = document.createElement(this.hookName);
        }
        dom.setAttribute('data-yjs-hook', this.hookName);
        if (binding !== undefined) {
            binding._createAssociation(dom, this);
        }
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlHookRefID);
        encoder.writeKey(this.hookName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlHook}
 *
 * @private
 * @function
 */ const readYXmlHook = (decoder)=>new YXmlHook(decoder.readKey());
/**
 * Represents text in a Dom Element. In the future this type will also handle
 * simple formatting information like bold and italic.
 */ class YXmlText extends YText {
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {ContentType} */ n.content.type : null;
    }
    _copy() {
        return new YXmlText();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */ clone() {
        const text = new YXmlText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks, binding) {
        const dom = _document.createTextNode(this.toString());
        if (binding !== undefined) {
            binding._createAssociation(dom, this);
        }
        return dom;
    }
    toString() {
        // @ts-ignore
        return this.toDelta().map((delta)=>{
            const nestedNodes = [];
            for(const nodeName in delta.attributes){
                const attrs = [];
                for(const key in delta.attributes[nodeName]){
                    attrs.push({
                        key,
                        value: delta.attributes[nodeName][key]
                    });
                }
                // sort attributes to get a unique order
                attrs.sort((a, b)=>a.key < b.key ? -1 : 1);
                nestedNodes.push({
                    nodeName,
                    attrs
                });
            }
            // sort node order to get a unique order
            nestedNodes.sort((a, b)=>a.nodeName < b.nodeName ? -1 : 1);
            // now convert to dom string
            let str = '';
            for(let i = 0; i < nestedNodes.length; i++){
                const node = nestedNodes[i];
                str += `<${node.nodeName}`;
                for(let j = 0; j < node.attrs.length; j++){
                    const attr = node.attrs[j];
                    str += ` ${attr.key}="${attr.value}"`;
                }
                str += '>';
            }
            str += delta.insert;
            for(let i = nestedNodes.length - 1; i >= 0; i--){
                str += `</${nestedNodes[i].nodeName}>`;
            }
            return str;
        }).join('');
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlText}
 *
 * @private
 * @function
 */ const readYXmlText = (decoder)=>new YXmlText();
class AbstractStruct {
    /**
   * @param {ID} id
   * @param {number} length
   */ constructor(id, length){
        this.id = id;
        this.length = length;
    }
    /**
   * @type {boolean}
   */ get deleted() {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */ write(encoder, offset, encodingRef) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
}
const structGCRefNumber = 0;
/**
 * @private
 */ class GC extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {GC} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) {
            return false;
        }
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.length -= offset;
        }
        addStruct(transaction.doc.store, this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structGCRefNumber);
        encoder.writeLen(this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
class ContentBinary {
    /**
   * @param {Uint8Array} content
   */ constructor(content){
        this.content = content;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.content
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentBinary}
   */ copy() {
        return new ContentBinary(this.content);
    }
    /**
   * @param {number} offset
   * @return {ContentBinary}
   */ splice(offset) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {ContentBinary} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeBuf(this.content);
    }
    /**
   * @return {number}
   */ getRef() {
        return 3;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentBinary}
 */ const readContentBinary = (decoder)=>new ContentBinary(decoder.readBuf());
class ContentDeleted {
    /**
   * @param {number} len
   */ constructor(len){
        this.len = len;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.len;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentDeleted}
   */ copy() {
        return new ContentDeleted(this.len);
    }
    /**
   * @param {number} offset
   * @return {ContentDeleted}
   */ splice(offset) {
        const right = new ContentDeleted(this.len - offset);
        this.len = offset;
        return right;
    }
    /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */ mergeWith(right) {
        this.len += right.len;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
        item.markDeleted();
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeLen(this.len - offset);
    }
    /**
   * @return {number}
   */ getRef() {
        return 1;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentDeleted}
 */ const readContentDeleted = (decoder)=>new ContentDeleted(decoder.readLen());
/**
 * @param {string} guid
 * @param {Object<string, any>} opts
 */ const createDocFromOpts = (guid, opts)=>new Doc({
        guid,
        ...opts,
        shouldLoad: opts.shouldLoad || opts.autoLoad || false
    });
/**
 * @private
 */ class ContentDoc {
    /**
   * @param {Doc} doc
   */ constructor(doc){
        if (doc._item) {
            console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');
        }
        /**
     * @type {Doc}
     */ this.doc = doc;
        /**
     * @type {any}
     */ const opts = {};
        this.opts = opts;
        if (!doc.gc) {
            opts.gc = false;
        }
        if (doc.autoLoad) {
            opts.autoLoad = true;
        }
        if (doc.meta !== null) {
            opts.meta = doc.meta;
        }
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.doc
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentDoc}
   */ copy() {
        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    /**
   * @param {number} offset
   * @return {ContentDoc}
   */ splice(offset) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {ContentDoc} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        // this needs to be reflected in doc.destroy as well
        this.doc._item = item;
        transaction.subdocsAdded.add(this.doc);
        if (this.doc.shouldLoad) {
            transaction.subdocsLoaded.add(this.doc);
        }
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (transaction.subdocsAdded.has(this.doc)) {
            transaction.subdocsAdded.delete(this.doc);
        } else {
            transaction.subdocsRemoved.add(this.doc);
        }
    }
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(this.doc.guid);
        encoder.writeAny(this.opts);
    }
    /**
   * @return {number}
   */ getRef() {
        return 9;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentDoc}
 */ const readContentDoc = (decoder)=>new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
/**
 * @private
 */ class ContentEmbed {
    /**
   * @param {Object} embed
   */ constructor(embed){
        this.embed = embed;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.embed
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentEmbed}
   */ copy() {
        return new ContentEmbed(this.embed);
    }
    /**
   * @param {number} offset
   * @return {ContentEmbed}
   */ splice(offset) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeJSON(this.embed);
    }
    /**
   * @return {number}
   */ getRef() {
        return 5;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentEmbed}
 */ const readContentEmbed = (decoder)=>new ContentEmbed(decoder.readJSON());
/**
 * @private
 */ class ContentFormat {
    /**
   * @param {string} key
   * @param {Object} value
   */ constructor(key, value){
        this.key = key;
        this.value = value;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentFormat}
   */ copy() {
        return new ContentFormat(this.key, this.value);
    }
    /**
   * @param {number} _offset
   * @return {ContentFormat}
   */ splice(_offset) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */ mergeWith(_right) {
        return false;
    }
    /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */ integrate(_transaction, item) {
        // @todo searchmarker are currently unsupported for rich text documents
        const p = item.parent;
        p._searchMarker = null;
        p._hasFormatting = true;
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeKey(this.key);
        encoder.writeJSON(this.value);
    }
    /**
   * @return {number}
   */ getRef() {
        return 6;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentFormat}
 */ const readContentFormat = (decoder)=>new ContentFormat(decoder.readKey(), decoder.readJSON());
/**
 * @private
 */ class ContentJSON {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentJSON}
   */ copy() {
        return new ContentJSON(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentJSON}
   */ splice(offset) {
        const right = new ContentJSON(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentJSON} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 2;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentJSON}
 */ const readContentJSON = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++){
        const c = decoder.readString();
        if (c === 'undefined') {
            cs.push(undefined);
        } else {
            cs.push(JSON.parse(c));
        }
    }
    return new ContentJSON(cs);
};
const isDevMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVariable"])('node_env') === 'development';
class ContentAny {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
        isDevMode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepFreeze"])(arr);
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentAny}
   */ copy() {
        return new ContentAny(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentAny}
   */ splice(offset) {
        const right = new ContentAny(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentAny} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeAny(c);
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 8;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentAny}
 */ const readContentAny = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++){
        cs.push(decoder.readAny());
    }
    return new ContentAny(cs);
};
/**
 * @private
 */ class ContentString {
    /**
   * @param {string} str
   */ constructor(str){
        /**
     * @type {string}
     */ this.str = str;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.str.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.str.split('');
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentString}
   */ copy() {
        return new ContentString(this.str);
    }
    /**
   * @param {number} offset
   * @return {ContentString}
   */ splice(offset) {
        const right = new ContentString(this.str.slice(offset));
        this.str = this.str.slice(0, offset);
        // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248
        const firstCharCode = this.str.charCodeAt(offset - 1);
        if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {
            // Last character of the left split is the start of a surrogate utf16/ucs2 pair.
            // We don't support splitting of surrogate pairs because this may lead to invalid documents.
            // Replace the invalid character with a unicode replacement character (� / U+FFFD)
            this.str = this.str.slice(0, offset - 1) + '�';
            // replace right as well
            right.str = '�' + right.str.slice(1);
        }
        return right;
    }
    /**
   * @param {ContentString} right
   * @return {boolean}
   */ mergeWith(right) {
        this.str += right.str;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    /**
   * @return {number}
   */ getRef() {
        return 4;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentString}
 */ const readContentString = (decoder)=>new ContentString(decoder.readString());
/**
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}
 * @private
 */ const typeRefs = [
    readYArray,
    readYMap,
    readYText,
    readYXmlElement,
    readYXmlFragment,
    readYXmlHook,
    readYXmlText
];
const YArrayRefID = 0;
const YMapRefID = 1;
const YTextRefID = 2;
const YXmlElementRefID = 3;
const YXmlFragmentRefID = 4;
const YXmlHookRefID = 5;
const YXmlTextRefID = 6;
/**
 * @private
 */ class ContentType {
    /**
   * @param {AbstractType<any>} type
   */ constructor(type){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.type
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentType}
   */ copy() {
        return new ContentType(this.type._copy());
    }
    /**
   * @param {number} offset
   * @return {ContentType}
   */ splice(offset) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["methodUnimplemented"])();
    }
    /**
   * @param {ContentType} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        this.type._integrate(transaction.doc, item);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        let item = this.type._start;
        while(item !== null){
            if (!item.deleted) {
                item.delete(transaction);
            } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
                // This will be gc'd later and we want to merge it if possible
                // We try to merge all deleted items after each transaction,
                // but we have no knowledge about that this needs to be merged
                // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
                transaction._mergeStructs.push(item);
            }
            item = item.right;
        }
        this.type._map.forEach((item)=>{
            if (!item.deleted) {
                item.delete(transaction);
            } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
                // same as above
                transaction._mergeStructs.push(item);
            }
        });
        transaction.changed.delete(this.type);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {
        let item = this.type._start;
        while(item !== null){
            item.gc(store, true);
            item = item.right;
        }
        this.type._start = null;
        this.type._map.forEach(/** @param {Item | null} item */ (item)=>{
            while(item !== null){
                item.gc(store, true);
                item = item.left;
            }
        });
        this.type._map = new Map();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        this.type._write(encoder);
    }
    /**
   * @return {number}
   */ getRef() {
        return 7;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentType}
 */ const readContentType = (decoder)=>new ContentType(typeRefs[decoder.readTypeRef()](decoder));
/**
 * @todo This should return several items
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {{item:Item, diff:number}}
 */ const followRedone = (store, id)=>{
    /**
   * @type {ID|null}
   */ let nextID = id;
    let diff = 0;
    let item;
    do {
        if (diff > 0) {
            nextID = createID(nextID.client, nextID.clock + diff);
        }
        item = getItem(store, nextID);
        diff = nextID.clock - item.id.clock;
        nextID = item.redone;
    }while (nextID !== null && item instanceof Item)
    return {
        item,
        diff
    };
};
/**
 * Make sure that neither item nor any of its parents is ever deleted.
 *
 * This property does not persist when storing it into a database or when
 * sending it to other peers
 *
 * @param {Item|null} item
 * @param {boolean} keep
 */ const keepItem = (item, keep)=>{
    while(item !== null && item.keep !== keep){
        item.keep = keep;
        item = /** @type {AbstractType<any>} */ item.parent._item;
    }
};
/**
 * Split leftItem into two items
 * @param {Transaction} transaction
 * @param {Item} leftItem
 * @param {number} diff
 * @return {Item}
 *
 * @function
 * @private
 */ const splitItem = (transaction, leftItem, diff)=>{
    // create rightItem
    const { client, clock } = leftItem.id;
    const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    if (leftItem.deleted) {
        rightItem.markDeleted();
    }
    if (leftItem.keep) {
        rightItem.keep = true;
    }
    if (leftItem.redone !== null) {
        rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    }
    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)
    leftItem.right = rightItem;
    // update right
    if (rightItem.right !== null) {
        rightItem.right.left = rightItem;
    }
    // right is more specific.
    transaction._mergeStructs.push(rightItem);
    // update parent._map
    if (rightItem.parentSub !== null && rightItem.right === null) {
        /** @type {AbstractType<any>} */ rightItem.parent._map.set(rightItem.parentSub, rightItem);
    }
    leftItem.length = diff;
    return rightItem;
};
/**
 * @param {Array<StackItem>} stack
 * @param {ID} id
 */ const isDeletedByUndoStack = (stack, id)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["some"])(stack, /** @param {StackItem} s */ (s)=>isDeleted(s.deletions, id));
/**
 * Redoes the effect of this operation.
 *
 * @param {Transaction} transaction The Yjs instance.
 * @param {Item} item
 * @param {Set<Item>} redoitems
 * @param {DeleteSet} itemsToDelete
 * @param {boolean} ignoreRemoteMapChanges
 * @param {import('../utils/UndoManager.js').UndoManager} um
 *
 * @return {Item|null}
 *
 * @private
 */ const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um)=>{
    const doc = transaction.doc;
    const store = doc.store;
    const ownClientID = doc.clientID;
    const redone = item.redone;
    if (redone !== null) {
        return getItemCleanStart(transaction, redone);
    }
    let parentItem = /** @type {AbstractType<any>} */ item.parent._item;
    /**
   * @type {Item|null}
   */ let left = null;
    /**
   * @type {Item|null}
   */ let right;
    // make sure that parent is redone
    if (parentItem !== null && parentItem.deleted === true) {
        // try to undo parent if it will be undone anyway
        if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
            return null;
        }
        while(parentItem.redone !== null){
            parentItem = getItemCleanStart(transaction, parentItem.redone);
        }
    }
    const parentType = parentItem === null ? item.parent : /** @type {ContentType} */ parentItem.content.type;
    if (item.parentSub === null) {
        // Is an array item. Insert at the old position
        left = item.left;
        right = item;
        // find next cloned_redo items
        while(left !== null){
            /**
       * @type {Item|null}
       */ let leftTrace = left;
            // trace redone until parent matches
            while(leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item !== parentItem){
                leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
            }
            if (leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item === parentItem) {
                left = leftTrace;
                break;
            }
            left = left.left;
        }
        while(right !== null){
            /**
       * @type {Item|null}
       */ let rightTrace = right;
            // trace redone until parent matches
            while(rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item !== parentItem){
                rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
            }
            if (rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item === parentItem) {
                right = rightTrace;
                break;
            }
            right = right.right;
        }
    } else {
        right = null;
        if (item.right && !ignoreRemoteMapChanges) {
            left = item;
            // Iterate right while right is in itemsToDelete
            // If it is intended to delete right while item is redone, we can expect that item should replace right.
            while(left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))){
                left = left.right;
                // follow redone
                while(left.redone)left = getItemCleanStart(transaction, left.redone);
            }
            if (left && left.right !== null) {
                // It is not possible to redo this item because it conflicts with a
                // change from another client
                return null;
            }
        } else {
            left = parentType._map.get(item.parentSub) || null;
        }
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
};
/**
 * Abstract class that represents any content.
 */ class Item extends AbstractStruct {
    /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */ constructor(id, left, origin, right, rightOrigin, parent, parentSub, content){
        super(id, content.getLength());
        /**
     * The item that was originally to the left of this item.
     * @type {ID | null}
     */ this.origin = origin;
        /**
     * The item that is currently to the left of this item.
     * @type {Item | null}
     */ this.left = left;
        /**
     * The item that is currently to the right of this item.
     * @type {Item | null}
     */ this.right = right;
        /**
     * The item that was originally to the right of this item.
     * @type {ID | null}
     */ this.rightOrigin = rightOrigin;
        /**
     * @type {AbstractType<any>|ID|null}
     */ this.parent = parent;
        /**
     * If the parent refers to this item with some kind of key (e.g. YMap, the
     * key is specified here. The key is then used to refer to the list in which
     * to insert this item. If `parentSub = null` type._start is the list in
     * which to insert to. Otherwise it is `parent._map`.
     * @type {String | null}
     */ this.parentSub = parentSub;
        /**
     * If this type's effect is redone this type refers to the type that undid
     * this operation.
     * @type {ID | null}
     */ this.redone = null;
        /**
     * @type {AbstractContent}
     */ this.content = content;
        /**
     * bit1: keep
     * bit2: countable
     * bit3: deleted
     * bit4: mark - mark node as fast-search-marker
     * @type {number} byte
     */ this.info = this.content.isCountable() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT2"] : 0;
    }
    /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */ set marker(isMarked) {
        if ((this.info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT4"]) > 0 !== isMarked) {
            this.info ^= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT4"];
        }
    }
    get marker() {
        return (this.info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT4"]) > 0;
    }
    /**
   * If true, do not garbage collect this Item.
   */ get keep() {
        return (this.info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT1"]) > 0;
    }
    set keep(doKeep) {
        if (this.keep !== doKeep) {
            this.info ^= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT1"];
        }
    }
    get countable() {
        return (this.info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT2"]) > 0;
    }
    /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */ get deleted() {
        return (this.info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT3"]) > 0;
    }
    set deleted(doDelete) {
        if (this.deleted !== doDelete) {
            this.info ^= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT3"];
        }
    }
    markDeleted() {
        this.info |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT3"];
    }
    /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
            return this.origin.client;
        }
        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
            return this.rightOrigin.client;
        }
        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
            return this.parent.client;
        }
        // We have all missing ids, now find the items
        if (this.origin) {
            this.left = getItemCleanEnd(transaction, store, this.origin);
            this.origin = this.left.lastId;
        }
        if (this.rightOrigin) {
            this.right = getItemCleanStart(transaction, this.rightOrigin);
            this.rightOrigin = this.right.id;
        }
        if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
            this.parent = null;
        } else if (!this.parent) {
            // only set parent if this shouldn't be garbage collected
            if (this.left && this.left.constructor === Item) {
                this.parent = this.left.parent;
                this.parentSub = this.left.parentSub;
            } else if (this.right && this.right.constructor === Item) {
                this.parent = this.right.parent;
                this.parentSub = this.right.parentSub;
            }
        } else if (this.parent.constructor === ID) {
            const parentItem = getItem(store, this.parent);
            if (parentItem.constructor === GC) {
                this.parent = null;
            } else {
                this.parent = /** @type {ContentType} */ parentItem.content.type;
            }
        }
        return null;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
            this.origin = this.left.lastId;
            this.content = this.content.splice(offset);
            this.length -= offset;
        }
        if (this.parent) {
            if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
                /**
         * @type {Item|null}
         */ let left = this.left;
                /**
         * @type {Item|null}
         */ let o;
                // set o to the first conflicting item
                if (left !== null) {
                    o = left.right;
                } else if (this.parentSub !== null) {
                    o = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(o !== null && o.left !== null){
                        o = o.left;
                    }
                } else {
                    o = /** @type {AbstractType<any>} */ this.parent._start;
                }
                // TODO: use something like DeleteSet here (a tree implementation would be best)
                // @todo use global set definitions
                /**
         * @type {Set<Item>}
         */ const conflictingItems = new Set();
                /**
         * @type {Set<Item>}
         */ const itemsBeforeOrigin = new Set();
                // Let c in conflictingItems, b in itemsBeforeOrigin
                // ***{origin}bbbb{this}{c,b}{c,b}{o}***
                // Note that conflictingItems is a subset of itemsBeforeOrigin
                while(o !== null && o !== this.right){
                    itemsBeforeOrigin.add(o);
                    conflictingItems.add(o);
                    if (compareIDs(this.origin, o.origin)) {
                        // case 1
                        if (o.id.client < this.id.client) {
                            left = o;
                            conflictingItems.clear();
                        } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
                            break;
                        } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
                    } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
                        // case 2
                        if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                            left = o;
                            conflictingItems.clear();
                        }
                    } else {
                        break;
                    }
                    o = o.right;
                }
                this.left = left;
            }
            // reconnect left/right + update parent map/start if necessary
            if (this.left !== null) {
                const right = this.left.right;
                this.right = right;
                this.left.right = this;
            } else {
                let r;
                if (this.parentSub !== null) {
                    r = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(r !== null && r.left !== null){
                        r = r.left;
                    }
                } else {
                    r = /** @type {AbstractType<any>} */ this.parent._start; /** @type {AbstractType<any>} */ 
                    this.parent._start = this;
                }
                this.right = r;
            }
            if (this.right !== null) {
                this.right.left = this;
            } else if (this.parentSub !== null) {
                // set as current parent value if right === null and this is parentSub
                /** @type {AbstractType<any>} */ this.parent._map.set(this.parentSub, this);
                if (this.left !== null) {
                    // this is the current attribute value of parent. delete right
                    this.left.delete(transaction);
                }
            }
            // adjust length of parent
            if (this.parentSub === null && this.countable && !this.deleted) {
                /** @type {AbstractType<any>} */ this.parent._length += this.length;
            }
            addStruct(transaction.doc.store, this);
            this.content.integrate(transaction, this);
            // add parent to transaction.changed
            addChangedTypeToTransaction(transaction, this.parent, this.parentSub);
            if (/** @type {AbstractType<any>} */ this.parent._item !== null && /** @type {AbstractType<any>} */ this.parent._item.deleted || this.parentSub !== null && this.right !== null) {
                // delete if parent is deleted or if this is not the current attribute value of parent
                this.delete(transaction);
            }
        } else {
            // parent is not defined. Integrate GC struct instead
            new GC(this.id, this.length).integrate(transaction, 0);
        }
    }
    /**
   * Returns the next non-deleted item
   */ get next() {
        let n = this.right;
        while(n !== null && n.deleted){
            n = n.right;
        }
        return n;
    }
    /**
   * Returns the previous non-deleted item
   */ get prev() {
        let n = this.left;
        while(n !== null && n.deleted){
            n = n.left;
        }
        return n;
    }
    /**
   * Computes the last content address of this Item.
   */ get lastId() {
        // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
        return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
            const searchMarker = /** @type {AbstractType<any>} */ this.parent._searchMarker;
            if (searchMarker) {
                searchMarker.forEach((marker)=>{
                    if (marker.p === right) {
                        // right is going to be "forgotten" so we need to update the marker
                        marker.p = this;
                        // adjust marker index
                        if (!this.deleted && this.countable) {
                            marker.index -= this.length;
                        }
                    }
                });
            }
            if (right.keep) {
                this.keep = true;
            }
            this.right = right.right;
            if (this.right !== null) {
                this.right.left = this;
            }
            this.length += right.length;
            return true;
        }
        return false;
    }
    /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (!this.deleted) {
            const parent = this.parent;
            // adjust the length of parent
            if (this.countable && this.parentSub === null) {
                parent._length -= this.length;
            }
            this.markDeleted();
            addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
            addChangedTypeToTransaction(transaction, parent, this.parentSub);
            this.content.delete(transaction);
        }
    }
    /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */ gc(store, parentGCd) {
        if (!this.deleted) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
        }
        this.content.gc(store);
        if (parentGCd) {
            replaceStruct(store, this, new GC(this.id, this.length));
        } else {
            this.content = new ContentDeleted(this.length);
        }
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */ write(encoder, offset) {
        const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
        const rightOrigin = this.rightOrigin;
        const parentSub = this.parentSub;
        const info = this.content.getRef() & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS5"] | (origin === null ? 0 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT8"]) | // origin is defined
        (rightOrigin === null ? 0 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT7"]) | // right origin is defined
        (parentSub === null ? 0 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BIT6"]); // parentSub is non-null
        encoder.writeInfo(info);
        if (origin !== null) {
            encoder.writeLeftID(origin);
        }
        if (rightOrigin !== null) {
            encoder.writeRightID(rightOrigin);
        }
        if (origin === null && rightOrigin === null) {
            const parent = this.parent;
            if (parent._item !== undefined) {
                const parentItem = parent._item;
                if (parentItem === null) {
                    // parent type on y._map
                    // find the correct key
                    const ykey = findRootTypeKey(parent);
                    encoder.writeParentInfo(true); // write parentYKey
                    encoder.writeString(ykey);
                } else {
                    encoder.writeParentInfo(false); // write parent id
                    encoder.writeLeftID(parentItem.id);
                }
            } else if (parent.constructor === String) {
                encoder.writeParentInfo(true); // write parentYKey
                encoder.writeString(parent);
            } else if (parent.constructor === ID) {
                encoder.writeParentInfo(false); // write parent id
                encoder.writeLeftID(parent);
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
            }
            if (parentSub !== null) {
                encoder.writeString(parentSub);
            }
        }
        this.content.write(encoder, offset);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @param {number} info
 */ const readItemContent = (decoder, info)=>contentRefs[info & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$binary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITS5"]](decoder);
/**
 * A lookup map for reading Item content.
 *
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}
 */ const contentRefs = [
    ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
    },
    readContentDeleted,
    readContentJSON,
    readContentBinary,
    readContentString,
    readContentEmbed,
    readContentFormat,
    readContentType,
    readContentAny,
    readContentDoc,
    ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
    } // 10 - Skip is not ItemContent
];
const structSkipRefNumber = 10;
/**
 * @private
 */ class Skip extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {Skip} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) {
            return false;
        }
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        // skip structs cannot be integrated
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unexpectedCase"])();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structSkipRefNumber);
        // write as VarUint because Skips can't make use of predictable length-encoding
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder.restEncoder, this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
/** eslint-env browser */ const glo = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
const importIdentifier = '__ $YJS$ __';
if (glo[importIdentifier] === true) {
    /**
   * Dear reader of this message. Please take this seriously.
   *
   * If you see this message, make sure that you only import one version of Yjs. In many cases,
   * your package manager installs two versions of Yjs that are used by different packages within your project.
   * Another reason for this message is that some parts of your project use the commonjs version of Yjs
   * and others use the EcmaScript version of Yjs.
   *
   * This often leads to issues that are hard to debug. We often need to perform constructor checks,
   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to
   * do the constructor checks anymore - which might break the CRDT algorithm.
   *
   * https://github.com/yjs/yjs/issues/438
   */ console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');
}
glo[importIdentifier] = true;
;
 //# sourceMappingURL=yjs.mjs.map
}}),
"[project]/node_modules/y-protocols/sync.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @module sync-protocol
 */ __turbopack_context__.s({
    "messageYjsSyncStep1": (()=>messageYjsSyncStep1),
    "messageYjsSyncStep2": (()=>messageYjsSyncStep2),
    "messageYjsUpdate": (()=>messageYjsUpdate),
    "readSyncMessage": (()=>readSyncMessage),
    "readSyncStep1": (()=>readSyncStep1),
    "readSyncStep2": (()=>readSyncStep2),
    "readUpdate": (()=>readUpdate),
    "writeSyncStep1": (()=>writeSyncStep1),
    "writeSyncStep2": (()=>writeSyncStep2),
    "writeUpdate": (()=>writeUpdate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lib0/decoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yjs$2f$dist$2f$yjs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/yjs/dist/yjs.mjs [app-client] (ecmascript)");
;
;
;
const messageYjsSyncStep1 = 0;
const messageYjsSyncStep2 = 1;
const messageYjsUpdate = 2;
const writeSyncStep1 = (encoder, doc)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, messageYjsSyncStep1);
    const sv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yjs$2f$dist$2f$yjs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeStateVector"])(doc);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, sv);
};
const writeSyncStep2 = (encoder, doc, encodedStateVector)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, messageYjsSyncStep2);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yjs$2f$dist$2f$yjs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeStateAsUpdate"])(doc, encodedStateVector));
};
const readSyncStep1 = (decoder, encoder, doc)=>writeSyncStep2(encoder, doc, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder));
const readSyncStep2 = (decoder, doc, transactionOrigin)=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yjs$2f$dist$2f$yjs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyUpdate"])(doc, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint8Array"])(decoder), transactionOrigin);
    } catch (error) {
        // This catches errors that are thrown by event handlers
        console.error('Caught error while handling a Yjs update', error);
    }
};
const writeUpdate = (encoder, update)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint"])(encoder, messageYjsUpdate);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeVarUint8Array"])(encoder, update);
};
const readUpdate = readSyncStep2;
const readSyncMessage = (decoder, encoder, doc, transactionOrigin)=>{
    const messageType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lib0$2f$decoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVarUint"])(decoder);
    switch(messageType){
        case messageYjsSyncStep1:
            readSyncStep1(decoder, encoder, doc);
            break;
        case messageYjsSyncStep2:
            readSyncStep2(decoder, doc, transactionOrigin);
            break;
        case messageYjsUpdate:
            readUpdate(decoder, doc, transactionOrigin);
            break;
        default:
            throw new Error('Unknown message type');
    }
    return messageType;
};
}}),
"[project]/node_modules/@y-sweet/client/dist/main.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/main.ts
__turbopack_context__.s({
    "EVENT_CONNECTION_STATUS": (()=>EVENT_CONNECTION_STATUS),
    "EVENT_LOCAL_CHANGES": (()=>EVENT_LOCAL_CHANGES),
    "STATUS_CONNECTED": (()=>STATUS_CONNECTED),
    "STATUS_CONNECTING": (()=>STATUS_CONNECTING),
    "STATUS_ERROR": (()=>STATUS_ERROR),
    "STATUS_HANDSHAKING": (()=>STATUS_HANDSHAKING),
    "STATUS_OFFLINE": (()=>STATUS_OFFLINE),
    "YSweetProvider": (()=>YSweetProvider2),
    "createYjsProvider": (()=>createYjsProvider),
    "debuggerUrl": (()=>debuggerUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$sdk$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/sdk/dist/main.mjs [app-client] (ecmascript)");
// src/provider.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/y-protocols/awareness.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/y-protocols/sync.js [app-client] (ecmascript)");
;
// ../../node_modules/lib0/binary.js
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
// ../../node_modules/lib0/math.js
var floor = Math.floor;
var min = (a, b)=>a < b ? a : b;
var max = (a, b)=>a > b ? a : b;
var isNaN = Number.isNaN;
// ../../node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num)=>typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN2 = Number.isNaN;
var parseInt = Number.parseInt;
// ../../node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var _encodeUtf8Polyfill = (str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        buf[i] = /** @type {number} */ encodedString.codePointAt(i);
    }
    return buf;
};
var utf8TextEncoder = /** @type {TextEncoder} */ typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
var _encodeUtf8Native = (str)=>utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", {
    fatal: true,
    ignoreBOM: true
});
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
    utf8TextDecoder = null;
}
// ../../node_modules/lib0/error.js
var create = (s)=>new Error(s);
// ../../node_modules/lib0/encoding.js
var Encoder = class {
    constructor(){
        this.cpos = 0;
        this.cbuf = new Uint8Array(100);
        this.bufs = [];
    }
};
var createEncoder = ()=>new Encoder();
var length = (encoder)=>{
    let len = encoder.cpos;
    for(let i = 0; i < encoder.bufs.length; i++){
        len += encoder.bufs[i].length;
    }
    return len;
};
var toUint8Array = (encoder)=>{
    const uint8arr = new Uint8Array(length(encoder));
    let curPos = 0;
    for(let i = 0; i < encoder.bufs.length; i++){
        const d = encoder.bufs[i];
        uint8arr.set(d, curPos);
        curPos += d.length;
    }
    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
};
var write = (encoder, num)=>{
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
        encoder.bufs.push(encoder.cbuf);
        encoder.cbuf = new Uint8Array(bufferLen * 2);
        encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
};
var writeVarUint = (encoder, num)=>{
    while(num > BITS7){
        write(encoder, BIT8 | BITS7 & num);
        num = floor(num / 128);
    }
    write(encoder, BITS7 & num);
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str)=>{
    if (str.length < _maxStrBSize) {
        const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
        writeVarUint(encoder, written);
        for(let i = 0; i < written; i++){
            write(encoder, _strBuffer[i]);
        }
    } else {
        writeVarUint8Array(encoder, encodeUtf8(str));
    }
};
var _writeVarStringPolyfill = (encoder, str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for(let i = 0; i < len; i++){
        write(encoder, /** @type {number} */ encodedString.codePointAt(i));
    }
};
var writeVarString = utf8TextEncoder && /** @type {any} */ utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array)=>{
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
        encoder.bufs.push(encoder.cbuf);
        encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
        encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
        encoder.cpos = rightCopyLen;
    }
};
var writeVarUint8Array = (encoder, uint8Array)=>{
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
};
var floatTestBed = new DataView(new ArrayBuffer(4));
// ../../node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create("Unexpected end of array");
var errorIntegerOutOfRange = create("Integer out of Range");
var Decoder = class {
    /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */ constructor(uint8Array){
        this.arr = uint8Array;
        this.pos = 0;
    }
};
var createDecoder = (uint8Array)=>new Decoder(uint8Array);
var readUint8Array = (decoder, len)=>{
    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view;
};
var readVarUint8Array = (decoder)=>readUint8Array(decoder, readVarUint(decoder));
var readVarUint = (decoder)=>{
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        const r = decoder.arr[decoder.pos++];
        num = num + (r & BITS7) * mult;
        mult *= 128;
        if (r < BIT8) {
            return num;
        }
        if (num > MAX_SAFE_INTEGER) {
            throw errorIntegerOutOfRange;
        }
    }
    throw errorUnexpectedEndOfArray;
};
;
;
// src/ws-status.ts
var EVENT_STATUS = "status";
var EVENT_SYNC = "sync";
var EVENT_CONNECTION_CLOSE = "connection-close";
var EVENT_CONNECTION_ERROR = "connection-error";
var EVENT_SYNCED = "synced";
var WEBSOCKET_STATUS_CONNECTED = "connected";
var WEBSOCKET_STATUS_DISCONNECTED = "disconnected";
var WEBSOCKET_STATUS_CONNECTING = "connecting";
function translateStatus(status) {
    if (status === STATUS_CONNECTED) {
        return WEBSOCKET_STATUS_CONNECTED;
    } else if ([
        STATUS_CONNECTING,
        STATUS_HANDSHAKING
    ].includes(status)) {
        return WEBSOCKET_STATUS_CONNECTING;
    } else {
        return WEBSOCKET_STATUS_DISCONNECTED;
    }
}
var WebSocketCompatLayer = class {
    constructor(provider){
        this.provider = provider;
        this.lastStatus = WEBSOCKET_STATUS_DISCONNECTED;
        this.lastSyncStatus = false;
        this.provider.on(EVENT_CONNECTION_STATUS, this.updateStatus.bind(this));
    }
    updateStatus(status) {
        const newStatus = translateStatus(status);
        const syncStatus = status === STATUS_CONNECTED;
        if (this.lastSyncStatus !== syncStatus) {
            this.lastSyncStatus = syncStatus;
            this.provider.emit(EVENT_SYNC, syncStatus);
            this.provider.emit(EVENT_SYNCED, syncStatus);
        }
        if (this.lastStatus !== newStatus) {
            this.lastStatus = newStatus;
            this.provider.emit(EVENT_STATUS, {
                status: newStatus
            });
        }
    }
};
// src/provider.ts
var MESSAGE_SYNC = 0;
var MESSAGE_QUERY_AWARENESS = 3;
var MESSAGE_AWARENESS = 1;
var MESSAGE_SYNC_STATUS = 102;
var RETRIES_BEFORE_TOKEN_REFRESH = 3;
var DELAY_MS_BEFORE_RECONNECT = 500;
var DELAY_MS_BEFORE_RETRY_TOKEN_REFRESH = 3e3;
var EVENT_LOCAL_CHANGES = "local-changes";
var EVENT_CONNECTION_STATUS = "connection-status";
var STATUS_OFFLINE = "offline";
var STATUS_CONNECTING = "connecting";
var STATUS_ERROR = "error";
var STATUS_HANDSHAKING = "handshaking";
var STATUS_CONNECTED = "connected";
async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
async function getClientToken(authEndpoint, roomname) {
    if (typeof authEndpoint === "function") {
        return await authEndpoint();
    }
    const body = JSON.stringify({
        docId: roomname
    });
    const res = await fetch(authEndpoint, {
        method: "POST",
        body,
        headers: {
            "Content-Type": "application/json"
        }
    });
    if (!res.ok) {
        throw new Error(`Failed to get client token: ${res.status} ${res.statusText}`);
    }
    const clientToken = await res.json();
    if (clientToken.docId !== roomname) {
        throw new Error(`Client token docId does not match roomname: ${clientToken.docId} !== ${roomname}`);
    }
    return clientToken;
}
var YSweetProvider2 = class {
    constructor(authEndpoint, docId, doc, extraOptions = {}){
        this.authEndpoint = authEndpoint;
        this.docId = docId;
        this.doc = doc;
        /** Current client token. */ this.clientToken = null;
        /** Whether the local document has unsynced changes. */ this.hasLocalChanges = true;
        /** Connection status. */ this.status = STATUS_OFFLINE;
        this.websocket = null;
        this.listeners = /* @__PURE__ */ new Map();
        this.lastSyncSent = 0;
        this.lastSyncAcked = -1;
        /** Whether a (re)connect loop is currently running. This acts as a lock to prevent two concurrent connect loops. */ this.isConnecting = false;
        if (extraOptions.initialClientToken) {
            this.clientToken = extraOptions.initialClientToken;
        }
        new WebSocketCompatLayer(this);
        this.awareness = extraOptions.awareness ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Awareness"](doc);
        this.awareness.on("update", this.handleAwarenessUpdate.bind(this));
        this.WebSocketPolyfill = extraOptions.WebSocketPolyfill || WebSocket;
        doc.on("update", this.update.bind(this));
        if (extraOptions.connect !== false) {
            this.connect();
        }
    }
    send(message) {
        if (this.websocket?.readyState === this.WebSocketPolyfill.OPEN) {
            this.websocket.send(message);
        }
    }
    updateSyncedState() {
        let hasLocalChanges = this.lastSyncAcked !== this.lastSyncSent;
        if (hasLocalChanges === this.hasLocalChanges) {
            return;
        }
        this.hasLocalChanges = hasLocalChanges;
        this.emit(EVENT_LOCAL_CHANGES, hasLocalChanges);
    }
    setStatus(status) {
        if (this.status === status) {
            return;
        }
        this.status = status;
        this.emit(EVENT_CONNECTION_STATUS, status);
    }
    update(update, origin) {
        if (origin !== this) {
            const encoder = createEncoder();
            writeVarUint(encoder, MESSAGE_SYNC);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeUpdate"])(encoder, update);
            this.send(toUint8Array(encoder));
            this.checkSync();
        }
    }
    checkSync() {
        this.lastSyncSent += 1;
        const encoder = createEncoder();
        writeVarUint(encoder, MESSAGE_SYNC_STATUS);
        const versionEncoder = createEncoder();
        writeVarUint(versionEncoder, this.lastSyncSent);
        writeVarUint8Array(encoder, toUint8Array(versionEncoder));
        this.send(toUint8Array(encoder));
        this.updateSyncedState();
    }
    async ensureClientToken() {
        if (this.clientToken) {
            return this.clientToken;
        }
        if (typeof this.authEndpoint === "string") {
            this.clientToken = await getClientToken(this.authEndpoint, this.docId);
            return this.clientToken;
        } else {
            this.clientToken = await this.authEndpoint();
            return this.clientToken;
        }
    }
    /**
   * Attempts to connect to the websocket.
   * Returns a promise that resolves to true if the connection was successful, or false if the connection failed.
   */ attemptToConnect(clientToken) {
        let promise = new Promise((resolve)=>{
            let statusListener = (event)=>{
                if (event === STATUS_CONNECTED) {
                    this.off(EVENT_CONNECTION_STATUS, statusListener);
                    resolve(true);
                } else if (event === STATUS_ERROR) {
                    this.off(EVENT_CONNECTION_STATUS, statusListener);
                    resolve(false);
                }
            };
            this.on(EVENT_CONNECTION_STATUS, statusListener);
        });
        let url = this.generateUrl(clientToken);
        this.setStatus(STATUS_CONNECTING);
        const websocket = new (this.WebSocketPolyfill || WebSocket)(url);
        this.bindWebsocket(websocket);
        return promise;
    }
    async connect() {
        if (this.isConnecting) {
            console.warn("connect() called while a connect loop is already running.");
            return;
        }
        this.isConnecting = true;
        this.setStatus(STATUS_CONNECTING);
        while(![
            STATUS_OFFLINE,
            STATUS_CONNECTED
        ].includes(this.status)){
            this.setStatus(STATUS_CONNECTING);
            let clientToken;
            try {
                clientToken = await this.ensureClientToken();
            } catch (e) {
                console.warn("Failed to get client token", e);
                this.setStatus(STATUS_ERROR);
                await sleep(DELAY_MS_BEFORE_RETRY_TOKEN_REFRESH);
                continue;
            }
            for(let i = 0; i < RETRIES_BEFORE_TOKEN_REFRESH; i++){
                if (await this.attemptToConnect(clientToken)) {
                    break;
                }
                await sleep(DELAY_MS_BEFORE_RECONNECT);
            }
            this.clientToken = null;
        }
        this.isConnecting = false;
    }
    disconnect() {
        if (this.websocket) {
            this.websocket.close();
        }
        this.setStatus(STATUS_OFFLINE);
    }
    bindWebsocket(websocket) {
        if (this.websocket) {
            this.websocket.close();
            this.websocket.onopen = null;
            this.websocket.onmessage = null;
            this.websocket.onclose = null;
            this.websocket.onerror = null;
        }
        this.websocket = websocket;
        this.websocket.binaryType = "arraybuffer";
        this.websocket.onopen = this.websocketOpen.bind(this);
        this.websocket.onmessage = this.receiveMessage.bind(this);
        this.websocket.onclose = this.websocketClose.bind(this);
        this.websocket.onerror = this.websocketError.bind(this);
    }
    generateUrl(clientToken) {
        const url = clientToken.url + `/${clientToken.docId}`;
        if (clientToken.token) {
            return `${url}?token=${clientToken.token}`;
        }
        return url;
    }
    syncStep1() {
        const encoder = createEncoder();
        writeVarUint(encoder, MESSAGE_SYNC);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeSyncStep1"])(encoder, this.doc);
        this.send(toUint8Array(encoder));
    }
    receiveSyncMessage(decoder) {
        const encoder = createEncoder();
        writeVarUint(encoder, MESSAGE_SYNC);
        const syncMessageType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readSyncMessage"])(decoder, encoder, this.doc, this);
        if (syncMessageType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["messageYjsSyncStep2"]) {
            this.setStatus(STATUS_CONNECTED);
        }
        if (length(encoder) > 1) {
            this.send(toUint8Array(encoder));
        }
    }
    queryAwareness() {
        const encoder = createEncoder();
        writeVarUint(encoder, MESSAGE_QUERY_AWARENESS);
        writeVarUint8Array(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeAwarenessUpdate"])(this.awareness, Array.from(this.awareness.getStates().keys())));
        this.send(toUint8Array(encoder));
    }
    broadcastAwareness() {
        if (this.awareness.getLocalState() !== null) {
            const encoderAwarenessState = createEncoder();
            writeVarUint(encoderAwarenessState, MESSAGE_AWARENESS);
            writeVarUint8Array(encoderAwarenessState, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeAwarenessUpdate"])(this.awareness, [
                this.doc.clientID
            ]));
            this.send(toUint8Array(encoderAwarenessState));
        }
    }
    updateAwareness(decoder) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAwarenessUpdate"])(this.awareness, readVarUint8Array(decoder), this);
    }
    websocketOpen() {
        this.setStatus(STATUS_HANDSHAKING);
        this.syncStep1();
        this.checkSync();
        this.broadcastAwareness();
    }
    receiveMessage(event) {
        let message = new Uint8Array(event.data);
        const decoder = createDecoder(message);
        const messageType = readVarUint(decoder);
        switch(messageType){
            case MESSAGE_SYNC:
                this.receiveSyncMessage(decoder);
                break;
            case MESSAGE_AWARENESS:
                this.updateAwareness(decoder);
                break;
            case MESSAGE_QUERY_AWARENESS:
                this.queryAwareness();
                break;
            case MESSAGE_SYNC_STATUS:
                let lastSyncBytes = readVarUint8Array(decoder);
                let d2 = createDecoder(lastSyncBytes);
                this.lastSyncAcked = readVarUint(d2);
                this.updateSyncedState();
                break;
            default:
                break;
        }
    }
    websocketClose(event) {
        this.emit(EVENT_CONNECTION_CLOSE, event);
        this.setStatus(STATUS_ERROR);
        this.connect();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeAwarenessStates"])(this.awareness, Array.from(this.awareness.getStates().keys()).filter((client)=>client !== this.doc.clientID), this);
    }
    websocketError(event) {
        this.emit(EVENT_CONNECTION_ERROR, event);
        this.setStatus(STATUS_ERROR);
        this.connect();
    }
    emit(eventName, data = null) {
        const listeners = this.listeners.get(eventName) || /* @__PURE__ */ new Set();
        for (const listener of listeners){
            listener(data);
        }
    }
    handleAwarenessUpdate({ added, updated, removed }, _origin) {
        const changedClients = added.concat(updated).concat(removed);
        const encoder = createEncoder();
        writeVarUint(encoder, MESSAGE_AWARENESS);
        writeVarUint8Array(encoder, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeAwarenessUpdate"])(this.awareness, changedClients));
        this.websocket?.send(toUint8Array(encoder));
    }
    destroy() {
        if (this.websocket) {
            this.websocket.close();
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$y$2d$protocols$2f$awareness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeAwarenessStates"])(this.awareness, [
            this.doc.clientID
        ], "window unload");
    }
    _on(type, listener, once) {
        if (!this.listeners.has(type)) {
            this.listeners.set(type, /* @__PURE__ */ new Set());
        }
        if (once) {
            let listenerOnce = (d)=>{
                listener(d);
                this.listeners.get(type)?.delete(listenerOnce);
            };
            this.listeners.get(type)?.add(listenerOnce);
        } else {
            this.listeners.get(type)?.add(listener);
        }
    }
    on(type, listener) {
        this._on(type, listener);
    }
    once(type, listener) {
        this._on(type, listener, true);
    }
    off(type, listener) {
        const listeners = this.listeners.get(type);
        if (listeners) {
            listeners.delete(listener);
        }
    }
    /**
   * Whether the provider should attempt to connect.
   *
   * @deprecated use provider.status !== 'offline' instead, or call `provider.connect()` / `provider.disconnect()` to set.
   */ get shouldConnect() {
        return this.status !== STATUS_OFFLINE;
    }
    /**
   * Whether the underlying websocket is connected.
   *
   * @deprecated use provider.status === 'connected' || provider.status === 'handshaking' instead.
   */ get wsconnected() {
        return this.status === STATUS_CONNECTED || this.status === STATUS_HANDSHAKING;
    }
    /**
   * Whether the underlying websocket is connecting.
   *
   * @deprecated use provider.status === 'connecting' instead.
   */ get wsconnecting() {
        return this.status === STATUS_CONNECTING;
    }
    /**
   * Whether the document is synced. (For compatibility with y-websocket.)
   *
   * @deprecated use provider.status === 'connected' instead.
   * */ get synced() {
        return this.status === STATUS_CONNECTED;
    }
};
// src/main.ts
function createYjsProvider(doc, docId, authEndpoint, extraOptions = {}) {
    return new YSweetProvider2(authEndpoint, docId, doc, extraOptions);
}
function debuggerUrl(clientToken) {
    const payload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$sdk$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeClientToken"])(clientToken);
    return `https://debugger.y-sweet.dev/?payload=${payload}`;
}
;
 //# sourceMappingURL=main.mjs.map
}}),
"[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "YDocProvider": (()=>YDocProvider),
    "useArray": (()=>useArray),
    "useAwareness": (()=>useAwareness),
    "useConnectionStatus": (()=>useConnectionStatus),
    "useHasLocalChanges": (()=>useHasLocalChanges),
    "useMap": (()=>useMap),
    "useObserve": (()=>useObserve),
    "usePresence": (()=>usePresence),
    "usePresenceSetter": (()=>usePresenceSetter),
    "useText": (()=>useText),
    "useYDoc": (()=>useYDoc),
    "useYSweetDebugUrl": (()=>useYSweetDebugUrl),
    "useYjsProvider": (()=>useYjsProvider)
});
// src/main.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/client/dist/main.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yjs$2f$dist$2f$yjs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/yjs/dist/yjs.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
;
;
var YjsContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
function useYDoc(options) {
    const yjsCtx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(YjsContext);
    if (options?.hideDebuggerLink) {
        console.warn("The `hideDebuggerLink` option is deprecated and no longer used. Pass `showDebuggerLink={false}` to `YDocProvider` as a prop instead.");
    }
    if (!yjsCtx) {
        throw new Error("Yjs hooks must be used within a YDocProvider");
    }
    return yjsCtx.doc;
}
function useYSweetDebugUrl() {
    const yjsCtx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(YjsContext);
    if (!yjsCtx) {
        throw new Error("Yjs hooks must be used within a YDocProvider");
    }
    if (!yjsCtx.provider.clientToken) {
        return "";
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debuggerUrl"])(yjsCtx.provider.clientToken);
}
function useYjsProvider() {
    const yjsCtx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(YjsContext);
    if (!yjsCtx) {
        throw new Error("Yjs hooks must be used within a YDocProvider");
    }
    return yjsCtx.provider;
}
function useHasLocalChanges() {
    const yjsCtx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(YjsContext);
    if (!yjsCtx) {
        throw new Error("Yjs hooks must be used within a YDocProvider");
    }
    const [isSynced, setIsSynced] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(yjsCtx.provider.hasLocalChanges);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHasLocalChanges.useEffect": ()=>{
            const handleSync = {
                "useHasLocalChanges.useEffect.handleSync": ()=>{
                    setIsSynced(yjsCtx.provider.hasLocalChanges);
                }
            }["useHasLocalChanges.useEffect.handleSync"];
            yjsCtx.provider.on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EVENT_LOCAL_CHANGES"], handleSync);
            return ({
                "useHasLocalChanges.useEffect": ()=>{
                    yjsCtx.provider.off(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EVENT_LOCAL_CHANGES"], handleSync);
                }
            })["useHasLocalChanges.useEffect"];
        }
    }["useHasLocalChanges.useEffect"], [
        yjsCtx.provider
    ]);
    return isSynced;
}
function useConnectionStatus() {
    const yjsCtx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(YjsContext);
    if (!yjsCtx) {
        throw new Error("Yjs hooks must be used within a YDocProvider");
    }
    const [status, setStatus] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(yjsCtx.provider.status);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useConnectionStatus.useEffect": ()=>{
            const handleStatus = {
                "useConnectionStatus.useEffect.handleStatus": (status2)=>{
                    setStatus(status2);
                }
            }["useConnectionStatus.useEffect.handleStatus"];
            yjsCtx.provider.on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EVENT_CONNECTION_STATUS"], handleStatus);
            return ({
                "useConnectionStatus.useEffect": ()=>{
                    yjsCtx.provider.off(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EVENT_CONNECTION_STATUS"], handleStatus);
                }
            })["useConnectionStatus.useEffect"];
        }
    }["useConnectionStatus.useEffect"], [
        yjsCtx.provider
    ]);
    return status;
}
function useAwareness() {
    const yjsCtx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(YjsContext);
    if (!yjsCtx) {
        throw new Error("Yjs hooks must be used within a YDocProvider");
    }
    return yjsCtx.provider.awareness;
}
function usePresenceSetter() {
    const awareness = useAwareness();
    const setLocalPresence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "usePresenceSetter.useCallback[setLocalPresence]": (localState)=>{
            if (awareness) {
                awareness.setLocalState(localState);
            }
        }
    }["usePresenceSetter.useCallback[setLocalPresence]"], [
        awareness
    ]);
    return setLocalPresence;
}
function usePresence(options) {
    const awareness = useAwareness();
    const [presence, setPresence] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(/* @__PURE__ */ new Map());
    const includeSelf = options?.includeSelf || false;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "usePresence.useEffect": ()=>{
            if (awareness) {
                const callback = {
                    "usePresence.useEffect.callback": ()=>{
                        const map = /* @__PURE__ */ new Map();
                        awareness.getStates().forEach({
                            "usePresence.useEffect.callback": (state, clientID)=>{
                                if (!includeSelf && clientID === awareness.clientID) return;
                                if (Object.keys(state).length > 0) {
                                    map.set(clientID, state);
                                }
                            }
                        }["usePresence.useEffect.callback"]);
                        setPresence(map);
                    }
                }["usePresence.useEffect.callback"];
                awareness.on("change", callback);
                return ({
                    "usePresence.useEffect": ()=>{
                        awareness.off("change", callback);
                    }
                })["usePresence.useEffect"];
            }
        }
    }["usePresence.useEffect"], [
        awareness
    ]);
    return presence;
}
function YDocProvider(props) {
    const { children, docId, authEndpoint, initialClientToken } = props;
    const [ctx, setCtx] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "YDocProvider.useEffect": ()=>{
            let canceled = false;
            let provider = null;
            const doc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yjs$2f$dist$2f$yjs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Doc"]();
            ({
                "YDocProvider.useEffect": async ()=>{
                    provider = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createYjsProvider"])(doc, docId, authEndpoint, {
                        initialClientToken
                    });
                    if ((props.showDebuggerLink ?? true) && provider.clientToken) {
                        const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debuggerUrl"])(provider.clientToken);
                        console.log(`%cOpen this in Y-Sweet Debugger \u2B95 ${url}`, "font-size: 1.5em; display: block; padding: 10px;");
                        console.log("%cTo hide the debugger link, pass showDebuggerLink={false} to YDocProvider", "font-style: italic;");
                    }
                    if (canceled) {
                        provider.destroy();
                        return;
                    }
                    setCtx({
                        doc,
                        provider
                    });
                }
            })["YDocProvider.useEffect"]();
            return ({
                "YDocProvider.useEffect": ()=>{
                    canceled = true;
                    provider?.destroy();
                    doc.destroy();
                }
            })["YDocProvider.useEffect"];
        }
    }["YDocProvider.useEffect"], [
        docId
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "YDocProvider.useEffect": ()=>{
            if (props.setQueryParam) {
                const url = new URL(window.location.href);
                url.searchParams.set(props.setQueryParam, docId);
                window.history.replaceState({}, "", url.toString());
            }
        }
    }["YDocProvider.useEffect"], [
        props.setQueryParam,
        docId
    ]);
    if (ctx === null) return null;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(YjsContext.Provider, {
        value: ctx,
        children
    });
}
function useRedraw() {
    const [_, setRedraw] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(0);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRedraw.useCallback": ()=>setRedraw({
                "useRedraw.useCallback": (x)=>x + 1
            }["useRedraw.useCallback"])
    }["useRedraw.useCallback"], [
        setRedraw
    ]);
}
function useMap(name, objectOptions) {
    const doc = useYDoc();
    const map = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useMap.useMemo[map]": ()=>doc.getMap(name)
    }["useMap.useMemo[map]"], [
        doc,
        name
    ]);
    useObserve(map, objectOptions?.observe || "deep");
    return map;
}
function useArray(name, objectOptions) {
    const doc = useYDoc();
    const array = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useArray.useMemo[array]": ()=>doc.getArray(name)
    }["useArray.useMemo[array]"], [
        doc,
        name
    ]);
    useObserve(array, objectOptions?.observe || "deep");
    return array;
}
function useText(name, observerKind) {
    const doc = useYDoc();
    const text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useText.useMemo[text]": ()=>doc.getText(name)
    }["useText.useMemo[text]"], [
        doc,
        name
    ]);
    useObserve(text, observerKind?.observe || "deep");
    return text;
}
function useObserve(object, kind) {
    const redraw = useRedraw();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useObserve.useEffect": ()=>{
            if (kind === "deep") {
                object.observeDeep(redraw);
            } else if (kind === "shallow") {
                object.observe(redraw);
            }
            return ({
                "useObserve.useEffect": ()=>{
                    if (kind === "deep") {
                        object.unobserveDeep(redraw);
                    } else if (kind === "shallow") {
                        object.unobserve(redraw);
                    }
                }
            })["useObserve.useEffect"];
        }
    }["useObserve.useEffect"]);
}
;
 //# sourceMappingURL=main.mjs.map
}}),
"[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/client/dist/main.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "YDocProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["YDocProvider"]),
    "YSweetProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["YSweetProvider"]),
    "createYjsProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createYjsProvider"]),
    "debuggerUrl": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debuggerUrl"]),
    "useArray": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useArray"]),
    "useAwareness": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useAwareness"]),
    "useConnectionStatus": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useConnectionStatus"]),
    "useHasLocalChanges": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useHasLocalChanges"]),
    "useMap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useMap"]),
    "useObserve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useObserve"]),
    "usePresence": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["usePresence"]),
    "usePresenceSetter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["usePresenceSetter"]),
    "useText": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useText"]),
    "useYDoc": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useYDoc"]),
    "useYSweetDebugUrl": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useYSweetDebugUrl"]),
    "useYjsProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useYjsProvider"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$client$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/client/dist/main.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "YDocProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["YDocProvider"]),
    "YSweetProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["YSweetProvider"]),
    "createYjsProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createYjsProvider"]),
    "debuggerUrl": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["debuggerUrl"]),
    "useArray": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useArray"]),
    "useAwareness": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useAwareness"]),
    "useConnectionStatus": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useConnectionStatus"]),
    "useHasLocalChanges": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useHasLocalChanges"]),
    "useMap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useMap"]),
    "useObserve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useObserve"]),
    "usePresence": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["usePresence"]),
    "usePresenceSetter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["usePresenceSetter"]),
    "useText": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useText"]),
    "useYDoc": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useYDoc"]),
    "useYSweetDebugUrl": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useYSweetDebugUrl"]),
    "useYjsProvider": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["useYjsProvider"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$y$2d$sweet$2f$react$2f$dist$2f$main$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/@y-sweet/react/dist/main.mjs [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * A shared function, used on both client and server, to generate a SVG blur placeholder.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImageBlurSvg", {
    enumerable: true,
    get: function() {
        return getImageBlurSvg;
    }
});
function getImageBlurSvg(param) {
    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;
    const std = 20;
    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;
    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;
    const viewBox = svgWidth && svgHeight ? "viewBox='0 0 " + svgWidth + " " + svgHeight + "'" : '';
    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';
    return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + viewBox + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='" + std + "'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='" + std + "'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + preserveAspectRatio + "' style='filter: url(%23b);' href='" + blurDataURL + "'/%3E%3C/svg%3E";
} //# sourceMappingURL=image-blur-svg.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    VALID_LOADERS: null,
    imageConfigDefault: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function() {
        return imageConfigDefault;
    }
});
const VALID_LOADERS = [
    'default',
    'imgix',
    'cloudinary',
    'akamai',
    'custom'
];
const imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        16,
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: '/_next/image',
    loader: 'default',
    loaderFile: '',
    domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 60,
    formats: [
        'image/webp'
    ],
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: "script-src 'none'; frame-src 'none'; sandbox;",
    contentDispositionType: 'attachment',
    localPatterns: undefined,
    remotePatterns: [],
    qualities: undefined,
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImgProps", {
    enumerable: true,
    get: function() {
        return getImgProps;
    }
});
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _imageblursvg = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const VALID_LOADING_VALUES = [
    'lazy',
    'eager',
    undefined
];
// Object-fit values that are not valid background-size values
const INVALID_BACKGROUND_SIZE_VALUES = [
    '-moz-initial',
    'fill',
    'none',
    'scale-down',
    undefined
];
function isStaticRequire(src) {
    return src.default !== undefined;
}
function isStaticImageData(src) {
    return src.src !== undefined;
}
function isStaticImport(src) {
    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));
}
const allImgs = new Map();
let perfObserver;
function getInt(x) {
    if (typeof x === 'undefined') {
        return x;
    }
    if (typeof x === 'number') {
        return Number.isFinite(x) ? x : NaN;
    }
    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {
        return parseInt(x, 10);
    }
    return NaN;
}
function getWidths(param, width, sizes) {
    let { deviceSizes, allSizes } = param;
    if (sizes) {
        // Find all the "vw" percent sizes used in the sizes prop
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for(let match; match = viewportWidthRe.exec(sizes); match){
            percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
            const smallestRatio = Math.min(...percentSizes) * 0.01;
            return {
                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),
                kind: 'w'
            };
        }
        return {
            widths: allSizes,
            kind: 'w'
        };
    }
    if (typeof width !== 'number') {
        return {
            widths: deviceSizes,
            kind: 'w'
        };
    }
    const widths = [
        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and
        // > blue colors. Showing a 3x resolution image in the app vs a 2x
        // > resolution image will be visually the same, though the 3x image
        // > takes significantly more data. Even true 3x resolution screens are
        // > wasteful as the human eye cannot see that level of detail without
        // > something like a magnifying glass.
        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
        [
            width,
            width * 2 /*, width * 3*/ 
        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))
    ];
    return {
        widths,
        kind: 'x'
    };
}
function generateImgAttrs(param) {
    let { config, src, unoptimized, width, quality, sizes, loader } = param;
    if (unoptimized) {
        return {
            src,
            srcSet: undefined,
            sizes: undefined
        };
    }
    const { widths, kind } = getWidths(config, width, sizes);
    const last = widths.length - 1;
    return {
        sizes: !sizes && kind === 'w' ? '100vw' : sizes,
        srcSet: widths.map((w, i)=>loader({
                config,
                src,
                quality,
                width: w
            }) + " " + (kind === 'w' ? w : i + 1) + kind).join(', '),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
            config,
            src,
            quality,
            width: widths[last]
        })
    };
}
function getImgProps(param, _state) {
    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;
    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;
    let config;
    let c = imgConf || _imageconfig.imageConfigDefault;
    if ('allSizes' in c) {
        config = c;
    } else {
        var _c_qualities;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);
        config = {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }
    if (typeof defaultLoader === 'undefined') {
        throw Object.defineProperty(new Error('images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config'), "__NEXT_ERROR_CODE", {
            value: "E163",
            enumerable: false,
            configurable: true
        });
    }
    let loader = rest.loader || defaultLoader;
    // Remove property so it's not spread on <img> element
    delete rest.loader;
    delete rest.srcSet;
    // This special value indicates that the user
    // didn't define a "loader" prop or "loader" config.
    const isDefaultLoader = '__next_img_default' in loader;
    if (isDefaultLoader) {
        if (config.loader === 'custom') {
            throw Object.defineProperty(new Error('Image with src "' + src + '" is missing "loader" prop.' + "\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader"), "__NEXT_ERROR_CODE", {
                value: "E252",
                enumerable: false,
                configurable: true
            });
        }
    } else {
        // The user defined a "loader" prop or config.
        // Since the config object is internal only, we
        // must not pass it to the user-defined "loader".
        const customImageLoader = loader;
        loader = (obj)=>{
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
        };
    }
    if (layout) {
        if (layout === 'fill') {
            fill = true;
        }
        const layoutToStyle = {
            intrinsic: {
                maxWidth: '100%',
                height: 'auto'
            },
            responsive: {
                width: '100%',
                height: 'auto'
            }
        };
        const layoutToSizes = {
            responsive: '100vw',
            fill: '100vw'
        };
        const layoutStyle = layoutToStyle[layout];
        if (layoutStyle) {
            style = {
                ...style,
                ...layoutStyle
            };
        }
        const layoutSizes = layoutToSizes[layout];
        if (layoutSizes && !sizes) {
            sizes = layoutSizes;
        }
    }
    let staticSrc = '';
    let widthInt = getInt(width);
    let heightInt = getInt(height);
    let blurWidth;
    let blurHeight;
    if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
            throw Object.defineProperty(new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(staticImageData)), "__NEXT_ERROR_CODE", {
                value: "E460",
                enumerable: false,
                configurable: true
            });
        }
        if (!staticImageData.height || !staticImageData.width) {
            throw Object.defineProperty(new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(staticImageData)), "__NEXT_ERROR_CODE", {
                value: "E48",
                enumerable: false,
                configurable: true
            });
        }
        blurWidth = staticImageData.blurWidth;
        blurHeight = staticImageData.blurHeight;
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!fill) {
            if (!widthInt && !heightInt) {
                widthInt = staticImageData.width;
                heightInt = staticImageData.height;
            } else if (widthInt && !heightInt) {
                const ratio = widthInt / staticImageData.width;
                heightInt = Math.round(staticImageData.height * ratio);
            } else if (!widthInt && heightInt) {
                const ratio = heightInt / staticImageData.height;
                widthInt = Math.round(staticImageData.width * ratio);
            }
        }
    }
    src = typeof src === 'string' ? src : staticSrc;
    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');
    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {
        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
        unoptimized = true;
        isLazy = false;
    }
    if (config.unoptimized) {
        unoptimized = true;
    }
    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {
        // Special case to make svg serve as-is to avoid proxying
        // through the built-in Image Optimization API.
        unoptimized = true;
    }
    const qualityInt = getInt(quality);
    if ("TURBOPACK compile-time truthy", 1) {
        if (config.output === 'export' && isDefaultLoader && !unoptimized) {
            throw Object.defineProperty(new Error("Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\n  Possible solutions:\n    - Remove `{ output: 'export' }` and run \"next start\" to run server mode including the Image Optimization API.\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\n  Read more: https://nextjs.org/docs/messages/export-image-api"), "__NEXT_ERROR_CODE", {
                value: "E500",
                enumerable: false,
                configurable: true
            });
        }
        if (!src) {
            // React doesn't show the stack trace and there's
            // no `src` to help identify which image, so we
            // instead console.error(ref) during mount.
            unoptimized = true;
        } else {
            if (fill) {
                if (width) {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has both "width" and "fill" properties. Only one should be used.'), "__NEXT_ERROR_CODE", {
                        value: "E96",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (height) {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has both "height" and "fill" properties. Only one should be used.'), "__NEXT_ERROR_CODE", {
                        value: "E115",
                        enumerable: false,
                        configurable: true
                    });
                }
                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has both "fill" and "style.position" properties. Images with "fill" always use position absolute - it cannot be modified.'), "__NEXT_ERROR_CODE", {
                        value: "E216",
                        enumerable: false,
                        configurable: true
                    });
                }
                if ((style == null ? void 0 : style.width) && style.width !== '100%') {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has both "fill" and "style.width" properties. Images with "fill" always use width 100% - it cannot be modified.'), "__NEXT_ERROR_CODE", {
                        value: "E73",
                        enumerable: false,
                        configurable: true
                    });
                }
                if ((style == null ? void 0 : style.height) && style.height !== '100%') {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has both "fill" and "style.height" properties. Images with "fill" always use height 100% - it cannot be modified.'), "__NEXT_ERROR_CODE", {
                        value: "E404",
                        enumerable: false,
                        configurable: true
                    });
                }
            } else {
                if (typeof widthInt === 'undefined') {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" is missing required "width" property.'), "__NEXT_ERROR_CODE", {
                        value: "E451",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(widthInt)) {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "width" property. Expected a numeric value in pixels but received "' + width + '".'), "__NEXT_ERROR_CODE", {
                        value: "E66",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (typeof heightInt === 'undefined') {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" is missing required "height" property.'), "__NEXT_ERROR_CODE", {
                        value: "E397",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(heightInt)) {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "height" property. Expected a numeric value in pixels but received "' + height + '".'), "__NEXT_ERROR_CODE", {
                        value: "E444",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/^[\x00-\x20]/.test(src)) {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.'), "__NEXT_ERROR_CODE", {
                        value: "E176",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/[\x00-\x20]$/.test(src)) {
                    throw Object.defineProperty(new Error('Image with src "' + src + '" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.'), "__NEXT_ERROR_CODE", {
                        value: "E21",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!VALID_LOADING_VALUES.includes(loading)) {
            throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "loading" property. Provided "' + loading + '" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + "."), "__NEXT_ERROR_CODE", {
                value: "E357",
                enumerable: false,
                configurable: true
            });
        }
        if (priority && loading === 'lazy') {
            throw Object.defineProperty(new Error('Image with src "' + src + '" has both "priority" and "loading=\'lazy\'" properties. Only one should be used.'), "__NEXT_ERROR_CODE", {
                value: "E218",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {
            throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "placeholder" property "' + placeholder + '".'), "__NEXT_ERROR_CODE", {
                value: "E431",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty') {
            if (widthInt && heightInt && widthInt * heightInt < 1600) {
                (0, _warnonce.warnOnce)('Image with src "' + src + '" is smaller than 40x40. Consider removing the "placeholder" property to improve performance.');
            }
        }
        if (placeholder === 'blur' && !blurDataURL) {
            const VALID_BLUR_EXT = [
                'jpeg',
                'png',
                'webp',
                'avif'
            ] // should match next-image-loader
            ;
            throw Object.defineProperty(new Error('Image with src "' + src + '" has "placeholder=\'blur\'" property but is missing the "blurDataURL" property.\n        Possible solutions:\n          - Add a "blurDataURL" property, the contents should be a small Data URL to represent the image\n          - Change the "src" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\n          - Remove the "placeholder" property, effectively no blur effect\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'), "__NEXT_ERROR_CODE", {
                value: "E371",
                enumerable: false,
                configurable: true
            });
        }
        if ('ref' in rest) {
            (0, _warnonce.warnOnce)('Image with src "' + src + '" is using unsupported "ref" property. Consider using the "onLoad" property instead.');
        }
        if (!unoptimized && !isDefaultLoader) {
            const urlStr = loader({
                config,
                src,
                width: widthInt || 400,
                quality: qualityInt || 75
            });
            let url;
            try {
                url = new URL(urlStr);
            } catch (err) {}
            if (urlStr === src || url && url.pathname === src && !url.search) {
                (0, _warnonce.warnOnce)('Image with src "' + src + '" has a "loader" property that does not implement width. Please implement it or use the "unoptimized" property instead.' + "\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width");
            }
        }
        if (onLoadingComplete) {
            (0, _warnonce.warnOnce)('Image with src "' + src + '" is using deprecated "onLoadingComplete" property. Please use the "onLoad" property instead.');
        }
        for (const [legacyKey, legacyValue] of Object.entries({
            layout,
            objectFit,
            objectPosition,
            lazyBoundary,
            lazyRoot
        })){
            if (legacyValue) {
                (0, _warnonce.warnOnce)('Image with src "' + src + '" has legacy prop "' + legacyKey + '". Did you forget to run the codemod?' + "\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13");
            }
        }
        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {
            perfObserver = new PerformanceObserver((entryList)=>{
                for (const entry of entryList.getEntries()){
                    var _entry_element;
                    // @ts-ignore - missing "LargestContentfulPaint" class with "element" prop
                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';
                    const lcpImage = allImgs.get(imgSrc);
                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {
                        // https://web.dev/lcp/#measure-lcp-in-javascript
                        (0, _warnonce.warnOnce)('Image with src "' + lcpImage.src + '" was detected as the Largest Contentful Paint (LCP). Please add the "priority" property if this image is above the fold.' + "\nRead more: https://nextjs.org/docs/api-reference/next/image#priority");
                    }
                }
            });
            try {
                perfObserver.observe({
                    type: 'largest-contentful-paint',
                    buffered: true
                });
            } catch (err) {
                // Log error but don't crash the app
                console.error(err);
            }
        }
    }
    const imgStyle = Object.assign(fill ? {
        position: 'absolute',
        height: '100%',
        width: '100%',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        objectFit,
        objectPosition
    } : {}, showAltText ? {} : {
        color: 'transparent'
    }, style);
    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url("data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({
        widthInt,
        heightInt,
        blurWidth,
        blurHeight,
        blurDataURL: blurDataURL || '',
        objectFit: imgStyle.objectFit
    }) + '")' : 'url("' + placeholder + '")' // assume `data:image/`
     : null;
    const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(imgStyle.objectFit) ? imgStyle.objectFit : imgStyle.objectFit === 'fill' ? '100% 100%' // the background-size equivalent of `fill`
     : 'cover';
    let placeholderStyle = backgroundImage ? {
        backgroundSize,
        backgroundPosition: imgStyle.objectPosition || '50% 50%',
        backgroundRepeat: 'no-repeat',
        backgroundImage
    } : {};
    if ("TURBOPACK compile-time truthy", 1) {
        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {
            // During `next dev`, we don't want to generate blur placeholders with webpack
            // because it can delay starting the dev server. Instead, `next-image-loader.js`
            // will inline a special url to lazily generate the blur placeholder at request time.
            placeholderStyle.backgroundImage = 'url("' + blurDataURL + '")';
        }
    }
    const imgAttributes = generateImgAttrs({
        config,
        src,
        unoptimized,
        width: widthInt,
        quality: qualityInt,
        sizes,
        loader
    });
    if ("TURBOPACK compile-time truthy", 1) {
        if (typeof window !== 'undefined') {
            let fullUrl;
            try {
                fullUrl = new URL(imgAttributes.src);
            } catch (e) {
                fullUrl = new URL(imgAttributes.src, window.location.href);
            }
            allImgs.set(fullUrl.href, {
                src,
                priority,
                placeholder
            });
        }
    }
    const props = {
        ...rest,
        loading: isLazy ? 'lazy' : loading,
        fetchPriority,
        width: widthInt,
        height: heightInt,
        decoding,
        className,
        style: {
            ...imgStyle,
            ...placeholderStyle
        },
        sizes: imgAttributes.sizes,
        srcSet: imgAttributes.srcSet,
        src: overrideSrc || imgAttributes.src
    };
    const meta = {
        unoptimized,
        priority,
        placeholder,
        fill
    };
    return {
        props,
        meta
    };
} //# sourceMappingURL=get-img-props.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SideEffect;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const isServer = typeof window === 'undefined';
const useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;
const useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements, props));
        }
    }
    if (isServer) {
        var _headManager_mountedInstances;
        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            var _headManager_mountedInstances;
            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    var _headManager_mountedInstances;
                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    if (headManager) {
                        headManager._pendingUpdate = emitChange;
                    }
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    useClientOnlyEffect({
        "SideEffect.useClientOnlyEffect": ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
            return ({
                "SideEffect.useClientOnlyEffect": ()=>{
                    if (headManager && headManager._pendingUpdate) {
                        headManager._pendingUpdate();
                        headManager._pendingUpdate = null;
                    }
                }
            })["SideEffect.useClientOnlyEffect"];
        }
    }["SideEffect.useClientOnlyEffect"]);
    return null;
} //# sourceMappingURL=side-effect.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AmpStateContext", {
    enumerable: true,
    get: function() {
        return AmpStateContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const AmpStateContext = _react.default.createContext({});
if ("TURBOPACK compile-time truthy", 1) {
    AmpStateContext.displayName = 'AmpStateContext';
} //# sourceMappingURL=amp-context.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/amp-mode.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isInAmpMode", {
    enumerable: true,
    get: function() {
        return isInAmpMode;
    }
});
function isInAmpMode(param) {
    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;
    return ampFirst || hybrid && hasQuery;
} //# sourceMappingURL=amp-mode.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)"));
const _ampcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js [app-client] (ecmascript)");
const _headmanagercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)");
const _ampmode = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/amp-mode.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function defaultHead(inAmpMode) {
    if (inAmpMode === void 0) inAmpMode = false;
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset")
    ];
    if (!inAmpMode) {
        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport"));
    }
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements, props) {
    const { inAmpMode } = props;
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                const srcMessage = c.props['src'] ? '<script> tag with src="' + c.props['src'] + '"' : "inline <script>";
                (0, _warnonce.warnOnce)("Do not add <script> tags using next/head (see " + srcMessage + "). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component");
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="' + c.props['href'] + '"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head(param) {
    let { children } = param;
    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImageConfigContext", {
    enumerable: true,
    get: function() {
        return ImageConfigContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);
if ("TURBOPACK compile-time truthy", 1) {
    ImageConfigContext.displayName = 'ImageConfigContext';
} //# sourceMappingURL=image-config-context.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouterContext", {
    enumerable: true,
    get: function() {
        return RouterContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const RouterContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    RouterContext.displayName = 'RouterContext';
} //# sourceMappingURL=router-context.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
(()=>{
    "use strict";
    var t = {
        170: (t, e, u)=>{
            const n = u(510);
            const isWindows = ()=>{
                if (typeof navigator !== "undefined" && navigator.platform) {
                    const t = navigator.platform.toLowerCase();
                    return t === "win32" || t === "windows";
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32";
                }
                return false;
            };
            function picomatch(t, e, u = false) {
                if (e && (e.windows === null || e.windows === undefined)) {
                    e = {
                        ...e,
                        windows: isWindows()
                    };
                }
                return n(t, e, u);
            }
            Object.assign(picomatch, n);
            t.exports = picomatch;
        },
        154: (t)=>{
            const e = "\\\\/";
            const u = `[^${e}]`;
            const n = "\\.";
            const o = "\\+";
            const s = "\\?";
            const r = "\\/";
            const a = "(?=.)";
            const i = "[^/]";
            const c = `(?:${r}|$)`;
            const p = `(?:^|${r})`;
            const l = `${n}{1,2}${c}`;
            const f = `(?!${n})`;
            const A = `(?!${p}${l})`;
            const _ = `(?!${n}{0,1}${c})`;
            const R = `(?!${l})`;
            const E = `[^.${r}]`;
            const h = `${i}*?`;
            const g = "/";
            const b = {
                DOT_LITERAL: n,
                PLUS_LITERAL: o,
                QMARK_LITERAL: s,
                SLASH_LITERAL: r,
                ONE_CHAR: a,
                QMARK: i,
                END_ANCHOR: c,
                DOTS_SLASH: l,
                NO_DOT: f,
                NO_DOTS: A,
                NO_DOT_SLASH: _,
                NO_DOTS_SLASH: R,
                QMARK_NO_DOT: E,
                STAR: h,
                START_ANCHOR: p,
                SEP: g
            };
            const C = {
                ...b,
                SLASH_LITERAL: `[${e}]`,
                QMARK: u,
                STAR: `${u}*?`,
                DOTS_SLASH: `${n}{1,2}(?:[${e}]|$)`,
                NO_DOT: `(?!${n})`,
                NO_DOTS: `(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,
                NO_DOT_SLASH: `(?!${n}{0,1}(?:[${e}]|$))`,
                NO_DOTS_SLASH: `(?!${n}{1,2}(?:[${e}]|$))`,
                QMARK_NO_DOT: `[^.${e}]`,
                START_ANCHOR: `(?:^|[${e}])`,
                END_ANCHOR: `(?:[${e}]|$)`,
                SEP: "\\"
            };
            const y = {
                alnum: "a-zA-Z0-9",
                alpha: "a-zA-Z",
                ascii: "\\x00-\\x7F",
                blank: " \\t",
                cntrl: "\\x00-\\x1F\\x7F",
                digit: "0-9",
                graph: "\\x21-\\x7E",
                lower: "a-z",
                print: "\\x20-\\x7E ",
                punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
                space: " \\t\\r\\n\\v\\f",
                upper: "A-Z",
                word: "A-Za-z0-9_",
                xdigit: "A-Fa-f0-9"
            };
            t.exports = {
                MAX_LENGTH: 1024 * 64,
                POSIX_REGEX_SOURCE: y,
                REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
                REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
                REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
                REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
                REPLACEMENTS: {
                    "***": "*",
                    "**/**": "**",
                    "**/**/**": "**"
                },
                CHAR_0: 48,
                CHAR_9: 57,
                CHAR_UPPERCASE_A: 65,
                CHAR_LOWERCASE_A: 97,
                CHAR_UPPERCASE_Z: 90,
                CHAR_LOWERCASE_Z: 122,
                CHAR_LEFT_PARENTHESES: 40,
                CHAR_RIGHT_PARENTHESES: 41,
                CHAR_ASTERISK: 42,
                CHAR_AMPERSAND: 38,
                CHAR_AT: 64,
                CHAR_BACKWARD_SLASH: 92,
                CHAR_CARRIAGE_RETURN: 13,
                CHAR_CIRCUMFLEX_ACCENT: 94,
                CHAR_COLON: 58,
                CHAR_COMMA: 44,
                CHAR_DOT: 46,
                CHAR_DOUBLE_QUOTE: 34,
                CHAR_EQUAL: 61,
                CHAR_EXCLAMATION_MARK: 33,
                CHAR_FORM_FEED: 12,
                CHAR_FORWARD_SLASH: 47,
                CHAR_GRAVE_ACCENT: 96,
                CHAR_HASH: 35,
                CHAR_HYPHEN_MINUS: 45,
                CHAR_LEFT_ANGLE_BRACKET: 60,
                CHAR_LEFT_CURLY_BRACE: 123,
                CHAR_LEFT_SQUARE_BRACKET: 91,
                CHAR_LINE_FEED: 10,
                CHAR_NO_BREAK_SPACE: 160,
                CHAR_PERCENT: 37,
                CHAR_PLUS: 43,
                CHAR_QUESTION_MARK: 63,
                CHAR_RIGHT_ANGLE_BRACKET: 62,
                CHAR_RIGHT_CURLY_BRACE: 125,
                CHAR_RIGHT_SQUARE_BRACKET: 93,
                CHAR_SEMICOLON: 59,
                CHAR_SINGLE_QUOTE: 39,
                CHAR_SPACE: 32,
                CHAR_TAB: 9,
                CHAR_UNDERSCORE: 95,
                CHAR_VERTICAL_LINE: 124,
                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
                extglobChars (t) {
                    return {
                        "!": {
                            type: "negate",
                            open: "(?:(?!(?:",
                            close: `))${t.STAR})`
                        },
                        "?": {
                            type: "qmark",
                            open: "(?:",
                            close: ")?"
                        },
                        "+": {
                            type: "plus",
                            open: "(?:",
                            close: ")+"
                        },
                        "*": {
                            type: "star",
                            open: "(?:",
                            close: ")*"
                        },
                        "@": {
                            type: "at",
                            open: "(?:",
                            close: ")"
                        }
                    };
                },
                globChars (t) {
                    return t === true ? C : b;
                }
            };
        },
        697: (t, e, u)=>{
            const n = u(154);
            const o = u(96);
            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: r, REGEX_NON_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_BACKREF: i, REPLACEMENTS: c } = n;
            const expandRange = (t, e)=>{
                if (typeof e.expandRange === "function") {
                    return e.expandRange(...t, e);
                }
                t.sort();
                const u = `[${t.join("-")}]`;
                try {
                    new RegExp(u);
                } catch (e) {
                    return t.map((t)=>o.escapeRegex(t)).join("..");
                }
                return u;
            };
            const syntaxError = (t, e)=>`Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`;
            const parse = (t, e)=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected a string");
                }
                t = c[t] || t;
                const u = {
                    ...e
                };
                const p = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                let l = t.length;
                if (l > p) {
                    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`);
                }
                const f = {
                    type: "bos",
                    value: "",
                    output: u.prepend || ""
                };
                const A = [
                    f
                ];
                const _ = u.capture ? "" : "?:";
                const R = n.globChars(u.windows);
                const E = n.extglobChars(R);
                const { DOT_LITERAL: h, PLUS_LITERAL: g, SLASH_LITERAL: b, ONE_CHAR: C, DOTS_SLASH: y, NO_DOT: $, NO_DOT_SLASH: x, NO_DOTS_SLASH: S, QMARK: H, QMARK_NO_DOT: v, STAR: d, START_ANCHOR: L } = R;
                const globstar = (t)=>`(${_}(?:(?!${L}${t.dot ? y : h}).)*?)`;
                const T = u.dot ? "" : $;
                const O = u.dot ? H : v;
                let k = u.bash === true ? globstar(u) : d;
                if (u.capture) {
                    k = `(${k})`;
                }
                if (typeof u.noext === "boolean") {
                    u.noextglob = u.noext;
                }
                const m = {
                    input: t,
                    index: -1,
                    start: 0,
                    dot: u.dot === true,
                    consumed: "",
                    output: "",
                    prefix: "",
                    backtrack: false,
                    negated: false,
                    brackets: 0,
                    braces: 0,
                    parens: 0,
                    quotes: 0,
                    globstar: false,
                    tokens: A
                };
                t = o.removePrefix(t, m);
                l = t.length;
                const w = [];
                const N = [];
                const I = [];
                let B = f;
                let G;
                const eos = ()=>m.index === l - 1;
                const D = m.peek = (e = 1)=>t[m.index + e];
                const M = m.advance = ()=>t[++m.index] || "";
                const remaining = ()=>t.slice(m.index + 1);
                const consume = (t = "", e = 0)=>{
                    m.consumed += t;
                    m.index += e;
                };
                const append = (t)=>{
                    m.output += t.output != null ? t.output : t.value;
                    consume(t.value);
                };
                const negate = ()=>{
                    let t = 1;
                    while(D() === "!" && (D(2) !== "(" || D(3) === "?")){
                        M();
                        m.start++;
                        t++;
                    }
                    if (t % 2 === 0) {
                        return false;
                    }
                    m.negated = true;
                    m.start++;
                    return true;
                };
                const increment = (t)=>{
                    m[t]++;
                    I.push(t);
                };
                const decrement = (t)=>{
                    m[t]--;
                    I.pop();
                };
                const push = (t)=>{
                    if (B.type === "globstar") {
                        const e = m.braces > 0 && (t.type === "comma" || t.type === "brace");
                        const u = t.extglob === true || w.length && (t.type === "pipe" || t.type === "paren");
                        if (t.type !== "slash" && t.type !== "paren" && !e && !u) {
                            m.output = m.output.slice(0, -B.output.length);
                            B.type = "star";
                            B.value = "*";
                            B.output = k;
                            m.output += B.output;
                        }
                    }
                    if (w.length && t.type !== "paren") {
                        w[w.length - 1].inner += t.value;
                    }
                    if (t.value || t.output) append(t);
                    if (B && B.type === "text" && t.type === "text") {
                        B.output = (B.output || B.value) + t.value;
                        B.value += t.value;
                        return;
                    }
                    t.prev = B;
                    A.push(t);
                    B = t;
                };
                const extglobOpen = (t, e)=>{
                    const n = {
                        ...E[e],
                        conditions: 1,
                        inner: ""
                    };
                    n.prev = B;
                    n.parens = m.parens;
                    n.output = m.output;
                    const o = (u.capture ? "(" : "") + n.open;
                    increment("parens");
                    push({
                        type: t,
                        value: e,
                        output: m.output ? "" : C
                    });
                    push({
                        type: "paren",
                        extglob: true,
                        value: M(),
                        output: o
                    });
                    w.push(n);
                };
                const extglobClose = (t)=>{
                    let n = t.close + (u.capture ? ")" : "");
                    let o;
                    if (t.type === "negate") {
                        let s = k;
                        if (t.inner && t.inner.length > 1 && t.inner.includes("/")) {
                            s = globstar(u);
                        }
                        if (s !== k || eos() || /^\)+$/.test(remaining())) {
                            n = t.close = `)$))${s}`;
                        }
                        if (t.inner.includes("*") && (o = remaining()) && /^\.[^\\/.]+$/.test(o)) {
                            const u = parse(o, {
                                ...e,
                                fastpaths: false
                            }).output;
                            n = t.close = `)${u})${s})`;
                        }
                        if (t.prev.type === "bos") {
                            m.negatedExtglob = true;
                        }
                    }
                    push({
                        type: "paren",
                        extglob: true,
                        value: G,
                        output: n
                    });
                    decrement("parens");
                };
                if (u.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(t)) {
                    let n = false;
                    let s = t.replace(i, (t, e, u, o, s, r)=>{
                        if (o === "\\") {
                            n = true;
                            return t;
                        }
                        if (o === "?") {
                            if (e) {
                                return e + o + (s ? H.repeat(s.length) : "");
                            }
                            if (r === 0) {
                                return O + (s ? H.repeat(s.length) : "");
                            }
                            return H.repeat(u.length);
                        }
                        if (o === ".") {
                            return h.repeat(u.length);
                        }
                        if (o === "*") {
                            if (e) {
                                return e + o + (s ? k : "");
                            }
                            return k;
                        }
                        return e ? t : `\\${t}`;
                    });
                    if (n === true) {
                        if (u.unescape === true) {
                            s = s.replace(/\\/g, "");
                        } else {
                            s = s.replace(/\\+/g, (t)=>t.length % 2 === 0 ? "\\\\" : t ? "\\" : "");
                        }
                    }
                    if (s === t && u.contains === true) {
                        m.output = t;
                        return m;
                    }
                    m.output = o.wrapOutput(s, m, e);
                    return m;
                }
                while(!eos()){
                    G = M();
                    if (G === "\0") {
                        continue;
                    }
                    if (G === "\\") {
                        const t = D();
                        if (t === "/" && u.bash !== true) {
                            continue;
                        }
                        if (t === "." || t === ";") {
                            continue;
                        }
                        if (!t) {
                            G += "\\";
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                        const e = /^\\+/.exec(remaining());
                        let n = 0;
                        if (e && e[0].length > 2) {
                            n = e[0].length;
                            m.index += n;
                            if (n % 2 !== 0) {
                                G += "\\";
                            }
                        }
                        if (u.unescape === true) {
                            G = M();
                        } else {
                            G += M();
                        }
                        if (m.brackets === 0) {
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                    }
                    if (m.brackets > 0 && (G !== "]" || B.value === "[" || B.value === "[^")) {
                        if (u.posix !== false && G === ":") {
                            const t = B.value.slice(1);
                            if (t.includes("[")) {
                                B.posix = true;
                                if (t.includes(":")) {
                                    const t = B.value.lastIndexOf("[");
                                    const e = B.value.slice(0, t);
                                    const u = B.value.slice(t + 2);
                                    const n = r[u];
                                    if (n) {
                                        B.value = e + n;
                                        m.backtrack = true;
                                        M();
                                        if (!f.output && A.indexOf(B) === 1) {
                                            f.output = C;
                                        }
                                        continue;
                                    }
                                }
                            }
                        }
                        if (G === "[" && D() !== ":" || G === "-" && D() === "]") {
                            G = `\\${G}`;
                        }
                        if (G === "]" && (B.value === "[" || B.value === "[^")) {
                            G = `\\${G}`;
                        }
                        if (u.posix === true && G === "!" && B.value === "[") {
                            G = "^";
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (m.quotes === 1 && G !== '"') {
                        G = o.escapeRegex(G);
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (G === '"') {
                        m.quotes = m.quotes === 1 ? 0 : 1;
                        if (u.keepQuotes === true) {
                            push({
                                type: "text",
                                value: G
                            });
                        }
                        continue;
                    }
                    if (G === "(") {
                        increment("parens");
                        push({
                            type: "paren",
                            value: G
                        });
                        continue;
                    }
                    if (G === ")") {
                        if (m.parens === 0 && u.strictBrackets === true) {
                            throw new SyntaxError(syntaxError("opening", "("));
                        }
                        const t = w[w.length - 1];
                        if (t && m.parens === t.parens + 1) {
                            extglobClose(w.pop());
                            continue;
                        }
                        push({
                            type: "paren",
                            value: G,
                            output: m.parens ? ")" : "\\)"
                        });
                        decrement("parens");
                        continue;
                    }
                    if (G === "[") {
                        if (u.nobracket === true || !remaining().includes("]")) {
                            if (u.nobracket !== true && u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("closing", "]"));
                            }
                            G = `\\${G}`;
                        } else {
                            increment("brackets");
                        }
                        push({
                            type: "bracket",
                            value: G
                        });
                        continue;
                    }
                    if (G === "]") {
                        if (u.nobracket === true || B && B.type === "bracket" && B.value.length === 1) {
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        if (m.brackets === 0) {
                            if (u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("opening", "["));
                            }
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        decrement("brackets");
                        const t = B.value.slice(1);
                        if (B.posix !== true && t[0] === "^" && !t.includes("/")) {
                            G = `/${G}`;
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        if (u.literalBrackets === false || o.hasRegexChars(t)) {
                            continue;
                        }
                        const e = o.escapeRegex(B.value);
                        m.output = m.output.slice(0, -B.value.length);
                        if (u.literalBrackets === true) {
                            m.output += e;
                            B.value = e;
                            continue;
                        }
                        B.value = `(${_}${e}|${B.value})`;
                        m.output += B.value;
                        continue;
                    }
                    if (G === "{" && u.nobrace !== true) {
                        increment("braces");
                        const t = {
                            type: "brace",
                            value: G,
                            output: "(",
                            outputIndex: m.output.length,
                            tokensIndex: m.tokens.length
                        };
                        N.push(t);
                        push(t);
                        continue;
                    }
                    if (G === "}") {
                        const t = N[N.length - 1];
                        if (u.nobrace === true || !t) {
                            push({
                                type: "text",
                                value: G,
                                output: G
                            });
                            continue;
                        }
                        let e = ")";
                        if (t.dots === true) {
                            const t = A.slice();
                            const n = [];
                            for(let e = t.length - 1; e >= 0; e--){
                                A.pop();
                                if (t[e].type === "brace") {
                                    break;
                                }
                                if (t[e].type !== "dots") {
                                    n.unshift(t[e].value);
                                }
                            }
                            e = expandRange(n, u);
                            m.backtrack = true;
                        }
                        if (t.comma !== true && t.dots !== true) {
                            const u = m.output.slice(0, t.outputIndex);
                            const n = m.tokens.slice(t.tokensIndex);
                            t.value = t.output = "\\{";
                            G = e = "\\}";
                            m.output = u;
                            for (const t of n){
                                m.output += t.output || t.value;
                            }
                        }
                        push({
                            type: "brace",
                            value: G,
                            output: e
                        });
                        decrement("braces");
                        N.pop();
                        continue;
                    }
                    if (G === "|") {
                        if (w.length > 0) {
                            w[w.length - 1].conditions++;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G === ",") {
                        let t = G;
                        const e = N[N.length - 1];
                        if (e && I[I.length - 1] === "braces") {
                            e.comma = true;
                            t = "|";
                        }
                        push({
                            type: "comma",
                            value: G,
                            output: t
                        });
                        continue;
                    }
                    if (G === "/") {
                        if (B.type === "dot" && m.index === m.start + 1) {
                            m.start = m.index + 1;
                            m.consumed = "";
                            m.output = "";
                            A.pop();
                            B = f;
                            continue;
                        }
                        push({
                            type: "slash",
                            value: G,
                            output: b
                        });
                        continue;
                    }
                    if (G === ".") {
                        if (m.braces > 0 && B.type === "dot") {
                            if (B.value === ".") B.output = h;
                            const t = N[N.length - 1];
                            B.type = "dots";
                            B.output += G;
                            B.value += G;
                            t.dots = true;
                            continue;
                        }
                        if (m.braces + m.parens === 0 && B.type !== "bos" && B.type !== "slash") {
                            push({
                                type: "text",
                                value: G,
                                output: h
                            });
                            continue;
                        }
                        push({
                            type: "dot",
                            value: G,
                            output: h
                        });
                        continue;
                    }
                    if (G === "?") {
                        const t = B && B.value === "(";
                        if (!t && u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("qmark", G);
                            continue;
                        }
                        if (B && B.type === "paren") {
                            const t = D();
                            let e = G;
                            if (B.value === "(" && !/[!=<:]/.test(t) || t === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                                e = `\\${G}`;
                            }
                            push({
                                type: "text",
                                value: G,
                                output: e
                            });
                            continue;
                        }
                        if (u.dot !== true && (B.type === "slash" || B.type === "bos")) {
                            push({
                                type: "qmark",
                                value: G,
                                output: v
                            });
                            continue;
                        }
                        push({
                            type: "qmark",
                            value: G,
                            output: H
                        });
                        continue;
                    }
                    if (G === "!") {
                        if (u.noextglob !== true && D() === "(") {
                            if (D(2) !== "?" || !/[!=<:]/.test(D(3))) {
                                extglobOpen("negate", G);
                                continue;
                            }
                        }
                        if (u.nonegate !== true && m.index === 0) {
                            negate();
                            continue;
                        }
                    }
                    if (G === "+") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("plus", G);
                            continue;
                        }
                        if (B && B.value === "(" || u.regex === false) {
                            push({
                                type: "plus",
                                value: G,
                                output: g
                            });
                            continue;
                        }
                        if (B && (B.type === "bracket" || B.type === "paren" || B.type === "brace") || m.parens > 0) {
                            push({
                                type: "plus",
                                value: G
                            });
                            continue;
                        }
                        push({
                            type: "plus",
                            value: g
                        });
                        continue;
                    }
                    if (G === "@") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            push({
                                type: "at",
                                extglob: true,
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G !== "*") {
                        if (G === "$" || G === "^") {
                            G = `\\${G}`;
                        }
                        const t = a.exec(remaining());
                        if (t) {
                            G += t[0];
                            m.index += t[0].length;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (B && (B.type === "globstar" || B.star === true)) {
                        B.type = "star";
                        B.star = true;
                        B.value += G;
                        B.output = k;
                        m.backtrack = true;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    let e = remaining();
                    if (u.noextglob !== true && /^\([^?]/.test(e)) {
                        extglobOpen("star", G);
                        continue;
                    }
                    if (B.type === "star") {
                        if (u.noglobstar === true) {
                            consume(G);
                            continue;
                        }
                        const n = B.prev;
                        const o = n.prev;
                        const s = n.type === "slash" || n.type === "bos";
                        const r = o && (o.type === "star" || o.type === "globstar");
                        if (u.bash === true && (!s || e[0] && e[0] !== "/")) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        const a = m.braces > 0 && (n.type === "comma" || n.type === "brace");
                        const i = w.length && (n.type === "pipe" || n.type === "paren");
                        if (!s && n.type !== "paren" && !a && !i) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        while(e.slice(0, 3) === "/**"){
                            const u = t[m.index + 4];
                            if (u && u !== "/") {
                                break;
                            }
                            e = e.slice(3);
                            consume("/**", 3);
                        }
                        if (n.type === "bos" && eos()) {
                            B.type = "globstar";
                            B.value += G;
                            B.output = globstar(u);
                            m.output = B.output;
                            m.globstar = true;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && !r && eos()) {
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = globstar(u) + (u.strictSlashes ? ")" : "|$)");
                            B.value += G;
                            m.globstar = true;
                            m.output += n.output + B.output;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && e[0] === "/") {
                            const t = e[1] !== void 0 ? "|$" : "";
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = `${globstar(u)}${b}|${b}${t})`;
                            B.value += G;
                            m.output += n.output + B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        if (n.type === "bos" && e[0] === "/") {
                            B.type = "globstar";
                            B.value += G;
                            B.output = `(?:^|${b}|${globstar(u)}${b})`;
                            m.output = B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        m.output = m.output.slice(0, -B.output.length);
                        B.type = "globstar";
                        B.output = globstar(u);
                        B.value += G;
                        m.output += B.output;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    const n = {
                        type: "star",
                        value: G,
                        output: k
                    };
                    if (u.bash === true) {
                        n.output = ".*?";
                        if (B.type === "bos" || B.type === "slash") {
                            n.output = T + n.output;
                        }
                        push(n);
                        continue;
                    }
                    if (B && (B.type === "bracket" || B.type === "paren") && u.regex === true) {
                        n.output = G;
                        push(n);
                        continue;
                    }
                    if (m.index === m.start || B.type === "slash" || B.type === "dot") {
                        if (B.type === "dot") {
                            m.output += x;
                            B.output += x;
                        } else if (u.dot === true) {
                            m.output += S;
                            B.output += S;
                        } else {
                            m.output += T;
                            B.output += T;
                        }
                        if (D() !== "*") {
                            m.output += C;
                            B.output += C;
                        }
                    }
                    push(n);
                }
                while(m.brackets > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
                    m.output = o.escapeLast(m.output, "[");
                    decrement("brackets");
                }
                while(m.parens > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
                    m.output = o.escapeLast(m.output, "(");
                    decrement("parens");
                }
                while(m.braces > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
                    m.output = o.escapeLast(m.output, "{");
                    decrement("braces");
                }
                if (u.strictSlashes !== true && (B.type === "star" || B.type === "bracket")) {
                    push({
                        type: "maybe_slash",
                        value: "",
                        output: `${b}?`
                    });
                }
                if (m.backtrack === true) {
                    m.output = "";
                    for (const t of m.tokens){
                        m.output += t.output != null ? t.output : t.value;
                        if (t.suffix) {
                            m.output += t.suffix;
                        }
                    }
                }
                return m;
            };
            parse.fastpaths = (t, e)=>{
                const u = {
                    ...e
                };
                const r = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                const a = t.length;
                if (a > r) {
                    throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`);
                }
                t = c[t] || t;
                const { DOT_LITERAL: i, SLASH_LITERAL: p, ONE_CHAR: l, DOTS_SLASH: f, NO_DOT: A, NO_DOTS: _, NO_DOTS_SLASH: R, STAR: E, START_ANCHOR: h } = n.globChars(u.windows);
                const g = u.dot ? _ : A;
                const b = u.dot ? R : A;
                const C = u.capture ? "" : "?:";
                const y = {
                    negated: false,
                    prefix: ""
                };
                let $ = u.bash === true ? ".*?" : E;
                if (u.capture) {
                    $ = `(${$})`;
                }
                const globstar = (t)=>{
                    if (t.noglobstar === true) return $;
                    return `(${C}(?:(?!${h}${t.dot ? f : i}).)*?)`;
                };
                const create = (t)=>{
                    switch(t){
                        case "*":
                            return `${g}${l}${$}`;
                        case ".*":
                            return `${i}${l}${$}`;
                        case "*.*":
                            return `${g}${$}${i}${l}${$}`;
                        case "*/*":
                            return `${g}${$}${p}${l}${b}${$}`;
                        case "**":
                            return g + globstar(u);
                        case "**/*":
                            return `(?:${g}${globstar(u)}${p})?${b}${l}${$}`;
                        case "**/*.*":
                            return `(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;
                        case "**/.*":
                            return `(?:${g}${globstar(u)}${p})?${i}${l}${$}`;
                        default:
                            {
                                const e = /^(.*?)\.(\w+)$/.exec(t);
                                if (!e) return;
                                const u = create(e[1]);
                                if (!u) return;
                                return u + i + e[2];
                            }
                    }
                };
                const x = o.removePrefix(t, y);
                let S = create(x);
                if (S && u.strictSlashes !== true) {
                    S += `${p}?`;
                }
                return S;
            };
            t.exports = parse;
        },
        510: (t, e, u)=>{
            const n = u(716);
            const o = u(697);
            const s = u(96);
            const r = u(154);
            const isObject = (t)=>t && typeof t === "object" && !Array.isArray(t);
            const picomatch = (t, e, u = false)=>{
                if (Array.isArray(t)) {
                    const n = t.map((t)=>picomatch(t, e, u));
                    const arrayMatcher = (t)=>{
                        for (const e of n){
                            const u = e(t);
                            if (u) return u;
                        }
                        return false;
                    };
                    return arrayMatcher;
                }
                const n = isObject(t) && t.tokens && t.input;
                if (t === "" || typeof t !== "string" && !n) {
                    throw new TypeError("Expected pattern to be a non-empty string");
                }
                const o = e || {};
                const s = o.windows;
                const r = n ? picomatch.compileRe(t, e) : picomatch.makeRe(t, e, false, true);
                const a = r.state;
                delete r.state;
                let isIgnored = ()=>false;
                if (o.ignore) {
                    const t = {
                        ...e,
                        ignore: null,
                        onMatch: null,
                        onResult: null
                    };
                    isIgnored = picomatch(o.ignore, t, u);
                }
                const matcher = (u, n = false)=>{
                    const { isMatch: i, match: c, output: p } = picomatch.test(u, r, e, {
                        glob: t,
                        posix: s
                    });
                    const l = {
                        glob: t,
                        state: a,
                        regex: r,
                        posix: s,
                        input: u,
                        output: p,
                        match: c,
                        isMatch: i
                    };
                    if (typeof o.onResult === "function") {
                        o.onResult(l);
                    }
                    if (i === false) {
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (isIgnored(u)) {
                        if (typeof o.onIgnore === "function") {
                            o.onIgnore(l);
                        }
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (typeof o.onMatch === "function") {
                        o.onMatch(l);
                    }
                    return n ? l : true;
                };
                if (u) {
                    matcher.state = a;
                }
                return matcher;
            };
            picomatch.test = (t, e, u, { glob: n, posix: o } = {})=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected input to be a string");
                }
                if (t === "") {
                    return {
                        isMatch: false,
                        output: ""
                    };
                }
                const r = u || {};
                const a = r.format || (o ? s.toPosixSlashes : null);
                let i = t === n;
                let c = i && a ? a(t) : t;
                if (i === false) {
                    c = a ? a(t) : t;
                    i = c === n;
                }
                if (i === false || r.capture === true) {
                    if (r.matchBase === true || r.basename === true) {
                        i = picomatch.matchBase(t, e, u, o);
                    } else {
                        i = e.exec(c);
                    }
                }
                return {
                    isMatch: Boolean(i),
                    match: i,
                    output: c
                };
            };
            picomatch.matchBase = (t, e, u)=>{
                const n = e instanceof RegExp ? e : picomatch.makeRe(e, u);
                return n.test(s.basename(t));
            };
            picomatch.isMatch = (t, e, u)=>picomatch(e, u)(t);
            picomatch.parse = (t, e)=>{
                if (Array.isArray(t)) return t.map((t)=>picomatch.parse(t, e));
                return o(t, {
                    ...e,
                    fastpaths: false
                });
            };
            picomatch.scan = (t, e)=>n(t, e);
            picomatch.compileRe = (t, e, u = false, n = false)=>{
                if (u === true) {
                    return t.output;
                }
                const o = e || {};
                const s = o.contains ? "" : "^";
                const r = o.contains ? "" : "$";
                let a = `${s}(?:${t.output})${r}`;
                if (t && t.negated === true) {
                    a = `^(?!${a}).*$`;
                }
                const i = picomatch.toRegex(a, e);
                if (n === true) {
                    i.state = t;
                }
                return i;
            };
            picomatch.makeRe = (t, e = {}, u = false, n = false)=>{
                if (!t || typeof t !== "string") {
                    throw new TypeError("Expected a non-empty string");
                }
                let s = {
                    negated: false,
                    fastpaths: true
                };
                if (e.fastpaths !== false && (t[0] === "." || t[0] === "*")) {
                    s.output = o.fastpaths(t, e);
                }
                if (!s.output) {
                    s = o(t, e);
                }
                return picomatch.compileRe(s, e, u, n);
            };
            picomatch.toRegex = (t, e)=>{
                try {
                    const u = e || {};
                    return new RegExp(t, u.flags || (u.nocase ? "i" : ""));
                } catch (t) {
                    if (e && e.debug === true) throw t;
                    return /$^/;
                }
            };
            picomatch.constants = r;
            t.exports = picomatch;
        },
        716: (t, e, u)=>{
            const n = u(96);
            const { CHAR_ASTERISK: o, CHAR_AT: s, CHAR_BACKWARD_SLASH: r, CHAR_COMMA: a, CHAR_DOT: i, CHAR_EXCLAMATION_MARK: c, CHAR_FORWARD_SLASH: p, CHAR_LEFT_CURLY_BRACE: l, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: _, CHAR_QUESTION_MARK: R, CHAR_RIGHT_CURLY_BRACE: E, CHAR_RIGHT_PARENTHESES: h, CHAR_RIGHT_SQUARE_BRACKET: g } = u(154);
            const isPathSeparator = (t)=>t === p || t === r;
            const depth = (t)=>{
                if (t.isPrefix !== true) {
                    t.depth = t.isGlobstar ? Infinity : 1;
                }
            };
            const scan = (t, e)=>{
                const u = e || {};
                const b = t.length - 1;
                const C = u.parts === true || u.scanToEnd === true;
                const y = [];
                const $ = [];
                const x = [];
                let S = t;
                let H = -1;
                let v = 0;
                let d = 0;
                let L = false;
                let T = false;
                let O = false;
                let k = false;
                let m = false;
                let w = false;
                let N = false;
                let I = false;
                let B = false;
                let G = false;
                let D = 0;
                let M;
                let P;
                let K = {
                    value: "",
                    depth: 0,
                    isGlob: false
                };
                const eos = ()=>H >= b;
                const peek = ()=>S.charCodeAt(H + 1);
                const advance = ()=>{
                    M = P;
                    return S.charCodeAt(++H);
                };
                while(H < b){
                    P = advance();
                    let t;
                    if (P === r) {
                        N = K.backslashes = true;
                        P = advance();
                        if (P === l) {
                            w = true;
                        }
                        continue;
                    }
                    if (w === true || P === l) {
                        D++;
                        while(eos() !== true && (P = advance())){
                            if (P === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (P === l) {
                                D++;
                                continue;
                            }
                            if (w !== true && P === i && (P = advance()) === i) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (w !== true && P === a) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (P === E) {
                                D--;
                                if (D === 0) {
                                    w = false;
                                    L = K.isBrace = true;
                                    G = true;
                                    break;
                                }
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === p) {
                        y.push(H);
                        $.push(K);
                        K = {
                            value: "",
                            depth: 0,
                            isGlob: false
                        };
                        if (G === true) continue;
                        if (M === i && H === v + 1) {
                            v += 2;
                            continue;
                        }
                        d = H + 1;
                        continue;
                    }
                    if (u.noext !== true) {
                        const t = P === _ || P === s || P === o || P === R || P === c;
                        if (t === true && peek() === f) {
                            O = K.isGlob = true;
                            k = K.isExtglob = true;
                            G = true;
                            if (P === c && H === v) {
                                B = true;
                            }
                            if (C === true) {
                                while(eos() !== true && (P = advance())){
                                    if (P === r) {
                                        N = K.backslashes = true;
                                        P = advance();
                                        continue;
                                    }
                                    if (P === h) {
                                        O = K.isGlob = true;
                                        G = true;
                                        break;
                                    }
                                }
                                continue;
                            }
                            break;
                        }
                    }
                    if (P === o) {
                        if (M === o) m = K.isGlobstar = true;
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === R) {
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === A) {
                        while(eos() !== true && (t = advance())){
                            if (t === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (t === g) {
                                T = K.isBracket = true;
                                O = K.isGlob = true;
                                G = true;
                                break;
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (u.nonegate !== true && P === c && H === v) {
                        I = K.negated = true;
                        v++;
                        continue;
                    }
                    if (u.noparen !== true && P === f) {
                        O = K.isGlob = true;
                        if (C === true) {
                            while(eos() !== true && (P = advance())){
                                if (P === f) {
                                    N = K.backslashes = true;
                                    P = advance();
                                    continue;
                                }
                                if (P === h) {
                                    G = true;
                                    break;
                                }
                            }
                            continue;
                        }
                        break;
                    }
                    if (O === true) {
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                }
                if (u.noext === true) {
                    k = false;
                    O = false;
                }
                let U = S;
                let X = "";
                let F = "";
                if (v > 0) {
                    X = S.slice(0, v);
                    S = S.slice(v);
                    d -= v;
                }
                if (U && O === true && d > 0) {
                    U = S.slice(0, d);
                    F = S.slice(d);
                } else if (O === true) {
                    U = "";
                    F = S;
                } else {
                    U = S;
                }
                if (U && U !== "" && U !== "/" && U !== S) {
                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {
                        U = U.slice(0, -1);
                    }
                }
                if (u.unescape === true) {
                    if (F) F = n.removeBackslashes(F);
                    if (U && N === true) {
                        U = n.removeBackslashes(U);
                    }
                }
                const Q = {
                    prefix: X,
                    input: t,
                    start: v,
                    base: U,
                    glob: F,
                    isBrace: L,
                    isBracket: T,
                    isGlob: O,
                    isExtglob: k,
                    isGlobstar: m,
                    negated: I,
                    negatedExtglob: B
                };
                if (u.tokens === true) {
                    Q.maxDepth = 0;
                    if (!isPathSeparator(P)) {
                        $.push(K);
                    }
                    Q.tokens = $;
                }
                if (u.parts === true || u.tokens === true) {
                    let e;
                    for(let n = 0; n < y.length; n++){
                        const o = e ? e + 1 : v;
                        const s = y[n];
                        const r = t.slice(o, s);
                        if (u.tokens) {
                            if (n === 0 && v !== 0) {
                                $[n].isPrefix = true;
                                $[n].value = X;
                            } else {
                                $[n].value = r;
                            }
                            depth($[n]);
                            Q.maxDepth += $[n].depth;
                        }
                        if (n !== 0 || r !== "") {
                            x.push(r);
                        }
                        e = s;
                    }
                    if (e && e + 1 < t.length) {
                        const n = t.slice(e + 1);
                        x.push(n);
                        if (u.tokens) {
                            $[$.length - 1].value = n;
                            depth($[$.length - 1]);
                            Q.maxDepth += $[$.length - 1].depth;
                        }
                    }
                    Q.slashes = y;
                    Q.parts = x;
                }
                return Q;
            };
            t.exports = scan;
        },
        96: (t, e, u)=>{
            const { REGEX_BACKSLASH: n, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: s, REGEX_SPECIAL_CHARS_GLOBAL: r } = u(154);
            e.isObject = (t)=>t !== null && typeof t === "object" && !Array.isArray(t);
            e.hasRegexChars = (t)=>s.test(t);
            e.isRegexChar = (t)=>t.length === 1 && e.hasRegexChars(t);
            e.escapeRegex = (t)=>t.replace(r, "\\$1");
            e.toPosixSlashes = (t)=>t.replace(n, "/");
            e.removeBackslashes = (t)=>t.replace(o, (t)=>t === "\\" ? "" : t);
            e.escapeLast = (t, u, n)=>{
                const o = t.lastIndexOf(u, n);
                if (o === -1) return t;
                if (t[o - 1] === "\\") return e.escapeLast(t, u, o - 1);
                return `${t.slice(0, o)}\\${t.slice(o)}`;
            };
            e.removePrefix = (t, e = {})=>{
                let u = t;
                if (u.startsWith("./")) {
                    u = u.slice(2);
                    e.prefix = "./";
                }
                return u;
            };
            e.wrapOutput = (t, e = {}, u = {})=>{
                const n = u.contains ? "" : "^";
                const o = u.contains ? "" : "$";
                let s = `${n}(?:${t})${o}`;
                if (e.negated === true) {
                    s = `(?:^(?!${s}).*$)`;
                }
                return s;
            };
            e.basename = (t, { windows: e } = {})=>{
                const u = t.split(e ? /[\\/]/ : "/");
                const n = u[u.length - 1];
                if (n === "") {
                    return u[u.length - 2];
                }
                return n;
            };
        }
    };
    var e = {};
    function __nccwpck_require__(u) {
        var n = e[u];
        if (n !== undefined) {
            return n.exports;
        }
        var o = e[u] = {
            exports: {}
        };
        var s = true;
        try {
            t[u](o, o.exports, __nccwpck_require__);
            s = false;
        } finally{
            if (s) delete e[u];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var u = __nccwpck_require__(170);
    module.exports = u;
})();
}}),
"[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasLocalMatch: null,
    matchLocalPattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasLocalMatch: function() {
        return hasLocalMatch;
    },
    matchLocalPattern: function() {
        return matchLocalPattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchLocalPattern(pattern, url) {
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    var _pattern_pathname;
    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasLocalMatch(localPatterns, urlPathAndQuery) {
    if (!localPatterns) {
        // if the user didn't define "localPatterns", we allow all local images
        return true;
    }
    const url = new URL(urlPathAndQuery, 'http://n');
    return localPatterns.some((p)=>matchLocalPattern(p, url));
} //# sourceMappingURL=match-local-pattern.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasRemoteMatch: null,
    matchRemotePattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasRemoteMatch: function() {
        return hasRemoteMatch;
    },
    matchRemotePattern: function() {
        return matchRemotePattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchRemotePattern(pattern, url) {
    if (pattern.protocol !== undefined) {
        if (pattern.protocol.replace(/:$/, '') !== url.protocol.replace(/:$/, '')) {
            return false;
        }
    }
    if (pattern.port !== undefined) {
        if (pattern.port !== url.port) {
            return false;
        }
    }
    if (pattern.hostname === undefined) {
        throw Object.defineProperty(new Error("Pattern should define hostname but found\n" + JSON.stringify(pattern)), "__NEXT_ERROR_CODE", {
            value: "E410",
            enumerable: false,
            configurable: true
        });
    } else {
        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {
            return false;
        }
    }
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    var _pattern_pathname;
    // Should be the same as writeImagesManifest()
    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasRemoteMatch(domains, remotePatterns, url) {
    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));
} //# sourceMappingURL=match-remote-pattern.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const DEFAULT_Q = 75;
function defaultLoader(param) {
    let { config, src, width, quality } = param;
    var _config_qualities;
    if ("TURBOPACK compile-time truthy", 1) {
        const missingValues = [];
        // these should always be provided but make sure they are
        if (!src) missingValues.push('src');
        if (!width) missingValues.push('width');
        if (missingValues.length > 0) {
            throw Object.defineProperty(new Error("Next Image Optimization requires " + missingValues.join(', ') + " to be provided. Make sure you pass them as props to the `next/image` component. Received: " + JSON.stringify({
                src,
                width,
                quality
            })), "__NEXT_ERROR_CODE", {
                value: "E188",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('//')) {
            throw Object.defineProperty(new Error('Failed to parse src "' + src + '" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'), "__NEXT_ERROR_CODE", {
                value: "E360",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('/') && config.localPatterns) {
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasLocalMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)");
                if (!hasLocalMatch(config.localPatterns, src)) {
                    throw Object.defineProperty(new Error("Invalid src prop (" + src + ") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\n" + "See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns"), "__NEXT_ERROR_CODE", {
                        value: "E426",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {
            let parsedSrc;
            try {
                parsedSrc = new URL(src);
            } catch (err) {
                console.error(err);
                throw Object.defineProperty(new Error('Failed to parse src "' + src + '" on `next/image`, if using relative image it must start with a leading slash "/" or be an absolute URL (http:// or https://)'), "__NEXT_ERROR_CODE", {
                    value: "E63",
                    enumerable: false,
                    configurable: true
                });
            }
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasRemoteMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)");
                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {
                    throw Object.defineProperty(new Error("Invalid src prop (" + src + ') on `next/image`, hostname "' + parsedSrc.hostname + '" is not configured under images in your `next.config.js`\n' + "See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host"), "__NEXT_ERROR_CODE", {
                        value: "E231",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (quality && config.qualities && !config.qualities.includes(quality)) {
            throw Object.defineProperty(new Error("Invalid quality prop (" + quality + ") on `next/image` does not match `images.qualities` configured in your `next.config.js`\n" + "See more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities"), "__NEXT_ERROR_CODE", {
                value: "E623",
                enumerable: false,
                configurable: true
            });
        }
    }
    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;
    return config.path + "?url=" + encodeURIComponent(src) + "&w=" + width + "&q=" + q + (src.startsWith('/_next/static/media/') && ("TURBOPACK compile-time value", false) ? ("TURBOPACK unreachable", undefined) : '');
}
// We use this to determine if the import is the default loader
// or a custom loader defined by the user in next.config.js
defaultLoader.__next_img_default = true;
const _default = defaultLoader; //# sourceMappingURL=image-loader.js.map
}}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}}),
"[project]/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function() {
        return Image;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)"));
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const _imageconfigcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _routercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
// This is replaced by webpack define plugin
const configEnv = ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[]}'));
if (typeof window === 'undefined') {
    ;
    globalThis.__NEXT_IMAGE_IMPORTED = true;
}
// See https://stackoverflow.com/q/39777833/266535 for why we use this ref
// handler instead of the img's onLoad attribute.
function handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {
    const src = img == null ? void 0 : img.src;
    if (!img || img['data-loaded-src'] === src) {
        return;
    }
    img['data-loaded-src'] = src;
    const p = 'decode' in img ? img.decode() : Promise.resolve();
    p.catch(()=>{}).then(()=>{
        if (!img.parentElement || !img.isConnected) {
            // Exit early in case of race condition:
            // - onload() is called
            // - decode() is called but incomplete
            // - unmount is called
            // - decode() completes
            return;
        }
        if (placeholder !== 'empty') {
            setBlurComplete(true);
        }
        if (onLoadRef == null ? void 0 : onLoadRef.current) {
            // Since we don't have the SyntheticEvent here,
            // we must create one with the same shape.
            // See https://reactjs.org/docs/events.html
            const event = new Event('load');
            Object.defineProperty(event, 'target', {
                writable: false,
                value: img
            });
            let prevented = false;
            let stopped = false;
            onLoadRef.current({
                ...event,
                nativeEvent: event,
                currentTarget: img,
                target: img,
                isDefaultPrevented: ()=>prevented,
                isPropagationStopped: ()=>stopped,
                persist: ()=>{},
                preventDefault: ()=>{
                    prevented = true;
                    event.preventDefault();
                },
                stopPropagation: ()=>{
                    stopped = true;
                    event.stopPropagation();
                }
            });
        }
        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {
            onLoadingCompleteRef.current(img);
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;
            if (img.getAttribute('data-nimg') === 'fill') {
                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {
                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;
                    if (widthViewportRatio < 0.6) {
                        if (sizesInput === '100vw') {
                            (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" prop and "sizes" prop of "100vw", but image is not rendered at full viewport width. Please adjust "sizes" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');
                        } else {
                            (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" but is missing "sizes" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');
                        }
                    }
                }
                if (img.parentElement) {
                    const { position } = window.getComputedStyle(img.parentElement);
                    const valid = [
                        'absolute',
                        'fixed',
                        'relative'
                    ];
                    if (!valid.includes(position)) {
                        (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" and parent element with invalid "position". Provided "' + position + '" should be one of ' + valid.map(String).join(',') + ".");
                    }
                }
                if (img.height === 0) {
                    (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');
                }
            }
            const heightModified = img.height.toString() !== img.getAttribute('height');
            const widthModified = img.width.toString() !== img.getAttribute('width');
            if (heightModified && !widthModified || !heightModified && widthModified) {
                (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \'width: "auto"\' or \'height: "auto"\' to maintain the aspect ratio.');
            }
        }
    });
}
function getDynamicProps(fetchPriority) {
    if (Boolean(_react.use)) {
        // In React 19.0.0 or newer, we must use camelCase
        // prop to avoid "Warning: Invalid DOM property".
        // See https://github.com/facebook/react/pull/25927
        return {
            fetchPriority
        };
    }
    // In React 18.2.0 or older, we must use lowercase prop
    // to avoid "Warning: Invalid DOM property".
    return {
        fetchpriority: fetchPriority
    };
}
const ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{
    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;
    const ownRef = (0, _react.useCallback)((img)=>{
        if (!img) {
            return;
        }
        if (onError) {
            // If the image has an error before react hydrates, then the error is lost.
            // The workaround is to wait until the image is mounted which is after hydration,
            // then we set the src again to trigger the error handler (if there was an error).
            // eslint-disable-next-line no-self-assign
            img.src = img.src;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (!src) {
                console.error('Image is missing required "src" property:', img);
            }
            if (img.getAttribute('alt') === null) {
                console.error('Image is missing required "alt" property. Please add Alternative Text to describe the image for screen readers and search engines.');
            }
        }
        if (img.complete) {
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        }
    }, [
        src,
        placeholder,
        onLoadRef,
        onLoadingCompleteRef,
        setBlurComplete,
        onError,
        unoptimized,
        sizesInput
    ]);
    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
        ...rest,
        ...getDynamicProps(fetchPriority),
        // It's intended to keep `loading` before `src` because React updates
        // props in order which causes Safari/Firefox to not lazy load properly.
        // See https://github.com/facebook/react/issues/25883
        loading: loading,
        width: width,
        height: height,
        decoding: decoding,
        "data-nimg": fill ? 'fill' : '1',
        className: className,
        style: style,
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        sizes: sizes,
        srcSet: srcSet,
        src: src,
        ref: ref,
        onLoad: (event)=>{
            const img = event.currentTarget;
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        },
        onError: (event)=>{
            // if the real image fails to load, this will ensure "alt" is visible
            setShowAltText(true);
            if (placeholder !== 'empty') {
                // If the real image fails to load, this will still remove the placeholder.
                setBlurComplete(true);
            }
            if (onError) {
                onError(event);
            }
        }
    });
});
function ImagePreload(param) {
    let { isAppRouter, imgAttributes } = param;
    const opts = {
        as: 'image',
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: imgAttributes.crossOrigin,
        referrerPolicy: imgAttributes.referrerPolicy,
        ...getDynamicProps(imgAttributes.fetchPriority)
    };
    if (isAppRouter && _reactdom.default.preload) {
        // See https://github.com/facebook/react/pull/26940
        _reactdom.default.preload(imgAttributes.src, opts);
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "preload",
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            href: imgAttributes.srcSet ? undefined : imgAttributes.src,
            ...opts
        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
    });
}
const Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{
    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
    const config = (0, _react.useMemo)(()=>{
        var _c_qualities;
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);
        return {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }, [
        configContext
    ]);
    const { onLoad, onLoadingComplete } = props;
    const onLoadRef = (0, _react.useRef)(onLoad);
    (0, _react.useEffect)(()=>{
        onLoadRef.current = onLoad;
    }, [
        onLoad
    ]);
    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
    (0, _react.useEffect)(()=>{
        onLoadingCompleteRef.current = onLoadingComplete;
    }, [
        onLoadingComplete
    ]);
    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
    const [showAltText, setShowAltText] = (0, _react.useState)(false);
    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {
        defaultLoader: _imageloader.default,
        imgConf: config,
        blurComplete,
        showAltText
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {
                ...imgAttributes,
                unoptimized: imgMeta.unoptimized,
                placeholder: imgMeta.placeholder,
                fill: imgMeta.fill,
                onLoadRef: onLoadRef,
                onLoadingCompleteRef: onLoadingCompleteRef,
                setBlurComplete: setBlurComplete,
                setShowAltText: setShowAltText,
                sizesInput: props.sizes,
                ref: forwardedRef
            }),
            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {
                isAppRouter: isAppRouter,
                imgAttributes: imgAttributes
            }) : null
        ]
    });
});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=image-component.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[]}'))
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}}),
"[project]/node_modules/next/image.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_ca33b878._.js.map