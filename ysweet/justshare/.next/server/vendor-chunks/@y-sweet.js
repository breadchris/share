"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@y-sweet";
exports.ids = ["vendor-chunks/@y-sweet"];
exports.modules = {

/***/ "(rsc)/./node_modules/@y-sweet/react/dist/main.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@y-sweet/react/dist/main.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YDocProvider: () => (/* binding */ YDocProvider),
/* harmony export */   YSweetProvider: () => (/* binding */ YSweetProvider),
/* harmony export */   createYjsProvider: () => (/* binding */ createYjsProvider),
/* harmony export */   debuggerUrl: () => (/* binding */ debuggerUrl),
/* harmony export */   useArray: () => (/* binding */ useArray),
/* harmony export */   useAwareness: () => (/* binding */ useAwareness),
/* harmony export */   useConnectionStatus: () => (/* binding */ useConnectionStatus),
/* harmony export */   useHasLocalChanges: () => (/* binding */ useHasLocalChanges),
/* harmony export */   useMap: () => (/* binding */ useMap),
/* harmony export */   useObserve: () => (/* binding */ useObserve),
/* harmony export */   usePresence: () => (/* binding */ usePresence),
/* harmony export */   usePresenceSetter: () => (/* binding */ usePresenceSetter),
/* harmony export */   useText: () => (/* binding */ useText),
/* harmony export */   useYDoc: () => (/* binding */ useYDoc),
/* harmony export */   useYSweetDebugUrl: () => (/* binding */ useYSweetDebugUrl),
/* harmony export */   useYjsProvider: () => (/* binding */ useYjsProvider)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server.edge */ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server-edge.js");

const YDocProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call YDocProvider() from the server but YDocProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"YDocProvider",
);const YSweetProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call YSweetProvider() from the server but YSweetProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"YSweetProvider",
);const createYjsProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call createYjsProvider() from the server but createYjsProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"createYjsProvider",
);const debuggerUrl = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call debuggerUrl() from the server but debuggerUrl is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"debuggerUrl",
);const useArray = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useArray() from the server but useArray is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useArray",
);const useAwareness = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useAwareness() from the server but useAwareness is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useAwareness",
);const useConnectionStatus = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useConnectionStatus() from the server but useConnectionStatus is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useConnectionStatus",
);const useHasLocalChanges = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useHasLocalChanges() from the server but useHasLocalChanges is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useHasLocalChanges",
);const useMap = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useMap() from the server but useMap is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useMap",
);const useObserve = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useObserve() from the server but useObserve is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useObserve",
);const usePresence = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call usePresence() from the server but usePresence is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"usePresence",
);const usePresenceSetter = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call usePresenceSetter() from the server but usePresenceSetter is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"usePresenceSetter",
);const useText = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useText() from the server but useText is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useText",
);const useYDoc = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useYDoc() from the server but useYDoc is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useYDoc",
);const useYSweetDebugUrl = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useYSweetDebugUrl() from the server but useYSweetDebugUrl is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useYSweetDebugUrl",
);const useYjsProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useYjsProvider() from the server but useYjsProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/hacked/Documents/GitHub/share/ysweet/justshare/node_modules/@y-sweet/react/dist/main.mjs",
"useYjsProvider",
);

/***/ }),

/***/ "(rsc)/./node_modules/@y-sweet/sdk/dist/main.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@y-sweet/sdk/dist/main.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocConnection: () => (/* binding */ DocConnection),\n/* harmony export */   DocumentManager: () => (/* binding */ DocumentManager),\n/* harmony export */   YSweetError: () => (/* binding */ YSweetError),\n/* harmony export */   createDoc: () => (/* binding */ createDoc),\n/* harmony export */   decodeClientToken: () => (/* binding */ decodeClientToken),\n/* harmony export */   encodeClientToken: () => (/* binding */ encodeClientToken),\n/* harmony export */   getClientToken: () => (/* binding */ getClientToken),\n/* harmony export */   getOrCreateDocAndToken: () => (/* binding */ getOrCreateDocAndToken)\n/* harmony export */ });\n// src/error.ts\nvar YSweetError = class _YSweetError extends Error {\n  /**\n   * Create a new {@link YSweetError}.\n   *\n   * @param cause An object representing metadata associated with the error.\n   * @see {@link YSweetErrorPayload}\n   */\n  constructor(cause) {\n    super(_YSweetError.getMessage(cause));\n    this.cause = cause;\n    this.name = \"YSweetError\";\n  }\n  /** Convert the message to an error string that can be displayed to the user.\n   *\n   * The error string can also be used with {@link YSweetError.fromMessage} to\n   * reconstruct the payload object, which is useful in the context of Next.js,\n   * which will only pass an error string from the server to the client.\n   *\n   * @param payload The payload object to convert to a string.\n   * @returns A string representation of the error.\n   */\n  static getMessage(payload) {\n    let message;\n    if (payload.code === \"ServerRefused\") {\n      message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`;\n    } else if (payload.code === \"ServerError\") {\n      message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`;\n    } else if (payload.code === \"NoAuthProvided\") {\n      message = \"No auth provided\";\n    } else if (payload.code === \"InvalidAuthProvided\") {\n      message = \"Invalid auth provided\";\n    } else {\n      message = payload.message;\n    }\n    return `${payload.code}: ${message}`;\n  }\n  /**\n   * In development, next.js passes error objects to the client but strips out everything but the\n   * `message` field. This method allows us to reconstruct the original error object.\n   *\n   * @param messageString The error message string to reconstruct a payload from.\n   * @returns A {@link YSweetError} object.\n   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}\n   */\n  static fromMessage(messageString) {\n    let match = messageString.match(/^(.*?): (.*)$/);\n    if (!match) {\n      return new _YSweetError({ code: \"Unknown\", message: messageString });\n    }\n    let [, code, message] = match;\n    if (code === \"ServerRefused\") {\n      match = message.match(/^Server at (.*?):(\\d+) refused connection. URL: (.*)$/);\n      if (!match) {\n        return new _YSweetError({ code: \"Unknown\", message: messageString });\n      }\n      let [, address, port, url] = match;\n      return new _YSweetError({ code, address, port: parseInt(port), url });\n    }\n    if (code === \"ServerError\") {\n      match = message.match(/^Server responded with (\\d+) (.*). URL: (.*)$/);\n      if (!match) {\n        return new _YSweetError({ code: \"Unknown\", message: messageString });\n      }\n      let [, status, statusText, url] = match;\n      return new _YSweetError({ code, status: parseInt(status), message: statusText, url });\n    }\n    if (code === \"NoAuthProvided\") {\n      return new _YSweetError({ code });\n    }\n    if (code === \"InvalidAuthProvided\") {\n      return new _YSweetError({ code });\n    }\n    return new _YSweetError({ code: \"Unknown\", message });\n  }\n};\n\n// src/http.ts\nvar HttpClient = class {\n  constructor(baseUrl, token) {\n    this.token = null;\n    this.baseUrl = baseUrl;\n    this.token = token;\n  }\n  async request(path, method, body) {\n    const headers = new Headers();\n    if (this.token) {\n      headers.set(\"Authorization\", `Bearer ${this.token}`);\n    }\n    let rawBody;\n    if (body instanceof Uint8Array) {\n      headers.set(\"Content-Type\", \"application/octet-stream\");\n      rawBody = body;\n    } else if (body) {\n      headers.set(\"Content-Type\", \"application/json\");\n      rawBody = JSON.stringify(body);\n    }\n    const cacheBust = generateRandomString();\n    let url = `${this.baseUrl}/${path}?z=${cacheBust}`;\n    let result;\n    try {\n      result = await fetch(url, {\n        method,\n        body: rawBody,\n        headers\n      });\n    } catch (error) {\n      if (error.cause?.code === \"ECONNREFUSED\") {\n        let { address, port } = error.cause;\n        throw new YSweetError({ code: \"ServerRefused\", address, port, url });\n      } else {\n        throw new YSweetError({ code: \"Unknown\", message: error.toString() });\n      }\n    }\n    if (!result.ok) {\n      if (result.status === 401) {\n        if (this.token) {\n          throw new YSweetError({ code: \"InvalidAuthProvided\" });\n        } else {\n          throw new YSweetError({ code: \"NoAuthProvided\" });\n        }\n      }\n      throw new YSweetError({\n        code: \"ServerError\",\n        status: result.status,\n        message: result.statusText,\n        url\n      });\n    }\n    return result;\n  }\n};\nfunction generateRandomString() {\n  return Math.random().toString(36).substring(2);\n}\n\n// src/connection.ts\nvar DocConnection = class {\n  constructor(clientToken) {\n    let baseUrl = clientToken.baseUrl.replace(/\\/$/, \"\");\n    this.client = new HttpClient(baseUrl, clientToken.token ?? null);\n    this.docId = clientToken.docId;\n  }\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * This can be turned back into a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let update = await manager.getDocAsUpdate(docId)\n   * let doc = new Y.Doc()\n   * doc.transact(() => {\n   *  Y.applyUpdate(doc, update)\n   * })\n   * ```\n   *\n   * @returns\n   */\n  async getAsUpdate() {\n    const result = await this.client.request(`as-update`, \"GET\");\n    if (!result.ok) {\n      throw new Error(`Failed to get doc ${this.docId}: ${result.status} ${result.statusText}`);\n    }\n    let buffer = await result.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * This can be generated from a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let doc = new Y.Doc()\n   * // Modify the document...\n   * let update = Y.encodeStateAsUpdate(doc)\n   * await manager.updateDoc(docId, update)\n   * ```\n   *\n   * @param update\n   */\n  async updateDoc(update) {\n    const result = await this.client.request(`update`, \"POST\", update);\n    if (!result.ok) {\n      throw new Error(`Failed to update doc ${this.docId}: ${result.status} ${result.statusText}`);\n    }\n  }\n};\n\n// src/encoding.ts\nfunction stringToBase64(input) {\n  if (typeof window !== \"undefined\" && window.btoa) {\n    return window.btoa(input);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(input).toString(\"base64\");\n  } else {\n    throw new Error(\"Unable to encode to Base64\");\n  }\n}\nfunction base64ToString(input) {\n  if (typeof window !== \"undefined\" && window.atob) {\n    return window.atob(input);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(input, \"base64\").toString();\n  } else {\n    throw new Error(\"Unable to decode from Base64\");\n  }\n}\nfunction encodeClientToken(token) {\n  const jsonString = JSON.stringify(token);\n  let base64 = stringToBase64(jsonString);\n  base64 = base64.replace(\"+\", \"-\").replace(\"/\", \"_\").replace(/=+$/, \"\");\n  return base64;\n}\nfunction decodeClientToken(token) {\n  let base64 = token.replace(\"-\", \"+\").replace(\"_\", \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  const jsonString = base64ToString(base64);\n  return JSON.parse(jsonString);\n}\n\n// src/main.ts\nvar DocumentManager = class {\n  /**\n   * Create a new {@link DocumentManager}.\n   *\n   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n   */\n  constructor(connectionString) {\n    const parsedUrl = new URL(connectionString);\n    let token = null;\n    if (parsedUrl.username) {\n      token = decodeURIComponent(parsedUrl.username);\n    }\n    let protocol = parsedUrl.protocol;\n    if (protocol === \"ys:\") {\n      protocol = \"http:\";\n    } else if (protocol === \"yss:\") {\n      protocol = \"https:\";\n    }\n    const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}`;\n    let baseUrl = url.replace(/\\/$/, \"\");\n    this.client = new HttpClient(baseUrl, token);\n  }\n  async checkStore() {\n    return await (await this.client.request(\"check_store\", \"POST\", {})).json();\n  }\n  /**\n   * Creates a new document on the y-sweet server given an optional docId. If a document with given\n   * ID already exists, this is a no-op.\n   *\n   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  async createDoc(docId) {\n    const body = docId ? { docId } : {};\n    const result = await this.client.request(\"doc/new\", \"POST\", body);\n    if (!result.ok) {\n      throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`);\n    }\n    const responseBody = await result.json();\n    return responseBody;\n  }\n  /**\n   * Get a client token for the given document.\n   *\n   * If you are using authorization, this is expected to be called from your server\n   * after a user has authenticated. The returned token should then be passed to the\n   * client.\n   *\n   * @param docId The ID of the document to get a token for.\n   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  async getClientToken(docId, authDocRequest) {\n    if (typeof docId !== \"string\") {\n      docId = docId.docId;\n    }\n    const result = await this.client.request(`doc/${docId}/auth`, \"POST\", authDocRequest ?? {});\n    if (!result.ok) {\n      throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`);\n    }\n    const responseBody = await result.json();\n    return responseBody;\n  }\n  /**\n   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for\n   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or\n   * that one is created. If no docId is provided, a new document is created with a random ID.\n   *\n   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.\n   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  async getOrCreateDocAndToken(docId, authDocRequest) {\n    const result = await this.createDoc(docId);\n    return await this.getClientToken(result, authDocRequest);\n  }\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * @param docId The ID of the document to get.\n   * @returns The document as a Yjs update byte string\n   */\n  async getDocAsUpdate(docId) {\n    const connection = await this.getDocConnection(docId);\n    return await connection.getAsUpdate();\n  }\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * @param docId The ID of the document to update.\n   * @param update The Yjs update byte string to apply to the document.\n   */\n  async updateDoc(docId, update) {\n    const connection = await this.getDocConnection(docId);\n    return await connection.updateDoc(update);\n  }\n  async getDocConnection(docId, authDocRequest) {\n    const clientToken = await this.getClientToken(docId, authDocRequest);\n    return new DocConnection(clientToken);\n  }\n  /**\n   * Creates a new document with initial content.\n   *\n   * @param update A Yjs update byte string representing the initial content.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  async createDocWithContent(update) {\n    const result = await this.createDoc();\n    await this.updateDoc(result.docId, update);\n    return result;\n  }\n};\nasync function getOrCreateDocAndToken(connectionString, docId, authDocRequest) {\n  const manager = new DocumentManager(connectionString);\n  return await manager.getOrCreateDocAndToken(docId, authDocRequest);\n}\nasync function getClientToken(connectionString, docId, authDocRequest) {\n  const manager = new DocumentManager(connectionString);\n  return await manager.getClientToken(docId, authDocRequest);\n}\nasync function createDoc(connectionString, docId) {\n  const manager = new DocumentManager(connectionString);\n  return await manager.createDoc(docId);\n}\n\n//# sourceMappingURL=main.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHktc3dlZXQvc2RrL2Rpc3QvbWFpbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQixHQUFHLGNBQWMsMkJBQTJCLFlBQVk7QUFDckcsTUFBTTtBQUNOLHlDQUF5QyxnQkFBZ0IsRUFBRSxnQkFBZ0IsU0FBUyxZQUFZO0FBQ2hHLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxhQUFhLElBQUksUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5Q0FBeUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5Q0FBeUM7QUFDM0U7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUNBQXlDO0FBQzNFO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQTBEO0FBQzFGO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEs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dC9qdXN0c2hhcmUvbm9kZV9tb2R1bGVzL0B5LXN3ZWV0L3Nkay9kaXN0L21haW4ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvci50c1xudmFyIFlTd2VldEVycm9yID0gY2xhc3MgX1lTd2VldEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBZU3dlZXRFcnJvcn0uXG4gICAqXG4gICAqIEBwYXJhbSBjYXVzZSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gICAqIEBzZWUge0BsaW5rIFlTd2VldEVycm9yUGF5bG9hZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhdXNlKSB7XG4gICAgc3VwZXIoX1lTd2VldEVycm9yLmdldE1lc3NhZ2UoY2F1c2UpKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJZU3dlZXRFcnJvclwiO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBtZXNzYWdlIHRvIGFuIGVycm9yIHN0cmluZyB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAqXG4gICAqIFRoZSBlcnJvciBzdHJpbmcgY2FuIGFsc28gYmUgdXNlZCB3aXRoIHtAbGluayBZU3dlZXRFcnJvci5mcm9tTWVzc2FnZX0gdG9cbiAgICogcmVjb25zdHJ1Y3QgdGhlIHBheWxvYWQgb2JqZWN0LCB3aGljaCBpcyB1c2VmdWwgaW4gdGhlIGNvbnRleHQgb2YgTmV4dC5qcyxcbiAgICogd2hpY2ggd2lsbCBvbmx5IHBhc3MgYW4gZXJyb3Igc3RyaW5nIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCBvYmplY3QgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgc3RhdGljIGdldE1lc3NhZ2UocGF5bG9hZCkge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmIChwYXlsb2FkLmNvZGUgPT09IFwiU2VydmVyUmVmdXNlZFwiKSB7XG4gICAgICBtZXNzYWdlID0gYFNlcnZlciBhdCAke3BheWxvYWQuYWRkcmVzc306JHtwYXlsb2FkLnBvcnR9IHJlZnVzZWQgY29ubmVjdGlvbi4gVVJMOiAke3BheWxvYWQudXJsfWA7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLmNvZGUgPT09IFwiU2VydmVyRXJyb3JcIikge1xuICAgICAgbWVzc2FnZSA9IGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtwYXlsb2FkLnN0YXR1c30gJHtwYXlsb2FkLm1lc3NhZ2V9LiBVUkw6ICR7cGF5bG9hZC51cmx9YDtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQuY29kZSA9PT0gXCJOb0F1dGhQcm92aWRlZFwiKSB7XG4gICAgICBtZXNzYWdlID0gXCJObyBhdXRoIHByb3ZpZGVkXCI7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLmNvZGUgPT09IFwiSW52YWxpZEF1dGhQcm92aWRlZFwiKSB7XG4gICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGF1dGggcHJvdmlkZWRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSA9IHBheWxvYWQubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3BheWxvYWQuY29kZX06ICR7bWVzc2FnZX1gO1xuICB9XG4gIC8qKlxuICAgKiBJbiBkZXZlbG9wbWVudCwgbmV4dC5qcyBwYXNzZXMgZXJyb3Igb2JqZWN0cyB0byB0aGUgY2xpZW50IGJ1dCBzdHJpcHMgb3V0IGV2ZXJ5dGhpbmcgYnV0IHRoZVxuICAgKiBgbWVzc2FnZWAgZmllbGQuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZVN0cmluZyBUaGUgZXJyb3IgbWVzc2FnZSBzdHJpbmcgdG8gcmVjb25zdHJ1Y3QgYSBwYXlsb2FkIGZyb20uXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFlTd2VldEVycm9yfSBvYmplY3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2ZpbGUtY29udmVudGlvbnMvZXJyb3IjZXJyb3JtZXNzYWdlfCBOZXh0LmpzIGRvY3N9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1lc3NhZ2UobWVzc2FnZVN0cmluZykge1xuICAgIGxldCBtYXRjaCA9IG1lc3NhZ2VTdHJpbmcubWF0Y2goL14oLio/KTogKC4qKSQvKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbmV3IF9ZU3dlZXRFcnJvcih7IGNvZGU6IFwiVW5rbm93blwiLCBtZXNzYWdlOiBtZXNzYWdlU3RyaW5nIH0pO1xuICAgIH1cbiAgICBsZXQgWywgY29kZSwgbWVzc2FnZV0gPSBtYXRjaDtcbiAgICBpZiAoY29kZSA9PT0gXCJTZXJ2ZXJSZWZ1c2VkXCIpIHtcbiAgICAgIG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvXlNlcnZlciBhdCAoLio/KTooXFxkKykgcmVmdXNlZCBjb25uZWN0aW9uLiBVUkw6ICguKikkLyk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZTogXCJVbmtub3duXCIsIG1lc3NhZ2U6IG1lc3NhZ2VTdHJpbmcgfSk7XG4gICAgICB9XG4gICAgICBsZXQgWywgYWRkcmVzcywgcG9ydCwgdXJsXSA9IG1hdGNoO1xuICAgICAgcmV0dXJuIG5ldyBfWVN3ZWV0RXJyb3IoeyBjb2RlLCBhZGRyZXNzLCBwb3J0OiBwYXJzZUludChwb3J0KSwgdXJsIH0pO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gXCJTZXJ2ZXJFcnJvclwiKSB7XG4gICAgICBtYXRjaCA9IG1lc3NhZ2UubWF0Y2goL15TZXJ2ZXIgcmVzcG9uZGVkIHdpdGggKFxcZCspICguKikuIFVSTDogKC4qKSQvKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfWVN3ZWV0RXJyb3IoeyBjb2RlOiBcIlVua25vd25cIiwgbWVzc2FnZTogbWVzc2FnZVN0cmluZyB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBbLCBzdGF0dXMsIHN0YXR1c1RleHQsIHVybF0gPSBtYXRjaDtcbiAgICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZSwgc3RhdHVzOiBwYXJzZUludChzdGF0dXMpLCBtZXNzYWdlOiBzdGF0dXNUZXh0LCB1cmwgfSk7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSBcIk5vQXV0aFByb3ZpZGVkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZSB9KTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IFwiSW52YWxpZEF1dGhQcm92aWRlZFwiKSB7XG4gICAgICByZXR1cm4gbmV3IF9ZU3dlZXRFcnJvcih7IGNvZGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZTogXCJVbmtub3duXCIsIG1lc3NhZ2UgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9odHRwLnRzXG52YXIgSHR0cENsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYmFzZVVybCwgdG9rZW4pIHtcbiAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHBhdGgsIG1ldGhvZCwgYm9keSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICBoZWFkZXJzLnNldChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke3RoaXMudG9rZW59YCk7XG4gICAgfVxuICAgIGxldCByYXdCb2R5O1xuICAgIGlmIChib2R5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gICAgICByYXdCb2R5ID0gYm9keTtcbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcbiAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgIHJhd0JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVCdXN0ID0gZ2VuZXJhdGVSYW5kb21TdHJpbmcoKTtcbiAgICBsZXQgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS8ke3BhdGh9P3o9JHtjYWNoZUJ1c3R9YDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBib2R5OiByYXdCb2R5LFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLmNhdXNlPy5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgICAgIGxldCB7IGFkZHJlc3MsIHBvcnQgfSA9IGVycm9yLmNhdXNlO1xuICAgICAgICB0aHJvdyBuZXcgWVN3ZWV0RXJyb3IoeyBjb2RlOiBcIlNlcnZlclJlZnVzZWRcIiwgYWRkcmVzcywgcG9ydCwgdXJsIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFlTd2VldEVycm9yKHsgY29kZTogXCJVbmtub3duXCIsIG1lc3NhZ2U6IGVycm9yLnRvU3RyaW5nKCkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlTd2VldEVycm9yKHsgY29kZTogXCJJbnZhbGlkQXV0aFByb3ZpZGVkXCIgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlTd2VldEVycm9yKHsgY29kZTogXCJOb0F1dGhQcm92aWRlZFwiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgWVN3ZWV0RXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIlNlcnZlckVycm9yXCIsXG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogcmVzdWx0LnN0YXR1c1RleHQsXG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbnZhciBEb2NDb25uZWN0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnRUb2tlbikge1xuICAgIGxldCBiYXNlVXJsID0gY2xpZW50VG9rZW4uYmFzZVVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgSHR0cENsaWVudChiYXNlVXJsLCBjbGllbnRUb2tlbi50b2tlbiA/PyBudWxsKTtcbiAgICB0aGlzLmRvY0lkID0gY2xpZW50VG9rZW4uZG9jSWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW50aXJlIGRvY3VtZW50LCByZXByZXNlbnRlZCBhcyBhIFlqcyB1cGRhdGUgYnl0ZSBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHR1cm5lZCBiYWNrIGludG8gYSBZanMgZG9jdW1lbnQgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbiAgICpcbiAgICogbGV0IHVwZGF0ZSA9IGF3YWl0IG1hbmFnZXIuZ2V0RG9jQXNVcGRhdGUoZG9jSWQpXG4gICAqIGxldCBkb2MgPSBuZXcgWS5Eb2MoKVxuICAgKiBkb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgKiAgWS5hcHBseVVwZGF0ZShkb2MsIHVwZGF0ZSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRBc1VwZGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KGBhcy11cGRhdGVgLCBcIkdFVFwiKTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGRvYyAke3RoaXMuZG9jSWR9OiAke3Jlc3VsdC5zdGF0dXN9ICR7cmVzdWx0LnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSBhd2FpdCByZXN1bHQuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIFlqcyB1cGRhdGUgYnl0ZSBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIGdlbmVyYXRlZCBmcm9tIGEgWWpzIGRvY3VtZW50IGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG4gICAqXG4gICAqIGxldCBkb2MgPSBuZXcgWS5Eb2MoKVxuICAgKiAvLyBNb2RpZnkgdGhlIGRvY3VtZW50Li4uXG4gICAqIGxldCB1cGRhdGUgPSBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKVxuICAgKiBhd2FpdCBtYW5hZ2VyLnVwZGF0ZURvYyhkb2NJZCwgdXBkYXRlKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHVwZGF0ZVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlRG9jKHVwZGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoYHVwZGF0ZWAsIFwiUE9TVFwiLCB1cGRhdGUpO1xuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgZG9jICR7dGhpcy5kb2NJZH06ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGluZy50c1xuZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjQoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmJ0b2EpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBlbmNvZGUgdG8gQmFzZTY0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBiYXNlNjRUb1N0cmluZyhpbnB1dCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuYXRvYikge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIGZyb20gQmFzZTY0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVDbGllbnRUb2tlbih0b2tlbikge1xuICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodG9rZW4pO1xuICBsZXQgYmFzZTY0ID0gc3RyaW5nVG9CYXNlNjQoanNvblN0cmluZyk7XG4gIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKFwiK1wiLCBcIi1cIikucmVwbGFjZShcIi9cIiwgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xuICByZXR1cm4gYmFzZTY0O1xufVxuZnVuY3Rpb24gZGVjb2RlQ2xpZW50VG9rZW4odG9rZW4pIHtcbiAgbGV0IGJhc2U2NCA9IHRva2VuLnJlcGxhY2UoXCItXCIsIFwiK1wiKS5yZXBsYWNlKFwiX1wiLCBcIi9cIik7XG4gIHdoaWxlIChiYXNlNjQubGVuZ3RoICUgNCkge1xuICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgfVxuICBjb25zdCBqc29uU3RyaW5nID0gYmFzZTY0VG9TdHJpbmcoYmFzZTY0KTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG59XG5cbi8vIHNyYy9tYWluLnRzXG52YXIgRG9jdW1lbnRNYW5hZ2VyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBEb2N1bWVudE1hbmFnZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmVyVG9rZW4gQSBjb25uZWN0aW9uIHN0cmluZyAoc3RhcnRpbmcgd2l0aCBgeXM6Ly9gIG9yIGB5c3M6Ly9gKSByZWZlcnJpbmcgdG8gYSB5LXN3ZWV0IHNlcnZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKGNvbm5lY3Rpb25TdHJpbmcpO1xuICAgIGxldCB0b2tlbiA9IG51bGw7XG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSkge1xuICAgICAgdG9rZW4gPSBkZWNvZGVVUklDb21wb25lbnQocGFyc2VkVXJsLnVzZXJuYW1lKTtcbiAgICB9XG4gICAgbGV0IHByb3RvY29sID0gcGFyc2VkVXJsLnByb3RvY29sO1xuICAgIGlmIChwcm90b2NvbCA9PT0gXCJ5czpcIikge1xuICAgICAgcHJvdG9jb2wgPSBcImh0dHA6XCI7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gXCJ5c3M6XCIpIHtcbiAgICAgIHByb3RvY29sID0gXCJodHRwczpcIjtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7cHJvdG9jb2x9Ly8ke3BhcnNlZFVybC5ob3N0fSR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgbGV0IGJhc2VVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IEh0dHBDbGllbnQoYmFzZVVybCwgdG9rZW4pO1xuICB9XG4gIGFzeW5jIGNoZWNrU3RvcmUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IChhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KFwiY2hlY2tfc3RvcmVcIiwgXCJQT1NUXCIsIHt9KSkuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IG9uIHRoZSB5LXN3ZWV0IHNlcnZlciBnaXZlbiBhbiBvcHRpb25hbCBkb2NJZC4gSWYgYSBkb2N1bWVudCB3aXRoIGdpdmVuXG4gICAqIElEIGFscmVhZHkgZXhpc3RzLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAqXG4gICAqIEBwYXJhbSBkb2NJZCBUaGUgSUQgb2YgdGhlIGRvY3VtZW50IHRvIGJlIGNyZWF0ZWQuIElmIG5vdCBwcm92aWRlZCwgYSByYW5kb20gSUQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIERvY0NyZWF0aW9uUmVzdWx0fSBvYmplY3QgY29udGFpbmluZyB0aGUgSUQgb2YgdGhlIGNyZWF0ZWQgZG9jdW1lbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVEb2MoZG9jSWQpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jSWQgPyB7IGRvY0lkIH0gOiB7fTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KFwiZG9jL25ld1wiLCBcIlBPU1RcIiwgYm9keSk7XG4gICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBkb2M6ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBjbGllbnQgdG9rZW4gZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICpcbiAgICogSWYgeW91IGFyZSB1c2luZyBhdXRob3JpemF0aW9uLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXIgc2VydmVyXG4gICAqIGFmdGVyIGEgdXNlciBoYXMgYXV0aGVudGljYXRlZC4gVGhlIHJldHVybmVkIHRva2VuIHNob3VsZCB0aGVuIGJlIHBhc3NlZCB0byB0aGVcbiAgICogY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZG9jSWQgVGhlIElEIG9mIHRoZSBkb2N1bWVudCB0byBnZXQgYSB0b2tlbiBmb3IuXG4gICAqIEBwYXJhbSBhdXRoRG9jUmVxdWVzdCBBbiBvcHRpb25hbCB7QGxpbmsgQXV0aERvY1JlcXVlc3R9IHByb3ZpZGluZyBvcHRpb25zIGZvciB0aGUgdG9rZW4gcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSB7QGxpbmsgQ2xpZW50VG9rZW59IG9iamVjdCBjb250YWluaW5nIHRoZSBVUkwgYW5kIHRva2VuIG5lZWRlZCB0byBjb25uZWN0IHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIGdldENsaWVudFRva2VuKGRvY0lkLCBhdXRoRG9jUmVxdWVzdCkge1xuICAgIGlmICh0eXBlb2YgZG9jSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRvY0lkID0gZG9jSWQuZG9jSWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoYGRvYy8ke2RvY0lkfS9hdXRoYCwgXCJQT1NUXCIsIGF1dGhEb2NSZXF1ZXN0ID8/IHt9KTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXV0aCBkb2MgJHtkb2NJZH06ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHdyYXBwZXIgYXJvdW5kIHtAbGluayBEb2N1bWVudE1hbmFnZXIuY3JlYXRlRG9jfSBhbmQge0BsaW5rIERvY3VtZW50TWFuYWdlci5nZXRDbGllbnRUb2tlbn0gZm9yXG4gICAqIGdldHRpbmcgYSBjbGllbnQgdG9rZW4gZm9yIGEgZG9jdW1lbnQuIElmIGEgZG9jSWQgaXMgcHJvdmlkZWQsIGVuc3VyZXMgdGhhdCBhIGRvY3VtZW50IGV4aXN0cyB3aXRoIHRoYXQgSUQgb3JcbiAgICogdGhhdCBvbmUgaXMgY3JlYXRlZC4gSWYgbm8gZG9jSWQgaXMgcHJvdmlkZWQsIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWQgd2l0aCBhIHJhbmRvbSBJRC5cbiAgICpcbiAgICogQHBhcmFtIGRvY0lkIFRoZSBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gZ2V0IG9yIGNyZWF0ZS4gSWYgbm90IHByb3ZpZGVkLCBhIG5ldyBkb2N1bWVudCB3aXRoIGEgcmFuZG9tIElEIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIGF1dGhEb2NSZXF1ZXN0IEFuIG9wdGlvbmFsIHtAbGluayBBdXRoRG9jUmVxdWVzdH0gcHJvdmlkaW5nIG9wdGlvbnMgZm9yIHRoZSB0b2tlbiByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBDbGllbnRUb2tlbn0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIFVSTCBhbmQgdG9rZW4gbmVlZGVkIHRvIGNvbm5lY3QgdG8gdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0T3JDcmVhdGVEb2NBbmRUb2tlbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNyZWF0ZURvYyhkb2NJZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q2xpZW50VG9rZW4ocmVzdWx0LCBhdXRoRG9jUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW50aXJlIGRvY3VtZW50LCByZXByZXNlbnRlZCBhcyBhIFlqcyB1cGRhdGUgYnl0ZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBkb2NJZCBUaGUgSUQgb2YgdGhlIGRvY3VtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGRvY3VtZW50IGFzIGEgWWpzIHVwZGF0ZSBieXRlIHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgZ2V0RG9jQXNVcGRhdGUoZG9jSWQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5nZXREb2NDb25uZWN0aW9uKGRvY0lkKTtcbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5nZXRBc1VwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gWWpzIHVwZGF0ZSBieXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGRvY0lkIFRoZSBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gdXBkYXRlIFRoZSBZanMgdXBkYXRlIGJ5dGUgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZURvYyhkb2NJZCwgdXBkYXRlKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZ2V0RG9jQ29ubmVjdGlvbihkb2NJZCk7XG4gICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24udXBkYXRlRG9jKHVwZGF0ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RG9jQ29ubmVjdGlvbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpIHtcbiAgICBjb25zdCBjbGllbnRUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50VG9rZW4oZG9jSWQsIGF1dGhEb2NSZXF1ZXN0KTtcbiAgICByZXR1cm4gbmV3IERvY0Nvbm5lY3Rpb24oY2xpZW50VG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHdpdGggaW5pdGlhbCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdXBkYXRlIEEgWWpzIHVwZGF0ZSBieXRlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGluaXRpYWwgY29udGVudC5cbiAgICogQHJldHVybnMgQSB7QGxpbmsgRG9jQ3JlYXRpb25SZXN1bHR9IG9iamVjdCBjb250YWluaW5nIHRoZSBJRCBvZiB0aGUgY3JlYXRlZCBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZURvY1dpdGhDb250ZW50KHVwZGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY3JlYXRlRG9jKCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVEb2MocmVzdWx0LmRvY0lkLCB1cGRhdGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZURvY0FuZFRva2VuKGNvbm5lY3Rpb25TdHJpbmcsIGRvY0lkLCBhdXRoRG9jUmVxdWVzdCkge1xuICBjb25zdCBtYW5hZ2VyID0gbmV3IERvY3VtZW50TWFuYWdlcihjb25uZWN0aW9uU3RyaW5nKTtcbiAgcmV0dXJuIGF3YWl0IG1hbmFnZXIuZ2V0T3JDcmVhdGVEb2NBbmRUb2tlbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50VG9rZW4oY29ubmVjdGlvblN0cmluZywgZG9jSWQsIGF1dGhEb2NSZXF1ZXN0KSB7XG4gIGNvbnN0IG1hbmFnZXIgPSBuZXcgRG9jdW1lbnRNYW5hZ2VyKGNvbm5lY3Rpb25TdHJpbmcpO1xuICByZXR1cm4gYXdhaXQgbWFuYWdlci5nZXRDbGllbnRUb2tlbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRG9jKGNvbm5lY3Rpb25TdHJpbmcsIGRvY0lkKSB7XG4gIGNvbnN0IG1hbmFnZXIgPSBuZXcgRG9jdW1lbnRNYW5hZ2VyKGNvbm5lY3Rpb25TdHJpbmcpO1xuICByZXR1cm4gYXdhaXQgbWFuYWdlci5jcmVhdGVEb2MoZG9jSWQpO1xufVxuZXhwb3J0IHtcbiAgRG9jQ29ubmVjdGlvbixcbiAgRG9jdW1lbnRNYW5hZ2VyLFxuICBZU3dlZXRFcnJvcixcbiAgY3JlYXRlRG9jLFxuICBkZWNvZGVDbGllbnRUb2tlbixcbiAgZW5jb2RlQ2xpZW50VG9rZW4sXG4gIGdldENsaWVudFRva2VuLFxuICBnZXRPckNyZWF0ZURvY0FuZFRva2VuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@y-sweet/sdk/dist/main.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@y-sweet/client/dist/main.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@y-sweet/client/dist/main.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EVENT_CONNECTION_STATUS: () => (/* binding */ EVENT_CONNECTION_STATUS),\n/* harmony export */   EVENT_LOCAL_CHANGES: () => (/* binding */ EVENT_LOCAL_CHANGES),\n/* harmony export */   STATUS_CONNECTED: () => (/* binding */ STATUS_CONNECTED),\n/* harmony export */   STATUS_CONNECTING: () => (/* binding */ STATUS_CONNECTING),\n/* harmony export */   STATUS_ERROR: () => (/* binding */ STATUS_ERROR),\n/* harmony export */   STATUS_HANDSHAKING: () => (/* binding */ STATUS_HANDSHAKING),\n/* harmony export */   STATUS_OFFLINE: () => (/* binding */ STATUS_OFFLINE),\n/* harmony export */   YSweetProvider: () => (/* binding */ YSweetProvider2),\n/* harmony export */   createYjsProvider: () => (/* binding */ createYjsProvider),\n/* harmony export */   debuggerUrl: () => (/* binding */ debuggerUrl)\n/* harmony export */ });\n/* harmony import */ var _y_sweet_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @y-sweet/sdk */ \"(ssr)/./node_modules/@y-sweet/sdk/dist/main.mjs\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-protocols/awareness */ \"(ssr)/./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var y_protocols_sync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/sync */ \"(ssr)/./node_modules/y-protocols/sync.js\");\n// src/main.ts\n\n\n// ../../node_modules/lib0/binary.js\nvar BIT8 = 128;\nvar BIT18 = 1 << 17;\nvar BIT19 = 1 << 18;\nvar BIT20 = 1 << 19;\nvar BIT21 = 1 << 20;\nvar BIT22 = 1 << 21;\nvar BIT23 = 1 << 22;\nvar BIT24 = 1 << 23;\nvar BIT25 = 1 << 24;\nvar BIT26 = 1 << 25;\nvar BIT27 = 1 << 26;\nvar BIT28 = 1 << 27;\nvar BIT29 = 1 << 28;\nvar BIT30 = 1 << 29;\nvar BIT31 = 1 << 30;\nvar BIT32 = 1 << 31;\nvar BITS7 = 127;\nvar BITS17 = BIT18 - 1;\nvar BITS18 = BIT19 - 1;\nvar BITS19 = BIT20 - 1;\nvar BITS20 = BIT21 - 1;\nvar BITS21 = BIT22 - 1;\nvar BITS22 = BIT23 - 1;\nvar BITS23 = BIT24 - 1;\nvar BITS24 = BIT25 - 1;\nvar BITS25 = BIT26 - 1;\nvar BITS26 = BIT27 - 1;\nvar BITS27 = BIT28 - 1;\nvar BITS28 = BIT29 - 1;\nvar BITS29 = BIT30 - 1;\nvar BITS30 = BIT31 - 1;\n\n// ../../node_modules/lib0/math.js\nvar floor = Math.floor;\nvar min = (a, b) => a < b ? a : b;\nvar max = (a, b) => a > b ? a : b;\nvar isNaN = Number.isNaN;\n\n// ../../node_modules/lib0/number.js\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar LOWEST_INT32 = 1 << 31;\nvar isInteger = Number.isInteger || ((num) => typeof num === \"number\" && isFinite(num) && floor(num) === num);\nvar isNaN2 = Number.isNaN;\nvar parseInt = Number.parseInt;\n\n// ../../node_modules/lib0/string.js\nvar fromCharCode = String.fromCharCode;\nvar fromCodePoint = String.fromCodePoint;\nvar MAX_UTF16_CHARACTER = fromCharCode(65535);\nvar _encodeUtf8Polyfill = (str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */\n    encodedString.codePointAt(i);\n  }\n  return buf;\n};\nvar utf8TextEncoder = (\n  /** @type {TextEncoder} */\n  typeof TextEncoder !== \"undefined\" ? new TextEncoder() : null\n);\nvar _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);\nvar encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\nvar utf8TextDecoder = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf-8\", { fatal: true, ignoreBOM: true });\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  utf8TextDecoder = null;\n}\n\n// ../../node_modules/lib0/error.js\nvar create = (s) => new Error(s);\n\n// ../../node_modules/lib0/encoding.js\nvar Encoder = class {\n  constructor() {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    this.bufs = [];\n  }\n};\nvar createEncoder = () => new Encoder();\nvar length = (encoder) => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len;\n};\nvar toUint8Array = (encoder) => {\n  const uint8arr = new Uint8Array(length(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr;\n};\nvar write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\nvar writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | BITS7 & num);\n    num = floor(num / 128);\n  }\n  write(encoder, BITS7 & num);\n};\nvar _strBuffer = new Uint8Array(3e4);\nvar _maxStrBSize = _strBuffer.length / 3;\nvar _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\nvar _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(\n      encoder,\n      /** @type {number} */\n      encodedString.codePointAt(i)\n    );\n  }\n};\nvar writeVarString = utf8TextEncoder && /** @type {any} */\nutf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;\nvar writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\nvar writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\nvar floatTestBed = new DataView(new ArrayBuffer(4));\n\n// ../../node_modules/lib0/decoding.js\nvar errorUnexpectedEndOfArray = create(\"Unexpected end of array\");\nvar errorIntegerOutOfRange = create(\"Integer out of Range\");\nvar Decoder = class {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor(uint8Array) {\n    this.arr = uint8Array;\n    this.pos = 0;\n  }\n};\nvar createDecoder = (uint8Array) => new Decoder(uint8Array);\nvar readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view;\n};\nvar readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));\nvar readVarUint = (decoder) => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return num;\n    }\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n  }\n  throw errorUnexpectedEndOfArray;\n};\n\n// src/provider.ts\n\n\n\n// src/ws-status.ts\nvar EVENT_STATUS = \"status\";\nvar EVENT_SYNC = \"sync\";\nvar EVENT_CONNECTION_CLOSE = \"connection-close\";\nvar EVENT_CONNECTION_ERROR = \"connection-error\";\nvar EVENT_SYNCED = \"synced\";\nvar WEBSOCKET_STATUS_CONNECTED = \"connected\";\nvar WEBSOCKET_STATUS_DISCONNECTED = \"disconnected\";\nvar WEBSOCKET_STATUS_CONNECTING = \"connecting\";\nfunction translateStatus(status) {\n  if (status === STATUS_CONNECTED) {\n    return WEBSOCKET_STATUS_CONNECTED;\n  } else if ([STATUS_CONNECTING, STATUS_HANDSHAKING].includes(status)) {\n    return WEBSOCKET_STATUS_CONNECTING;\n  } else {\n    return WEBSOCKET_STATUS_DISCONNECTED;\n  }\n}\nvar WebSocketCompatLayer = class {\n  constructor(provider) {\n    this.provider = provider;\n    this.lastStatus = WEBSOCKET_STATUS_DISCONNECTED;\n    this.lastSyncStatus = false;\n    this.provider.on(EVENT_CONNECTION_STATUS, this.updateStatus.bind(this));\n  }\n  updateStatus(status) {\n    const newStatus = translateStatus(status);\n    const syncStatus = status === STATUS_CONNECTED;\n    if (this.lastSyncStatus !== syncStatus) {\n      this.lastSyncStatus = syncStatus;\n      this.provider.emit(EVENT_SYNC, syncStatus);\n      this.provider.emit(EVENT_SYNCED, syncStatus);\n    }\n    if (this.lastStatus !== newStatus) {\n      this.lastStatus = newStatus;\n      this.provider.emit(EVENT_STATUS, { status: newStatus });\n    }\n  }\n};\n\n// src/provider.ts\nvar MESSAGE_SYNC = 0;\nvar MESSAGE_QUERY_AWARENESS = 3;\nvar MESSAGE_AWARENESS = 1;\nvar MESSAGE_SYNC_STATUS = 102;\nvar RETRIES_BEFORE_TOKEN_REFRESH = 3;\nvar DELAY_MS_BEFORE_RECONNECT = 500;\nvar DELAY_MS_BEFORE_RETRY_TOKEN_REFRESH = 3e3;\nvar EVENT_LOCAL_CHANGES = \"local-changes\";\nvar EVENT_CONNECTION_STATUS = \"connection-status\";\nvar STATUS_OFFLINE = \"offline\";\nvar STATUS_CONNECTING = \"connecting\";\nvar STATUS_ERROR = \"error\";\nvar STATUS_HANDSHAKING = \"handshaking\";\nvar STATUS_CONNECTED = \"connected\";\nasync function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nasync function getClientToken(authEndpoint, roomname) {\n  if (typeof authEndpoint === \"function\") {\n    return await authEndpoint();\n  }\n  const body = JSON.stringify({ docId: roomname });\n  const res = await fetch(authEndpoint, {\n    method: \"POST\",\n    body,\n    headers: { \"Content-Type\": \"application/json\" }\n  });\n  if (!res.ok) {\n    throw new Error(`Failed to get client token: ${res.status} ${res.statusText}`);\n  }\n  const clientToken = await res.json();\n  if (clientToken.docId !== roomname) {\n    throw new Error(\n      `Client token docId does not match roomname: ${clientToken.docId} !== ${roomname}`\n    );\n  }\n  return clientToken;\n}\nvar YSweetProvider2 = class {\n  constructor(authEndpoint, docId, doc, extraOptions = {}) {\n    this.authEndpoint = authEndpoint;\n    this.docId = docId;\n    this.doc = doc;\n    /** Current client token. */\n    this.clientToken = null;\n    /** Whether the local document has unsynced changes. */\n    this.hasLocalChanges = true;\n    /** Connection status. */\n    this.status = STATUS_OFFLINE;\n    this.websocket = null;\n    this.listeners = /* @__PURE__ */ new Map();\n    this.lastSyncSent = 0;\n    this.lastSyncAcked = -1;\n    /** Whether a (re)connect loop is currently running. This acts as a lock to prevent two concurrent connect loops. */\n    this.isConnecting = false;\n    if (extraOptions.initialClientToken) {\n      this.clientToken = extraOptions.initialClientToken;\n    }\n    new WebSocketCompatLayer(this);\n    this.awareness = extraOptions.awareness ?? new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.Awareness(doc);\n    this.awareness.on(\"update\", this.handleAwarenessUpdate.bind(this));\n    this.WebSocketPolyfill = extraOptions.WebSocketPolyfill || WebSocket;\n    doc.on(\"update\", this.update.bind(this));\n    if (extraOptions.connect !== false) {\n      this.connect();\n    }\n  }\n  send(message) {\n    if (this.websocket?.readyState === this.WebSocketPolyfill.OPEN) {\n      this.websocket.send(message);\n    }\n  }\n  updateSyncedState() {\n    let hasLocalChanges = this.lastSyncAcked !== this.lastSyncSent;\n    if (hasLocalChanges === this.hasLocalChanges) {\n      return;\n    }\n    this.hasLocalChanges = hasLocalChanges;\n    this.emit(EVENT_LOCAL_CHANGES, hasLocalChanges);\n  }\n  setStatus(status) {\n    if (this.status === status) {\n      return;\n    }\n    this.status = status;\n    this.emit(EVENT_CONNECTION_STATUS, status);\n  }\n  update(update, origin) {\n    if (origin !== this) {\n      const encoder = createEncoder();\n      writeVarUint(encoder, MESSAGE_SYNC);\n      y_protocols_sync__WEBPACK_IMPORTED_MODULE_2__.writeUpdate(encoder, update);\n      this.send(toUint8Array(encoder));\n      this.checkSync();\n    }\n  }\n  checkSync() {\n    this.lastSyncSent += 1;\n    const encoder = createEncoder();\n    writeVarUint(encoder, MESSAGE_SYNC_STATUS);\n    const versionEncoder = createEncoder();\n    writeVarUint(versionEncoder, this.lastSyncSent);\n    writeVarUint8Array(encoder, toUint8Array(versionEncoder));\n    this.send(toUint8Array(encoder));\n    this.updateSyncedState();\n  }\n  async ensureClientToken() {\n    if (this.clientToken) {\n      return this.clientToken;\n    }\n    if (typeof this.authEndpoint === \"string\") {\n      this.clientToken = await getClientToken(this.authEndpoint, this.docId);\n      return this.clientToken;\n    } else {\n      this.clientToken = await this.authEndpoint();\n      return this.clientToken;\n    }\n  }\n  /**\n   * Attempts to connect to the websocket.\n   * Returns a promise that resolves to true if the connection was successful, or false if the connection failed.\n   */\n  attemptToConnect(clientToken) {\n    let promise = new Promise((resolve) => {\n      let statusListener = (event) => {\n        if (event === STATUS_CONNECTED) {\n          this.off(EVENT_CONNECTION_STATUS, statusListener);\n          resolve(true);\n        } else if (event === STATUS_ERROR) {\n          this.off(EVENT_CONNECTION_STATUS, statusListener);\n          resolve(false);\n        }\n      };\n      this.on(EVENT_CONNECTION_STATUS, statusListener);\n    });\n    let url = this.generateUrl(clientToken);\n    this.setStatus(STATUS_CONNECTING);\n    const websocket = new (this.WebSocketPolyfill || WebSocket)(url);\n    this.bindWebsocket(websocket);\n    return promise;\n  }\n  async connect() {\n    if (this.isConnecting) {\n      console.warn(\"connect() called while a connect loop is already running.\");\n      return;\n    }\n    this.isConnecting = true;\n    this.setStatus(STATUS_CONNECTING);\n    while (![STATUS_OFFLINE, STATUS_CONNECTED].includes(this.status)) {\n      this.setStatus(STATUS_CONNECTING);\n      let clientToken;\n      try {\n        clientToken = await this.ensureClientToken();\n      } catch (e) {\n        console.warn(\"Failed to get client token\", e);\n        this.setStatus(STATUS_ERROR);\n        await sleep(DELAY_MS_BEFORE_RETRY_TOKEN_REFRESH);\n        continue;\n      }\n      for (let i = 0; i < RETRIES_BEFORE_TOKEN_REFRESH; i++) {\n        if (await this.attemptToConnect(clientToken)) {\n          break;\n        }\n        await sleep(DELAY_MS_BEFORE_RECONNECT);\n      }\n      this.clientToken = null;\n    }\n    this.isConnecting = false;\n  }\n  disconnect() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n    this.setStatus(STATUS_OFFLINE);\n  }\n  bindWebsocket(websocket) {\n    if (this.websocket) {\n      this.websocket.close();\n      this.websocket.onopen = null;\n      this.websocket.onmessage = null;\n      this.websocket.onclose = null;\n      this.websocket.onerror = null;\n    }\n    this.websocket = websocket;\n    this.websocket.binaryType = \"arraybuffer\";\n    this.websocket.onopen = this.websocketOpen.bind(this);\n    this.websocket.onmessage = this.receiveMessage.bind(this);\n    this.websocket.onclose = this.websocketClose.bind(this);\n    this.websocket.onerror = this.websocketError.bind(this);\n  }\n  generateUrl(clientToken) {\n    const url = clientToken.url + `/${clientToken.docId}`;\n    if (clientToken.token) {\n      return `${url}?token=${clientToken.token}`;\n    }\n    return url;\n  }\n  syncStep1() {\n    const encoder = createEncoder();\n    writeVarUint(encoder, MESSAGE_SYNC);\n    y_protocols_sync__WEBPACK_IMPORTED_MODULE_2__.writeSyncStep1(encoder, this.doc);\n    this.send(toUint8Array(encoder));\n  }\n  receiveSyncMessage(decoder) {\n    const encoder = createEncoder();\n    writeVarUint(encoder, MESSAGE_SYNC);\n    const syncMessageType = y_protocols_sync__WEBPACK_IMPORTED_MODULE_2__.readSyncMessage(decoder, encoder, this.doc, this);\n    if (syncMessageType === y_protocols_sync__WEBPACK_IMPORTED_MODULE_2__.messageYjsSyncStep2) {\n      this.setStatus(STATUS_CONNECTED);\n    }\n    if (length(encoder) > 1) {\n      this.send(toUint8Array(encoder));\n    }\n  }\n  queryAwareness() {\n    const encoder = createEncoder();\n    writeVarUint(encoder, MESSAGE_QUERY_AWARENESS);\n    writeVarUint8Array(\n      encoder,\n      y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.encodeAwarenessUpdate(\n        this.awareness,\n        Array.from(this.awareness.getStates().keys())\n      )\n    );\n    this.send(toUint8Array(encoder));\n  }\n  broadcastAwareness() {\n    if (this.awareness.getLocalState() !== null) {\n      const encoderAwarenessState = createEncoder();\n      writeVarUint(encoderAwarenessState, MESSAGE_AWARENESS);\n      writeVarUint8Array(\n        encoderAwarenessState,\n        y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID])\n      );\n      this.send(toUint8Array(encoderAwarenessState));\n    }\n  }\n  updateAwareness(decoder) {\n    y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.applyAwarenessUpdate(\n      this.awareness,\n      readVarUint8Array(decoder),\n      this\n    );\n  }\n  websocketOpen() {\n    this.setStatus(STATUS_HANDSHAKING);\n    this.syncStep1();\n    this.checkSync();\n    this.broadcastAwareness();\n  }\n  receiveMessage(event) {\n    let message = new Uint8Array(event.data);\n    const decoder = createDecoder(message);\n    const messageType = readVarUint(decoder);\n    switch (messageType) {\n      case MESSAGE_SYNC:\n        this.receiveSyncMessage(decoder);\n        break;\n      case MESSAGE_AWARENESS:\n        this.updateAwareness(decoder);\n        break;\n      case MESSAGE_QUERY_AWARENESS:\n        this.queryAwareness();\n        break;\n      case MESSAGE_SYNC_STATUS:\n        let lastSyncBytes = readVarUint8Array(decoder);\n        let d2 = createDecoder(lastSyncBytes);\n        this.lastSyncAcked = readVarUint(d2);\n        this.updateSyncedState();\n        break;\n      default:\n        break;\n    }\n  }\n  websocketClose(event) {\n    this.emit(EVENT_CONNECTION_CLOSE, event);\n    this.setStatus(STATUS_ERROR);\n    this.connect();\n    y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.removeAwarenessStates(\n      this.awareness,\n      Array.from(this.awareness.getStates().keys()).filter(\n        (client) => client !== this.doc.clientID\n      ),\n      this\n    );\n  }\n  websocketError(event) {\n    this.emit(EVENT_CONNECTION_ERROR, event);\n    this.setStatus(STATUS_ERROR);\n    this.connect();\n  }\n  emit(eventName, data = null) {\n    const listeners = this.listeners.get(eventName) || /* @__PURE__ */ new Set();\n    for (const listener of listeners) {\n      listener(data);\n    }\n  }\n  handleAwarenessUpdate({ added, updated, removed }, _origin) {\n    const changedClients = added.concat(updated).concat(removed);\n    const encoder = createEncoder();\n    writeVarUint(encoder, MESSAGE_AWARENESS);\n    writeVarUint8Array(\n      encoder,\n      y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.encodeAwarenessUpdate(this.awareness, changedClients)\n    );\n    this.websocket?.send(toUint8Array(encoder));\n  }\n  destroy() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n    y_protocols_awareness__WEBPACK_IMPORTED_MODULE_1__.removeAwarenessStates(this.awareness, [this.doc.clientID], \"window unload\");\n  }\n  _on(type, listener, once) {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, /* @__PURE__ */ new Set());\n    }\n    if (once) {\n      let listenerOnce = (d) => {\n        listener(d);\n        this.listeners.get(type)?.delete(listenerOnce);\n      };\n      this.listeners.get(type)?.add(listenerOnce);\n    } else {\n      this.listeners.get(type)?.add(listener);\n    }\n  }\n  on(type, listener) {\n    this._on(type, listener);\n  }\n  once(type, listener) {\n    this._on(type, listener, true);\n  }\n  off(type, listener) {\n    const listeners = this.listeners.get(type);\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n  /**\n   * Whether the provider should attempt to connect.\n   *\n   * @deprecated use provider.status !== 'offline' instead, or call `provider.connect()` / `provider.disconnect()` to set.\n   */\n  get shouldConnect() {\n    return this.status !== STATUS_OFFLINE;\n  }\n  /**\n   * Whether the underlying websocket is connected.\n   *\n   * @deprecated use provider.status === 'connected' || provider.status === 'handshaking' instead.\n   */\n  get wsconnected() {\n    return this.status === STATUS_CONNECTED || this.status === STATUS_HANDSHAKING;\n  }\n  /**\n   * Whether the underlying websocket is connecting.\n   *\n   * @deprecated use provider.status === 'connecting' instead.\n   */\n  get wsconnecting() {\n    return this.status === STATUS_CONNECTING;\n  }\n  /**\n   * Whether the document is synced. (For compatibility with y-websocket.)\n   *\n   * @deprecated use provider.status === 'connected' instead.\n   * */\n  get synced() {\n    return this.status === STATUS_CONNECTED;\n  }\n};\n\n// src/main.ts\nfunction createYjsProvider(doc, docId, authEndpoint, extraOptions = {}) {\n  return new YSweetProvider2(authEndpoint, docId, doc, extraOptions);\n}\nfunction debuggerUrl(clientToken) {\n  const payload = (0,_y_sweet_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeClientToken)(clientToken);\n  return `https://debugger.y-sweet.dev/?payload=${payload}`;\n}\n\n//# sourceMappingURL=main.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHktc3dlZXQvY2xpZW50L2Rpc3QvbWFpbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2lEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsOEJBQThCO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBNEI7QUFDeEQsNEJBQTRCLGlFQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3RUFBdUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RUFBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQXVDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0VBQXVDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RUFBdUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFpQjtBQUNuQyxrREFBa0QsUUFBUTtBQUMxRDtBQVlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYWNrZWQvRG9jdW1lbnRzL0dpdEh1Yi9zaGFyZS95c3dlZXQvanVzdHNoYXJlL25vZGVfbW9kdWxlcy9AeS1zd2VldC9jbGllbnQvZGlzdC9tYWluLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbWFpbi50c1xuaW1wb3J0IHsgZW5jb2RlQ2xpZW50VG9rZW4gfSBmcm9tIFwiQHktc3dlZXQvc2RrXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9saWIwL2JpbmFyeS5qc1xudmFyIEJJVDggPSAxMjg7XG52YXIgQklUMTggPSAxIDw8IDE3O1xudmFyIEJJVDE5ID0gMSA8PCAxODtcbnZhciBCSVQyMCA9IDEgPDwgMTk7XG52YXIgQklUMjEgPSAxIDw8IDIwO1xudmFyIEJJVDIyID0gMSA8PCAyMTtcbnZhciBCSVQyMyA9IDEgPDwgMjI7XG52YXIgQklUMjQgPSAxIDw8IDIzO1xudmFyIEJJVDI1ID0gMSA8PCAyNDtcbnZhciBCSVQyNiA9IDEgPDwgMjU7XG52YXIgQklUMjcgPSAxIDw8IDI2O1xudmFyIEJJVDI4ID0gMSA8PCAyNztcbnZhciBCSVQyOSA9IDEgPDwgMjg7XG52YXIgQklUMzAgPSAxIDw8IDI5O1xudmFyIEJJVDMxID0gMSA8PCAzMDtcbnZhciBCSVQzMiA9IDEgPDwgMzE7XG52YXIgQklUUzcgPSAxMjc7XG52YXIgQklUUzE3ID0gQklUMTggLSAxO1xudmFyIEJJVFMxOCA9IEJJVDE5IC0gMTtcbnZhciBCSVRTMTkgPSBCSVQyMCAtIDE7XG52YXIgQklUUzIwID0gQklUMjEgLSAxO1xudmFyIEJJVFMyMSA9IEJJVDIyIC0gMTtcbnZhciBCSVRTMjIgPSBCSVQyMyAtIDE7XG52YXIgQklUUzIzID0gQklUMjQgLSAxO1xudmFyIEJJVFMyNCA9IEJJVDI1IC0gMTtcbnZhciBCSVRTMjUgPSBCSVQyNiAtIDE7XG52YXIgQklUUzI2ID0gQklUMjcgLSAxO1xudmFyIEJJVFMyNyA9IEJJVDI4IC0gMTtcbnZhciBCSVRTMjggPSBCSVQyOSAtIDE7XG52YXIgQklUUzI5ID0gQklUMzAgLSAxO1xudmFyIEJJVFMzMCA9IEJJVDMxIC0gMTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWF0aC5qc1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBtaW4gPSAoYSwgYikgPT4gYSA8IGIgPyBhIDogYjtcbnZhciBtYXggPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYjtcbnZhciBpc05hTiA9IE51bWJlci5pc05hTjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xudmFyIE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbnZhciBMT1dFU1RfSU5UMzIgPSAxIDw8IDMxO1xudmFyIGlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgKChudW0pID0+IHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUobnVtKSAmJiBmbG9vcihudW0pID09PSBudW0pO1xudmFyIGlzTmFOMiA9IE51bWJlci5pc05hTjtcbnZhciBwYXJzZUludCA9IE51bWJlci5wYXJzZUludDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzXG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG52YXIgTUFYX1VURjE2X0NIQVJBQ1RFUiA9IGZyb21DaGFyQ29kZSg2NTUzNSk7XG52YXIgX2VuY29kZVV0ZjhQb2x5ZmlsbCA9IChzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICBlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xudmFyIHV0ZjhUZXh0RW5jb2RlciA9IChcbiAgLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi9cbiAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsXG4pO1xudmFyIF9lbmNvZGVVdGY4TmF0aXZlID0gKHN0cikgPT4gdXRmOFRleHRFbmNvZGVyLmVuY29kZShzdHIpO1xudmFyIGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGw7XG52YXIgdXRmOFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KTtcbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgdXRmOFRleHREZWNvZGVyID0gbnVsbDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvZXJyb3IuanNcbnZhciBjcmVhdGUgPSAocykgPT4gbmV3IEVycm9yKHMpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9lbmNvZGluZy5qc1xudmFyIEVuY29kZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY3BvcyA9IDA7XG4gICAgdGhpcy5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTAwKTtcbiAgICB0aGlzLmJ1ZnMgPSBbXTtcbiAgfVxufTtcbnZhciBjcmVhdGVFbmNvZGVyID0gKCkgPT4gbmV3IEVuY29kZXIoKTtcbnZhciBsZW5ndGggPSAoZW5jb2RlcikgPT4ge1xuICBsZXQgbGVuID0gZW5jb2Rlci5jcG9zO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGxlbiArPSBlbmNvZGVyLmJ1ZnNbaV0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBsZW47XG59O1xudmFyIHRvVWludDhBcnJheSA9IChlbmNvZGVyKSA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKGVuY29kZXIpKTtcbiAgbGV0IGN1clBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGVuY29kZXIuYnVmc1tpXTtcbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKTtcbiAgICBjdXJQb3MgKz0gZC5sZW5ndGg7XG4gIH1cbiAgdWludDhhcnIuc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcyksIGN1clBvcyk7XG4gIHJldHVybiB1aW50OGFycjtcbn07XG52YXIgd3JpdGUgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGlmIChlbmNvZGVyLmNwb3MgPT09IGJ1ZmZlckxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuICogMik7XG4gICAgZW5jb2Rlci5jcG9zID0gMDtcbiAgfVxuICBlbmNvZGVyLmNidWZbZW5jb2Rlci5jcG9zKytdID0gbnVtO1xufTtcbnZhciB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBCSVRTNykge1xuICAgIHdyaXRlKGVuY29kZXIsIEJJVDggfCBCSVRTNyAmIG51bSk7XG4gICAgbnVtID0gZmxvb3IobnVtIC8gMTI4KTtcbiAgfVxuICB3cml0ZShlbmNvZGVyLCBCSVRTNyAmIG51bSk7XG59O1xudmFyIF9zdHJCdWZmZXIgPSBuZXcgVWludDhBcnJheSgzZTQpO1xudmFyIF9tYXhTdHJCU2l6ZSA9IF9zdHJCdWZmZXIubGVuZ3RoIC8gMztcbnZhciBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGlmIChzdHIubGVuZ3RoIDwgX21heFN0ckJTaXplKSB7XG4gICAgY29uc3Qgd3JpdHRlbiA9IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0ciwgX3N0ckJ1ZmZlcikud3JpdHRlbiB8fCAwO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCB3cml0dGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGVVdGY4KHN0cikpO1xuICB9XG59O1xudmFyIF93cml0ZVZhclN0cmluZ1BvbHlmaWxsID0gKGVuY29kZXIsIHN0cikgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB3cml0ZShcbiAgICAgIGVuY29kZXIsXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSlcbiAgICApO1xuICB9XG59O1xudmFyIHdyaXRlVmFyU3RyaW5nID0gdXRmOFRleHRFbmNvZGVyICYmIC8qKiBAdHlwZSB7YW55fSAqL1xudXRmOFRleHRFbmNvZGVyLmVuY29kZUludG8gPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbDtcbnZhciB3cml0ZVVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zO1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW47XG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpO1xuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW47XG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShtYXgoYnVmZmVyTGVuICogMiwgcmlnaHRDb3B5TGVuKSk7XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSk7XG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuO1xuICB9XG59O1xudmFyIHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdWludDhBcnJheSk7XG59O1xudmFyIGZsb2F0VGVzdEJlZCA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9kZWNvZGluZy5qc1xudmFyIGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXkgPSBjcmVhdGUoXCJVbmV4cGVjdGVkIGVuZCBvZiBhcnJheVwiKTtcbnZhciBlcnJvckludGVnZXJPdXRPZlJhbmdlID0gY3JlYXRlKFwiSW50ZWdlciBvdXQgb2YgUmFuZ2VcIik7XG52YXIgRGVjb2RlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheSBCaW5hcnkgZGF0YSB0byBkZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmFyciA9IHVpbnQ4QXJyYXk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG59O1xudmFyIGNyZWF0ZURlY29kZXIgPSAodWludDhBcnJheSkgPT4gbmV3IERlY29kZXIodWludDhBcnJheSk7XG52YXIgcmVhZFVpbnQ4QXJyYXkgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShkZWNvZGVyLmFyci5idWZmZXIsIGRlY29kZXIucG9zICsgZGVjb2Rlci5hcnIuYnl0ZU9mZnNldCwgbGVuKTtcbiAgZGVjb2Rlci5wb3MgKz0gbGVuO1xuICByZXR1cm4gdmlldztcbn07XG52YXIgcmVhZFZhclVpbnQ4QXJyYXkgPSAoZGVjb2RlcikgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xudmFyIHJlYWRWYXJVaW50ID0gKGRlY29kZXIpID0+IHtcbiAgbGV0IG51bSA9IDA7XG4gIGxldCBtdWx0ID0gMTtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5hcnIubGVuZ3RoO1xuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gICAgbnVtID0gbnVtICsgKHIgJiBCSVRTNykgKiBtdWx0O1xuICAgIG11bHQgKj0gMTI4O1xuICAgIGlmIChyIDwgQklUOCkge1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgaWYgKG51bSA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2U7XG4gICAgfVxuICB9XG4gIHRocm93IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXk7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbmltcG9ydCAqIGFzIGF3YXJlbmVzc1Byb3RvY29sIGZyb20gXCJ5LXByb3RvY29scy9hd2FyZW5lc3NcIjtcbmltcG9ydCAqIGFzIHN5bmNQcm90b2NvbCBmcm9tIFwieS1wcm90b2NvbHMvc3luY1wiO1xuXG4vLyBzcmMvd3Mtc3RhdHVzLnRzXG52YXIgRVZFTlRfU1RBVFVTID0gXCJzdGF0dXNcIjtcbnZhciBFVkVOVF9TWU5DID0gXCJzeW5jXCI7XG52YXIgRVZFTlRfQ09OTkVDVElPTl9DTE9TRSA9IFwiY29ubmVjdGlvbi1jbG9zZVwiO1xudmFyIEVWRU5UX0NPTk5FQ1RJT05fRVJST1IgPSBcImNvbm5lY3Rpb24tZXJyb3JcIjtcbnZhciBFVkVOVF9TWU5DRUQgPSBcInN5bmNlZFwiO1xudmFyIFdFQlNPQ0tFVF9TVEFUVVNfQ09OTkVDVEVEID0gXCJjb25uZWN0ZWRcIjtcbnZhciBXRUJTT0NLRVRfU1RBVFVTX0RJU0NPTk5FQ1RFRCA9IFwiZGlzY29ubmVjdGVkXCI7XG52YXIgV0VCU09DS0VUX1NUQVRVU19DT05ORUNUSU5HID0gXCJjb25uZWN0aW5nXCI7XG5mdW5jdGlvbiB0cmFuc2xhdGVTdGF0dXMoc3RhdHVzKSB7XG4gIGlmIChzdGF0dXMgPT09IFNUQVRVU19DT05ORUNURUQpIHtcbiAgICByZXR1cm4gV0VCU09DS0VUX1NUQVRVU19DT05ORUNURUQ7XG4gIH0gZWxzZSBpZiAoW1NUQVRVU19DT05ORUNUSU5HLCBTVEFUVVNfSEFORFNIQUtJTkddLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICByZXR1cm4gV0VCU09DS0VUX1NUQVRVU19DT05ORUNUSU5HO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBXRUJTT0NLRVRfU1RBVFVTX0RJU0NPTk5FQ1RFRDtcbiAgfVxufVxudmFyIFdlYlNvY2tldENvbXBhdExheWVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLmxhc3RTdGF0dXMgPSBXRUJTT0NLRVRfU1RBVFVTX0RJU0NPTk5FQ1RFRDtcbiAgICB0aGlzLmxhc3RTeW5jU3RhdHVzID0gZmFsc2U7XG4gICAgdGhpcy5wcm92aWRlci5vbihFVkVOVF9DT05ORUNUSU9OX1NUQVRVUywgdGhpcy51cGRhdGVTdGF0dXMuYmluZCh0aGlzKSk7XG4gIH1cbiAgdXBkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIGNvbnN0IG5ld1N0YXR1cyA9IHRyYW5zbGF0ZVN0YXR1cyhzdGF0dXMpO1xuICAgIGNvbnN0IHN5bmNTdGF0dXMgPSBzdGF0dXMgPT09IFNUQVRVU19DT05ORUNURUQ7XG4gICAgaWYgKHRoaXMubGFzdFN5bmNTdGF0dXMgIT09IHN5bmNTdGF0dXMpIHtcbiAgICAgIHRoaXMubGFzdFN5bmNTdGF0dXMgPSBzeW5jU3RhdHVzO1xuICAgICAgdGhpcy5wcm92aWRlci5lbWl0KEVWRU5UX1NZTkMsIHN5bmNTdGF0dXMpO1xuICAgICAgdGhpcy5wcm92aWRlci5lbWl0KEVWRU5UX1NZTkNFRCwgc3luY1N0YXR1cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RTdGF0dXMgIT09IG5ld1N0YXR1cykge1xuICAgICAgdGhpcy5sYXN0U3RhdHVzID0gbmV3U3RhdHVzO1xuICAgICAgdGhpcy5wcm92aWRlci5lbWl0KEVWRU5UX1NUQVRVUywgeyBzdGF0dXM6IG5ld1N0YXR1cyB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci50c1xudmFyIE1FU1NBR0VfU1lOQyA9IDA7XG52YXIgTUVTU0FHRV9RVUVSWV9BV0FSRU5FU1MgPSAzO1xudmFyIE1FU1NBR0VfQVdBUkVORVNTID0gMTtcbnZhciBNRVNTQUdFX1NZTkNfU1RBVFVTID0gMTAyO1xudmFyIFJFVFJJRVNfQkVGT1JFX1RPS0VOX1JFRlJFU0ggPSAzO1xudmFyIERFTEFZX01TX0JFRk9SRV9SRUNPTk5FQ1QgPSA1MDA7XG52YXIgREVMQVlfTVNfQkVGT1JFX1JFVFJZX1RPS0VOX1JFRlJFU0ggPSAzZTM7XG52YXIgRVZFTlRfTE9DQUxfQ0hBTkdFUyA9IFwibG9jYWwtY2hhbmdlc1wiO1xudmFyIEVWRU5UX0NPTk5FQ1RJT05fU1RBVFVTID0gXCJjb25uZWN0aW9uLXN0YXR1c1wiO1xudmFyIFNUQVRVU19PRkZMSU5FID0gXCJvZmZsaW5lXCI7XG52YXIgU1RBVFVTX0NPTk5FQ1RJTkcgPSBcImNvbm5lY3RpbmdcIjtcbnZhciBTVEFUVVNfRVJST1IgPSBcImVycm9yXCI7XG52YXIgU1RBVFVTX0hBTkRTSEFLSU5HID0gXCJoYW5kc2hha2luZ1wiO1xudmFyIFNUQVRVU19DT05ORUNURUQgPSBcImNvbm5lY3RlZFwiO1xuYXN5bmMgZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRDbGllbnRUb2tlbihhdXRoRW5kcG9pbnQsIHJvb21uYW1lKSB7XG4gIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gYXdhaXQgYXV0aEVuZHBvaW50KCk7XG4gIH1cbiAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgZG9jSWQ6IHJvb21uYW1lIH0pO1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhdXRoRW5kcG9pbnQsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHksXG4gICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9XG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBjbGllbnQgdG9rZW46ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgfVxuICBjb25zdCBjbGllbnRUb2tlbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIGlmIChjbGllbnRUb2tlbi5kb2NJZCAhPT0gcm9vbW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2xpZW50IHRva2VuIGRvY0lkIGRvZXMgbm90IG1hdGNoIHJvb21uYW1lOiAke2NsaWVudFRva2VuLmRvY0lkfSAhPT0gJHtyb29tbmFtZX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2xpZW50VG9rZW47XG59XG52YXIgWVN3ZWV0UHJvdmlkZXIyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhdXRoRW5kcG9pbnQsIGRvY0lkLCBkb2MsIGV4dHJhT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5hdXRoRW5kcG9pbnQgPSBhdXRoRW5kcG9pbnQ7XG4gICAgdGhpcy5kb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKiBDdXJyZW50IGNsaWVudCB0b2tlbi4gKi9cbiAgICB0aGlzLmNsaWVudFRva2VuID0gbnVsbDtcbiAgICAvKiogV2hldGhlciB0aGUgbG9jYWwgZG9jdW1lbnQgaGFzIHVuc3luY2VkIGNoYW5nZXMuICovXG4gICAgdGhpcy5oYXNMb2NhbENoYW5nZXMgPSB0cnVlO1xuICAgIC8qKiBDb25uZWN0aW9uIHN0YXR1cy4gKi9cbiAgICB0aGlzLnN0YXR1cyA9IFNUQVRVU19PRkZMSU5FO1xuICAgIHRoaXMud2Vic29ja2V0ID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5sYXN0U3luY1NlbnQgPSAwO1xuICAgIHRoaXMubGFzdFN5bmNBY2tlZCA9IC0xO1xuICAgIC8qKiBXaGV0aGVyIGEgKHJlKWNvbm5lY3QgbG9vcCBpcyBjdXJyZW50bHkgcnVubmluZy4gVGhpcyBhY3RzIGFzIGEgbG9jayB0byBwcmV2ZW50IHR3byBjb25jdXJyZW50IGNvbm5lY3QgbG9vcHMuICovXG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAoZXh0cmFPcHRpb25zLmluaXRpYWxDbGllbnRUb2tlbikge1xuICAgICAgdGhpcy5jbGllbnRUb2tlbiA9IGV4dHJhT3B0aW9ucy5pbml0aWFsQ2xpZW50VG9rZW47XG4gICAgfVxuICAgIG5ldyBXZWJTb2NrZXRDb21wYXRMYXllcih0aGlzKTtcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGV4dHJhT3B0aW9ucy5hd2FyZW5lc3MgPz8gbmV3IGF3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzcyhkb2MpO1xuICAgIHRoaXMuYXdhcmVuZXNzLm9uKFwidXBkYXRlXCIsIHRoaXMuaGFuZGxlQXdhcmVuZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuV2ViU29ja2V0UG9seWZpbGwgPSBleHRyYU9wdGlvbnMuV2ViU29ja2V0UG9seWZpbGwgfHwgV2ViU29ja2V0O1xuICAgIGRvYy5vbihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICBpZiAoZXh0cmFPcHRpb25zLmNvbm5lY3QgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG4gIH1cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMud2Vic29ja2V0Py5yZWFkeVN0YXRlID09PSB0aGlzLldlYlNvY2tldFBvbHlmaWxsLk9QRU4pIHtcbiAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVN5bmNlZFN0YXRlKCkge1xuICAgIGxldCBoYXNMb2NhbENoYW5nZXMgPSB0aGlzLmxhc3RTeW5jQWNrZWQgIT09IHRoaXMubGFzdFN5bmNTZW50O1xuICAgIGlmIChoYXNMb2NhbENoYW5nZXMgPT09IHRoaXMuaGFzTG9jYWxDaGFuZ2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFzTG9jYWxDaGFuZ2VzID0gaGFzTG9jYWxDaGFuZ2VzO1xuICAgIHRoaXMuZW1pdChFVkVOVF9MT0NBTF9DSEFOR0VTLCBoYXNMb2NhbENoYW5nZXMpO1xuICB9XG4gIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmVtaXQoRVZFTlRfQ09OTkVDVElPTl9TVEFUVVMsIHN0YXR1cyk7XG4gIH1cbiAgdXBkYXRlKHVwZGF0ZSwgb3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiAhPT0gdGhpcykge1xuICAgICAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX1NZTkMpO1xuICAgICAgc3luY1Byb3RvY29sLndyaXRlVXBkYXRlKGVuY29kZXIsIHVwZGF0ZSk7XG4gICAgICB0aGlzLnNlbmQodG9VaW50OEFycmF5KGVuY29kZXIpKTtcbiAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgfVxuICB9XG4gIGNoZWNrU3luYygpIHtcbiAgICB0aGlzLmxhc3RTeW5jU2VudCArPSAxO1xuICAgIGNvbnN0IGVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIE1FU1NBR0VfU1lOQ19TVEFUVVMpO1xuICAgIGNvbnN0IHZlcnNpb25FbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIHdyaXRlVmFyVWludCh2ZXJzaW9uRW5jb2RlciwgdGhpcy5sYXN0U3luY1NlbnQpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkodmVyc2lvbkVuY29kZXIpKTtcbiAgICB0aGlzLnNlbmQodG9VaW50OEFycmF5KGVuY29kZXIpKTtcbiAgICB0aGlzLnVwZGF0ZVN5bmNlZFN0YXRlKCk7XG4gIH1cbiAgYXN5bmMgZW5zdXJlQ2xpZW50VG9rZW4oKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50VG9rZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFRva2VuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuYXV0aEVuZHBvaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNsaWVudFRva2VuID0gYXdhaXQgZ2V0Q2xpZW50VG9rZW4odGhpcy5hdXRoRW5kcG9pbnQsIHRoaXMuZG9jSWQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50VG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xpZW50VG9rZW4gPSBhd2FpdCB0aGlzLmF1dGhFbmRwb2ludCgpO1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50VG9rZW47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBjb25uZWN0IHRvIHRoZSB3ZWJzb2NrZXQuXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgb3IgZmFsc2UgaWYgdGhlIGNvbm5lY3Rpb24gZmFpbGVkLlxuICAgKi9cbiAgYXR0ZW1wdFRvQ29ubmVjdChjbGllbnRUb2tlbikge1xuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBzdGF0dXNMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQgPT09IFNUQVRVU19DT05ORUNURUQpIHtcbiAgICAgICAgICB0aGlzLm9mZihFVkVOVF9DT05ORUNUSU9OX1NUQVRVUywgc3RhdHVzTGlzdGVuZXIpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFNUQVRVU19FUlJPUikge1xuICAgICAgICAgIHRoaXMub2ZmKEVWRU5UX0NPTk5FQ1RJT05fU1RBVFVTLCBzdGF0dXNMaXN0ZW5lcik7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm9uKEVWRU5UX0NPTk5FQ1RJT05fU1RBVFVTLCBzdGF0dXNMaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgbGV0IHVybCA9IHRoaXMuZ2VuZXJhdGVVcmwoY2xpZW50VG9rZW4pO1xuICAgIHRoaXMuc2V0U3RhdHVzKFNUQVRVU19DT05ORUNUSU5HKTtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgKHRoaXMuV2ViU29ja2V0UG9seWZpbGwgfHwgV2ViU29ja2V0KSh1cmwpO1xuICAgIHRoaXMuYmluZFdlYnNvY2tldCh3ZWJzb2NrZXQpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJjb25uZWN0KCkgY2FsbGVkIHdoaWxlIGEgY29ubmVjdCBsb29wIGlzIGFscmVhZHkgcnVubmluZy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNDb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLnNldFN0YXR1cyhTVEFUVVNfQ09OTkVDVElORyk7XG4gICAgd2hpbGUgKCFbU1RBVFVTX09GRkxJTkUsIFNUQVRVU19DT05ORUNURURdLmluY2x1ZGVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgdGhpcy5zZXRTdGF0dXMoU1RBVFVTX0NPTk5FQ1RJTkcpO1xuICAgICAgbGV0IGNsaWVudFRva2VuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xpZW50VG9rZW4gPSBhd2FpdCB0aGlzLmVuc3VyZUNsaWVudFRva2VuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBnZXQgY2xpZW50IHRva2VuXCIsIGUpO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhTVEFUVVNfRVJST1IpO1xuICAgICAgICBhd2FpdCBzbGVlcChERUxBWV9NU19CRUZPUkVfUkVUUllfVE9LRU5fUkVGUkVTSCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBSRVRSSUVTX0JFRk9SRV9UT0tFTl9SRUZSRVNIOyBpKyspIHtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuYXR0ZW1wdFRvQ29ubmVjdChjbGllbnRUb2tlbikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbGVlcChERUxBWV9NU19CRUZPUkVfUkVDT05ORUNUKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpZW50VG9rZW4gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMud2Vic29ja2V0KSB7XG4gICAgICB0aGlzLndlYnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXR1cyhTVEFUVVNfT0ZGTElORSk7XG4gIH1cbiAgYmluZFdlYnNvY2tldCh3ZWJzb2NrZXQpIHtcbiAgICBpZiAodGhpcy53ZWJzb2NrZXQpIHtcbiAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSBudWxsO1xuICAgICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMud2Vic29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuICAgIHRoaXMud2Vic29ja2V0LmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gdGhpcy53ZWJzb2NrZXRPcGVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMud2Vic29ja2V0Lm9uY2xvc2UgPSB0aGlzLndlYnNvY2tldENsb3NlLmJpbmQodGhpcyk7XG4gICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IHRoaXMud2Vic29ja2V0RXJyb3IuYmluZCh0aGlzKTtcbiAgfVxuICBnZW5lcmF0ZVVybChjbGllbnRUb2tlbikge1xuICAgIGNvbnN0IHVybCA9IGNsaWVudFRva2VuLnVybCArIGAvJHtjbGllbnRUb2tlbi5kb2NJZH1gO1xuICAgIGlmIChjbGllbnRUb2tlbi50b2tlbikge1xuICAgICAgcmV0dXJuIGAke3VybH0/dG9rZW49JHtjbGllbnRUb2tlbi50b2tlbn1gO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHN5bmNTdGVwMSgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX1NZTkMpO1xuICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyLCB0aGlzLmRvYyk7XG4gICAgdGhpcy5zZW5kKHRvVWludDhBcnJheShlbmNvZGVyKSk7XG4gIH1cbiAgcmVjZWl2ZVN5bmNNZXNzYWdlKGRlY29kZXIpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX1NZTkMpO1xuICAgIGNvbnN0IHN5bmNNZXNzYWdlVHlwZSA9IHN5bmNQcm90b2NvbC5yZWFkU3luY01lc3NhZ2UoZGVjb2RlciwgZW5jb2RlciwgdGhpcy5kb2MsIHRoaXMpO1xuICAgIGlmIChzeW5jTWVzc2FnZVR5cGUgPT09IHN5bmNQcm90b2NvbC5tZXNzYWdlWWpzU3luY1N0ZXAyKSB7XG4gICAgICB0aGlzLnNldFN0YXR1cyhTVEFUVVNfQ09OTkVDVEVEKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aChlbmNvZGVyKSA+IDEpIHtcbiAgICAgIHRoaXMuc2VuZCh0b1VpbnQ4QXJyYXkoZW5jb2RlcikpO1xuICAgIH1cbiAgfVxuICBxdWVyeUF3YXJlbmVzcygpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX1FVRVJZX0FXQVJFTkVTUyk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KFxuICAgICAgZW5jb2RlcixcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShcbiAgICAgICAgdGhpcy5hd2FyZW5lc3MsXG4gICAgICAgIEFycmF5LmZyb20odGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5zZW5kKHRvVWludDhBcnJheShlbmNvZGVyKSk7XG4gIH1cbiAgYnJvYWRjYXN0QXdhcmVuZXNzKCkge1xuICAgIGlmICh0aGlzLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIE1FU1NBR0VfQVdBUkVORVNTKTtcbiAgICAgIHdyaXRlVmFyVWludDhBcnJheShcbiAgICAgICAgZW5jb2RlckF3YXJlbmVzc1N0YXRlLFxuICAgICAgICBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0pXG4gICAgICApO1xuICAgICAgdGhpcy5zZW5kKHRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUpKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQXdhcmVuZXNzKGRlY29kZXIpIHtcbiAgICBhd2FyZW5lc3NQcm90b2NvbC5hcHBseUF3YXJlbmVzc1VwZGF0ZShcbiAgICAgIHRoaXMuYXdhcmVuZXNzLFxuICAgICAgcmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuICB3ZWJzb2NrZXRPcGVuKCkge1xuICAgIHRoaXMuc2V0U3RhdHVzKFNUQVRVU19IQU5EU0hBS0lORyk7XG4gICAgdGhpcy5zeW5jU3RlcDEoKTtcbiAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgIHRoaXMuYnJvYWRjYXN0QXdhcmVuZXNzKCk7XG4gIH1cbiAgcmVjZWl2ZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBsZXQgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KGV2ZW50LmRhdGEpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKG1lc3NhZ2UpO1xuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gICAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgICAgY2FzZSBNRVNTQUdFX1NZTkM6XG4gICAgICAgIHRoaXMucmVjZWl2ZVN5bmNNZXNzYWdlKGRlY29kZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTUVTU0FHRV9BV0FSRU5FU1M6XG4gICAgICAgIHRoaXMudXBkYXRlQXdhcmVuZXNzKGRlY29kZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTUVTU0FHRV9RVUVSWV9BV0FSRU5FU1M6XG4gICAgICAgIHRoaXMucXVlcnlBd2FyZW5lc3MoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1FU1NBR0VfU1lOQ19TVEFUVVM6XG4gICAgICAgIGxldCBsYXN0U3luY0J5dGVzID0gcmVhZFZhclVpbnQ4QXJyYXkoZGVjb2Rlcik7XG4gICAgICAgIGxldCBkMiA9IGNyZWF0ZURlY29kZXIobGFzdFN5bmNCeXRlcyk7XG4gICAgICAgIHRoaXMubGFzdFN5bmNBY2tlZCA9IHJlYWRWYXJVaW50KGQyKTtcbiAgICAgICAgdGhpcy51cGRhdGVTeW5jZWRTdGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB3ZWJzb2NrZXRDbG9zZShldmVudCkge1xuICAgIHRoaXMuZW1pdChFVkVOVF9DT05ORUNUSU9OX0NMT1NFLCBldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0dXMoU1RBVFVTX0VSUk9SKTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXMoXG4gICAgICB0aGlzLmF3YXJlbmVzcyxcbiAgICAgIEFycmF5LmZyb20odGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKS5maWx0ZXIoXG4gICAgICAgIChjbGllbnQpID0+IGNsaWVudCAhPT0gdGhpcy5kb2MuY2xpZW50SURcbiAgICAgICksXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuICB3ZWJzb2NrZXRFcnJvcihldmVudCkge1xuICAgIHRoaXMuZW1pdChFVkVOVF9DT05ORUNUSU9OX0VSUk9SLCBldmVudCk7XG4gICAgdGhpcy5zZXRTdGF0dXMoU1RBVFVTX0VSUk9SKTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBlbWl0KGV2ZW50TmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnROYW1lKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihkYXRhKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQXdhcmVuZXNzVXBkYXRlKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgX29yaWdpbikge1xuICAgIGNvbnN0IGNoYW5nZWRDbGllbnRzID0gYWRkZWQuY29uY2F0KHVwZGF0ZWQpLmNvbmNhdChyZW1vdmVkKTtcbiAgICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX0FXQVJFTkVTUyk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KFxuICAgICAgZW5jb2RlcixcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgY2hhbmdlZENsaWVudHMpXG4gICAgKTtcbiAgICB0aGlzLndlYnNvY2tldD8uc2VuZCh0b1VpbnQ4QXJyYXkoZW5jb2RlcikpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud2Vic29ja2V0KSB7XG4gICAgICB0aGlzLndlYnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0sIFwid2luZG93IHVubG9hZFwiKTtcbiAgfVxuICBfb24odHlwZSwgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyh0eXBlKSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KHR5cGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBpZiAob25jZSkge1xuICAgICAgbGV0IGxpc3RlbmVyT25jZSA9IChkKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKGQpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5nZXQodHlwZSk/LmRlbGV0ZShsaXN0ZW5lck9uY2UpO1xuICAgICAgfTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmdldCh0eXBlKT8uYWRkKGxpc3RlbmVyT25jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmdldCh0eXBlKT8uYWRkKGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX29uKHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgfVxuICBvZmYodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm92aWRlciBzaG91bGQgYXR0ZW1wdCB0byBjb25uZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgcHJvdmlkZXIuc3RhdHVzICE9PSAnb2ZmbGluZScgaW5zdGVhZCwgb3IgY2FsbCBgcHJvdmlkZXIuY29ubmVjdCgpYCAvIGBwcm92aWRlci5kaXNjb25uZWN0KClgIHRvIHNldC5cbiAgICovXG4gIGdldCBzaG91bGRDb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyAhPT0gU1RBVFVTX09GRkxJTkU7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHVuZGVybHlpbmcgd2Vic29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHByb3ZpZGVyLnN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcgfHwgcHJvdmlkZXIuc3RhdHVzID09PSAnaGFuZHNoYWtpbmcnIGluc3RlYWQuXG4gICAqL1xuICBnZXQgd3Njb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBTVEFUVVNfQ09OTkVDVEVEIHx8IHRoaXMuc3RhdHVzID09PSBTVEFUVVNfSEFORFNIQUtJTkc7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHVuZGVybHlpbmcgd2Vic29ja2V0IGlzIGNvbm5lY3RpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBwcm92aWRlci5zdGF0dXMgPT09ICdjb25uZWN0aW5nJyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHdzY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFNUQVRVU19DT05ORUNUSU5HO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBkb2N1bWVudCBpcyBzeW5jZWQuIChGb3IgY29tcGF0aWJpbGl0eSB3aXRoIHktd2Vic29ja2V0LilcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHByb3ZpZGVyLnN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcgaW5zdGVhZC5cbiAgICogKi9cbiAgZ2V0IHN5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFNUQVRVU19DT05ORUNURUQ7XG4gIH1cbn07XG5cbi8vIHNyYy9tYWluLnRzXG5mdW5jdGlvbiBjcmVhdGVZanNQcm92aWRlcihkb2MsIGRvY0lkLCBhdXRoRW5kcG9pbnQsIGV4dHJhT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBuZXcgWVN3ZWV0UHJvdmlkZXIyKGF1dGhFbmRwb2ludCwgZG9jSWQsIGRvYywgZXh0cmFPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlYnVnZ2VyVXJsKGNsaWVudFRva2VuKSB7XG4gIGNvbnN0IHBheWxvYWQgPSBlbmNvZGVDbGllbnRUb2tlbihjbGllbnRUb2tlbik7XG4gIHJldHVybiBgaHR0cHM6Ly9kZWJ1Z2dlci55LXN3ZWV0LmRldi8/cGF5bG9hZD0ke3BheWxvYWR9YDtcbn1cbmV4cG9ydCB7XG4gIEVWRU5UX0NPTk5FQ1RJT05fU1RBVFVTLFxuICBFVkVOVF9MT0NBTF9DSEFOR0VTLFxuICBTVEFUVVNfQ09OTkVDVEVELFxuICBTVEFUVVNfQ09OTkVDVElORyxcbiAgU1RBVFVTX0VSUk9SLFxuICBTVEFUVVNfSEFORFNIQUtJTkcsXG4gIFNUQVRVU19PRkZMSU5FLFxuICBZU3dlZXRQcm92aWRlcjIgYXMgWVN3ZWV0UHJvdmlkZXIsXG4gIGNyZWF0ZVlqc1Byb3ZpZGVyLFxuICBkZWJ1Z2dlclVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@y-sweet/client/dist/main.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@y-sweet/react/dist/main.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@y-sweet/react/dist/main.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YDocProvider: () => (/* binding */ YDocProvider),\n/* harmony export */   YSweetProvider: () => (/* reexport safe */ _y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.YSweetProvider),\n/* harmony export */   createYjsProvider: () => (/* reexport safe */ _y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.createYjsProvider),\n/* harmony export */   debuggerUrl: () => (/* reexport safe */ _y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.debuggerUrl),\n/* harmony export */   useArray: () => (/* binding */ useArray),\n/* harmony export */   useAwareness: () => (/* binding */ useAwareness),\n/* harmony export */   useConnectionStatus: () => (/* binding */ useConnectionStatus),\n/* harmony export */   useHasLocalChanges: () => (/* binding */ useHasLocalChanges),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useObserve: () => (/* binding */ useObserve),\n/* harmony export */   usePresence: () => (/* binding */ usePresence),\n/* harmony export */   usePresenceSetter: () => (/* binding */ usePresenceSetter),\n/* harmony export */   useText: () => (/* binding */ useText),\n/* harmony export */   useYDoc: () => (/* binding */ useYDoc),\n/* harmony export */   useYSweetDebugUrl: () => (/* binding */ useYSweetDebugUrl),\n/* harmony export */   useYjsProvider: () => (/* binding */ useYjsProvider)\n/* harmony export */ });\n/* harmony import */ var _y_sweet_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @y-sweet/client */ \"(ssr)/./node_modules/@y-sweet/client/dist/main.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ YDocProvider,YSweetProvider,createYjsProvider,debuggerUrl,useArray,useAwareness,useConnectionStatus,useHasLocalChanges,useMap,useObserve,usePresence,usePresenceSetter,useText,useYDoc,useYSweetDebugUrl,useYjsProvider auto */ // src/main.tsx\n\n\n\n\nvar YjsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction useYDoc(options) {\n    const yjsCtx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(YjsContext);\n    if (options?.hideDebuggerLink) {\n        console.warn(\"The `hideDebuggerLink` option is deprecated and no longer used. Pass `showDebuggerLink={false}` to `YDocProvider` as a prop instead.\");\n    }\n    if (!yjsCtx) {\n        throw new Error(\"Yjs hooks must be used within a YDocProvider\");\n    }\n    return yjsCtx.doc;\n}\nfunction useYSweetDebugUrl() {\n    const yjsCtx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(YjsContext);\n    if (!yjsCtx) {\n        throw new Error(\"Yjs hooks must be used within a YDocProvider\");\n    }\n    if (!yjsCtx.provider.clientToken) {\n        return \"\";\n    }\n    return (0,_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.debuggerUrl)(yjsCtx.provider.clientToken);\n}\nfunction useYjsProvider() {\n    const yjsCtx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(YjsContext);\n    if (!yjsCtx) {\n        throw new Error(\"Yjs hooks must be used within a YDocProvider\");\n    }\n    return yjsCtx.provider;\n}\nfunction useHasLocalChanges() {\n    const yjsCtx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(YjsContext);\n    if (!yjsCtx) {\n        throw new Error(\"Yjs hooks must be used within a YDocProvider\");\n    }\n    const [isSynced, setIsSynced] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(yjsCtx.provider.hasLocalChanges);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useHasLocalChanges.useEffect\": ()=>{\n            const handleSync = {\n                \"useHasLocalChanges.useEffect.handleSync\": ()=>{\n                    setIsSynced(yjsCtx.provider.hasLocalChanges);\n                }\n            }[\"useHasLocalChanges.useEffect.handleSync\"];\n            yjsCtx.provider.on(_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.EVENT_LOCAL_CHANGES, handleSync);\n            return ({\n                \"useHasLocalChanges.useEffect\": ()=>{\n                    yjsCtx.provider.off(_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.EVENT_LOCAL_CHANGES, handleSync);\n                }\n            })[\"useHasLocalChanges.useEffect\"];\n        }\n    }[\"useHasLocalChanges.useEffect\"], [\n        yjsCtx.provider\n    ]);\n    return isSynced;\n}\nfunction useConnectionStatus() {\n    const yjsCtx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(YjsContext);\n    if (!yjsCtx) {\n        throw new Error(\"Yjs hooks must be used within a YDocProvider\");\n    }\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(yjsCtx.provider.status);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useConnectionStatus.useEffect\": ()=>{\n            const handleStatus = {\n                \"useConnectionStatus.useEffect.handleStatus\": (status2)=>{\n                    setStatus(status2);\n                }\n            }[\"useConnectionStatus.useEffect.handleStatus\"];\n            yjsCtx.provider.on(_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.EVENT_CONNECTION_STATUS, handleStatus);\n            return ({\n                \"useConnectionStatus.useEffect\": ()=>{\n                    yjsCtx.provider.off(_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.EVENT_CONNECTION_STATUS, handleStatus);\n                }\n            })[\"useConnectionStatus.useEffect\"];\n        }\n    }[\"useConnectionStatus.useEffect\"], [\n        yjsCtx.provider\n    ]);\n    return status;\n}\nfunction useAwareness() {\n    const yjsCtx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(YjsContext);\n    if (!yjsCtx) {\n        throw new Error(\"Yjs hooks must be used within a YDocProvider\");\n    }\n    return yjsCtx.provider.awareness;\n}\nfunction usePresenceSetter() {\n    const awareness = useAwareness();\n    const setLocalPresence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"usePresenceSetter.useCallback[setLocalPresence]\": (localState)=>{\n            if (awareness) {\n                awareness.setLocalState(localState);\n            }\n        }\n    }[\"usePresenceSetter.useCallback[setLocalPresence]\"], [\n        awareness\n    ]);\n    return setLocalPresence;\n}\nfunction usePresence(options) {\n    const awareness = useAwareness();\n    const [presence, setPresence] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(/* @__PURE__ */ new Map());\n    const includeSelf = options?.includeSelf || false;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"usePresence.useEffect\": ()=>{\n            if (awareness) {\n                const callback = {\n                    \"usePresence.useEffect.callback\": ()=>{\n                        const map = /* @__PURE__ */ new Map();\n                        awareness.getStates().forEach({\n                            \"usePresence.useEffect.callback\": (state, clientID)=>{\n                                if (!includeSelf && clientID === awareness.clientID) return;\n                                if (Object.keys(state).length > 0) {\n                                    map.set(clientID, state);\n                                }\n                            }\n                        }[\"usePresence.useEffect.callback\"]);\n                        setPresence(map);\n                    }\n                }[\"usePresence.useEffect.callback\"];\n                awareness.on(\"change\", callback);\n                return ({\n                    \"usePresence.useEffect\": ()=>{\n                        awareness.off(\"change\", callback);\n                    }\n                })[\"usePresence.useEffect\"];\n            }\n        }\n    }[\"usePresence.useEffect\"], [\n        awareness\n    ]);\n    return presence;\n}\nfunction YDocProvider(props) {\n    const { children, docId, authEndpoint, initialClientToken } = props;\n    const [ctx, setCtx] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"YDocProvider.useEffect\": ()=>{\n            let canceled = false;\n            let provider = null;\n            const doc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();\n            ({\n                \"YDocProvider.useEffect\": async ()=>{\n                    provider = await (0,_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.createYjsProvider)(doc, docId, authEndpoint, {\n                        initialClientToken\n                    });\n                    if ((props.showDebuggerLink ?? true) && provider.clientToken) {\n                        const url = (0,_y_sweet_client__WEBPACK_IMPORTED_MODULE_0__.debuggerUrl)(provider.clientToken);\n                        console.log(`%cOpen this in Y-Sweet Debugger \\u2B95 ${url}`, \"font-size: 1.5em; display: block; padding: 10px;\");\n                        console.log(\"%cTo hide the debugger link, pass showDebuggerLink={false} to YDocProvider\", \"font-style: italic;\");\n                    }\n                    if (canceled) {\n                        provider.destroy();\n                        return;\n                    }\n                    setCtx({\n                        doc,\n                        provider\n                    });\n                }\n            })[\"YDocProvider.useEffect\"]();\n            return ({\n                \"YDocProvider.useEffect\": ()=>{\n                    canceled = true;\n                    provider?.destroy();\n                    doc.destroy();\n                }\n            })[\"YDocProvider.useEffect\"];\n        }\n    }[\"YDocProvider.useEffect\"], [\n        docId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"YDocProvider.useEffect\": ()=>{\n            if (props.setQueryParam) {\n                const url = new URL(window.location.href);\n                url.searchParams.set(props.setQueryParam, docId);\n                window.history.replaceState({}, \"\", url.toString());\n            }\n        }\n    }[\"YDocProvider.useEffect\"], [\n        props.setQueryParam,\n        docId\n    ]);\n    if (ctx === null) return null;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(YjsContext.Provider, {\n        value: ctx,\n        children\n    });\n}\nfunction useRedraw() {\n    const [_, setRedraw] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useRedraw.useCallback\": ()=>setRedraw({\n                \"useRedraw.useCallback\": (x)=>x + 1\n            }[\"useRedraw.useCallback\"])\n    }[\"useRedraw.useCallback\"], [\n        setRedraw\n    ]);\n}\nfunction useMap(name, objectOptions) {\n    const doc = useYDoc();\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useMap.useMemo[map]\": ()=>doc.getMap(name)\n    }[\"useMap.useMemo[map]\"], [\n        doc,\n        name\n    ]);\n    useObserve(map, objectOptions?.observe || \"deep\");\n    return map;\n}\nfunction useArray(name, objectOptions) {\n    const doc = useYDoc();\n    const array = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useArray.useMemo[array]\": ()=>doc.getArray(name)\n    }[\"useArray.useMemo[array]\"], [\n        doc,\n        name\n    ]);\n    useObserve(array, objectOptions?.observe || \"deep\");\n    return array;\n}\nfunction useText(name, observerKind) {\n    const doc = useYDoc();\n    const text = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useText.useMemo[text]\": ()=>doc.getText(name)\n    }[\"useText.useMemo[text]\"], [\n        doc,\n        name\n    ]);\n    useObserve(text, observerKind?.observe || \"deep\");\n    return text;\n}\nfunction useObserve(object, kind) {\n    const redraw = useRedraw();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useObserve.useEffect\": ()=>{\n            if (kind === \"deep\") {\n                object.observeDeep(redraw);\n            } else if (kind === \"shallow\") {\n                object.observe(redraw);\n            }\n            return ({\n                \"useObserve.useEffect\": ()=>{\n                    if (kind === \"deep\") {\n                        object.unobserveDeep(redraw);\n                    } else if (kind === \"shallow\") {\n                        object.unobserve(redraw);\n                    }\n                }\n            })[\"useObserve.useEffect\"];\n        }\n    }[\"useObserve.useEffect\"]);\n}\n //# sourceMappingURL=main.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHktc3dlZXQvcmVhY3QvZGlzdC9tYWluLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTTztBQUk4RTtBQUVsRTtBQW1SVjtBQXJRVCxJQUFNLDJCQUFhLG9EQUFhLENBQXdCLElBQUk7QUFjckQsU0FBUyxRQUFRLFNBQThCO0lBQ3BELE1BQU0sU0FBUyxpREFBVSxDQUFDLFVBQVU7SUFFcEMsSUFBSSxTQUFTLGtCQUFrQjtRQUM3QixRQUFRLEtBQ047SUFFSjtJQUVBLElBQUksQ0FBQyxRQUFRO1FBQ1gsTUFBTSxJQUFJLE1BQU0sOENBQThDO0lBQ2hFO0lBQ0EsT0FBTyxPQUFPO0FBQ2hCO0FBT08sU0FBUyxvQkFBNEI7SUFDMUMsTUFBTSxTQUFTLGlEQUFVLENBQUMsVUFBVTtJQUNwQyxJQUFJLENBQUMsUUFBUTtRQUNYLE1BQU0sSUFBSSxNQUFNLDhDQUE4QztJQUNoRTtJQUNBLElBQUksQ0FBQyxPQUFPLFNBQVMsYUFBYTtRQUNoQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPLDREQUFXLENBQUMsT0FBTyxTQUFTLFdBQVc7QUFDaEQ7QUFVTyxTQUFTLGlCQUFpQztJQUMvQyxNQUFNLFNBQVMsaURBQVUsQ0FBQyxVQUFVO0lBQ3BDLElBQUksQ0FBQyxRQUFRO1FBQ1gsTUFBTSxJQUFJLE1BQU0sOENBQThDO0lBQ2hFO0lBQ0EsT0FBTyxPQUFPO0FBQ2hCO0FBR08sU0FBUyxxQkFBOEI7SUFDNUMsTUFBTSxTQUFTLGlEQUFVLENBQUMsVUFBVTtJQUNwQyxJQUFJLENBQUMsUUFBUTtRQUNYLE1BQU0sSUFBSSxNQUFNLDhDQUE4QztJQUNoRTtJQUVBLE1BQU0sQ0FBQyxVQUFVLFdBQVcsSUFBSSwrQ0FBUSxDQUFDLE9BQU8sU0FBUyxlQUFlO0lBRXhFLGdEQUFTO3dDQUFDO1lBQ1IsTUFBTTsyREFBYTtvQkFDakIsWUFBWSxPQUFPLFNBQVMsZUFBZTtnQkFDN0M7O1lBQ0EsT0FBTyxTQUFTLEdBQUcs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Tyw4Q0FBTztpQ0FBQyxJQUFNLElBQUksUUFBUSxJQUFJO2dDQUFHO1FBQUM7UUFBSyxJQUFJO0tBQUM7SUFDekQsV0FBVyxNQUFNLGNBQWMsV0FBVyxNQUFNO0lBRWhELE9BQU87QUFDVDtBQVlPLFNBQVMsV0FBVyxRQUE2QixNQUFvQjtJQUMxRSxNQUFNLFNBQVMsVUFBVTtJQUV6QixnREFBUztnQ0FBQztZQUNSLElBQUksU0FBUyxRQUFRO2dCQUNuQixPQUFPLFlBQVksTUFBTTtZQUMzQixXQUFXLFNBQVMsV0FBVztnQkFDN0IsT0FBTyxRQUFRLE1BQU07WUFDdkI7WUFFQTt3Q0FBTztvQkFDTCxJQUFJLFNBQVMsUUFBUTt3QkFDbkIsT0FBTyxjQUFjLE1BQU07b0JBQzdCLFdBQVcsU0FBUyxXQUFXO3dCQUM3QixPQUFPLFVBQVUsTUFBTTtvQkFDekI7Z0JBQ0Y7O1FBQ0YsQ0FBQzs7QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL2hhY2tlZC9Eb2N1bWVudHMvR2l0SHViL3NoYXJlL3lzd2VldC9zcmMvbWFpbi50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7XG4gIFlTd2VldFByb3ZpZGVyLFxuICBZU3dlZXRQcm92aWRlclBhcmFtcyxcbiAgY3JlYXRlWWpzUHJvdmlkZXIsXG4gIGRlYnVnZ2VyVXJsLFxuICBFVkVOVF9MT0NBTF9DSEFOR0VTLFxuICBFVkVOVF9DT05ORUNUSU9OX1NUQVRVUyxcbn0gZnJvbSAnQHktc3dlZXQvY2xpZW50J1xuaW1wb3J0IHR5cGUgeyBBdXRoRW5kcG9pbnQsIFlTd2VldFN0YXR1cyB9IGZyb20gJ0B5LXN3ZWV0L2NsaWVudCdcbmltcG9ydCB0eXBlIHsgQ2xpZW50VG9rZW4gfSBmcm9tICdAeS1zd2VldC9zZGsnXG5pbXBvcnQgdHlwZSB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgQXdhcmVuZXNzIH0gZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5leHBvcnQge1xuICBjcmVhdGVZanNQcm92aWRlcixcbiAgWVN3ZWV0UHJvdmlkZXIsXG4gIGRlYnVnZ2VyVXJsLFxuICB0eXBlIFlTd2VldFByb3ZpZGVyUGFyYW1zLFxuICB0eXBlIEF1dGhFbmRwb2ludCxcbn1cblxudHlwZSBZanNDb250ZXh0VHlwZSA9IHtcbiAgZG9jOiBZLkRvY1xuICBwcm92aWRlcjogWVN3ZWV0UHJvdmlkZXJcbn1cblxuY29uc3QgWWpzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8WWpzQ29udGV4dFR5cGUgfCBudWxsPihudWxsKVxuXG50eXBlIFlEb2NPcHRpb25zID0ge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgMC42LjAgYW5kIG5vdCB1c2VkLiBQYXNzIGBzaG93RGVidWdnZXJMaW5rPXtmYWxzZX1gIHRvIGBZRG9jUHJvdmlkZXJgIGFzIGEgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgaGlkZURlYnVnZ2VyTGluaz86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBSZWFjdCBob29rIHRvIGdldCB0aGUgWS5Eb2MgaW5zdGFuY2UgZnJvbSB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIEByZXR1cm5zIFRoZSBZLkRvYyBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVlEb2Mob3B0aW9ucz86IFlEb2NPcHRpb25zKTogWS5Eb2Mge1xuICBjb25zdCB5anNDdHggPSB1c2VDb250ZXh0KFlqc0NvbnRleHQpXG5cbiAgaWYgKG9wdGlvbnM/LmhpZGVEZWJ1Z2dlckxpbmspIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnVGhlIGBoaWRlRGVidWdnZXJMaW5rYCBvcHRpb24gaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIHVzZWQuIFBhc3MgYHNob3dEZWJ1Z2dlckxpbms9e2ZhbHNlfWAgdG8gYFlEb2NQcm92aWRlcmAgYXMgYSBwcm9wIGluc3RlYWQuJyxcbiAgICApXG4gIH1cblxuICBpZiAoIXlqc0N0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWWpzIGhvb2tzIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBZRG9jUHJvdmlkZXInKVxuICB9XG4gIHJldHVybiB5anNDdHguZG9jXG59XG5cbi8qKlxuICogUmVhY3QgaG9vayB0byBnZXQgdGhlIFkuRG9jIGluc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBAcmV0dXJucyBBIGRlYnVnZ2VyIFVSTCBhcyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVlTd2VldERlYnVnVXJsKCk6IHN0cmluZyB7XG4gIGNvbnN0IHlqc0N0eCA9IHVzZUNvbnRleHQoWWpzQ29udGV4dClcbiAgaWYgKCF5anNDdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lqcyBob29rcyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgWURvY1Byb3ZpZGVyJylcbiAgfVxuICBpZiAoIXlqc0N0eC5wcm92aWRlci5jbGllbnRUb2tlbikge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIHJldHVybiBkZWJ1Z2dlclVybCh5anNDdHgucHJvdmlkZXIuY2xpZW50VG9rZW4pXG59XG5cbi8qKlxuICogUmVhY3QgaG9vayBmb3Igb2J0YWluaW5nIHRoZSBZU3dlZXRQcm92aWRlciBpbnN0YW5jZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGludGVncmF0aW5nIGNvbXBvbmVudHMgdGhhdCBleHBlY3QgYSBkaXJlY3QgcmVmZXJlbmNlXG4gKiB0byB0aGUgcHJvdmlkZXIuXG4gKlxuICogQHJldHVybnMgVGhlIFlTd2VldFByb3ZpZGVyIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlWWpzUHJvdmlkZXIoKTogWVN3ZWV0UHJvdmlkZXIge1xuICBjb25zdCB5anNDdHggPSB1c2VDb250ZXh0KFlqc0NvbnRleHQpXG4gIGlmICgheWpzQ3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZanMgaG9va3MgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFlEb2NQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIHlqc0N0eC5wcm92aWRlclxufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBsb2NhbCBkb2N1bWVudCBoYXMgdW5zYXZlZCBjaGFuZ2VzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0xvY2FsQ2hhbmdlcygpOiBib29sZWFuIHtcbiAgY29uc3QgeWpzQ3R4ID0gdXNlQ29udGV4dChZanNDb250ZXh0KVxuICBpZiAoIXlqc0N0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWWpzIGhvb2tzIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBZRG9jUHJvdmlkZXInKVxuICB9XG5cbiAgY29uc3QgW2lzU3luY2VkLCBzZXRJc1N5bmNlZF0gPSB1c2VTdGF0ZSh5anNDdHgucHJvdmlkZXIuaGFzTG9jYWxDaGFuZ2VzKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU3luYyA9ICgpID0+IHtcbiAgICAgIHNldElzU3luY2VkKHlqc0N0eC5wcm92aWRlci5oYXNMb2NhbENoYW5nZXMpXG4gICAgfVxuICAgIHlqc0N0eC5wcm92aWRlci5vbihFVkVOVF9MT0NBTF9DSEFOR0VTLCBoYW5kbGVTeW5jKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB5anNDdHgucHJvdmlkZXIub2ZmKEVWRU5UX0xPQ0FMX0NIQU5HRVMsIGhhbmRsZVN5bmMpXG4gICAgfVxuICB9LCBbeWpzQ3R4LnByb3ZpZGVyXSlcblxuICByZXR1cm4gaXNTeW5jZWRcbn1cblxuLyoqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0dXMgb2YgdGhlIFlqcyBwcm92aWRlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb25uZWN0aW9uU3RhdHVzKCk6IFlTd2VldFN0YXR1cyB7XG4gIGNvbnN0IHlqc0N0eCA9IHVzZUNvbnRleHQoWWpzQ29udGV4dClcbiAgaWYgKCF5anNDdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lqcyBob29rcyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgWURvY1Byb3ZpZGVyJylcbiAgfVxuXG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZSh5anNDdHgucHJvdmlkZXIuc3RhdHVzKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU3RhdHVzID0gKHN0YXR1czogWVN3ZWV0U3RhdHVzKSA9PiB7XG4gICAgICBzZXRTdGF0dXMoc3RhdHVzKVxuICAgIH1cbiAgICB5anNDdHgucHJvdmlkZXIub24oRVZFTlRfQ09OTkVDVElPTl9TVEFUVVMsIGhhbmRsZVN0YXR1cylcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgeWpzQ3R4LnByb3ZpZGVyLm9mZihFVkVOVF9DT05ORUNUSU9OX1NUQVRVUywgaGFuZGxlU3RhdHVzKVxuICAgIH1cbiAgfSwgW3lqc0N0eC5wcm92aWRlcl0pXG5cbiAgcmV0dXJuIHN0YXR1c1xufVxuXG4vKipcbiAqIFJlYWN0IGhvb2sgZm9yIG9idGFpbmluZyB0aGUgWWpzIEF3YXJlbmVzcyBpbnN0YW5jZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogQHJldHVybnMgVGhlIFlqcyBBd2FyZW5lc3MgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXdhcmVuZXNzKCk6IEF3YXJlbmVzcyB7XG4gIGNvbnN0IHlqc0N0eCA9IHVzZUNvbnRleHQoWWpzQ29udGV4dClcbiAgaWYgKCF5anNDdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lqcyBob29rcyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgWURvY1Byb3ZpZGVyJylcbiAgfVxuICByZXR1cm4geWpzQ3R4LnByb3ZpZGVyLmF3YXJlbmVzc1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgdXNlUHJlc2VuY2V9IGhvb2suXG4gKi9cbnR5cGUgVXNlUHJlc2VuY2VPcHRpb25zID0ge1xuICAvKiogV2hldGhlciB0aGUgcHJlc2VuY2Ugb2JqZWN0IHNob3VsZCBpbmNsdWRlIHRoZSBsb2NhbCBjbGllbnQuXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBpbmNsdWRlU2VsZj86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBSZWFjdCBob29rIHRoYXQgcmV0dXJzIGEgc2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbG9jYWwgcHJlc2VuY2Ugb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEEgc2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbG9jYWwgcHJlc2VuY2Ugb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc2VuY2VTZXR0ZXI8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KCk6IChwcmVzZW5jZTogVCkgPT4gdm9pZCB7XG4gIGNvbnN0IGF3YXJlbmVzcyA9IHVzZUF3YXJlbmVzcygpXG5cbiAgY29uc3Qgc2V0TG9jYWxQcmVzZW5jZSA9IHVzZUNhbGxiYWNrKFxuICAgIChsb2NhbFN0YXRlOiBhbnkpID0+IHtcbiAgICAgIGlmIChhd2FyZW5lc3MpIHtcbiAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGUobG9jYWxTdGF0ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIFthd2FyZW5lc3NdLFxuICApXG5cbiAgcmV0dXJuIHNldExvY2FsUHJlc2VuY2Vcbn1cblxuLyoqIFJlYWN0IGhvb2sgdGhhdCByZXR1cm5zIG90aGVyIHVzZXJz4oCZIHByZXNlbmNlIHZhbHVlcyBhcyBhIGBNYXA8bnVtYmVyLCBhbnk+YC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVzZW5jZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gIG9wdGlvbnM/OiBVc2VQcmVzZW5jZU9wdGlvbnMsXG4pOiBNYXA8bnVtYmVyLCBUPiB7XG4gIGNvbnN0IGF3YXJlbmVzcyA9IHVzZUF3YXJlbmVzcygpXG4gIGNvbnN0IFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdID0gdXNlU3RhdGU8TWFwPG51bWJlciwgVD4+KG5ldyBNYXAoKSlcblxuICBjb25zdCBpbmNsdWRlU2VsZiA9IG9wdGlvbnM/LmluY2x1ZGVTZWxmIHx8IGZhbHNlXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYXdhcmVuZXNzKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCgpXG4gICAgICAgIGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5mb3JFYWNoKChzdGF0ZSwgY2xpZW50SUQpID0+IHtcbiAgICAgICAgICBpZiAoIWluY2x1ZGVTZWxmICYmIGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQpIHJldHVyblxuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGNsaWVudElELCBzdGF0ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgc2V0UHJlc2VuY2UobWFwKVxuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm9uKCdjaGFuZ2UnLCBjYWxsYmFjaylcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIGNhbGxiYWNrKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2F3YXJlbmVzc10pXG5cbiAgcmV0dXJuIHByZXNlbmNlXG59XG5cbi8qKlxuICogUHJvcHMgdG8gdGhlIHtAbGluayBZRG9jUHJvdmlkZXJ9IGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IHR5cGUgWURvY1Byb3ZpZGVyUHJvcHMgPSB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gcmVuZGVyLiAqL1xuICBjaGlsZHJlbjogUmVhY3ROb2RlXG5cbiAgLyoqIFRoZSBkb2MgaWQgdG8gdXNlIGZvciB0aGUgWS5Eb2MuICovXG4gIGRvY0lkOiBzdHJpbmdcblxuICAvKiogVGhlIGVuZHBvaW50IHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb24gb3IgYW4gYXN5bmMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY2xpZW50IHRva2VuLiAqL1xuICBhdXRoRW5kcG9pbnQ6IEF1dGhFbmRwb2ludFxuXG4gIC8qKiBBbiBvcHRpb25hbCBpbml0aWFsIGNsaWVudCB0b2tlbiB0byB1c2UgZm9yIHRoZSBZLkRvYy4gVGhpcyB3aWxsIGJlIHVzZWQgaW5pdGlhbGx5LCBhbmQgaWZcbiAgICogdGhlIGNsaWVudCB0b2tlbiBleHBpcmVzLCB0aGUgYGF1dGhFbmRwb2ludGAgd2lsbCBiZSBjYWxsZWQgdG8gZ2V0IGEgbmV3IGNsaWVudCB0b2tlbi4gKi9cbiAgaW5pdGlhbENsaWVudFRva2VuPzogQ2xpZW50VG9rZW5cblxuICAvKiogSWYgc2V0IHRvIGEgc3RyaW5nLCB0aGUgVVJMIHF1ZXJ5IHBhcmFtZXRlciB3aXRoIHRoaXMgbmFtZVxuICAgKiB3aWxsIGJlIHNldCB0byB0aGUgZG9jIGlkIHByb3ZpZGVkLiAqL1xuICBzZXRRdWVyeVBhcmFtPzogc3RyaW5nXG5cbiAgLyoqIFdoZXRoZXIgdG8gaGlkZSB0aGUgZGVidWdnZXIgbGluay4gRGVmYXVsdHMgdG8gdHJ1ZS4gKi9cbiAgc2hvd0RlYnVnZ2VyTGluaz86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIGEgWS5Eb2MgaW5zdGFuY2UgdG8gaXRzIGNoaWxkcmVuIGdpdmVuIGFuIGF1dGggZW5kcG9pbnQgYW5kIGEgZG9jIGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gWURvY1Byb3ZpZGVyKHByb3BzOiBZRG9jUHJvdmlkZXJQcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBkb2NJZCwgYXV0aEVuZHBvaW50LCBpbml0aWFsQ2xpZW50VG9rZW4gfSA9IHByb3BzXG5cbiAgY29uc3QgW2N0eCwgc2V0Q3R4XSA9IHVzZVN0YXRlPFlqc0NvbnRleHRUeXBlIHwgbnVsbD4obnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlXG4gICAgbGV0IHByb3ZpZGVyOiBZU3dlZXRQcm92aWRlciB8IG51bGwgPSBudWxsXG4gICAgY29uc3QgZG9jID0gbmV3IFkuRG9jKClcblxuICAgIDsoYXN5bmMgKCkgPT4ge1xuICAgICAgcHJvdmlkZXIgPSBhd2FpdCBjcmVhdGVZanNQcm92aWRlcihkb2MsIGRvY0lkLCBhdXRoRW5kcG9pbnQsIHtcbiAgICAgICAgaW5pdGlhbENsaWVudFRva2VuLFxuICAgICAgfSlcblxuICAgICAgaWYgKChwcm9wcy5zaG93RGVidWdnZXJMaW5rID8/IHRydWUpICYmIHByb3ZpZGVyLmNsaWVudFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGRlYnVnZ2VyVXJsKHByb3ZpZGVyLmNsaWVudFRva2VuKVxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgJWNPcGVuIHRoaXMgaW4gWS1Td2VldCBEZWJ1Z2dlciDirpUgJHt1cmx9YCxcbiAgICAgICAgICAnZm9udC1zaXplOiAxLjVlbTsgZGlzcGxheTogYmxvY2s7IHBhZGRpbmc6IDEwcHg7JyxcbiAgICAgICAgKVxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAnJWNUbyBoaWRlIHRoZSBkZWJ1Z2dlciBsaW5rLCBwYXNzIHNob3dEZWJ1Z2dlckxpbms9e2ZhbHNlfSB0byBZRG9jUHJvdmlkZXInLFxuICAgICAgICAgICdmb250LXN0eWxlOiBpdGFsaWM7JyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgICAgcHJvdmlkZXIuZGVzdHJveSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBzZXRDdHgoeyBkb2MsIHByb3ZpZGVyIH0pXG4gICAgfSkoKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZVxuICAgICAgcHJvdmlkZXI/LmRlc3Ryb3koKVxuICAgICAgZG9jLmRlc3Ryb3koKVxuICAgIH1cbiAgfSwgW2RvY0lkXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5zZXRRdWVyeVBhcmFtKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQocHJvcHMuc2V0UXVlcnlQYXJhbSwgZG9jSWQpXG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCB1cmwudG9TdHJpbmcoKSlcbiAgICB9XG4gIH0sIFtwcm9wcy5zZXRRdWVyeVBhcmFtLCBkb2NJZF0pXG5cbiAgaWYgKGN0eCA9PT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gPFlqc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2N0eH0+e2NoaWxkcmVufTwvWWpzQ29udGV4dC5Qcm92aWRlcj5cbn1cblxuZnVuY3Rpb24gdXNlUmVkcmF3KCkge1xuICBjb25zdCBbXywgc2V0UmVkcmF3XSA9IHVzZVN0YXRlKDApXG4gIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiBzZXRSZWRyYXcoKHgpID0+IHggKyAxKSwgW3NldFJlZHJhd10pXG59XG5cbi8qKiBSZXByZXNlbnRzIHBvc3NpYmxlIHZhbHVlcyB0byBwYXNzIHRvIGhvb2tzIHRoYXQgcmV0dXJuIFlqcyBvYmplY3RzLFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGV5IHRyaWdnZXIgYSByZS1yZW5kZXIgd2hlbiB0aGVcbiAqIFlqcyBvYmplY3QgY2hhbmdlcy5cbiAqXG4gKiAtIGAnZGVlcCdgIHdpbGwgcmUtcmVuZGVyIHdoZW4gYW55IG5lc3RlZCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICogLSBgJ3NoYWxsb3cnYCB3aWxsIHJlLXJlbmRlciB3aGVuIHRoZSBvYmplY3QgaXRzZWxmIGNoYW5nZXMuXG4gKiAtIGAnbm9uZSdgIHdpbGwgbmV2ZXIgcmUtcmVuZGVyLlxuICovXG5leHBvcnQgdHlwZSBPYnNlcnZlcktpbmQgPSAnZGVlcCcgfCAnc2hhbGxvdycgfCAnbm9uZSdcblxuLyoqXG4gKiBPcHRpb25zIGZvciBob29rcyB0aGF0IHJldHVybiBZanMgb2JqZWN0cywgbGlrZSB7QGxpbmsgdXNlTWFwfS5cbiAqXG4gKiBAc2VlIHtAbGluayBPYnNlcnZlcktpbmR9XG4gKi9cbmV4cG9ydCB0eXBlIE9iamVjdE9wdGlvbnMgPSB7XG4gIG9ic2VydmU/OiBPYnNlcnZlcktpbmRcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYFkuTWFwPFQ+YCBvYmplY3QgZnJvbSB0aGUgYFkuRG9jYCBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIFRoZSBzdHJpbmcgYG5hbWVgIGlzIHRoZSBuYW1lIG9mIHRoZSB0b3AtbGV2ZWwgWWpzIG9iamVjdCB0byByZXR1cm4uXG4gKiBUd28gY2xpZW50cyB0aGF0IGNhbGwgYHVzZU1hcCguLi4pYCB3aXRoIHRoZSBzYW1lIGBuYW1lYCB3aWxsIGdldFxuICogdGhlIHNhbWUgb2JqZWN0LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCBzdWJzY3JpYmUgdGhlIGNhbGxpbmcgY29tcG9uZW50IHRvIHVwZGF0ZXMgb25cbiAqIHRoZSBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbi4gU2VlIHtAbGluayBPYmplY3RPcHRpb25zfSBhbmRcbiAqIHtAbGluayBPYnNlcnZlcktpbmR9IGZvciBmaW5lciBjb250cm9sIG9mIG9ic2VydmVyIGJlaGF2aW9yLlxuICpcbiAqIEB0eXBlUGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBtYXAuIEtleXMgYXJlIGFsd2F5cyBzdHJpbmdzLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRvcC1sZXZlbCBZanMgb2JqZWN0IHRvIHJldHVybi4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIG9iamVjdE9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXA8VD4obmFtZT86IHN0cmluZywgb2JqZWN0T3B0aW9ucz86IE9iamVjdE9wdGlvbnMpOiBZLk1hcDxUPiB7XG4gIGNvbnN0IGRvYyA9IHVzZVlEb2MoKVxuICBjb25zdCBtYXAgPSB1c2VNZW1vKCgpID0+IGRvYy5nZXRNYXA8VD4obmFtZSksIFtkb2MsIG5hbWVdKVxuICB1c2VPYnNlcnZlKG1hcCwgb2JqZWN0T3B0aW9ucz8ub2JzZXJ2ZSB8fCAnZGVlcCcpXG5cbiAgcmV0dXJuIG1hcFxufVxuXG4vKipcbiAqIFJldHVybnMgYSBgWS5BcnJheTxUPmAgb2JqZWN0IGZyb20gdGhlIGBZLkRvY2AgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBUaGUgc3RyaW5nIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiB0aGUgdG9wLWxldmVsIFlqcyBvYmplY3QgdG8gcmV0dXJuLlxuICogVHdvIGNsaWVudHMgdGhhdCBjYWxsIGB1c2VBcnJheSguLi4pYCB3aXRoIHRoZSBzYW1lIGBuYW1lYCB3aWxsIGdldFxuICogdGhlIHNhbWUgb2JqZWN0LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCBzdWJzY3JpYmUgdGhlIGNhbGxpbmcgY29tcG9uZW50IHRvIHVwZGF0ZXMgb25cbiAqIHRoZSBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbi4gU2VlIHtAbGluayBPYmplY3RPcHRpb25zfSBhbmRcbiAqIHtAbGluayBPYnNlcnZlcktpbmR9IGZvciBmaW5lciBjb250cm9sIG9mIG9ic2VydmVyIGJlaGF2aW9yLlxuICpcbiAqIEB0eXBlUGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0b3AtbGV2ZWwgWWpzIG9iamVjdCB0byByZXR1cm4uIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZy5cbiAqIEBwYXJhbSBvYmplY3RPcHRpb25zXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJyYXk8VD4obmFtZT86IHN0cmluZywgb2JqZWN0T3B0aW9ucz86IE9iamVjdE9wdGlvbnMpOiBZLkFycmF5PFQ+IHtcbiAgY29uc3QgZG9jID0gdXNlWURvYygpXG4gIGNvbnN0IGFycmF5ID0gdXNlTWVtbygoKSA9PiBkb2MuZ2V0QXJyYXk8VD4obmFtZSksIFtkb2MsIG5hbWVdKVxuICB1c2VPYnNlcnZlKGFycmF5LCBvYmplY3RPcHRpb25zPy5vYnNlcnZlIHx8ICdkZWVwJylcblxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYFkuVGV4dGAgb2JqZWN0IGZyb20gdGhlIGBZLkRvY2AgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBUaGUgc3RyaW5nIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiB0aGUgdG9wLWxldmVsIFlqcyBvYmplY3QgdG8gcmV0dXJuLlxuICogVHdvIGNsaWVudHMgdGhhdCBjYWxsIGB1c2VUZXh0KC4uLilgIHdpdGggdGhlIHNhbWUgYG5hbWVgIHdpbGwgZ2V0XG4gKiB0aGUgc2FtZSBvYmplY3QuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhpcyB3aWxsIHN1YnNjcmliZSB0aGUgY2FsbGluZyBjb21wb25lbnQgdG8gdXBkYXRlcyBvblxuICogdGhlIG9iamVjdCBhbmQgaXRzIGNoaWxkcmVuLiBTZWUge0BsaW5rIE9iamVjdE9wdGlvbnN9IGFuZFxuICoge0BsaW5rIE9ic2VydmVyS2luZH0gZm9yIGZpbmVyIGNvbnRyb2wgb2Ygb2JzZXJ2ZXIgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRvcC1sZXZlbCBZanMgb2JqZWN0IHRvIHJldHVybi4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIG9iamVjdE9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUZXh0KG5hbWU/OiBzdHJpbmcsIG9ic2VydmVyS2luZD86IE9iamVjdE9wdGlvbnMpOiBZLlRleHQge1xuICBjb25zdCBkb2MgPSB1c2VZRG9jKClcbiAgY29uc3QgdGV4dCA9IHVzZU1lbW8oKCkgPT4gZG9jLmdldFRleHQobmFtZSksIFtkb2MsIG5hbWVdKVxuICB1c2VPYnNlcnZlKHRleHQsIG9ic2VydmVyS2luZD8ub2JzZXJ2ZSB8fCAnZGVlcCcpXG5cbiAgcmV0dXJuIHRleHRcbn1cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBjYXVzZXMgaXRzIGNhbGxpbmcgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBnaXZlblxuICogWWpzIG9iamVjdCBjaGFuZ2VzLlxuICpcbiAqIFRoZSBga2luZGAgcGFyYW1ldGVyIGRldGVybWluZXMgdGhlIGxldmVsIG9mIGNoYW5nZSB0aGF0IHdpbGwgdHJpZ2dlclxuICogYSByZS1yZW5kZXIuIFNlZSB7QGxpbmsgT2JzZXJ2ZXJLaW5kfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IFRoZSBZanMgb2JqZWN0IHRvIG9ic2VydmUuXG4gKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiBvYnNlcnZhdGlvbiB0byBwZXJmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT2JzZXJ2ZShvYmplY3Q6IFkuQWJzdHJhY3RUeXBlPGFueT4sIGtpbmQ6IE9ic2VydmVyS2luZCkge1xuICBjb25zdCByZWRyYXcgPSB1c2VSZWRyYXcoKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGtpbmQgPT09ICdkZWVwJykge1xuICAgICAgb2JqZWN0Lm9ic2VydmVEZWVwKHJlZHJhdylcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdzaGFsbG93Jykge1xuICAgICAgb2JqZWN0Lm9ic2VydmUocmVkcmF3KVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoa2luZCA9PT0gJ2RlZXAnKSB7XG4gICAgICAgIG9iamVjdC51bm9ic2VydmVEZWVwKHJlZHJhdylcbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICAgIG9iamVjdC51bm9ic2VydmUocmVkcmF3KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJzdGF0dXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@y-sweet/react/dist/main.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@y-sweet/sdk/dist/main.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@y-sweet/sdk/dist/main.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocConnection: () => (/* binding */ DocConnection),\n/* harmony export */   DocumentManager: () => (/* binding */ DocumentManager),\n/* harmony export */   YSweetError: () => (/* binding */ YSweetError),\n/* harmony export */   createDoc: () => (/* binding */ createDoc),\n/* harmony export */   decodeClientToken: () => (/* binding */ decodeClientToken),\n/* harmony export */   encodeClientToken: () => (/* binding */ encodeClientToken),\n/* harmony export */   getClientToken: () => (/* binding */ getClientToken),\n/* harmony export */   getOrCreateDocAndToken: () => (/* binding */ getOrCreateDocAndToken)\n/* harmony export */ });\n// src/error.ts\nvar YSweetError = class _YSweetError extends Error {\n  /**\n   * Create a new {@link YSweetError}.\n   *\n   * @param cause An object representing metadata associated with the error.\n   * @see {@link YSweetErrorPayload}\n   */\n  constructor(cause) {\n    super(_YSweetError.getMessage(cause));\n    this.cause = cause;\n    this.name = \"YSweetError\";\n  }\n  /** Convert the message to an error string that can be displayed to the user.\n   *\n   * The error string can also be used with {@link YSweetError.fromMessage} to\n   * reconstruct the payload object, which is useful in the context of Next.js,\n   * which will only pass an error string from the server to the client.\n   *\n   * @param payload The payload object to convert to a string.\n   * @returns A string representation of the error.\n   */\n  static getMessage(payload) {\n    let message;\n    if (payload.code === \"ServerRefused\") {\n      message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`;\n    } else if (payload.code === \"ServerError\") {\n      message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`;\n    } else if (payload.code === \"NoAuthProvided\") {\n      message = \"No auth provided\";\n    } else if (payload.code === \"InvalidAuthProvided\") {\n      message = \"Invalid auth provided\";\n    } else {\n      message = payload.message;\n    }\n    return `${payload.code}: ${message}`;\n  }\n  /**\n   * In development, next.js passes error objects to the client but strips out everything but the\n   * `message` field. This method allows us to reconstruct the original error object.\n   *\n   * @param messageString The error message string to reconstruct a payload from.\n   * @returns A {@link YSweetError} object.\n   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}\n   */\n  static fromMessage(messageString) {\n    let match = messageString.match(/^(.*?): (.*)$/);\n    if (!match) {\n      return new _YSweetError({ code: \"Unknown\", message: messageString });\n    }\n    let [, code, message] = match;\n    if (code === \"ServerRefused\") {\n      match = message.match(/^Server at (.*?):(\\d+) refused connection. URL: (.*)$/);\n      if (!match) {\n        return new _YSweetError({ code: \"Unknown\", message: messageString });\n      }\n      let [, address, port, url] = match;\n      return new _YSweetError({ code, address, port: parseInt(port), url });\n    }\n    if (code === \"ServerError\") {\n      match = message.match(/^Server responded with (\\d+) (.*). URL: (.*)$/);\n      if (!match) {\n        return new _YSweetError({ code: \"Unknown\", message: messageString });\n      }\n      let [, status, statusText, url] = match;\n      return new _YSweetError({ code, status: parseInt(status), message: statusText, url });\n    }\n    if (code === \"NoAuthProvided\") {\n      return new _YSweetError({ code });\n    }\n    if (code === \"InvalidAuthProvided\") {\n      return new _YSweetError({ code });\n    }\n    return new _YSweetError({ code: \"Unknown\", message });\n  }\n};\n\n// src/http.ts\nvar HttpClient = class {\n  constructor(baseUrl, token) {\n    this.token = null;\n    this.baseUrl = baseUrl;\n    this.token = token;\n  }\n  async request(path, method, body) {\n    const headers = new Headers();\n    if (this.token) {\n      headers.set(\"Authorization\", `Bearer ${this.token}`);\n    }\n    let rawBody;\n    if (body instanceof Uint8Array) {\n      headers.set(\"Content-Type\", \"application/octet-stream\");\n      rawBody = body;\n    } else if (body) {\n      headers.set(\"Content-Type\", \"application/json\");\n      rawBody = JSON.stringify(body);\n    }\n    const cacheBust = generateRandomString();\n    let url = `${this.baseUrl}/${path}?z=${cacheBust}`;\n    let result;\n    try {\n      result = await fetch(url, {\n        method,\n        body: rawBody,\n        headers\n      });\n    } catch (error) {\n      if (error.cause?.code === \"ECONNREFUSED\") {\n        let { address, port } = error.cause;\n        throw new YSweetError({ code: \"ServerRefused\", address, port, url });\n      } else {\n        throw new YSweetError({ code: \"Unknown\", message: error.toString() });\n      }\n    }\n    if (!result.ok) {\n      if (result.status === 401) {\n        if (this.token) {\n          throw new YSweetError({ code: \"InvalidAuthProvided\" });\n        } else {\n          throw new YSweetError({ code: \"NoAuthProvided\" });\n        }\n      }\n      throw new YSweetError({\n        code: \"ServerError\",\n        status: result.status,\n        message: result.statusText,\n        url\n      });\n    }\n    return result;\n  }\n};\nfunction generateRandomString() {\n  return Math.random().toString(36).substring(2);\n}\n\n// src/connection.ts\nvar DocConnection = class {\n  constructor(clientToken) {\n    let baseUrl = clientToken.baseUrl.replace(/\\/$/, \"\");\n    this.client = new HttpClient(baseUrl, clientToken.token ?? null);\n    this.docId = clientToken.docId;\n  }\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * This can be turned back into a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let update = await manager.getDocAsUpdate(docId)\n   * let doc = new Y.Doc()\n   * doc.transact(() => {\n   *  Y.applyUpdate(doc, update)\n   * })\n   * ```\n   *\n   * @returns\n   */\n  async getAsUpdate() {\n    const result = await this.client.request(`as-update`, \"GET\");\n    if (!result.ok) {\n      throw new Error(`Failed to get doc ${this.docId}: ${result.status} ${result.statusText}`);\n    }\n    let buffer = await result.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * This can be generated from a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let doc = new Y.Doc()\n   * // Modify the document...\n   * let update = Y.encodeStateAsUpdate(doc)\n   * await manager.updateDoc(docId, update)\n   * ```\n   *\n   * @param update\n   */\n  async updateDoc(update) {\n    const result = await this.client.request(`update`, \"POST\", update);\n    if (!result.ok) {\n      throw new Error(`Failed to update doc ${this.docId}: ${result.status} ${result.statusText}`);\n    }\n  }\n};\n\n// src/encoding.ts\nfunction stringToBase64(input) {\n  if (typeof window !== \"undefined\" && window.btoa) {\n    return window.btoa(input);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(input).toString(\"base64\");\n  } else {\n    throw new Error(\"Unable to encode to Base64\");\n  }\n}\nfunction base64ToString(input) {\n  if (typeof window !== \"undefined\" && window.atob) {\n    return window.atob(input);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(input, \"base64\").toString();\n  } else {\n    throw new Error(\"Unable to decode from Base64\");\n  }\n}\nfunction encodeClientToken(token) {\n  const jsonString = JSON.stringify(token);\n  let base64 = stringToBase64(jsonString);\n  base64 = base64.replace(\"+\", \"-\").replace(\"/\", \"_\").replace(/=+$/, \"\");\n  return base64;\n}\nfunction decodeClientToken(token) {\n  let base64 = token.replace(\"-\", \"+\").replace(\"_\", \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  const jsonString = base64ToString(base64);\n  return JSON.parse(jsonString);\n}\n\n// src/main.ts\nvar DocumentManager = class {\n  /**\n   * Create a new {@link DocumentManager}.\n   *\n   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n   */\n  constructor(connectionString) {\n    const parsedUrl = new URL(connectionString);\n    let token = null;\n    if (parsedUrl.username) {\n      token = decodeURIComponent(parsedUrl.username);\n    }\n    let protocol = parsedUrl.protocol;\n    if (protocol === \"ys:\") {\n      protocol = \"http:\";\n    } else if (protocol === \"yss:\") {\n      protocol = \"https:\";\n    }\n    const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}`;\n    let baseUrl = url.replace(/\\/$/, \"\");\n    this.client = new HttpClient(baseUrl, token);\n  }\n  async checkStore() {\n    return await (await this.client.request(\"check_store\", \"POST\", {})).json();\n  }\n  /**\n   * Creates a new document on the y-sweet server given an optional docId. If a document with given\n   * ID already exists, this is a no-op.\n   *\n   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  async createDoc(docId) {\n    const body = docId ? { docId } : {};\n    const result = await this.client.request(\"doc/new\", \"POST\", body);\n    if (!result.ok) {\n      throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`);\n    }\n    const responseBody = await result.json();\n    return responseBody;\n  }\n  /**\n   * Get a client token for the given document.\n   *\n   * If you are using authorization, this is expected to be called from your server\n   * after a user has authenticated. The returned token should then be passed to the\n   * client.\n   *\n   * @param docId The ID of the document to get a token for.\n   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  async getClientToken(docId, authDocRequest) {\n    if (typeof docId !== \"string\") {\n      docId = docId.docId;\n    }\n    const result = await this.client.request(`doc/${docId}/auth`, \"POST\", authDocRequest ?? {});\n    if (!result.ok) {\n      throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`);\n    }\n    const responseBody = await result.json();\n    return responseBody;\n  }\n  /**\n   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for\n   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or\n   * that one is created. If no docId is provided, a new document is created with a random ID.\n   *\n   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.\n   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  async getOrCreateDocAndToken(docId, authDocRequest) {\n    const result = await this.createDoc(docId);\n    return await this.getClientToken(result, authDocRequest);\n  }\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * @param docId The ID of the document to get.\n   * @returns The document as a Yjs update byte string\n   */\n  async getDocAsUpdate(docId) {\n    const connection = await this.getDocConnection(docId);\n    return await connection.getAsUpdate();\n  }\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * @param docId The ID of the document to update.\n   * @param update The Yjs update byte string to apply to the document.\n   */\n  async updateDoc(docId, update) {\n    const connection = await this.getDocConnection(docId);\n    return await connection.updateDoc(update);\n  }\n  async getDocConnection(docId, authDocRequest) {\n    const clientToken = await this.getClientToken(docId, authDocRequest);\n    return new DocConnection(clientToken);\n  }\n  /**\n   * Creates a new document with initial content.\n   *\n   * @param update A Yjs update byte string representing the initial content.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  async createDocWithContent(update) {\n    const result = await this.createDoc();\n    await this.updateDoc(result.docId, update);\n    return result;\n  }\n};\nasync function getOrCreateDocAndToken(connectionString, docId, authDocRequest) {\n  const manager = new DocumentManager(connectionString);\n  return await manager.getOrCreateDocAndToken(docId, authDocRequest);\n}\nasync function getClientToken(connectionString, docId, authDocRequest) {\n  const manager = new DocumentManager(connectionString);\n  return await manager.getClientToken(docId, authDocRequest);\n}\nasync function createDoc(connectionString, docId) {\n  const manager = new DocumentManager(connectionString);\n  return await manager.createDoc(docId);\n}\n\n//# sourceMappingURL=main.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHktc3dlZXQvc2RrL2Rpc3QvbWFpbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQixHQUFHLGNBQWMsMkJBQTJCLFlBQVk7QUFDckcsTUFBTTtBQUNOLHlDQUF5QyxnQkFBZ0IsRUFBRSxnQkFBZ0IsU0FBUyxZQUFZO0FBQ2hHLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxhQUFhLElBQUksUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5Q0FBeUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5Q0FBeUM7QUFDM0U7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUNBQXlDO0FBQzNFO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQTBEO0FBQzFGO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEs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dC9qdXN0c2hhcmUvbm9kZV9tb2R1bGVzL0B5LXN3ZWV0L3Nkay9kaXN0L21haW4ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvci50c1xudmFyIFlTd2VldEVycm9yID0gY2xhc3MgX1lTd2VldEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBZU3dlZXRFcnJvcn0uXG4gICAqXG4gICAqIEBwYXJhbSBjYXVzZSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gICAqIEBzZWUge0BsaW5rIFlTd2VldEVycm9yUGF5bG9hZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhdXNlKSB7XG4gICAgc3VwZXIoX1lTd2VldEVycm9yLmdldE1lc3NhZ2UoY2F1c2UpKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJZU3dlZXRFcnJvclwiO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBtZXNzYWdlIHRvIGFuIGVycm9yIHN0cmluZyB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAqXG4gICAqIFRoZSBlcnJvciBzdHJpbmcgY2FuIGFsc28gYmUgdXNlZCB3aXRoIHtAbGluayBZU3dlZXRFcnJvci5mcm9tTWVzc2FnZX0gdG9cbiAgICogcmVjb25zdHJ1Y3QgdGhlIHBheWxvYWQgb2JqZWN0LCB3aGljaCBpcyB1c2VmdWwgaW4gdGhlIGNvbnRleHQgb2YgTmV4dC5qcyxcbiAgICogd2hpY2ggd2lsbCBvbmx5IHBhc3MgYW4gZXJyb3Igc3RyaW5nIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCBvYmplY3QgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgc3RhdGljIGdldE1lc3NhZ2UocGF5bG9hZCkge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmIChwYXlsb2FkLmNvZGUgPT09IFwiU2VydmVyUmVmdXNlZFwiKSB7XG4gICAgICBtZXNzYWdlID0gYFNlcnZlciBhdCAke3BheWxvYWQuYWRkcmVzc306JHtwYXlsb2FkLnBvcnR9IHJlZnVzZWQgY29ubmVjdGlvbi4gVVJMOiAke3BheWxvYWQudXJsfWA7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLmNvZGUgPT09IFwiU2VydmVyRXJyb3JcIikge1xuICAgICAgbWVzc2FnZSA9IGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtwYXlsb2FkLnN0YXR1c30gJHtwYXlsb2FkLm1lc3NhZ2V9LiBVUkw6ICR7cGF5bG9hZC51cmx9YDtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQuY29kZSA9PT0gXCJOb0F1dGhQcm92aWRlZFwiKSB7XG4gICAgICBtZXNzYWdlID0gXCJObyBhdXRoIHByb3ZpZGVkXCI7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLmNvZGUgPT09IFwiSW52YWxpZEF1dGhQcm92aWRlZFwiKSB7XG4gICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGF1dGggcHJvdmlkZWRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSA9IHBheWxvYWQubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3BheWxvYWQuY29kZX06ICR7bWVzc2FnZX1gO1xuICB9XG4gIC8qKlxuICAgKiBJbiBkZXZlbG9wbWVudCwgbmV4dC5qcyBwYXNzZXMgZXJyb3Igb2JqZWN0cyB0byB0aGUgY2xpZW50IGJ1dCBzdHJpcHMgb3V0IGV2ZXJ5dGhpbmcgYnV0IHRoZVxuICAgKiBgbWVzc2FnZWAgZmllbGQuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZVN0cmluZyBUaGUgZXJyb3IgbWVzc2FnZSBzdHJpbmcgdG8gcmVjb25zdHJ1Y3QgYSBwYXlsb2FkIGZyb20uXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFlTd2VldEVycm9yfSBvYmplY3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2ZpbGUtY29udmVudGlvbnMvZXJyb3IjZXJyb3JtZXNzYWdlfCBOZXh0LmpzIGRvY3N9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1lc3NhZ2UobWVzc2FnZVN0cmluZykge1xuICAgIGxldCBtYXRjaCA9IG1lc3NhZ2VTdHJpbmcubWF0Y2goL14oLio/KTogKC4qKSQvKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbmV3IF9ZU3dlZXRFcnJvcih7IGNvZGU6IFwiVW5rbm93blwiLCBtZXNzYWdlOiBtZXNzYWdlU3RyaW5nIH0pO1xuICAgIH1cbiAgICBsZXQgWywgY29kZSwgbWVzc2FnZV0gPSBtYXRjaDtcbiAgICBpZiAoY29kZSA9PT0gXCJTZXJ2ZXJSZWZ1c2VkXCIpIHtcbiAgICAgIG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvXlNlcnZlciBhdCAoLio/KTooXFxkKykgcmVmdXNlZCBjb25uZWN0aW9uLiBVUkw6ICguKikkLyk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZTogXCJVbmtub3duXCIsIG1lc3NhZ2U6IG1lc3NhZ2VTdHJpbmcgfSk7XG4gICAgICB9XG4gICAgICBsZXQgWywgYWRkcmVzcywgcG9ydCwgdXJsXSA9IG1hdGNoO1xuICAgICAgcmV0dXJuIG5ldyBfWVN3ZWV0RXJyb3IoeyBjb2RlLCBhZGRyZXNzLCBwb3J0OiBwYXJzZUludChwb3J0KSwgdXJsIH0pO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gXCJTZXJ2ZXJFcnJvclwiKSB7XG4gICAgICBtYXRjaCA9IG1lc3NhZ2UubWF0Y2goL15TZXJ2ZXIgcmVzcG9uZGVkIHdpdGggKFxcZCspICguKikuIFVSTDogKC4qKSQvKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfWVN3ZWV0RXJyb3IoeyBjb2RlOiBcIlVua25vd25cIiwgbWVzc2FnZTogbWVzc2FnZVN0cmluZyB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBbLCBzdGF0dXMsIHN0YXR1c1RleHQsIHVybF0gPSBtYXRjaDtcbiAgICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZSwgc3RhdHVzOiBwYXJzZUludChzdGF0dXMpLCBtZXNzYWdlOiBzdGF0dXNUZXh0LCB1cmwgfSk7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSBcIk5vQXV0aFByb3ZpZGVkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZSB9KTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IFwiSW52YWxpZEF1dGhQcm92aWRlZFwiKSB7XG4gICAgICByZXR1cm4gbmV3IF9ZU3dlZXRFcnJvcih7IGNvZGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1lTd2VldEVycm9yKHsgY29kZTogXCJVbmtub3duXCIsIG1lc3NhZ2UgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9odHRwLnRzXG52YXIgSHR0cENsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYmFzZVVybCwgdG9rZW4pIHtcbiAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHBhdGgsIG1ldGhvZCwgYm9keSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICBoZWFkZXJzLnNldChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke3RoaXMudG9rZW59YCk7XG4gICAgfVxuICAgIGxldCByYXdCb2R5O1xuICAgIGlmIChib2R5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gICAgICByYXdCb2R5ID0gYm9keTtcbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcbiAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgIHJhd0JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVCdXN0ID0gZ2VuZXJhdGVSYW5kb21TdHJpbmcoKTtcbiAgICBsZXQgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS8ke3BhdGh9P3o9JHtjYWNoZUJ1c3R9YDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBib2R5OiByYXdCb2R5LFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLmNhdXNlPy5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgICAgIGxldCB7IGFkZHJlc3MsIHBvcnQgfSA9IGVycm9yLmNhdXNlO1xuICAgICAgICB0aHJvdyBuZXcgWVN3ZWV0RXJyb3IoeyBjb2RlOiBcIlNlcnZlclJlZnVzZWRcIiwgYWRkcmVzcywgcG9ydCwgdXJsIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFlTd2VldEVycm9yKHsgY29kZTogXCJVbmtub3duXCIsIG1lc3NhZ2U6IGVycm9yLnRvU3RyaW5nKCkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlTd2VldEVycm9yKHsgY29kZTogXCJJbnZhbGlkQXV0aFByb3ZpZGVkXCIgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlTd2VldEVycm9yKHsgY29kZTogXCJOb0F1dGhQcm92aWRlZFwiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgWVN3ZWV0RXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIlNlcnZlckVycm9yXCIsXG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogcmVzdWx0LnN0YXR1c1RleHQsXG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbnZhciBEb2NDb25uZWN0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnRUb2tlbikge1xuICAgIGxldCBiYXNlVXJsID0gY2xpZW50VG9rZW4uYmFzZVVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgSHR0cENsaWVudChiYXNlVXJsLCBjbGllbnRUb2tlbi50b2tlbiA/PyBudWxsKTtcbiAgICB0aGlzLmRvY0lkID0gY2xpZW50VG9rZW4uZG9jSWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW50aXJlIGRvY3VtZW50LCByZXByZXNlbnRlZCBhcyBhIFlqcyB1cGRhdGUgYnl0ZSBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHR1cm5lZCBiYWNrIGludG8gYSBZanMgZG9jdW1lbnQgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbiAgICpcbiAgICogbGV0IHVwZGF0ZSA9IGF3YWl0IG1hbmFnZXIuZ2V0RG9jQXNVcGRhdGUoZG9jSWQpXG4gICAqIGxldCBkb2MgPSBuZXcgWS5Eb2MoKVxuICAgKiBkb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgKiAgWS5hcHBseVVwZGF0ZShkb2MsIHVwZGF0ZSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRBc1VwZGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KGBhcy11cGRhdGVgLCBcIkdFVFwiKTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGRvYyAke3RoaXMuZG9jSWR9OiAke3Jlc3VsdC5zdGF0dXN9ICR7cmVzdWx0LnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSBhd2FpdCByZXN1bHQuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIFlqcyB1cGRhdGUgYnl0ZSBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIGdlbmVyYXRlZCBmcm9tIGEgWWpzIGRvY3VtZW50IGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG4gICAqXG4gICAqIGxldCBkb2MgPSBuZXcgWS5Eb2MoKVxuICAgKiAvLyBNb2RpZnkgdGhlIGRvY3VtZW50Li4uXG4gICAqIGxldCB1cGRhdGUgPSBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKVxuICAgKiBhd2FpdCBtYW5hZ2VyLnVwZGF0ZURvYyhkb2NJZCwgdXBkYXRlKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHVwZGF0ZVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlRG9jKHVwZGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoYHVwZGF0ZWAsIFwiUE9TVFwiLCB1cGRhdGUpO1xuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgZG9jICR7dGhpcy5kb2NJZH06ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGluZy50c1xuZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjQoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmJ0b2EpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBlbmNvZGUgdG8gQmFzZTY0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBiYXNlNjRUb1N0cmluZyhpbnB1dCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuYXRvYikge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIGZyb20gQmFzZTY0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVDbGllbnRUb2tlbih0b2tlbikge1xuICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodG9rZW4pO1xuICBsZXQgYmFzZTY0ID0gc3RyaW5nVG9CYXNlNjQoanNvblN0cmluZyk7XG4gIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKFwiK1wiLCBcIi1cIikucmVwbGFjZShcIi9cIiwgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xuICByZXR1cm4gYmFzZTY0O1xufVxuZnVuY3Rpb24gZGVjb2RlQ2xpZW50VG9rZW4odG9rZW4pIHtcbiAgbGV0IGJhc2U2NCA9IHRva2VuLnJlcGxhY2UoXCItXCIsIFwiK1wiKS5yZXBsYWNlKFwiX1wiLCBcIi9cIik7XG4gIHdoaWxlIChiYXNlNjQubGVuZ3RoICUgNCkge1xuICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgfVxuICBjb25zdCBqc29uU3RyaW5nID0gYmFzZTY0VG9TdHJpbmcoYmFzZTY0KTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG59XG5cbi8vIHNyYy9tYWluLnRzXG52YXIgRG9jdW1lbnRNYW5hZ2VyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBEb2N1bWVudE1hbmFnZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmVyVG9rZW4gQSBjb25uZWN0aW9uIHN0cmluZyAoc3RhcnRpbmcgd2l0aCBgeXM6Ly9gIG9yIGB5c3M6Ly9gKSByZWZlcnJpbmcgdG8gYSB5LXN3ZWV0IHNlcnZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKGNvbm5lY3Rpb25TdHJpbmcpO1xuICAgIGxldCB0b2tlbiA9IG51bGw7XG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSkge1xuICAgICAgdG9rZW4gPSBkZWNvZGVVUklDb21wb25lbnQocGFyc2VkVXJsLnVzZXJuYW1lKTtcbiAgICB9XG4gICAgbGV0IHByb3RvY29sID0gcGFyc2VkVXJsLnByb3RvY29sO1xuICAgIGlmIChwcm90b2NvbCA9PT0gXCJ5czpcIikge1xuICAgICAgcHJvdG9jb2wgPSBcImh0dHA6XCI7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gXCJ5c3M6XCIpIHtcbiAgICAgIHByb3RvY29sID0gXCJodHRwczpcIjtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7cHJvdG9jb2x9Ly8ke3BhcnNlZFVybC5ob3N0fSR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgbGV0IGJhc2VVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IEh0dHBDbGllbnQoYmFzZVVybCwgdG9rZW4pO1xuICB9XG4gIGFzeW5jIGNoZWNrU3RvcmUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IChhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KFwiY2hlY2tfc3RvcmVcIiwgXCJQT1NUXCIsIHt9KSkuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IG9uIHRoZSB5LXN3ZWV0IHNlcnZlciBnaXZlbiBhbiBvcHRpb25hbCBkb2NJZC4gSWYgYSBkb2N1bWVudCB3aXRoIGdpdmVuXG4gICAqIElEIGFscmVhZHkgZXhpc3RzLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAqXG4gICAqIEBwYXJhbSBkb2NJZCBUaGUgSUQgb2YgdGhlIGRvY3VtZW50IHRvIGJlIGNyZWF0ZWQuIElmIG5vdCBwcm92aWRlZCwgYSByYW5kb20gSUQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIERvY0NyZWF0aW9uUmVzdWx0fSBvYmplY3QgY29udGFpbmluZyB0aGUgSUQgb2YgdGhlIGNyZWF0ZWQgZG9jdW1lbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVEb2MoZG9jSWQpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jSWQgPyB7IGRvY0lkIH0gOiB7fTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KFwiZG9jL25ld1wiLCBcIlBPU1RcIiwgYm9keSk7XG4gICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBkb2M6ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBjbGllbnQgdG9rZW4gZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICpcbiAgICogSWYgeW91IGFyZSB1c2luZyBhdXRob3JpemF0aW9uLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXIgc2VydmVyXG4gICAqIGFmdGVyIGEgdXNlciBoYXMgYXV0aGVudGljYXRlZC4gVGhlIHJldHVybmVkIHRva2VuIHNob3VsZCB0aGVuIGJlIHBhc3NlZCB0byB0aGVcbiAgICogY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZG9jSWQgVGhlIElEIG9mIHRoZSBkb2N1bWVudCB0byBnZXQgYSB0b2tlbiBmb3IuXG4gICAqIEBwYXJhbSBhdXRoRG9jUmVxdWVzdCBBbiBvcHRpb25hbCB7QGxpbmsgQXV0aERvY1JlcXVlc3R9IHByb3ZpZGluZyBvcHRpb25zIGZvciB0aGUgdG9rZW4gcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSB7QGxpbmsgQ2xpZW50VG9rZW59IG9iamVjdCBjb250YWluaW5nIHRoZSBVUkwgYW5kIHRva2VuIG5lZWRlZCB0byBjb25uZWN0IHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIGdldENsaWVudFRva2VuKGRvY0lkLCBhdXRoRG9jUmVxdWVzdCkge1xuICAgIGlmICh0eXBlb2YgZG9jSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRvY0lkID0gZG9jSWQuZG9jSWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoYGRvYy8ke2RvY0lkfS9hdXRoYCwgXCJQT1NUXCIsIGF1dGhEb2NSZXF1ZXN0ID8/IHt9KTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXV0aCBkb2MgJHtkb2NJZH06ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHdyYXBwZXIgYXJvdW5kIHtAbGluayBEb2N1bWVudE1hbmFnZXIuY3JlYXRlRG9jfSBhbmQge0BsaW5rIERvY3VtZW50TWFuYWdlci5nZXRDbGllbnRUb2tlbn0gZm9yXG4gICAqIGdldHRpbmcgYSBjbGllbnQgdG9rZW4gZm9yIGEgZG9jdW1lbnQuIElmIGEgZG9jSWQgaXMgcHJvdmlkZWQsIGVuc3VyZXMgdGhhdCBhIGRvY3VtZW50IGV4aXN0cyB3aXRoIHRoYXQgSUQgb3JcbiAgICogdGhhdCBvbmUgaXMgY3JlYXRlZC4gSWYgbm8gZG9jSWQgaXMgcHJvdmlkZWQsIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWQgd2l0aCBhIHJhbmRvbSBJRC5cbiAgICpcbiAgICogQHBhcmFtIGRvY0lkIFRoZSBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gZ2V0IG9yIGNyZWF0ZS4gSWYgbm90IHByb3ZpZGVkLCBhIG5ldyBkb2N1bWVudCB3aXRoIGEgcmFuZG9tIElEIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIGF1dGhEb2NSZXF1ZXN0IEFuIG9wdGlvbmFsIHtAbGluayBBdXRoRG9jUmVxdWVzdH0gcHJvdmlkaW5nIG9wdGlvbnMgZm9yIHRoZSB0b2tlbiByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBDbGllbnRUb2tlbn0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIFVSTCBhbmQgdG9rZW4gbmVlZGVkIHRvIGNvbm5lY3QgdG8gdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0T3JDcmVhdGVEb2NBbmRUb2tlbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNyZWF0ZURvYyhkb2NJZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q2xpZW50VG9rZW4ocmVzdWx0LCBhdXRoRG9jUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW50aXJlIGRvY3VtZW50LCByZXByZXNlbnRlZCBhcyBhIFlqcyB1cGRhdGUgYnl0ZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBkb2NJZCBUaGUgSUQgb2YgdGhlIGRvY3VtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGRvY3VtZW50IGFzIGEgWWpzIHVwZGF0ZSBieXRlIHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgZ2V0RG9jQXNVcGRhdGUoZG9jSWQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5nZXREb2NDb25uZWN0aW9uKGRvY0lkKTtcbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5nZXRBc1VwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gWWpzIHVwZGF0ZSBieXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGRvY0lkIFRoZSBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gdXBkYXRlIFRoZSBZanMgdXBkYXRlIGJ5dGUgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZURvYyhkb2NJZCwgdXBkYXRlKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZ2V0RG9jQ29ubmVjdGlvbihkb2NJZCk7XG4gICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24udXBkYXRlRG9jKHVwZGF0ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RG9jQ29ubmVjdGlvbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpIHtcbiAgICBjb25zdCBjbGllbnRUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50VG9rZW4oZG9jSWQsIGF1dGhEb2NSZXF1ZXN0KTtcbiAgICByZXR1cm4gbmV3IERvY0Nvbm5lY3Rpb24oY2xpZW50VG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHdpdGggaW5pdGlhbCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdXBkYXRlIEEgWWpzIHVwZGF0ZSBieXRlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGluaXRpYWwgY29udGVudC5cbiAgICogQHJldHVybnMgQSB7QGxpbmsgRG9jQ3JlYXRpb25SZXN1bHR9IG9iamVjdCBjb250YWluaW5nIHRoZSBJRCBvZiB0aGUgY3JlYXRlZCBkb2N1bWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZURvY1dpdGhDb250ZW50KHVwZGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY3JlYXRlRG9jKCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVEb2MocmVzdWx0LmRvY0lkLCB1cGRhdGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZURvY0FuZFRva2VuKGNvbm5lY3Rpb25TdHJpbmcsIGRvY0lkLCBhdXRoRG9jUmVxdWVzdCkge1xuICBjb25zdCBtYW5hZ2VyID0gbmV3IERvY3VtZW50TWFuYWdlcihjb25uZWN0aW9uU3RyaW5nKTtcbiAgcmV0dXJuIGF3YWl0IG1hbmFnZXIuZ2V0T3JDcmVhdGVEb2NBbmRUb2tlbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50VG9rZW4oY29ubmVjdGlvblN0cmluZywgZG9jSWQsIGF1dGhEb2NSZXF1ZXN0KSB7XG4gIGNvbnN0IG1hbmFnZXIgPSBuZXcgRG9jdW1lbnRNYW5hZ2VyKGNvbm5lY3Rpb25TdHJpbmcpO1xuICByZXR1cm4gYXdhaXQgbWFuYWdlci5nZXRDbGllbnRUb2tlbihkb2NJZCwgYXV0aERvY1JlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRG9jKGNvbm5lY3Rpb25TdHJpbmcsIGRvY0lkKSB7XG4gIGNvbnN0IG1hbmFnZXIgPSBuZXcgRG9jdW1lbnRNYW5hZ2VyKGNvbm5lY3Rpb25TdHJpbmcpO1xuICByZXR1cm4gYXdhaXQgbWFuYWdlci5jcmVhdGVEb2MoZG9jSWQpO1xufVxuZXhwb3J0IHtcbiAgRG9jQ29ubmVjdGlvbixcbiAgRG9jdW1lbnRNYW5hZ2VyLFxuICBZU3dlZXRFcnJvcixcbiAgY3JlYXRlRG9jLFxuICBkZWNvZGVDbGllbnRUb2tlbixcbiAgZW5jb2RlQ2xpZW50VG9rZW4sXG4gIGdldENsaWVudFRva2VuLFxuICBnZXRPckNyZWF0ZURvY0FuZFRva2VuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@y-sweet/sdk/dist/main.mjs\n");

/***/ })

};
;