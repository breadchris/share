// Code generated by 'yaegi extract gorm.io/gorm/clause'. DO NOT EDIT.

package symbol

import (
	"go/constant"
	"go/token"
	"gorm.io/gorm/clause"
	"reflect"
)

func init() {
	Symbols["gorm.io/gorm/clause/clause"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"And":                      reflect.ValueOf(clause.And),
		"AndWithSpace":             reflect.ValueOf(constant.MakeFromLiteral("\" AND \"", token.STRING, 0)),
		"AssignmentColumns":        reflect.ValueOf(clause.AssignmentColumns),
		"Assignments":              reflect.ValueOf(clause.Assignments),
		"Associations":             reflect.ValueOf(clause.Associations),
		"CrossJoin":                reflect.ValueOf(clause.CrossJoin),
		"CurrentTable":             reflect.ValueOf(clause.CurrentTable),
		"Has":                      reflect.ValueOf(clause.Has),
		"InnerJoin":                reflect.ValueOf(clause.InnerJoin),
		"JoinTable":                reflect.ValueOf(clause.JoinTable),
		"LeftJoin":                 reflect.ValueOf(clause.LeftJoin),
		"LockingOptionsNoWait":     reflect.ValueOf(constant.MakeFromLiteral("\"NOWAIT\"", token.STRING, 0)),
		"LockingOptionsSkipLocked": reflect.ValueOf(constant.MakeFromLiteral("\"SKIP LOCKED\"", token.STRING, 0)),
		"LockingStrengthShare":     reflect.ValueOf(constant.MakeFromLiteral("\"SHARE\"", token.STRING, 0)),
		"LockingStrengthUpdate":    reflect.ValueOf(constant.MakeFromLiteral("\"UPDATE\"", token.STRING, 0)),
		"Not":                      reflect.ValueOf(clause.Not),
		"Or":                       reflect.ValueOf(clause.Or),
		"OrWithSpace":              reflect.ValueOf(constant.MakeFromLiteral("\" OR \"", token.STRING, 0)),
		"PrimaryColumn":            reflect.ValueOf(&clause.PrimaryColumn).Elem(),
		"PrimaryKey":               reflect.ValueOf(clause.PrimaryKey),
		"RightJoin":                reflect.ValueOf(clause.RightJoin),

		// type definitions
		"AndConditions":             reflect.ValueOf((*clause.AndConditions)(nil)),
		"Assignment":                reflect.ValueOf((*clause.Assignment)(nil)),
		"Builder":                   reflect.ValueOf((*clause.Builder)(nil)),
		"Clause":                    reflect.ValueOf((*clause.Clause)(nil)),
		"ClauseBuilder":             reflect.ValueOf((*clause.ClauseBuilder)(nil)),
		"Column":                    reflect.ValueOf((*clause.Column)(nil)),
		"CommaExpression":           reflect.ValueOf((*clause.CommaExpression)(nil)),
		"Delete":                    reflect.ValueOf((*clause.Delete)(nil)),
		"Eq":                        reflect.ValueOf((*clause.Eq)(nil)),
		"Expr":                      reflect.ValueOf((*clause.Expr)(nil)),
		"Expression":                reflect.ValueOf((*clause.Expression)(nil)),
		"From":                      reflect.ValueOf((*clause.From)(nil)),
		"GroupBy":                   reflect.ValueOf((*clause.GroupBy)(nil)),
		"Gt":                        reflect.ValueOf((*clause.Gt)(nil)),
		"Gte":                       reflect.ValueOf((*clause.Gte)(nil)),
		"IN":                        reflect.ValueOf((*clause.IN)(nil)),
		"Insert":                    reflect.ValueOf((*clause.Insert)(nil)),
		"Interface":                 reflect.ValueOf((*clause.Interface)(nil)),
		"Join":                      reflect.ValueOf((*clause.Join)(nil)),
		"JoinTarget":                reflect.ValueOf((*clause.JoinTarget)(nil)),
		"JoinType":                  reflect.ValueOf((*clause.JoinType)(nil)),
		"Like":                      reflect.ValueOf((*clause.Like)(nil)),
		"Limit":                     reflect.ValueOf((*clause.Limit)(nil)),
		"Locking":                   reflect.ValueOf((*clause.Locking)(nil)),
		"Lt":                        reflect.ValueOf((*clause.Lt)(nil)),
		"Lte":                       reflect.ValueOf((*clause.Lte)(nil)),
		"NamedExpr":                 reflect.ValueOf((*clause.NamedExpr)(nil)),
		"NegationExpressionBuilder": reflect.ValueOf((*clause.NegationExpressionBuilder)(nil)),
		"Neq":                       reflect.ValueOf((*clause.Neq)(nil)),
		"NotConditions":             reflect.ValueOf((*clause.NotConditions)(nil)),
		"OnConflict":                reflect.ValueOf((*clause.OnConflict)(nil)),
		"OrConditions":              reflect.ValueOf((*clause.OrConditions)(nil)),
		"OrderBy":                   reflect.ValueOf((*clause.OrderBy)(nil)),
		"OrderByColumn":             reflect.ValueOf((*clause.OrderByColumn)(nil)),
		"Returning":                 reflect.ValueOf((*clause.Returning)(nil)),
		"Select":                    reflect.ValueOf((*clause.Select)(nil)),
		"Set":                       reflect.ValueOf((*clause.Set)(nil)),
		"Table":                     reflect.ValueOf((*clause.Table)(nil)),
		"Update":                    reflect.ValueOf((*clause.Update)(nil)),
		"Values":                    reflect.ValueOf((*clause.Values)(nil)),
		"Where":                     reflect.ValueOf((*clause.Where)(nil)),
		"With":                      reflect.ValueOf((*clause.With)(nil)),
		"Writer":                    reflect.ValueOf((*clause.Writer)(nil)),

		// interface wrapper definitions
		"_Builder":                   reflect.ValueOf((*_gorm_io_gorm_clause_Builder)(nil)),
		"_Expression":                reflect.ValueOf((*_gorm_io_gorm_clause_Expression)(nil)),
		"_Interface":                 reflect.ValueOf((*_gorm_io_gorm_clause_Interface)(nil)),
		"_NegationExpressionBuilder": reflect.ValueOf((*_gorm_io_gorm_clause_NegationExpressionBuilder)(nil)),
		"_Writer":                    reflect.ValueOf((*_gorm_io_gorm_clause_Writer)(nil)),
	}
}

// _gorm_io_gorm_clause_Builder is an interface wrapper for Builder type
type _gorm_io_gorm_clause_Builder struct {
	IValue       interface{}
	WAddError    func(a0 error) error
	WAddVar      func(a0 clause.Writer, a1 ...interface{})
	WWriteByte   func(a0 byte) error
	WWriteQuoted func(field interface{})
	WWriteString func(a0 string) (int, error)
}

func (W _gorm_io_gorm_clause_Builder) AddError(a0 error) error { return W.WAddError(a0) }
func (W _gorm_io_gorm_clause_Builder) AddVar(a0 clause.Writer, a1 ...interface{}) {
	W.WAddVar(a0, a1...)
}
func (W _gorm_io_gorm_clause_Builder) WriteByte(a0 byte) error            { return W.WWriteByte(a0) }
func (W _gorm_io_gorm_clause_Builder) WriteQuoted(field interface{})      { W.WWriteQuoted(field) }
func (W _gorm_io_gorm_clause_Builder) WriteString(a0 string) (int, error) { return W.WWriteString(a0) }

// _gorm_io_gorm_clause_Expression is an interface wrapper for Expression type
type _gorm_io_gorm_clause_Expression struct {
	IValue interface{}
	WBuild func(builder clause.Builder)
}

func (W _gorm_io_gorm_clause_Expression) Build(builder clause.Builder) { W.WBuild(builder) }

// _gorm_io_gorm_clause_Interface is an interface wrapper for Interface type
type _gorm_io_gorm_clause_Interface struct {
	IValue       interface{}
	WBuild       func(a0 clause.Builder)
	WMergeClause func(a0 *clause.Clause)
	WName        func() string
}

func (W _gorm_io_gorm_clause_Interface) Build(a0 clause.Builder)       { W.WBuild(a0) }
func (W _gorm_io_gorm_clause_Interface) MergeClause(a0 *clause.Clause) { W.WMergeClause(a0) }
func (W _gorm_io_gorm_clause_Interface) Name() string                  { return W.WName() }

// _gorm_io_gorm_clause_NegationExpressionBuilder is an interface wrapper for NegationExpressionBuilder type
type _gorm_io_gorm_clause_NegationExpressionBuilder struct {
	IValue         interface{}
	WNegationBuild func(builder clause.Builder)
}

func (W _gorm_io_gorm_clause_NegationExpressionBuilder) NegationBuild(builder clause.Builder) {
	W.WNegationBuild(builder)
}

// _gorm_io_gorm_clause_Writer is an interface wrapper for Writer type
type _gorm_io_gorm_clause_Writer struct {
	IValue       interface{}
	WWriteByte   func(a0 byte) error
	WWriteString func(a0 string) (int, error)
}

func (W _gorm_io_gorm_clause_Writer) WriteByte(a0 byte) error            { return W.WWriteByte(a0) }
func (W _gorm_io_gorm_clause_Writer) WriteString(a0 string) (int, error) { return W.WWriteString(a0) }
