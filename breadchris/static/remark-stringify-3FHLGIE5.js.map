{
  "version": 3,
  "sources": ["../../node_modules/mdast-util-to-markdown/lib/configure.js", "../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js", "../../node_modules/mdast-util-to-markdown/lib/handle/break.js", "../../node_modules/longest-streak/index.js", "../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js", "../../node_modules/mdast-util-to-markdown/lib/handle/code.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js", "../../node_modules/mdast-util-to-markdown/lib/handle/definition.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js", "../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js", "../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js", "../../node_modules/mdast-util-to-markdown/lib/handle/heading.js", "../../node_modules/mdast-util-to-markdown/lib/handle/html.js", "../../node_modules/mdast-util-to-markdown/lib/handle/image.js", "../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js", "../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js", "../../node_modules/mdast-util-to-markdown/lib/handle/link.js", "../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js", "../../node_modules/mdast-util-to-markdown/lib/handle/list.js", "../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js", "../../node_modules/mdast-util-to-markdown/lib/handle/root.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js", "../../node_modules/mdast-util-to-markdown/lib/handle/strong.js", "../../node_modules/mdast-util-to-markdown/lib/handle/text.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js", "../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js", "../../node_modules/mdast-util-to-markdown/lib/handle/index.js", "../../node_modules/mdast-util-to-markdown/lib/join.js", "../../node_modules/mdast-util-to-markdown/lib/unsafe.js", "../../node_modules/mdast-util-to-markdown/lib/index.js", "../../node_modules/remark-stringify/lib/index.js"],
  "sourcesContent": ["/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n", "/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n", "/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can\u2019t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n", "/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n", "/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If there\u2019s no info\u2026\n      !node.lang &&\n      // And there\u2019s a non-whitespace character\u2026\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn\u2019t start or end in a blank\u2026\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there\u2019s no url, or\u2026\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot \u201Cform\u201D depending on the\n// previous or next character of sequences.\n// There\u2019s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n", "/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n", "/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\u2026\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\u2026\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn\u2019t matter that\n  // we\u2019ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n", "/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n", "/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there\u2019s no url but there is a title\u2026\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n", "/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we\u2019re in phrasing, because escapes don\u2019t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn\u2019t matter that\n  // we\u2019ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n", "/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there\u2019s a url\u2026\n      node.url &&\n      // And there\u2019s a no title\u2026\n      !node.title &&\n      // And the content of `node` is a single text node\u2026\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\u2026\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\u2026\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn\u2019t contain ASCII control codes (character escapes and\n      // references don\u2019t work), space, or angle brackets\u2026\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n", "/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we\u2019re in phrasing, because escapes don\u2019t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there\u2019s no url but there is a title\u2026\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n", "/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we\u2019re in phrasing, because escapes don\u2019t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn\u2019t matter that\n  // we\u2019ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there\u2019s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // \u2026because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there\u2019s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // \u2026because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n", "/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n", "/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot \u201Cform\u201D depending on the\n// previous or next character of sequences.\n// There\u2019s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n", "/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n", "/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n", "import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n", "/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n", "/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n", "/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: we\u2019ll fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: we\u2019ll add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What \u201Cconstructs\u201D we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n", "/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[Options?]|void[], Node, string>}\n */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n"],
  "mappings": "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",
  "names": ["configure", "base", "extension", "index", "key", "blockquote", "node", "_", "state", "info", "exit", "tracker", "value", "map", "line", "blank", "hardBreak", "_", "_1", "state", "info", "index", "patternInScope", "longestStreak", "value", "substring", "source", "index", "expected", "count", "max", "formatCodeAsIndented", "node", "state", "checkFence", "state", "marker", "code", "node", "_", "state", "info", "marker", "checkFence", "raw", "suffix", "formatCodeAsIndented", "exit", "value", "map", "tracker", "sequence", "longestStreak", "subexit", "line", "blank", "checkQuote", "state", "marker", "definition", "node", "_", "state", "info", "quote", "checkQuote", "suffix", "exit", "subexit", "tracker", "value", "checkEmphasis", "state", "marker", "emphasis", "emphasisPeek", "node", "_", "state", "info", "marker", "checkEmphasis", "exit", "tracker", "value", "_1", "formatHeadingAsSetext", "node", "state", "literalWithBreak", "visit", "EXIT", "toString", "heading", "node", "_", "state", "info", "rank", "tracker", "formatHeadingAsSetext", "exit", "subexit", "value", "sequence", "html", "htmlPeek", "node", "image", "imagePeek", "node", "_", "state", "info", "quote", "checkQuote", "suffix", "exit", "subexit", "tracker", "value", "imageReference", "imageReferencePeek", "node", "_", "state", "info", "type", "exit", "subexit", "tracker", "value", "alt", "stack", "reference", "formatLinkAsAutolink", "node", "state", "raw", "toString", "link", "linkPeek", "node", "_", "state", "info", "quote", "checkQuote", "suffix", "tracker", "exit", "subexit", "formatLinkAsAutolink", "stack", "value", "linkReference", "linkReferencePeek", "node", "_", "state", "info", "type", "exit", "subexit", "tracker", "value", "text", "stack", "reference", "checkBulletOther", "state", "bullet", "checkBullet", "bulletOther", "checkBulletOrdered", "state", "marker", "checkBulletOrderedOther", "state", "bulletOrdered", "checkBulletOrdered", "bulletOrderedOther", "checkRule", "state", "marker", "list", "node", "parent", "state", "info", "exit", "bulletCurrent", "bullet", "checkBulletOrdered", "checkBullet", "bulletOther", "checkBulletOrderedOther", "checkBulletOther", "bulletLastUsed", "useDifferentMarker", "firstListItem", "checkRule", "index", "item", "value", "paragraph", "node", "_", "state", "info", "exit", "subexit", "value", "root", "node", "_", "state", "info", "d", "phrasing", "checkStrong", "state", "marker", "strong", "strongPeek", "node", "_", "state", "info", "marker", "checkStrong", "exit", "tracker", "value", "_1", "text", "node", "_", "state", "info", "checkRuleRepetition", "state", "repetition", "thematicBreak", "_", "_1", "state", "value", "checkRule", "checkRuleRepetition", "handle", "blockquote", "hardBreak", "code", "definition", "emphasis", "heading", "html", "image", "imageReference", "inlineCode", "link", "linkReference", "list", "listItem", "paragraph", "root", "strong", "text", "thematicBreak", "join", "joinDefaults", "left", "right", "parent", "state", "formatCodeAsIndented", "formatHeadingAsSetext", "fullPhrasingSpans", "unsafe", "toMarkdown", "tree", "options", "state", "enter", "indentLines", "association", "containerPhrasingBound", "containerFlowBound", "track", "safeBound", "configure", "unsafe", "join", "handle", "joinDefinition", "zwitch", "invalid", "unknown", "result", "name", "exit", "value", "node", "left", "right", "parent", "info", "containerPhrasing", "containerFlow", "config", "safe", "remarkStringify", "options", "tree", "settings", "toMarkdown"]
}
