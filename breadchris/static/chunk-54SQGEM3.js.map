{
  "version": 3,
  "sources": ["../../node_modules/decode-named-character-reference/index.dom.js", "../../node_modules/micromark-util-decode-numeric-character-reference/index.js", "../../node_modules/micromark-util-decode-string/index.js"],
  "sourcesContent": ["/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string|false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const char = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `\u00ACit;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char\n}\n", "/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > 126 && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) ||\n    // Noncharacters.\n    (code > 64975 && code < 65008) /* eslint-disable no-bitwise */ ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||\n    // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n  return String.fromCharCode(code)\n}\n", "import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The \u201Cstring\u201D content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n  return decodeNamedCharacterReference($2) || $0\n}\n"],
  "mappings": "AAIA,IAAMA,EAAU,SAAS,cAAc,GAAG,EAMnC,SAASC,EAA8BC,EAAO,CACnD,IAAMC,EAAqB,IAAMD,EAAQ,IACzCF,EAAQ,UAAYG,EACpB,IAAMC,EAAOJ,EAAQ,YAUrB,OAAII,EAAK,WAAWA,EAAK,OAAS,CAAC,IAAM,IAAgBF,IAAU,QAQ5DE,IAASD,EAPP,GAOoCC,CAC/C,CClBO,SAASC,EAAgCC,EAAOC,EAAM,CAC3D,IAAMC,EAAO,OAAO,SAASF,EAAOC,CAAI,EACxC,OAEEC,EAAO,GACPA,IAAS,IACRA,EAAO,IAAMA,EAAO,IAEpBA,EAAO,KAAOA,EAAO,KAErBA,EAAO,OAASA,EAAO,OAEvBA,EAAO,OAASA,EAAO,QACvBA,EAAO,SAAW,QAClBA,EAAO,SAAW,OAEnBA,EAAO,QAEA,SAEF,OAAO,aAAaA,CAAI,CACjC,CCjCA,IAAMC,EACJ,oEAcK,SAASC,EAAaC,EAAO,CAClC,OAAOA,EAAM,QAAQF,EAA4BG,CAAM,CACzD,CAQA,SAASA,EAAOC,EAAIC,EAAIC,EAAI,CAC1B,GAAID,EAEF,OAAOA,EAKT,GADaC,EAAG,WAAW,CAAC,IACf,GAAI,CACf,IAAMC,EAAOD,EAAG,WAAW,CAAC,EACtBE,EAAMD,IAAS,KAAOA,IAAS,GACrC,OAAOE,EAAgCH,EAAG,MAAME,EAAM,EAAI,CAAC,EAAGA,EAAM,GAAK,EAAE,CAC7E,CACA,OAAOE,EAA8BJ,CAAE,GAAKF,CAC9C",
  "names": ["element", "decodeNamedCharacterReference", "value", "characterReference", "char", "decodeNumericCharacterReference", "value", "base", "code", "characterEscapeOrReference", "decodeString", "value", "decode", "$0", "$1", "$2", "head", "hex", "decodeNumericCharacterReference", "decodeNamedCharacterReference"]
}
