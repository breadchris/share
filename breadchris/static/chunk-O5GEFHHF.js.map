{
  "version": 3,
  "sources": ["../../node_modules/mdast-util-to-markdown/lib/util/association.js", "../../node_modules/mdast-util-to-markdown/lib/util/container-flow.js", "../../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js", "../../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js", "../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js", "../../node_modules/mdast-util-to-markdown/lib/util/safe.js", "../../node_modules/mdast-util-to-markdown/lib/util/track.js", "../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js", "../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js", "../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js", "../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js"],
  "sourcesContent": ["/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don\u2019t work in this\n * matching: `&copy;` does not match `\u00A9`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we\u2019re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n", "/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n", "/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n", "/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n", "/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What \u201Cconstructs\u201D we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n", "/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n", "/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it\u2019s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it\u2019s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we\u2019d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can\u2019t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n", "/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don\u2019t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can\u2019t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n", "/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n"],
  "mappings": "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",
  "names": ["association", "node", "decodeString", "containerFlow", "parent", "state", "info", "indexStack", "children", "tracker", "results", "index", "child", "between", "left", "right", "result", "eol", "indentLines", "value", "map", "result", "start", "line", "match", "one", "patternCompile", "pattern", "before", "patternInScope", "stack", "pattern", "listInScope", "list", "none", "index", "safe", "state", "input", "config", "value", "positions", "result", "infos", "index", "pattern", "patternInScope", "expression", "patternCompile", "match", "before", "after", "position", "numerical", "start", "end", "escapeBackslashes", "a", "b", "results", "whole", "track", "config", "options", "now", "lineShift", "line", "column", "move", "current", "shift", "value", "input", "chunks", "tail", "containerPhrasing", "parent", "state", "info", "indexStack", "children", "results", "index", "before", "tracker", "child", "after", "handle", "inlineCode", "inlineCodePeek", "node", "_", "state", "value", "sequence", "index", "pattern", "expression", "patternCompile", "match", "position", "checkBullet", "state", "marker", "checkListItemIndent", "state", "style", "listItem", "node", "parent", "state", "info", "listItemIndent", "checkListItemIndent", "bullet", "checkBullet", "size", "tracker", "exit", "value", "map", "line", "index", "blank"]
}
