package user

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"

	"github.com/gzuidhof/tygo/tygo"
)

func main() {
	// Step 1: Generate TypeScript types using tygo
	if err := generateTypes(); err != nil {
		fmt.Printf("Error generating types: %v\n", err)
		os.Exit(1)
	}

	// Step 2: Analyze Go functions and generate API client
	if err := generateAPIClient(); err != nil {
		fmt.Printf("Error generating API client: %v\n", err)
		os.Exit(1)
	}

	// Step 3: Generate demo React component
	if err := generateDemoComponent(); err != nil {
		fmt.Printf("Error generating demo component: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("âœ… Generation complete!")
	fmt.Println("Generated files:")
	fmt.Println("  - types.ts")
	fmt.Println("  - api_client.ts")
	fmt.Println("  - demo_component.tsx")
}

func generateTypes() error {
	config := &tygo.Config{
		Packages: []*tygo.PackageConfig{
			{
				Path: ".", // Current package
				TypeMappings: map[string]string{
					"time.Time":  "string",
					"*time.Time": "string | undefined",
				},
				OutputPath: "types.ts",
				Frontmatter: `// Generated by tygo from Go structs
// DO NOT EDIT - This file is automatically generated

`,
			},
		},
	}

	gen := tygo.New(config)
	return gen.Generate()
}

func generateAPIClient() error {
	// Parse the current package to find API functions
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse package: %v", err)
	}

	var functions []FunctionInfo

	// Extract function information
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				if funcDecl, ok := n.(*ast.FuncDecl); ok {
					if info := extractFunctionInfo(funcDecl); info != nil {
						functions = append(functions, *info)
					}
				}
				return true
			})
		}
	}

	// Generate the API client TypeScript code
	return writeAPIClient(functions)
}

type FunctionInfo struct {
	Name         string
	RequestType  string
	ResponseType string
	Endpoint     string
}

func extractFunctionInfo(funcDecl *ast.FuncDecl) *FunctionInfo {
	// Check if function matches pattern: func Name(req Type) (resp Type, error)
	if funcDecl.Type.Params.NumFields() != 1 || funcDecl.Type.Results.NumFields() != 2 {
		return nil
	}

	// Check if second return type is error
	if len(funcDecl.Type.Results.List) < 2 {
		return nil
	}

	if ident, ok := funcDecl.Type.Results.List[1].Type.(*ast.Ident); !ok || ident.Name != "error" {
		return nil
	}

	funcName := funcDecl.Name.Name
	reqType := getTypeString(funcDecl.Type.Params.List[0].Type)
	respType := getTypeString(funcDecl.Type.Results.List[0].Type)

	return &FunctionInfo{
		Name:         funcName,
		RequestType:  reqType,
		ResponseType: respType,
		Endpoint:     strings.ToLower(funcName),
	}
}

func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", getTypeString(t.X), t.Sel.Name)
	case *ast.StarExpr:
		return getTypeString(t.X)
	default:
		return "unknown"
	}
}

func writeAPIClient(functions []FunctionInfo) error {
	var sb strings.Builder

	// Import the generated types
	sb.WriteString("// Generated API client with type-safe fetch functions\n")
	sb.WriteString("// DO NOT EDIT - This file is automatically generated\n\n")
	sb.WriteString("import * as Types from './types';\n\n")

	// Write interfaces for fetch options and response
	sb.WriteString(`export interface FetchOptions {
    baseURL?: string;
    headers?: Record<string, string>;
    timeout?: number;
}

export interface Response<T> {
    data: T;
    status: number;
    statusText: string;
}

`)

	// Generate individual API functions
	for _, fn := range functions {
		sb.WriteString(fmt.Sprintf(`export async function %s(req: Types.%s, options: FetchOptions = {}): Promise<Response<Types.%s>> {
    const url = `+"`${options.baseURL || ''}/%s`"+`;
    const headers = {
        'Content-Type': 'application/json',
        ...options.headers
    };

    const response = await fetch(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(req)
    });

    if (!response.ok) {
        throw new Error(`+"`HTTP error! status: ${response.status}`"+`);
    }

    const data = await response.json();
    return {
        data,
        status: response.status,
        statusText: response.statusText
    };
}

`, fn.Name, fn.RequestType, fn.ResponseType, fn.Endpoint))
	}

	return os.WriteFile("api_client.ts", []byte(sb.String()), 0644)
}

func generateDemoComponent() error {
	component := `// Generated demo React component
// This demonstrates usage of the generated types and API client

import React, { useState, useEffect } from 'react';
import * as API from './api_client';
import * as Types from './types';

interface TodoDemoProps {
    userId: string;
    baseURL?: string;
}

const TodoDemo: React.FC<TodoDemoProps> = ({ userId, baseURL = '/api' }) => {
    const [todos, setTodos] = useState<Types.Todo[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [newTodoTitle, setNewTodoTitle] = useState('');

    const apiOptions: API.FetchOptions = { baseURL };

    const loadTodos = async () => {
        try {
            setLoading(true);
            setError(null);
            const response = await API.ListTodos({ user_id: userId }, apiOptions);
            setTodos(response.data.todos);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load todos');
        } finally {
            setLoading(false);
        }
    };

    const createTodo = async (title: string) => {
        try {
            setLoading(true);
            const response = await API.CreateTodo({ title }, apiOptions);
            setTodos(prev => [...prev, response.data.todo]);
            setNewTodoTitle('');
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to create todo');
        } finally {
            setLoading(false);
        }
    };

    const updateTodoStatus = async (id: string, status: Types.TodoStatus) => {
        try {
            const response = await API.UpdateTodo({ id, status }, apiOptions);
            setTodos(prev => prev.map(todo => 
                todo.id === id ? response.data.todo : todo
            ));
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to update todo');
        }
    };

    const deleteTodo = async (id: string) => {
        try {
            await API.DeleteTodo({ id }, apiOptions);
            setTodos(prev => prev.filter(todo => todo.id !== id));
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to delete todo');
        }
    };

    useEffect(() => {
        loadTodos();
    }, [userId]);

    return (
        <div className="p-6 max-w-4xl mx-auto">
            <h1 className="text-2xl font-bold mb-6">tygo + Fetch Functions Demo</h1>
            
            {error && (
                <div className="mb-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                    {error}
                </div>
            )}

            {/* Create Todo Form */}
            <div className="mb-6 p-4 border rounded-lg">
                <h2 className="text-lg font-semibold mb-3">Create New Todo</h2>
                <div className="flex gap-2">
                    <input
                        type="text"
                        value={newTodoTitle}
                        onChange={(e) => setNewTodoTitle(e.target.value)}
                        placeholder="Todo title"
                        className="flex-1 p-2 border rounded"
                        disabled={loading}
                    />
                    <button
                        onClick={() => createTodo(newTodoTitle)}
                        disabled={loading || !newTodoTitle.trim()}
                        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
                    >
                        Create
                    </button>
                </div>
            </div>

            {/* Todos List */}
            <div>
                <h2 className="text-xl font-semibold mb-4">Todos ({todos.length})</h2>
                {loading && todos.length === 0 ? (
                    <p>Loading...</p>
                ) : todos.length === 0 ? (
                    <p className="text-gray-500">No todos found. Create one above!</p>
                ) : (
                    <div className="space-y-2">
                        {todos.map((todo) => (
                            <div key={todo.id} className="p-4 border rounded-lg flex justify-between items-center">
                                <div>
                                    <h3 className="font-semibold">{todo.title}</h3>
                                    <p className="text-sm text-gray-600">{todo.description}</p>
                                    <p className="text-xs text-gray-500">
                                        Status: {todo.status} | Created: {new Date(todo.created_at).toLocaleDateString()}
                                    </p>
                                </div>
                                <div className="flex gap-2">
                                    {todo.status !== 'completed' && (
                                        <button
                                            onClick={() => updateTodoStatus(todo.id, 'completed')}
                                            className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm"
                                        >
                                            Complete
                                        </button>
                                    )}
                                    <button
                                        onClick={() => deleteTodo(todo.id)}
                                        className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                                    >
                                        Delete
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {loading && (
                <div className="fixed bottom-4 right-4 p-3 bg-blue-500 text-white rounded shadow-lg">
                    Processing...
                </div>
            )}
        </div>
    );
};

export default TodoDemo;
`

	return os.WriteFile("demo_component.tsx", []byte(component), 0644)
}
